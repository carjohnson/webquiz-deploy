{"version":3,"file":"extensions_cornerstone-dicom-sr_src_components_OHIFCornerstoneSRViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAIA;AAEA;AAEA;AAAA;AAIA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAOA;AAEA;AAEA;AAAA;AACA;AAAA;AAIA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAEA;AAKA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAMA;AAAA;AAxNA;AAsBA;AAAA;AAoMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA","sources":["file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone-dicom-sr%5Csrc%5Ccomponents%5COHIFCornerstoneSRContainer.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone-dicom-sr%5Csrc%5Ccomponents%5COHIFCornerstoneSRContentItem.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone-dicom-sr%5Csrc%5Ccomponents%5COHIFCornerstoneSRMeasurementViewport.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone-dicom-sr%5Csrc%5Ccomponents%5COHIFCornerstoneSRTextViewport.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone-dicom-sr%5Csrc%5Ccomponents%5COHIFCornerstoneSRViewport.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone-dicom-sr%5Csrc%5Cutils%5CformatContentItem.ts"],"sourcesContent":["import PropTypes from 'prop-types';\r\nimport React from 'react';\r\nimport { OHIFCornerstoneSRContentItem } from './OHIFCornerstoneSRContentItem';\r\n\r\nexport function OHIFCornerstoneSRContainer(props) {\r\n  const { container, nodeIndexesTree = [0], containerNumberedTree = [1] } = props;\r\n  const { ContinuityOfContent, ConceptNameCodeSequence } = container;\r\n  const { CodeMeaning } = ConceptNameCodeSequence ?? {};\r\n  let childContainerIndex = 1;\r\n  const contentItems = container.ContentSequence?.map((contentItem, i) => {\r\n    const { ValueType } = contentItem;\r\n    const childNodeLevel = [...nodeIndexesTree, i];\r\n    const key = childNodeLevel.join('.');\r\n\r\n    let Component;\r\n    let componentProps;\r\n\r\n    if (ValueType === 'CONTAINER') {\r\n      const childContainerNumberedTree = [...containerNumberedTree, childContainerIndex++];\r\n\r\n      Component = OHIFCornerstoneSRContainer;\r\n      componentProps = {\r\n        container: contentItem,\r\n        nodeIndexesTree: childNodeLevel,\r\n        containerNumberedTree: childContainerNumberedTree,\r\n      };\r\n    } else {\r\n      Component = OHIFCornerstoneSRContentItem;\r\n      componentProps = {\r\n        contentItem,\r\n        nodeIndexesTree: childNodeLevel,\r\n        continuityOfContent: ContinuityOfContent,\r\n      };\r\n    }\r\n\r\n    return (\r\n      <Component\r\n        key={key}\r\n        {...componentProps}\r\n      />\r\n    );\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <div className=\"font-bold\">\r\n        {containerNumberedTree.join('.')}.&nbsp;\r\n        {CodeMeaning}\r\n      </div>\r\n      <div className=\"ml-4 mb-2\">{contentItems}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nOHIFCornerstoneSRContainer.propTypes = {\r\n  /**\r\n   * A tree node that may contain another container or one or more content items\r\n   * (text, code, uidref, pname, etc.)\r\n   */\r\n  container: PropTypes.object,\r\n  /**\r\n   * A 0-based index list\r\n   */\r\n  nodeIndexesTree: PropTypes.arrayOf(PropTypes.number),\r\n  /**\r\n   * A 1-based index list that represents a container in a multi-level numbered\r\n   * list (tree).\r\n   *\r\n   * Example:\r\n   *  1. History\r\n   *    1.1. Chief Complaint\r\n   *    1.2. Present Illness\r\n   *    1.3. Past History\r\n   *    1.4. Family History\r\n   *  2. Findings\r\n   * */\r\n  containerNumberedTree: PropTypes.arrayOf(PropTypes.number),\r\n};\r\n","import PropTypes from 'prop-types';\r\nimport React from 'react';\r\nimport { CodeNameCodeSequenceValues } from '../enums';\r\nimport formatContentItemValue from '../utils/formatContentItem';\r\n\r\nconst EMPTY_TAG_VALUE = '[empty]';\r\n\r\nfunction OHIFCornerstoneSRContentItem(props) {\r\n  const { contentItem, nodeIndexesTree, continuityOfContent } = props;\r\n  const { ConceptNameCodeSequence } = contentItem;\r\n  const { CodeValue, CodeMeaning } = ConceptNameCodeSequence;\r\n  const isChildFirstNode = nodeIndexesTree[nodeIndexesTree.length - 1] === 0;\r\n  const formattedValue = formatContentItemValue(contentItem) ?? EMPTY_TAG_VALUE;\r\n  const startWithAlphaNumCharRegEx = /^[a-zA-Z0-9]/;\r\n  const isContinuous = continuityOfContent === 'CONTINUOUS';\r\n  const isFinding = CodeValue === CodeNameCodeSequenceValues.Finding;\r\n  const addExtraSpace =\r\n    isContinuous && !isChildFirstNode && startWithAlphaNumCharRegEx.test(formattedValue?.[0]);\r\n\r\n  // Collapse sequences of white space preserving newline characters\r\n  let className = 'whitespace-pre-line';\r\n\r\n  if (CodeValue === CodeNameCodeSequenceValues.Finding) {\r\n    // Preserve spaces because it is common to see tabular text in a\r\n    // \"Findings\" ConceptNameCodeSequence\r\n    className = 'whitespace-pre-wrap';\r\n  }\r\n\r\n  if (isContinuous) {\r\n    return (\r\n      <>\r\n        <span\r\n          className={className}\r\n          title={CodeMeaning}\r\n        >\r\n          {addExtraSpace ? ' ' : ''}\r\n          {formattedValue}\r\n        </span>\r\n      </>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div className=\"mb-2\">\r\n        <span className=\"font-bold\">{CodeMeaning}: </span>\r\n        {isFinding ? (\r\n          <pre>{formattedValue}</pre>\r\n        ) : (\r\n          <span className={className}>{formattedValue}</span>\r\n        )}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nOHIFCornerstoneSRContentItem.propTypes = {\r\n  contentItem: PropTypes.object,\r\n  nodeIndexesTree: PropTypes.arrayOf(PropTypes.number),\r\n  continuityOfContent: PropTypes.string,\r\n};\r\n\r\nexport { OHIFCornerstoneSRContentItem };\r\n","import PropTypes from 'prop-types';\r\nimport React, { useCallback, useEffect, useState } from 'react';\r\nimport { setTrackingUniqueIdentifiersForElement } from '../tools/modules/dicomSRModule';\r\n\r\nimport createReferencedImageDisplaySet from '../utils/createReferencedImageDisplaySet';\r\nimport { usePositionPresentationStore, OHIFCornerstoneViewport } from '@ohif/extension-cornerstone';\r\nimport { useViewportGrid } from '@ohif/ui-next';\r\nimport { useSystem } from '@ohif/core/src/contextProviders/SystemProvider';\r\n\r\nconst SR_TOOLGROUP_BASE_NAME = 'SRToolGroup';\r\n\r\nfunction OHIFCornerstoneSRMeasurementViewport(props) {\r\n  const { servicesManager } = useSystem();\r\n  const { children, dataSource, displaySets, viewportOptions } = props as {\r\n    children: React.ReactNode;\r\n    dataSource: unknown;\r\n    displaySets: AppTypes.DisplaySet[];\r\n    viewportOptions: AppTypes.ViewportOptions;\r\n  };\r\n\r\n  const { displaySetService } = servicesManager.services;\r\n\r\n  const viewportId = viewportOptions.viewportId;\r\n\r\n  // SR viewport will always have a single display set\r\n  if (displaySets.length > 1) {\r\n    throw new Error('SR viewport should only have a single display set');\r\n  }\r\n\r\n  const srDisplaySet = displaySets[0];\r\n\r\n  const { setPositionPresentation } = usePositionPresentationStore();\r\n\r\n  const [viewportGrid, viewportGridService] = useViewportGrid();\r\n  const [measurementSelected, setMeasurementSelected] = useState(0);\r\n  const [activeImageDisplaySetData, setActiveImageDisplaySetData] = useState(null);\r\n  const [referencedDisplaySetMetadata, setReferencedDisplaySetMetadata] = useState(null);\r\n  const [element, setElement] = useState(null);\r\n  const { viewports, activeViewportId } = viewportGrid;\r\n\r\n  const setTrackingIdentifiers = useCallback(\r\n    measurementSelected => {\r\n      const { measurements } = srDisplaySet;\r\n\r\n      setTrackingUniqueIdentifiersForElement(\r\n        element,\r\n        measurements.map(measurement => measurement.TrackingUniqueIdentifier),\r\n        measurementSelected\r\n      );\r\n    },\r\n    [element, measurementSelected, srDisplaySet]\r\n  );\r\n\r\n  /**\r\n   * OnElementEnabled callback which is called after the cornerstoneExtension\r\n   * has enabled the element. Note: we delegate all the image rendering to\r\n   * cornerstoneExtension, so we don't need to do anything here regarding\r\n   * the image rendering, element enabling etc.\r\n   */\r\n  const onElementEnabled = evt => {\r\n    setElement(evt.detail.element);\r\n  };\r\n\r\n  const updateViewport = useCallback(\r\n    newMeasurementSelected => {\r\n      const { StudyInstanceUID, displaySetInstanceUID, sopClassUids } = srDisplaySet;\r\n\r\n      if (!StudyInstanceUID || !displaySetInstanceUID) {\r\n        return;\r\n      }\r\n\r\n      if (sopClassUids && sopClassUids.length > 1) {\r\n        // Todo: what happens if there are multiple SOP Classes? Why we are\r\n        // not throwing an error?\r\n        console.warn('More than one SOPClassUID in the same series is not yet supported.');\r\n      }\r\n\r\n      _getViewportReferencedDisplaySetData(\r\n        srDisplaySet,\r\n        newMeasurementSelected,\r\n        displaySetService\r\n      ).then(({ referencedDisplaySet, referencedDisplaySetMetadata }) => {\r\n        if (!referencedDisplaySet || !referencedDisplaySetMetadata) {\r\n          return;\r\n        }\r\n\r\n        setMeasurementSelected(newMeasurementSelected);\r\n\r\n        setActiveImageDisplaySetData(referencedDisplaySet);\r\n        setReferencedDisplaySetMetadata(referencedDisplaySetMetadata);\r\n\r\n        const { presentationIds } = viewportOptions;\r\n        const measurement = srDisplaySet.measurements[newMeasurementSelected];\r\n        setPositionPresentation(presentationIds.positionPresentationId, {\r\n          viewReference: {\r\n            referencedImageId: measurement.imageId,\r\n          },\r\n        });\r\n      });\r\n    },\r\n    [dataSource, srDisplaySet, activeImageDisplaySetData, viewportId]\r\n  );\r\n\r\n  const getCornerstoneViewport = useCallback(() => {\r\n    if (!activeImageDisplaySetData) {\r\n      return null;\r\n    }\r\n\r\n    const { measurements } = srDisplaySet;\r\n    const measurement = measurements[measurementSelected];\r\n\r\n    if (!measurement) {\r\n      return null;\r\n    }\r\n\r\n    return (\r\n      <OHIFCornerstoneViewport\r\n        {...props}\r\n        // should be passed second since we don't want SR displaySet to\r\n        // override the activeImageDisplaySetData\r\n        displaySets={[activeImageDisplaySetData]}\r\n        // It is possible that there is a hanging protocol applying viewportOptions\r\n        // for the SR, so inherit the viewport options\r\n        // TODO: Ensure the viewport options are set correctly with respect to\r\n        // stack etc, in the incoming viewport options.\r\n        viewportOptions={{\r\n          ...viewportOptions,\r\n          toolGroupId: `${SR_TOOLGROUP_BASE_NAME}`,\r\n          // viewportType should not be required, as the stack type should be\r\n          // required already in order to view SR, but sometimes segmentation\r\n          // views set the viewport type without fixing the allowed display\r\n          viewportType: 'stack',\r\n          // The positionIds for the viewport aren't meaningful for the child display sets\r\n          positionIds: null,\r\n        }}\r\n        onElementEnabled={evt => {\r\n          props.onElementEnabled?.(evt);\r\n          onElementEnabled(evt);\r\n        }}\r\n        isJumpToMeasurementDisabled={true}\r\n      />\r\n    );\r\n  }, [activeImageDisplaySetData, viewportId, measurementSelected]);\r\n\r\n  /**\r\n   Cleanup the SR viewport when the viewport is destroyed\r\n   */\r\n  useEffect(() => {\r\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\r\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\r\n      ({ displaySetInstanceUIDs }) => {\r\n        const activeViewport = viewports.get(activeViewportId);\r\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\r\n          viewportGridService.setDisplaySetsForViewport({\r\n            viewportId: activeViewportId,\r\n            displaySetInstanceUIDs: [],\r\n          });\r\n        }\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      onDisplaySetsRemovedSubscription.unsubscribe();\r\n    };\r\n  }, []);\r\n\r\n  /**\r\n   * Loading the measurements from the SR viewport, which goes through the\r\n   * isHydratable check, the outcome for the isHydrated state here is always FALSE\r\n   * since we don't do the hydration here. Todo: can't we just set it as false? why\r\n   * we are changing the state here? isHydrated is always false at this stage, and\r\n   * if it is hydrated we don't even use the SR viewport.\r\n   */\r\n  useEffect(() => {\r\n    const loadSR = async () => {\r\n      if (!srDisplaySet.isLoaded) {\r\n        await srDisplaySet.load();\r\n      }\r\n      updateViewport(measurementSelected);\r\n    };\r\n    loadSR();\r\n  }, [srDisplaySet]);\r\n\r\n  /**\r\n   * Hook to update the tracking identifiers when the selected measurement changes or\r\n   * the element changes\r\n   */\r\n  useEffect(() => {\r\n    const updateSR = async () => {\r\n      if (!srDisplaySet.isLoaded) {\r\n        await srDisplaySet.load();\r\n      }\r\n      if (!element || !srDisplaySet.isLoaded) {\r\n        return;\r\n      }\r\n      setTrackingIdentifiers(measurementSelected);\r\n    };\r\n    updateSR();\r\n  }, [measurementSelected, element, setTrackingIdentifiers, srDisplaySet]);\r\n\r\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n  let childrenWithProps = null;\r\n\r\n  if (!activeImageDisplaySetData || !referencedDisplaySetMetadata) {\r\n    return null;\r\n  }\r\n\r\n  if (children && children.length) {\r\n    childrenWithProps = children.map((child, index) => {\r\n      return (\r\n        child &&\r\n        React.cloneElement(child, {\r\n          viewportId,\r\n          key: index,\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\r\n        {getCornerstoneViewport()}\r\n        {childrenWithProps}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nOHIFCornerstoneSRMeasurementViewport.propTypes = {\r\n  displaySets: PropTypes.arrayOf(PropTypes.object),\r\n  viewportId: PropTypes.string.isRequired,\r\n  dataSource: PropTypes.object,\r\n  children: PropTypes.node,\r\n  viewportLabel: PropTypes.string,\r\n  viewportOptions: PropTypes.object,\r\n};\r\n\r\nasync function _getViewportReferencedDisplaySetData(\r\n  displaySet,\r\n  measurementSelected,\r\n  displaySetService\r\n) {\r\n  const { measurements } = displaySet;\r\n  const measurement = measurements[measurementSelected];\r\n\r\n  const { displaySetInstanceUID } = measurement;\r\n  if (!displaySet.keyImageDisplaySet) {\r\n    // Create a new display set, and preserve a reference to it here,\r\n    // so that it can be re-displayed and shown inside the SR viewport.\r\n    // This is only for ease of redisplay - the display set is stored in the\r\n    // usual manner in the display set service.\r\n    displaySet.keyImageDisplaySet = createReferencedImageDisplaySet(displaySetService, displaySet);\r\n  }\r\n\r\n  if (!displaySetInstanceUID) {\r\n    return { referencedDisplaySetMetadata: null, referencedDisplaySet: null };\r\n  }\r\n\r\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n  const image0 = referencedDisplaySet.images[0];\r\n  const referencedDisplaySetMetadata = {\r\n    PatientID: image0.PatientID,\r\n    PatientName: image0.PatientName,\r\n    PatientSex: image0.PatientSex,\r\n    PatientAge: image0.PatientAge,\r\n    SliceThickness: image0.SliceThickness,\r\n    StudyDate: image0.StudyDate,\r\n    SeriesDescription: image0.SeriesDescription,\r\n    SeriesInstanceUID: image0.SeriesInstanceUID,\r\n    SeriesNumber: image0.SeriesNumber,\r\n    ManufacturerModelName: image0.ManufacturerModelName,\r\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\r\n  };\r\n\r\n  return { referencedDisplaySetMetadata, referencedDisplaySet };\r\n}\r\n\r\nexport default OHIFCornerstoneSRMeasurementViewport;\r\n","import PropTypes from 'prop-types';\r\nimport React from 'react';\r\nimport { ExtensionManager } from '@ohif/core';\r\nimport { OHIFCornerstoneSRContainer } from './OHIFCornerstoneSRContainer';\r\n\r\nfunction OHIFCornerstoneSRTextViewport(props: withAppTypes) {\r\n  const { displaySets } = props;\r\n  const displaySet = displaySets[0];\r\n  const instance = displaySet.instances[0];\r\n\r\n  return (\r\n    <div className=\"relative flex h-full w-full flex-col overflow-auto p-4 text-white\">\r\n      <div>\r\n        {/* The root level is always a container */}\r\n        <OHIFCornerstoneSRContainer container={instance} />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nOHIFCornerstoneSRTextViewport.propTypes = {\r\n  displaySets: PropTypes.arrayOf(PropTypes.object),\r\n  viewportId: PropTypes.string.isRequired,\r\n  dataSource: PropTypes.object,\r\n  children: PropTypes.node,\r\n  viewportLabel: PropTypes.string,\r\n  viewportOptions: PropTypes.object,\r\n  servicesManager: PropTypes.object.isRequired,\r\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\r\n};\r\n\r\nexport default OHIFCornerstoneSRTextViewport;\r\n","import PropTypes from 'prop-types';\r\nimport React from 'react';\r\nimport { ExtensionManager } from '@ohif/core';\r\n\r\nimport OHIFCornerstoneSRMeasurementViewport from './OHIFCornerstoneSRMeasurementViewport';\r\nimport OHIFCornerstoneSRTextViewport from './OHIFCornerstoneSRTextViewport';\r\n\r\nfunction OHIFCornerstoneSRViewport(props: withAppTypes) {\r\n  const { displaySets } = props;\r\n  const { isImagingMeasurementReport } = displaySets[0];\r\n\r\n  if (isImagingMeasurementReport) {\r\n    return <OHIFCornerstoneSRMeasurementViewport {...props}></OHIFCornerstoneSRMeasurementViewport>;\r\n  }\r\n\r\n  return <OHIFCornerstoneSRTextViewport {...props}></OHIFCornerstoneSRTextViewport>;\r\n}\r\n\r\nOHIFCornerstoneSRViewport.propTypes = {\r\n  displaySets: PropTypes.arrayOf(PropTypes.object),\r\n  viewportId: PropTypes.string.isRequired,\r\n  dataSource: PropTypes.object,\r\n  children: PropTypes.node,\r\n  viewportLabel: PropTypes.string,\r\n  viewportOptions: PropTypes.object,\r\n  servicesManager: PropTypes.object.isRequired,\r\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\r\n};\r\n\r\nexport default OHIFCornerstoneSRViewport;\r\n","import { utils } from '@ohif/core';\r\n\r\n/**\r\n * Formatters used to format each of the content items (SR \"nodes\") which can be\r\n * text, code, UID ref, number, person name, date, time and date time. Each\r\n * formatter must be a function with the following signature:\r\n *\r\n *    [VALUE_TYPE]: (contentItem) => string\r\n *\r\n */\r\nconst contentItemFormatters = {\r\n  TEXT: contentItem => contentItem.TextValue,\r\n  CODE: contentItem => contentItem.ConceptCodeSequence?.[0]?.CodeMeaning,\r\n  UIDREF: contentItem => contentItem.UID,\r\n  NUM: contentItem => {\r\n    const measuredValue = contentItem.MeasuredValueSequence?.[0];\r\n\r\n    if (!measuredValue) {\r\n      return;\r\n    }\r\n\r\n    const { NumericValue, MeasurementUnitsCodeSequence } = measuredValue;\r\n    const { CodeValue } = MeasurementUnitsCodeSequence;\r\n\r\n    return `${NumericValue} ${CodeValue}`;\r\n  },\r\n  PNAME: contentItem => {\r\n    const personName = contentItem.PersonName?.[0];\r\n    return personName ? utils.formatPN(personName) : undefined;\r\n  },\r\n  DATE: contentItem => {\r\n    const { Date } = contentItem;\r\n    return Date ? utils.formatDate(Date) : undefined;\r\n  },\r\n  TIME: contentItem => {\r\n    const { Time } = contentItem;\r\n    return Time ? utils.formatTime(Time) : undefined;\r\n  },\r\n  DATETIME: contentItem => {\r\n    const { DateTime } = contentItem;\r\n\r\n    if (typeof DateTime !== 'string') {\r\n      return;\r\n    }\r\n\r\n    // 14 characters because it should be something like 20180614113714\r\n    if (DateTime.length < 14) {\r\n      return DateTime;\r\n    }\r\n\r\n    const dicomDate = DateTime.substring(0, 8);\r\n    const dicomTime = DateTime.substring(8, 14);\r\n    const formattedDate = utils.formatDate(dicomDate);\r\n    const formattedTime = utils.formatTime(dicomTime);\r\n\r\n    return `${formattedDate} ${formattedTime}`;\r\n  },\r\n};\r\n\r\nfunction formatContentItemValue(contentItem) {\r\n  const { ValueType } = contentItem;\r\n  const fnFormat = contentItemFormatters[ValueType];\r\n\r\n  return fnFormat ? fnFormat(contentItem) : `[${ValueType} is not supported]`;\r\n}\r\n\r\nexport { formatContentItemValue as default, formatContentItemValue };\r\n"],"names":[],"sourceRoot":""}