{"version":3,"file":"extensions_cornerstone_src_Viewport_OHIFCornerstoneViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAIA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AAAA;AAGA;AAAA;AA/RA;AAiSA;AAjSA;;AAmSA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AAIA;AAIA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5jBA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAxEA;AA0EA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AAAA;AA4BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAeA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAOA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AAHA;AAxMA;AAiBA;AAAA;AA2LA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AAHA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AAFA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAIA;;AAEA;AACA;AACA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAKA;AAAA;AASA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxcA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AA7FA;AA+FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AASA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AAAA;AAzEA;AA2EA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AAEA;AAQA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAQA;AAAA;AAEA;AAAA;AAGA;AAWA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAxKA;AAYA;AAAA;AAsKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvPA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAAA;AAAA;AAAA;AAEA;AAIA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAnJA;AAYA;AAAA;AAyIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAKA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AA1FA;AA4FA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtPA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAMA;AAAA;AA/EA;AAEA;AAAA;AA+EA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7FA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAQA;AACA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAIA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COHIFCornerstoneViewport.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5CCornerstoneOverlays.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5CCustomizableViewportOverlay.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5CViewportImageScrollbar.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5CViewportImageSliceLoadingIndicator.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5CViewportOrientationMarkers.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5Cutils.ts","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5Ccomponents%5CCinePlayer%5CCinePlayer.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5Ccomponents%5CCinePlayer%5Cindex.ts","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5Ccomponents%5COHIFViewportActionCorners.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5Cutils%5CActiveViewportBehavior.tsx","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5Cutils%5Cpresentations%5CgetViewportPresentations.ts","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COHIFCornerstoneViewport.css","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5CCustomizableViewportOverlay.css","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cextensions%5Ccornerstone%5Csrc%5CViewport%5COverlays%5CViewportOrientationMarkers.css","webpack:///../../../extensions/cornerstone/src/Viewport/OHIFCornerstoneViewport.css?83dc","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/CustomizableViewportOverlay.css?ab6b","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportOrientationMarkers.css?ca32"],"sourcesContent":["import React, { useEffect, useRef, useCallback, useState } from 'react';\r\nimport * as cs3DTools from '@cornerstonejs/tools';\r\nimport { Enums, eventTarget, getEnabledElement } from '@cornerstonejs/core';\r\nimport { MeasurementService, useViewportRef } from '@ohif/core';\r\nimport { useViewportDialog } from '@ohif/ui-next';\r\nimport type { Types as csTypes } from '@cornerstonejs/core';\r\n\r\nimport { setEnabledElement } from '../state';\r\n\r\nimport './OHIFCornerstoneViewport.css';\r\nimport CornerstoneOverlays from './Overlays/CornerstoneOverlays';\r\nimport CinePlayer from '../components/CinePlayer';\r\nimport type { Types } from '@ohif/core';\r\n\r\nimport OHIFViewportActionCorners from '../components/OHIFViewportActionCorners';\r\nimport ViewportColorbarsContainer from '../components/ViewportColorbar';\r\nimport { getViewportPresentations } from '../utils/presentations/getViewportPresentations';\r\nimport { useSynchronizersStore } from '../stores/useSynchronizersStore';\r\nimport ActiveViewportBehavior from '../utils/ActiveViewportBehavior';\r\nimport { WITH_NAVIGATION } from '../services/ViewportService/CornerstoneViewportService';\r\n\r\nconst STACK = 'stack';\r\n\r\n// Cache for viewport dimensions, persists across component remounts\r\nconst viewportDimensions = new Map<string, { width: number; height: number }>();\r\n\r\n// Todo: This should be done with expose of internal API similar to react-vtkjs-viewport\r\n// Then we don't need to worry about the re-renders if the props change.\r\nconst OHIFCornerstoneViewport = React.memo(\r\n  (\r\n    props: withAppTypes<{\r\n      viewportId: string;\r\n      displaySets: AppTypes.DisplaySet[];\r\n      viewportOptions: AppTypes.ViewportGrid.GridViewportOptions;\r\n      initialImageIndex: number;\r\n    }>\r\n  ) => {\r\n    const {\r\n      displaySets,\r\n      dataSource,\r\n      viewportOptions,\r\n      displaySetOptions,\r\n      servicesManager,\r\n      onElementEnabled,\r\n      // eslint-disable-next-line react/prop-types\r\n      onElementDisabled,\r\n      isJumpToMeasurementDisabled = false,\r\n      // Note: you SHOULD NOT use the initialImageIdOrIndex for manipulation\r\n      // of the imageData in the OHIFCornerstoneViewport. This prop is used\r\n      // to set the initial state of the viewport's first image to render\r\n      // eslint-disable-next-line react/prop-types\r\n      initialImageIndex,\r\n      // if the viewport is part of a hanging protocol layout\r\n      // we should not really rely on the old synchronizers and\r\n      // you see below we only rehydrate the synchronizers if the viewport\r\n      // is not part of the hanging protocol layout. HPs should\r\n      // define their own synchronizers. Since the synchronizers are\r\n      // viewportId dependent and\r\n      // eslint-disable-next-line react/prop-types\r\n      isHangingProtocolLayout,\r\n    } = props;\r\n    const viewportId = viewportOptions.viewportId;\r\n\r\n    if (!viewportId) {\r\n      throw new Error('Viewport ID is required');\r\n    }\r\n\r\n    // Make sure displaySetOptions has one object per displaySet\r\n    while (displaySetOptions.length < displaySets.length) {\r\n      displaySetOptions.push({});\r\n    }\r\n\r\n    // Since we only have support for dynamic data in volume viewports, we should\r\n    // handle this case here and set the viewportType to volume if any of the\r\n    // displaySets are dynamic volumes\r\n    viewportOptions.viewportType = displaySets.some(\r\n      ds => ds.isDynamicVolume && ds.isReconstructable\r\n    )\r\n      ? 'volume'\r\n      : viewportOptions.viewportType;\r\n\r\n    const [scrollbarHeight, setScrollbarHeight] = useState('100px');\r\n    const [enabledVPElement, setEnabledVPElement] = useState(null);\r\n    const elementRef = useRef() as React.MutableRefObject<HTMLDivElement>;\r\n    const viewportRef = useViewportRef(viewportId);\r\n\r\n    const {\r\n      displaySetService,\r\n      toolbarService,\r\n      toolGroupService,\r\n      syncGroupService,\r\n      cornerstoneViewportService,\r\n      segmentationService,\r\n      cornerstoneCacheService,\r\n      customizationService,\r\n      measurementService,\r\n    } = servicesManager.services;\r\n\r\n    const [viewportDialogState] = useViewportDialog();\r\n    // useCallback for scroll bar height calculation\r\n    const setImageScrollBarHeight = useCallback(() => {\r\n      const scrollbarHeight = `${elementRef.current.clientHeight - 10}px`;\r\n      setScrollbarHeight(scrollbarHeight);\r\n    }, [elementRef]);\r\n\r\n    // useCallback for onResize\r\n    const onResize = useCallback(\r\n      (entries: ResizeObserverEntry[]) => {\r\n        if (elementRef.current && entries?.length) {\r\n          const entry = entries[0];\r\n          const { width, height } = entry.contentRect;\r\n\r\n          const prevDimensions = viewportDimensions.get(viewportId) || { width: 0, height: 0 };\r\n\r\n          // Check if dimensions actually changed and then only resize if they have changed\r\n          const hasDimensionsChanged =\r\n            prevDimensions.width !== width || prevDimensions.height !== height;\r\n\r\n          if (width > 0 && height > 0 && hasDimensionsChanged) {\r\n            viewportDimensions.set(viewportId, { width, height });\r\n            // Perform resize operations\r\n            cornerstoneViewportService.resize();\r\n            setImageScrollBarHeight();\r\n          }\r\n        }\r\n      },\r\n      [viewportId, elementRef, cornerstoneViewportService, setImageScrollBarHeight]\r\n    );\r\n\r\n    useEffect(() => {\r\n      const element = elementRef.current;\r\n      if (!element) {\r\n        return;\r\n      }\r\n\r\n      const resizeObserver = new ResizeObserver(onResize);\r\n      resizeObserver.observe(element);\r\n\r\n      // Cleanup function\r\n      return () => {\r\n        resizeObserver.unobserve(element);\r\n        resizeObserver.disconnect();\r\n      };\r\n    }, [onResize]);\r\n\r\n    const cleanUpServices = useCallback(\r\n      viewportInfo => {\r\n        const renderingEngineId = viewportInfo.getRenderingEngineId();\r\n        const syncGroups = viewportInfo.getSyncGroups();\r\n\r\n        toolGroupService.removeViewportFromToolGroup(viewportId, renderingEngineId);\r\n        syncGroupService.removeViewportFromSyncGroup(viewportId, renderingEngineId, syncGroups);\r\n\r\n        segmentationService.clearSegmentationRepresentations(viewportId);\r\n      },\r\n      [viewportId, segmentationService, syncGroupService, toolGroupService]\r\n    );\r\n\r\n    const elementEnabledHandler = useCallback(\r\n      evt => {\r\n        // check this is this element reference and return early if doesn't match\r\n        if (evt.detail.element !== elementRef.current) {\r\n          return;\r\n        }\r\n\r\n        const { viewportId, element } = evt.detail;\r\n        const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\r\n\r\n        if (!viewportInfo) {\r\n          return;\r\n        }\r\n\r\n        setEnabledElement(viewportId, element);\r\n        setEnabledVPElement(element);\r\n\r\n        const renderingEngineId = viewportInfo.getRenderingEngineId();\r\n        const toolGroupId = viewportInfo.getToolGroupId();\r\n        const syncGroups = viewportInfo.getSyncGroups();\r\n\r\n        toolGroupService.addViewportToToolGroup(viewportId, renderingEngineId, toolGroupId);\r\n\r\n        syncGroupService.addViewportToSyncGroup(viewportId, renderingEngineId, syncGroups);\r\n\r\n        // we don't need reactivity here so just use state\r\n        const { synchronizersStore } = useSynchronizersStore.getState();\r\n        if (synchronizersStore?.[viewportId]?.length && !isHangingProtocolLayout) {\r\n          // If the viewport used to have a synchronizer, re apply it again\r\n          _rehydrateSynchronizers(viewportId, syncGroupService);\r\n        }\r\n\r\n        if (onElementEnabled && typeof onElementEnabled === 'function') {\r\n          onElementEnabled(evt);\r\n        }\r\n      },\r\n      [viewportId, onElementEnabled, toolGroupService]\r\n    );\r\n\r\n    // disable the element upon unmounting\r\n    useEffect(() => {\r\n      cornerstoneViewportService.enableViewport(viewportId, elementRef.current);\r\n\r\n      eventTarget.addEventListener(Enums.Events.ELEMENT_ENABLED, elementEnabledHandler);\r\n\r\n      setImageScrollBarHeight();\r\n\r\n      return () => {\r\n        const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\r\n\r\n        if (!viewportInfo) {\r\n          return;\r\n        }\r\n\r\n        cornerstoneViewportService.storePresentation({ viewportId });\r\n\r\n        // This should be done after the store presentation since synchronizers\r\n        // will get cleaned up and they need the viewportInfo to be present\r\n        cleanUpServices(viewportInfo);\r\n\r\n        if (onElementDisabled && typeof onElementDisabled === 'function') {\r\n          onElementDisabled(viewportInfo);\r\n        }\r\n\r\n        cornerstoneViewportService.disableElement(viewportId);\r\n        viewportRef.unregister();\r\n\r\n        eventTarget.removeEventListener(Enums.Events.ELEMENT_ENABLED, elementEnabledHandler);\r\n      };\r\n    }, []);\r\n\r\n    // subscribe to displaySet metadata invalidation (updates)\r\n    // Currently, if the metadata changes we need to re-render the display set\r\n    // for it to take effect in the viewport. As we deal with scaling in the loading,\r\n    // we need to remove the old volume from the cache, and let the\r\n    // viewport to re-add it which will use the new metadata. Otherwise, the\r\n    // viewport will use the cached volume and the new metadata will not be used.\r\n    // Note: this approach does not actually end of sending network requests\r\n    // and it uses the network cache\r\n    useEffect(() => {\r\n      const { unsubscribe } = displaySetService.subscribe(\r\n        displaySetService.EVENTS.DISPLAY_SET_SERIES_METADATA_INVALIDATED,\r\n        async ({\r\n          displaySetInstanceUID: invalidatedDisplaySetInstanceUID,\r\n          invalidateData,\r\n        }: Types.DisplaySetSeriesMetadataInvalidatedEvent) => {\r\n          if (!invalidateData) {\r\n            return;\r\n          }\r\n\r\n          const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\r\n\r\n          if (viewportInfo.hasDisplaySet(invalidatedDisplaySetInstanceUID)) {\r\n            const viewportData = viewportInfo.getViewportData();\r\n            const newViewportData = await cornerstoneCacheService.invalidateViewportData(\r\n              viewportData,\r\n              invalidatedDisplaySetInstanceUID,\r\n              dataSource,\r\n              displaySetService\r\n            );\r\n\r\n            const keepCamera = true;\r\n            cornerstoneViewportService.updateViewport(viewportId, newViewportData, keepCamera);\r\n          }\r\n        }\r\n      );\r\n      return () => {\r\n        unsubscribe();\r\n      };\r\n    }, [viewportId]);\r\n\r\n    useEffect(() => {\r\n      // handle the default viewportType to be stack\r\n      if (!viewportOptions.viewportType) {\r\n        viewportOptions.viewportType = STACK;\r\n      }\r\n\r\n      const loadViewportData = async () => {\r\n        const viewportData = await cornerstoneCacheService.createViewportData(\r\n          displaySets,\r\n          viewportOptions,\r\n          dataSource,\r\n          initialImageIndex\r\n        );\r\n\r\n        const presentations = getViewportPresentations(viewportId, viewportOptions);\r\n\r\n        // Note: This is a hack to get the grid to re-render the OHIFCornerstoneViewport component\r\n        // Used for segmentation hydration right now, since the logic to decide whether\r\n        // a viewport needs to render a segmentation lives inside the CornerstoneViewportService\r\n        // so we need to re-render (force update via change of the needsRerendering) so that React\r\n        // does the diffing and decides we should render this again (although the id and element has not changed)\r\n        // so that the CornerstoneViewportService can decide whether to render the segmentation or not. Not that we reached here we can turn it off.\r\n        if (viewportOptions.needsRerendering) {\r\n          viewportOptions.needsRerendering = false;\r\n        }\r\n\r\n        cornerstoneViewportService.setViewportData(\r\n          viewportId,\r\n          viewportData,\r\n          viewportOptions,\r\n          displaySetOptions,\r\n          presentations\r\n        );\r\n      };\r\n\r\n      loadViewportData();\r\n    }, [viewportOptions, displaySets, dataSource]);\r\n\r\n    /**\r\n     * There are two scenarios for jump to click\r\n     * 1. Current viewports contain the displaySet that the annotation was drawn on\r\n     * 2. Current viewports don't contain the displaySet that the annotation was drawn on\r\n     * and we need to change the viewports displaySet for jumping.\r\n     * Since measurement_jump happens via events and listeners, the former case is handled\r\n     * by the measurement_jump direct callback, but the latter case is handled first by\r\n     * the viewportGrid to set the correct displaySet on the viewport, AND THEN we check\r\n     * the cache for jumping to see if there is any jump queued, then we jump to the correct slice.\r\n     */\r\n    useEffect(() => {\r\n      if (isJumpToMeasurementDisabled) {\r\n        return;\r\n      }\r\n\r\n      const { unsubscribe } = measurementService.subscribe(\r\n        MeasurementService.EVENTS.JUMP_TO_MEASUREMENT_VIEWPORT,\r\n        event => handleJumpToMeasurement(event, elementRef, viewportId, cornerstoneViewportService)\r\n      );\r\n\r\n      return () => {\r\n        unsubscribe();\r\n      };\r\n    }, [displaySets, elementRef, viewportId, isJumpToMeasurementDisabled, servicesManager]);\r\n\r\n    const Notification = customizationService.getCustomization('ui.notificationComponent');\r\n\r\n    return (\r\n      <React.Fragment>\r\n        <div className=\"viewport-wrapper\">\r\n          <div\r\n            className=\"cornerstone-viewport-element\"\r\n            style={{ height: '100%', width: '100%' }}\r\n            onContextMenu={e => e.preventDefault()}\r\n            onMouseDown={e => e.preventDefault()}\r\n            data-viewportId={viewportId}\r\n            ref={el => {\r\n              elementRef.current = el;\r\n              if (el) {\r\n                viewportRef.register(el);\r\n              }\r\n            }}\r\n          ></div>\r\n          <CornerstoneOverlays\r\n            viewportId={viewportId}\r\n            toolBarService={toolbarService}\r\n            element={elementRef.current}\r\n            scrollbarHeight={scrollbarHeight}\r\n            servicesManager={servicesManager}\r\n          />\r\n          <CinePlayer\r\n            enabledVPElement={enabledVPElement}\r\n            viewportId={viewportId}\r\n            servicesManager={servicesManager}\r\n          />\r\n          <ActiveViewportBehavior\r\n            viewportId={viewportId}\r\n            servicesManager={servicesManager}\r\n          />\r\n        </div>\r\n        {/* top offset of 24px to account for ViewportActionCorners. */}\r\n        <div className=\"absolute top-[24px] w-full\">\r\n          {viewportDialogState.viewportId === viewportId && (\r\n            <Notification\r\n              id=\"viewport-notification\"\r\n              message={viewportDialogState.message}\r\n              type={viewportDialogState.type}\r\n              actions={viewportDialogState.actions}\r\n              onSubmit={viewportDialogState.onSubmit}\r\n              onOutsideClick={viewportDialogState.onOutsideClick}\r\n              onKeyPress={viewportDialogState.onKeyPress}\r\n            />\r\n          )}\r\n        </div>\r\n        {/* The OHIFViewportActionCorners follows the viewport in the DOM so that it is naturally at a higher z-index.*/}\r\n        <OHIFViewportActionCorners viewportId={viewportId} />\r\n      </React.Fragment>\r\n    );\r\n  },\r\n  areEqual\r\n);\r\n\r\n// Helper function to handle jumping to measurements\r\nfunction handleJumpToMeasurement(event, elementRef, viewportId, cornerstoneViewportService) {\r\n  const { measurement, isConsumed } = event;\r\n  if (!measurement || isConsumed) {\r\n    return;\r\n  }\r\n\r\n  const enabledElement = getEnabledElement(elementRef.current);\r\n\r\n  if (!enabledElement) {\r\n    return;\r\n  }\r\n\r\n  const viewport = enabledElement.viewport as csTypes.IStackViewport | csTypes.IVolumeViewport;\r\n\r\n  const { metadata, displaySetInstanceUID } = measurement;\r\n\r\n  const viewportDisplaySets = cornerstoneViewportService.getViewportDisplaySets(viewportId);\r\n\r\n  const showingDisplaySet = viewportDisplaySets.find(\r\n    ds => ds.displaySetInstanceUID === displaySetInstanceUID\r\n  );\r\n\r\n  let metadataToUse = metadata;\r\n  // if it is not showing the displaySet we need to remove the FOR from the metadata\r\n  if (!showingDisplaySet) {\r\n    metadataToUse = {\r\n      ...metadata,\r\n      FrameOfReferenceUID: undefined,\r\n    };\r\n  }\r\n\r\n  // Todo: make it work with cases where we want to define FOR based measurements too\r\n  if (!viewport.isReferenceViewable(metadataToUse, WITH_NAVIGATION)) {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    viewport.setViewReference(metadata);\r\n    viewport.render();\r\n  } catch (e) {\r\n    console.warn('Unable to apply', metadata, e);\r\n  }\r\n\r\n  cs3DTools.annotation.selection.setAnnotationSelected(measurement.uid);\r\n  event?.consume?.();\r\n}\r\n\r\nfunction _rehydrateSynchronizers(viewportId: string, syncGroupService: any) {\r\n  const { synchronizersStore } = useSynchronizersStore.getState();\r\n  const synchronizers = synchronizersStore[viewportId];\r\n\r\n  if (!synchronizers) {\r\n    return;\r\n  }\r\n\r\n  synchronizers.forEach(synchronizerObj => {\r\n    if (!synchronizerObj.id) {\r\n      return;\r\n    }\r\n\r\n    const { id, sourceViewports, targetViewports } = synchronizerObj;\r\n\r\n    const synchronizer = syncGroupService.getSynchronizer(id);\r\n\r\n    if (!synchronizer) {\r\n      return;\r\n    }\r\n\r\n    const sourceViewportInfo = sourceViewports.find(\r\n      sourceViewport => sourceViewport.viewportId === viewportId\r\n    );\r\n\r\n    const targetViewportInfo = targetViewports.find(\r\n      targetViewport => targetViewport.viewportId === viewportId\r\n    );\r\n\r\n    const isSourceViewportInSynchronizer = synchronizer\r\n      .getSourceViewports()\r\n      .find(sourceViewport => sourceViewport.viewportId === viewportId);\r\n\r\n    const isTargetViewportInSynchronizer = synchronizer\r\n      .getTargetViewports()\r\n      .find(targetViewport => targetViewport.viewportId === viewportId);\r\n\r\n    // if the viewport was previously a source viewport, add it again\r\n    if (sourceViewportInfo && !isSourceViewportInSynchronizer) {\r\n      synchronizer.addSource({\r\n        viewportId: sourceViewportInfo.viewportId,\r\n        renderingEngineId: sourceViewportInfo.renderingEngineId,\r\n      });\r\n    }\r\n\r\n    // if the viewport was previously a target viewport, add it again\r\n    if (targetViewportInfo && !isTargetViewportInSynchronizer) {\r\n      synchronizer.addTarget({\r\n        viewportId: targetViewportInfo.viewportId,\r\n        renderingEngineId: targetViewportInfo.renderingEngineId,\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n// Component displayName\r\nOHIFCornerstoneViewport.displayName = 'OHIFCornerstoneViewport';\r\n\r\nfunction areEqual(prevProps, nextProps) {\r\n  if (nextProps.needsRerendering) {\r\n    return false;\r\n  }\r\n\r\n  if (prevProps.displaySets.length !== nextProps.displaySets.length) {\r\n    return false;\r\n  }\r\n\r\n  if (prevProps.viewportOptions.orientation !== nextProps.viewportOptions.orientation) {\r\n    return false;\r\n  }\r\n\r\n  if (prevProps.viewportOptions.toolGroupId !== nextProps.viewportOptions.toolGroupId) {\r\n    return false;\r\n  }\r\n\r\n  if (\r\n    nextProps.viewportOptions.viewportType &&\r\n    prevProps.viewportOptions.viewportType !== nextProps.viewportOptions.viewportType\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  if (nextProps.viewportOptions.needsRerendering) {\r\n    return false;\r\n  }\r\n\r\n  const prevDisplaySets = prevProps.displaySets;\r\n  const nextDisplaySets = nextProps.displaySets;\r\n\r\n  if (prevDisplaySets.length !== nextDisplaySets.length) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < prevDisplaySets.length; i++) {\r\n    const prevDisplaySet = prevDisplaySets[i];\r\n\r\n    const foundDisplaySet = nextDisplaySets.find(\r\n      nextDisplaySet =>\r\n        nextDisplaySet.displaySetInstanceUID === prevDisplaySet.displaySetInstanceUID\r\n    );\r\n\r\n    if (!foundDisplaySet) {\r\n      return false;\r\n    }\r\n\r\n    // check they contain the same image\r\n    if (foundDisplaySet.images?.length !== prevDisplaySet.images?.length) {\r\n      return false;\r\n    }\r\n\r\n    // check if their imageIds are the same\r\n    if (foundDisplaySet.images?.length) {\r\n      for (let j = 0; j < foundDisplaySet.images.length; j++) {\r\n        if (foundDisplaySet.images[j].imageId !== prevDisplaySet.images[j].imageId) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// Helper function to check if display sets have changed\r\nfunction haveDisplaySetsChanged(prevDisplaySets, currentDisplaySets) {\r\n  if (prevDisplaySets.length !== currentDisplaySets.length) {\r\n    return true;\r\n  }\r\n\r\n  return currentDisplaySets.some((currentDS, index) => {\r\n    const prevDS = prevDisplaySets[index];\r\n    return currentDS.displaySetInstanceUID !== prevDS.displaySetInstanceUID;\r\n  });\r\n}\r\n\r\nexport default OHIFCornerstoneViewport;\r\n","import React, { useEffect, useState } from 'react';\r\n\r\nimport ViewportImageScrollbar from './ViewportImageScrollbar';\r\nimport CustomizableViewportOverlay from './CustomizableViewportOverlay';\r\nimport ViewportOrientationMarkers from './ViewportOrientationMarkers';\r\nimport ViewportImageSliceLoadingIndicator from './ViewportImageSliceLoadingIndicator';\r\n\r\nfunction CornerstoneOverlays(props: withAppTypes) {\r\n  const { viewportId, element, scrollbarHeight, servicesManager } = props;\r\n  const { cornerstoneViewportService } = servicesManager.services;\r\n  const [imageSliceData, setImageSliceData] = useState({\r\n    imageIndex: 0,\r\n    numberOfSlices: 0,\r\n  });\r\n  const [viewportData, setViewportData] = useState(null);\r\n\r\n  useEffect(() => {\r\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\r\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\r\n      props => {\r\n        if (props.viewportId !== viewportId) {\r\n          return;\r\n        }\r\n\r\n        setViewportData(props.viewportData);\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [viewportId]);\r\n\r\n  if (!element) {\r\n    return null;\r\n  }\r\n\r\n  if (viewportData) {\r\n    const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\r\n\r\n    if (viewportInfo?.viewportOptions?.customViewportProps?.hideOverlays) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"noselect\">\r\n      <ViewportImageScrollbar\r\n        viewportId={viewportId}\r\n        viewportData={viewportData}\r\n        element={element}\r\n        imageSliceData={imageSliceData}\r\n        setImageSliceData={setImageSliceData}\r\n        scrollbarHeight={scrollbarHeight}\r\n        servicesManager={servicesManager}\r\n      />\r\n\r\n      <CustomizableViewportOverlay\r\n        imageSliceData={imageSliceData}\r\n        viewportData={viewportData}\r\n        viewportId={viewportId}\r\n        servicesManager={servicesManager}\r\n        element={element}\r\n      />\r\n\r\n      <ViewportImageSliceLoadingIndicator\r\n        viewportData={viewportData}\r\n        element={element}\r\n      />\r\n\r\n      <ViewportOrientationMarkers\r\n        imageSliceData={imageSliceData}\r\n        element={element}\r\n        viewportData={viewportData}\r\n        servicesManager={servicesManager}\r\n        viewportId={viewportId}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default CornerstoneOverlays;\r\n","import React, { useCallback, useEffect, useMemo, useState } from 'react';\r\nimport { vec3 } from 'gl-matrix';\r\nimport PropTypes from 'prop-types';\r\nimport { metaData, Enums, utilities } from '@cornerstonejs/core';\r\nimport type { ImageSliceData } from '@cornerstonejs/core/types';\r\nimport { ViewportOverlay } from '@ohif/ui-next';\r\nimport type { InstanceMetadata } from '@ohif/core/src/types';\r\nimport { formatDICOMDate, formatDICOMTime, formatNumberPrecision } from './utils';\r\nimport { utils } from '@ohif/core';\r\nimport { StackViewportData, VolumeViewportData } from '../../types/CornerstoneCacheService';\r\n\r\nimport './CustomizableViewportOverlay.css';\r\nimport { useViewportRendering } from '../../hooks';\r\n\r\nconst EPSILON = 1e-4;\r\nconst { formatPN } = utils;\r\n\r\ntype ViewportData = StackViewportData | VolumeViewportData;\r\n\r\ninterface OverlayItemProps {\r\n  element: HTMLElement;\r\n  viewportData: ViewportData;\r\n  imageSliceData: ImageSliceData;\r\n  servicesManager: AppTypes.ServicesManager;\r\n  viewportId: string;\r\n  instance: InstanceMetadata;\r\n  customization: any;\r\n  formatters: {\r\n    formatPN: (val) => string;\r\n    formatDate: (val) => string;\r\n    formatTime: (val) => string;\r\n    formatNumberPrecision: (val, number) => string;\r\n  };\r\n\r\n  // calculated values\r\n  voi: {\r\n    windowWidth: number;\r\n    windowCenter: number;\r\n  };\r\n  instanceNumber?: number;\r\n  scale?: number;\r\n}\r\n\r\nconst OverlayItemComponents = {\r\n  'ohif.overlayItem': OverlayItem,\r\n  'ohif.overlayItem.windowLevel': VOIOverlayItem,\r\n  'ohif.overlayItem.zoomLevel': ZoomOverlayItem,\r\n  'ohif.overlayItem.instanceNumber': InstanceNumberOverlayItem,\r\n};\r\n\r\n/**\r\n * Customizable Viewport Overlay\r\n */\r\nfunction CustomizableViewportOverlay({\r\n  element,\r\n  viewportData,\r\n  imageSliceData,\r\n  viewportId,\r\n  servicesManager,\r\n}: {\r\n  element: HTMLElement;\r\n  viewportData: ViewportData;\r\n  imageSliceData: ImageSliceData;\r\n  viewportId: string;\r\n  servicesManager: AppTypes.ServicesManager;\r\n}) {\r\n  const { cornerstoneViewportService, customizationService, toolGroupService, displaySetService } =\r\n    servicesManager.services;\r\n  const [voi, setVOI] = useState({ windowCenter: null, windowWidth: null });\r\n  const [scale, setScale] = useState(1);\r\n  const { isViewportBackgroundLight: isLight } = useViewportRendering(viewportId);\r\n  const { imageIndex } = imageSliceData;\r\n\r\n  // Historical usage defined the overlays as separate items due to lack of\r\n  // append functionality.  This code enables the historical usage, but\r\n  // the recommended functionality is to append to the default values in\r\n  // cornerstoneOverlay rather than defining individual items.\r\n  const topLeftCustomization = customizationService.getCustomization('viewportOverlay.topLeft');\r\n  const topRightCustomization = customizationService.getCustomization('viewportOverlay.topRight');\r\n  const bottomLeftCustomization = customizationService.getCustomization(\r\n    'viewportOverlay.bottomLeft'\r\n  );\r\n  const bottomRightCustomization = customizationService.getCustomization(\r\n    'viewportOverlay.bottomRight'\r\n  );\r\n\r\n  const instanceNumber = useMemo(\r\n    () =>\r\n      viewportData\r\n        ? getInstanceNumber(viewportData, viewportId, imageIndex, cornerstoneViewportService)\r\n        : null,\r\n    [viewportData, viewportId, imageIndex, cornerstoneViewportService]\r\n  );\r\n\r\n  const displaySetProps = useMemo(() => {\r\n    const displaySets = getDisplaySets(viewportData, displaySetService);\r\n    if (!displaySets) {\r\n      return null;\r\n    }\r\n    const [displaySet] = displaySets;\r\n    const { instances, instance: referenceInstance } = displaySet;\r\n    return {\r\n      displaySets,\r\n      displaySet,\r\n      instance: instances?.[imageIndex],\r\n      instances,\r\n      referenceInstance,\r\n    };\r\n  }, [viewportData, viewportId, instanceNumber, cornerstoneViewportService]);\r\n\r\n  /**\r\n   * Updating the VOI when the viewport changes its voi\r\n   */\r\n  useEffect(() => {\r\n    const updateVOI = eventDetail => {\r\n      const { range } = eventDetail.detail;\r\n\r\n      if (!range) {\r\n        return;\r\n      }\r\n\r\n      const { lower, upper } = range;\r\n      const { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\r\n\r\n      setVOI({ windowCenter, windowWidth });\r\n    };\r\n\r\n    element.addEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\r\n\r\n    return () => {\r\n      element.removeEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\r\n    };\r\n  }, [viewportId, viewportData, voi, element]);\r\n\r\n  /**\r\n   * Updating the scale when the viewport changes its zoom\r\n   */\r\n  useEffect(() => {\r\n    const updateScale = eventDetail => {\r\n      const { previousCamera, camera } = eventDetail.detail;\r\n\r\n      if (\r\n        previousCamera.parallelScale !== camera.parallelScale ||\r\n        previousCamera.scale !== camera.scale\r\n      ) {\r\n        const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n\r\n        if (!viewport) {\r\n          return;\r\n        }\r\n\r\n        const scale = viewport.getZoom();\r\n\r\n        setScale(scale);\r\n      }\r\n    };\r\n\r\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\r\n\r\n    return () => {\r\n      element.removeEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\r\n    };\r\n  }, [viewportId, viewportData, cornerstoneViewportService, element]);\r\n\r\n  const _renderOverlayItem = useCallback(\r\n    (item, props) => {\r\n      const overlayItemProps = {\r\n        ...props,\r\n        element,\r\n        viewportData,\r\n        imageSliceData,\r\n        viewportId,\r\n        servicesManager,\r\n        customization: item,\r\n        isLight,\r\n        formatters: {\r\n          formatPN,\r\n          formatDate: formatDICOMDate,\r\n          formatTime: formatDICOMTime,\r\n          formatNumberPrecision,\r\n        },\r\n      };\r\n\r\n      if (!item) {\r\n        return null;\r\n      }\r\n\r\n      const { inheritsFrom } = item;\r\n      const OverlayItemComponent = OverlayItemComponents[inheritsFrom];\r\n\r\n      if (OverlayItemComponent) {\r\n        return <OverlayItemComponent {...overlayItemProps} />;\r\n      } else {\r\n        const renderItem = customizationService.transform(item);\r\n\r\n        if (typeof renderItem.contentF === 'function') {\r\n          return renderItem.contentF(overlayItemProps);\r\n        }\r\n      }\r\n    },\r\n    [\r\n      element,\r\n      viewportData,\r\n      imageSliceData,\r\n      viewportId,\r\n      servicesManager,\r\n      customizationService,\r\n      displaySetProps,\r\n      voi,\r\n      scale,\r\n      instanceNumber,\r\n    ]\r\n  );\r\n\r\n  const getContent = useCallback(\r\n    (customization, keyPrefix) => {\r\n      const props = {\r\n        ...displaySetProps,\r\n        formatters: { formatDate: formatDICOMDate },\r\n        voi,\r\n        scale,\r\n        instanceNumber,\r\n        viewportId,\r\n        toolGroupService,\r\n        isLight,\r\n      };\r\n\r\n      return (\r\n        <>\r\n          {customization.map((item, index) => (\r\n            <div key={`${keyPrefix}_${index}`}>\r\n              {((!item?.condition || item.condition(props)) && _renderOverlayItem(item, props)) ||\r\n                null}\r\n            </div>\r\n          ))}\r\n        </>\r\n      );\r\n    },\r\n    [_renderOverlayItem]\r\n  );\r\n\r\n  return (\r\n    <ViewportOverlay\r\n      topLeft={getContent(topLeftCustomization, 'topLeftOverlayItem')}\r\n      topRight={getContent(topRightCustomization, 'topRightOverlayItem')}\r\n      bottomLeft={getContent(bottomLeftCustomization, 'bottomLeftOverlayItem')}\r\n      bottomRight={getContent(bottomRightCustomization, 'bottomRightOverlayItem')}\r\n      color={isLight ? 'text-neutral-dark' : 'text-neutral-light'}\r\n      shadowClass={isLight ? 'shadow-light' : 'shadow-dark'}\r\n    />\r\n  );\r\n}\r\n\r\n/**\r\n * Gets an array of display sets for the given viewport, based on the viewport data.\r\n * Returns null if none found.\r\n */\r\nfunction getDisplaySets(viewportData, displaySetService) {\r\n  if (!viewportData?.data?.length) {\r\n    return null;\r\n  }\r\n  const displaySets = viewportData.data\r\n    .map(datum => displaySetService.getDisplaySetByUID(datum.displaySetInstanceUID))\r\n    .filter(it => !!it);\r\n  if (!displaySets.length) {\r\n    return null;\r\n  }\r\n  return displaySets;\r\n}\r\n\r\nconst getInstanceNumber = (viewportData, viewportId, imageIndex, cornerstoneViewportService) => {\r\n  let instanceNumber;\r\n\r\n  switch (viewportData.viewportType) {\r\n    case Enums.ViewportType.STACK:\r\n      instanceNumber = _getInstanceNumberFromStack(viewportData, imageIndex);\r\n      break;\r\n    case Enums.ViewportType.ORTHOGRAPHIC:\r\n      instanceNumber = _getInstanceNumberFromVolume(\r\n        viewportData,\r\n        viewportId,\r\n        cornerstoneViewportService,\r\n        imageIndex\r\n      );\r\n      break;\r\n  }\r\n\r\n  return instanceNumber ?? null;\r\n};\r\n\r\nfunction _getInstanceNumberFromStack(viewportData, imageIndex) {\r\n  const imageIds = viewportData.data[0].imageIds;\r\n  const imageId = imageIds[imageIndex];\r\n\r\n  if (!imageId) {\r\n    return;\r\n  }\r\n\r\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\r\n  const { instanceNumber } = generalImageModule;\r\n\r\n  const stackSize = imageIds.length;\r\n\r\n  if (stackSize <= 1) {\r\n    return;\r\n  }\r\n\r\n  return parseInt(instanceNumber);\r\n}\r\n\r\n// Since volume viewports can be in any view direction, they can render\r\n// a reconstructed image which don't have imageIds; therefore, no instance and instanceNumber\r\n// Here we check if viewport is in the acquisition direction and if so, we get the instanceNumber\r\nfunction _getInstanceNumberFromVolume(\r\n  viewportData,\r\n  viewportId,\r\n  cornerstoneViewportService,\r\n  imageIndex\r\n) {\r\n  const volumes = viewportData.data;\r\n\r\n  if (!volumes) {\r\n    return;\r\n  }\r\n\r\n  // Todo: support fusion of acquisition plane which has instanceNumber\r\n  const { volume } = volumes[0];\r\n\r\n  if (!volume) {\r\n    return;\r\n  }\r\n\r\n  const { direction, imageIds } = volume;\r\n\r\n  const cornerstoneViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n\r\n  if (!cornerstoneViewport) {\r\n    return;\r\n  }\r\n\r\n  const camera = cornerstoneViewport.getCamera();\r\n  const { viewPlaneNormal } = camera;\r\n  // checking if camera is looking at the acquisition plane (defined by the direction on the volume)\r\n\r\n  const scanAxisNormal = direction.slice(6, 9);\r\n\r\n  // check if viewPlaneNormal is parallel to scanAxisNormal\r\n  const cross = vec3.cross(vec3.create(), viewPlaneNormal, scanAxisNormal);\r\n  const isAcquisitionPlane = vec3.length(cross) < EPSILON;\r\n\r\n  if (isAcquisitionPlane) {\r\n    const imageId = imageIds[imageIndex];\r\n\r\n    if (!imageId) {\r\n      return {};\r\n    }\r\n\r\n    const { instanceNumber } = metaData.get('generalImageModule', imageId) || {};\r\n    return parseInt(instanceNumber);\r\n  }\r\n}\r\n\r\nfunction OverlayItem(props) {\r\n  const { instance, customization = {} } = props;\r\n  const { color, attribute, title, label, background } = customization;\r\n  const value = customization.contentF?.(props, customization) ?? instance?.[attribute];\r\n  if (value === undefined || value === null) {\r\n    return null;\r\n  }\r\n  return (\r\n    <div\r\n      className=\"overlay-item flex flex-row\"\r\n      style={{ color, background }}\r\n      title={title}\r\n    >\r\n      {label ? <span className=\"mr-1 shrink-0\">{label}</span> : null}\r\n      <span className=\"ml-0 mr-2 shrink-0\">{value}</span>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Window Level / Center Overlay item\r\n * //\r\n */\r\nfunction VOIOverlayItem({ voi, customization }: OverlayItemProps) {\r\n  const { windowWidth, windowCenter } = voi;\r\n  if (typeof windowCenter !== 'number' || typeof windowWidth !== 'number') {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div\r\n      className=\"overlay-item flex flex-row\"\r\n      style={{ color: customization?.color }}\r\n    >\r\n      <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">W:</span>\r\n      <span className=\"mr-2.5 shrink-0\">{windowWidth.toFixed(0)}</span>\r\n      <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">L:</span>\r\n      <span className=\"shrink-0\">{windowCenter.toFixed(0)}</span>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Zoom Level Overlay item\r\n */\r\nfunction ZoomOverlayItem({ scale, customization }: OverlayItemProps) {\r\n  return (\r\n    <div\r\n      className=\"overlay-item flex flex-row\"\r\n      style={{ color: (customization && customization.color) || undefined }}\r\n    >\r\n      <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">Zoom:</span>\r\n      <span>{scale.toFixed(2)}x</span>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Instance Number Overlay Item\r\n */\r\nfunction InstanceNumberOverlayItem({\r\n  instanceNumber,\r\n  imageSliceData,\r\n  customization,\r\n}: OverlayItemProps) {\r\n  const { imageIndex, numberOfSlices } = imageSliceData;\r\n\r\n  return (\r\n    <div\r\n      className=\"overlay-item flex flex-row\"\r\n      style={{ color: (customization && customization.color) || undefined }}\r\n    >\r\n      <span>\r\n        {instanceNumber !== undefined && instanceNumber !== null ? (\r\n          <>\r\n            <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">I:</span>\r\n            <span>{`${instanceNumber} (${imageIndex + 1}/${numberOfSlices})`}</span>\r\n          </>\r\n        ) : (\r\n          `${imageIndex + 1}/${numberOfSlices}`\r\n        )}\r\n      </span>\r\n    </div>\r\n  );\r\n}\r\n\r\nCustomizableViewportOverlay.propTypes = {\r\n  viewportData: PropTypes.object,\r\n  imageIndex: PropTypes.number,\r\n  viewportId: PropTypes.string,\r\n};\r\n\r\nexport default CustomizableViewportOverlay;\r\n\r\nexport { CustomizableViewportOverlay };\r\n","import React, { useEffect } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Enums, VolumeViewport3D, utilities as csUtils } from '@cornerstonejs/core';\r\nimport { ImageScrollbar } from '@ohif/ui-next';\r\n\r\nfunction CornerstoneImageScrollbar({\r\n  viewportData,\r\n  viewportId,\r\n  element,\r\n  imageSliceData,\r\n  setImageSliceData,\r\n  scrollbarHeight,\r\n  servicesManager,\r\n}: withAppTypes<{\r\n  element: HTMLElement;\r\n}>) {\r\n  const { cineService, cornerstoneViewportService } = servicesManager.services;\r\n\r\n  const onImageScrollbarChange = (imageIndex, viewportId) => {\r\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n\r\n    const { isCineEnabled } = cineService.getState();\r\n\r\n    if (isCineEnabled) {\r\n      // on image scrollbar change, stop the CINE if it is playing\r\n      cineService.stopClip(element, { viewportId });\r\n      cineService.setCine({ id: viewportId, isPlaying: false });\r\n    }\r\n\r\n    csUtils.jumpToSlice(viewport.element, {\r\n      imageIndex,\r\n      debounceLoading: true,\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!viewportData) {\r\n      return;\r\n    }\r\n\r\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n\r\n    if (!viewport || viewport instanceof VolumeViewport3D) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const imageIndex = viewport.getCurrentImageIdIndex();\r\n      const numberOfSlices = viewport.getNumberOfSlices();\r\n\r\n      setImageSliceData({\r\n        imageIndex: imageIndex,\r\n        numberOfSlices,\r\n      });\r\n    } catch (error) {\r\n      console.warn(error);\r\n    }\r\n  }, [viewportId, viewportData]);\r\n\r\n  useEffect(() => {\r\n    if (!viewportData) {\r\n      return;\r\n    }\r\n    const { viewportType } = viewportData;\r\n    const eventId =\r\n      (viewportType === Enums.ViewportType.STACK && Enums.Events.STACK_NEW_IMAGE) ||\r\n      (viewportType === Enums.ViewportType.ORTHOGRAPHIC && Enums.Events.VOLUME_NEW_IMAGE) ||\r\n      Enums.Events.IMAGE_RENDERED;\r\n\r\n    const updateIndex = event => {\r\n      const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n      if (!viewport || viewport instanceof VolumeViewport3D) {\r\n        return;\r\n      }\r\n      const { imageIndex, newImageIdIndex = imageIndex, imageIdIndex } = event.detail;\r\n      const numberOfSlices = viewport.getNumberOfSlices();\r\n      // find the index of imageId in the imageIds\r\n      setImageSliceData({\r\n        imageIndex: newImageIdIndex ?? imageIdIndex,\r\n        numberOfSlices,\r\n      });\r\n    };\r\n\r\n    element.addEventListener(eventId, updateIndex);\r\n\r\n    return () => {\r\n      element.removeEventListener(eventId, updateIndex);\r\n    };\r\n  }, [viewportData, element]);\r\n\r\n  return (\r\n    <ImageScrollbar\r\n      onChange={evt => onImageScrollbarChange(evt, viewportId)}\r\n      max={imageSliceData.numberOfSlices ? imageSliceData.numberOfSlices - 1 : 0}\r\n      height={scrollbarHeight}\r\n      value={imageSliceData.imageIndex || 0}\r\n    />\r\n  );\r\n}\r\n\r\nCornerstoneImageScrollbar.propTypes = {\r\n  viewportData: PropTypes.object,\r\n  viewportId: PropTypes.string.isRequired,\r\n  element: PropTypes.instanceOf(Element),\r\n  scrollbarHeight: PropTypes.string,\r\n  imageSliceData: PropTypes.object.isRequired,\r\n  setImageSliceData: PropTypes.func.isRequired,\r\n  servicesManager: PropTypes.object.isRequired,\r\n};\r\n\r\nexport default CornerstoneImageScrollbar;\r\n","import React, { useEffect, useState, useRef } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Enums } from '@cornerstonejs/core';\r\n\r\nfunction ViewportImageSliceLoadingIndicator({ viewportData, element }) {\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(false);\r\n\r\n  const loadIndicatorRef = useRef(null);\r\n  const imageIdToBeLoaded = useRef(null);\r\n\r\n  const setLoadingState = evt => {\r\n    clearTimeout(loadIndicatorRef.current);\r\n\r\n    loadIndicatorRef.current = setTimeout(() => {\r\n      setLoading(true);\r\n    }, 50);\r\n  };\r\n\r\n  const setFinishLoadingState = evt => {\r\n    clearTimeout(loadIndicatorRef.current);\r\n\r\n    setLoading(false);\r\n  };\r\n\r\n  const setErrorState = evt => {\r\n    clearTimeout(loadIndicatorRef.current);\r\n\r\n    if (imageIdToBeLoaded.current === evt.detail.imageId) {\r\n      setError(evt.detail.error);\r\n      imageIdToBeLoaded.current = null;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    element.addEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, setLoadingState);\r\n    element.addEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\r\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, setFinishLoadingState);\r\n\r\n    return () => {\r\n      element.removeEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, setLoadingState);\r\n\r\n      element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, setFinishLoadingState);\r\n\r\n      element.removeEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\r\n    };\r\n  }, [element, viewportData]);\r\n\r\n  if (error) {\r\n    return (\r\n      <>\r\n        <div className=\"absolute top-0 left-0 h-full w-full bg-black opacity-50\">\r\n          <div className=\"transparent flex h-full w-full items-center justify-center\">\r\n            <p className=\"text-primary-light text-xl font-light\">\r\n              <h4>Error Loading Image</h4>\r\n              <p>An error has occurred.</p>\r\n              <p>{error}</p>\r\n            </p>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n\r\n  if (loading) {\r\n    return (\r\n      // IMPORTANT: we need to use the pointer-events-none class to prevent the loading indicator from\r\n      // interacting with the mouse, since scrolling should propagate to the viewport underneath\r\n      <div className=\"pointer-events-none absolute top-0 left-0 h-full w-full bg-black opacity-50\">\r\n        <div className=\"transparent flex h-full w-full items-center justify-center\">\r\n          <p className=\"text-primary-light text-xl font-light\">Loading...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nViewportImageSliceLoadingIndicator.propTypes = {\r\n  error: PropTypes.object,\r\n  element: PropTypes.object,\r\n};\r\n\r\nexport default ViewportImageSliceLoadingIndicator;\r\n","import React, { useEffect, useState, useMemo, useRef } from 'react';\r\nimport classNames from 'classnames';\r\nimport {\r\n  metaData,\r\n  Enums,\r\n  Types,\r\n  getEnabledElement,\r\n  utilities as coreUtilities,\r\n} from '@cornerstonejs/core';\r\nimport { utilities } from '@cornerstonejs/tools';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nimport './ViewportOrientationMarkers.css';\r\nimport { useViewportRendering } from '../../hooks';\r\nconst { getOrientationStringLPS, invertOrientationStringLPS } = utilities.orientation;\r\n\r\nfunction ViewportOrientationMarkers({\r\n  element,\r\n  viewportData,\r\n  imageSliceData,\r\n  viewportId,\r\n  servicesManager,\r\n  orientationMarkers = ['top', 'left'],\r\n}: withAppTypes) {\r\n  // Rotation is in degrees\r\n  const [rotation, setRotation] = useState(0);\r\n  const [flipHorizontal, setFlipHorizontal] = useState(false);\r\n  const [flipVertical, setFlipVertical] = useState(false);\r\n  const { isViewportBackgroundLight: isLight } = useViewportRendering(viewportId);\r\n  const { cornerstoneViewportService } = servicesManager.services;\r\n\r\n  // Store initial viewUp and viewRight for volume viewports\r\n  const initialVolumeOrientationRef = useRef<{\r\n    initialViewUp: number[] | null;\r\n    initialViewRight: number[] | null;\r\n  }>({\r\n    initialViewUp: null,\r\n    initialViewRight: null,\r\n  });\r\n\r\n  useEffect(() => {\r\n    initialVolumeOrientationRef.current.initialViewUp = null;\r\n    initialVolumeOrientationRef.current.initialViewRight = null;\r\n\r\n    if (viewportData?.viewportType !== 'stack' && element && getEnabledElement(element)) {\r\n      const { viewport } = getEnabledElement(element);\r\n      const { viewUp, viewPlaneNormal } = viewport.getCamera();\r\n\r\n      const viewRight = vec3.create();\r\n      vec3.cross(viewRight, viewUp, viewPlaneNormal);\r\n\r\n      initialVolumeOrientationRef.current.initialViewUp = [...viewUp];\r\n      initialVolumeOrientationRef.current.initialViewRight = [...viewRight];\r\n    }\r\n  }, [element, viewportData]);\r\n\r\n  useEffect(() => {\r\n    const cameraModifiedListener = (evt: Types.EventTypes.CameraModifiedEvent) => {\r\n      const { previousCamera, camera } = evt.detail;\r\n\r\n      const { rotation } = camera;\r\n      if (rotation !== undefined) {\r\n        setRotation(rotation);\r\n      }\r\n\r\n      if (\r\n        camera.flipHorizontal !== undefined &&\r\n        previousCamera.flipHorizontal !== camera.flipHorizontal\r\n      ) {\r\n        setFlipHorizontal(camera.flipHorizontal);\r\n      }\r\n\r\n      if (\r\n        camera.flipVertical !== undefined &&\r\n        previousCamera.flipVertical !== camera.flipVertical\r\n      ) {\r\n        setFlipVertical(camera.flipVertical);\r\n      }\r\n    };\r\n\r\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, cameraModifiedListener);\r\n\r\n    return () => {\r\n      element.removeEventListener(Enums.Events.CAMERA_MODIFIED, cameraModifiedListener);\r\n    };\r\n  }, []);\r\n\r\n  const markers = useMemo(() => {\r\n    if (!viewportData) {\r\n      return '';\r\n    }\r\n\r\n    let rowCosines, columnCosines, isDefaultValueSetForRowCosine, isDefaultValueSetForColumnCosine;\r\n    if (viewportData.viewportType === 'stack') {\r\n      const imageIndex = imageSliceData.imageIndex;\r\n      const imageId = viewportData.data[0].imageIds?.[imageIndex];\r\n\r\n      // Workaround for below TODO stub\r\n      if (!imageId) {\r\n        return false;\r\n      }\r\n\r\n      ({\r\n        rowCosines,\r\n        columnCosines,\r\n        isDefaultValueSetForColumnCosine,\r\n        isDefaultValueSetForColumnCosine,\r\n      } = metaData.get('imagePlaneModule', imageId) || {});\r\n    } else {\r\n      if (!element || !getEnabledElement(element)) {\r\n        return '';\r\n      }\r\n\r\n      if (\r\n        initialVolumeOrientationRef.current.initialViewUp &&\r\n        initialVolumeOrientationRef.current.initialViewRight\r\n      ) {\r\n        // Use initial orientation values for consistency, even as the camera changes\r\n        columnCosines = [\r\n          -initialVolumeOrientationRef.current.initialViewUp[0],\r\n          -initialVolumeOrientationRef.current.initialViewUp[1],\r\n          -initialVolumeOrientationRef.current.initialViewUp[2],\r\n        ];\r\n        rowCosines = initialVolumeOrientationRef.current.initialViewRight;\r\n      } else {\r\n        console.warn('ViewportOrientationMarkers::No initial orientation values');\r\n        return '';\r\n      }\r\n    }\r\n\r\n    if (\r\n      !rowCosines ||\r\n      !columnCosines ||\r\n      rotation === undefined ||\r\n      isDefaultValueSetForRowCosine ||\r\n      isDefaultValueSetForColumnCosine\r\n    ) {\r\n      return '';\r\n    }\r\n\r\n    const markers = _getOrientationMarkers(\r\n      rowCosines,\r\n      columnCosines,\r\n      rotation,\r\n      flipVertical,\r\n      flipHorizontal\r\n    );\r\n\r\n    const ohifViewport = cornerstoneViewportService.getViewportInfo(viewportId);\r\n\r\n    if (!ohifViewport) {\r\n      console.log('ViewportOrientationMarkers::No viewport');\r\n      return null;\r\n    }\r\n\r\n    return orientationMarkers.map((m, index) => (\r\n      <div\r\n        className={classNames(\r\n          'overlay-text',\r\n          `${m}-mid orientation-marker`,\r\n          isLight ? 'text-neutral-dark/70' : 'text-neutral-light/70',\r\n          isLight ? 'shadow-light' : 'shadow-dark',\r\n          'text-base',\r\n          'leading-5'\r\n        )}\r\n        key={`${m}-mid orientation-marker`}\r\n      >\r\n        <div className=\"orientation-marker-value\">{markers[m]}</div>\r\n      </div>\r\n    ));\r\n  }, [\r\n    viewportData,\r\n    imageSliceData,\r\n    rotation,\r\n    flipVertical,\r\n    flipHorizontal,\r\n    orientationMarkers,\r\n    element,\r\n    isLight,\r\n  ]);\r\n\r\n  return <div className=\"ViewportOrientationMarkers select-none\">{markers}</div>;\r\n}\r\n\r\n/**\r\n *\r\n * Computes the orientation labels on a Cornerstone-enabled Viewport element\r\n * when the viewport settings change (e.g. when a horizontal flip or a rotation occurs)\r\n *\r\n * @param {*} rowCosines\r\n * @param {*} columnCosines\r\n * @param {*} rotation in degrees\r\n * @returns\r\n */\r\nfunction _getOrientationMarkers(rowCosines, columnCosines, rotation, flipVertical, flipHorizontal) {\r\n  const rowString = getOrientationStringLPS(rowCosines);\r\n  const columnString = getOrientationStringLPS(columnCosines);\r\n  const oppositeRowString = invertOrientationStringLPS(rowString);\r\n  const oppositeColumnString = invertOrientationStringLPS(columnString);\r\n\r\n  const markers = {\r\n    top: oppositeColumnString,\r\n    left: oppositeRowString,\r\n    right: rowString,\r\n    bottom: columnString,\r\n  };\r\n\r\n  // If any vertical or horizontal flips are applied, change the orientation strings ahead of\r\n  // the rotation applications\r\n  if (flipVertical) {\r\n    markers.top = invertOrientationStringLPS(markers.top);\r\n    markers.bottom = invertOrientationStringLPS(markers.bottom);\r\n  }\r\n\r\n  if (flipHorizontal) {\r\n    markers.left = invertOrientationStringLPS(markers.left);\r\n    markers.right = invertOrientationStringLPS(markers.right);\r\n  }\r\n\r\n  // Swap the labels accordingly if the viewport has been rotated\r\n  // This could be done in a more complex way for intermediate rotation values (e.g. 45 degrees)\r\n  if (rotation === 90 || rotation === -270) {\r\n    return {\r\n      top: markers.left,\r\n      left: invertOrientationStringLPS(markers.top),\r\n      right: invertOrientationStringLPS(markers.bottom),\r\n      bottom: markers.right, // left\r\n    };\r\n  } else if (rotation === -90 || rotation === 270) {\r\n    return {\r\n      top: invertOrientationStringLPS(markers.left),\r\n      left: markers.top,\r\n      bottom: markers.left,\r\n      right: markers.bottom,\r\n    };\r\n  } else if (rotation === 180 || rotation === -180) {\r\n    return {\r\n      top: invertOrientationStringLPS(markers.top),\r\n      left: invertOrientationStringLPS(markers.left),\r\n      bottom: invertOrientationStringLPS(markers.bottom),\r\n      right: invertOrientationStringLPS(markers.right),\r\n    };\r\n  }\r\n\r\n  return markers;\r\n}\r\n\r\nexport default ViewportOrientationMarkers;\r\n","import moment from 'moment';\r\nimport { metaData } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Checks if value is valid.\r\n *\r\n * @param {number} value\r\n * @returns {boolean} is valid.\r\n */\r\nexport function isValidNumber(value) {\r\n  return typeof value === 'number' && !isNaN(value);\r\n}\r\n\r\n/**\r\n * Formats number precision.\r\n *\r\n * @param {number} number\r\n * @param {number} precision\r\n * @returns {number} formatted number.\r\n */\r\nexport function formatNumberPrecision(number, precision = 0) {\r\n  if (number !== null) {\r\n    return parseFloat(number).toFixed(precision);\r\n  }\r\n}\r\n\r\n/**\r\n * Formats DICOM date.\r\n *\r\n * @param {string} date\r\n * @param {string} strFormat\r\n * @returns {string} formatted date.\r\n */\r\nexport function formatDICOMDate(date, strFormat = 'MMM D, YYYY') {\r\n  return moment(date, 'YYYYMMDD').format(strFormat);\r\n}\r\n\r\n/**\r\n *    DICOM Time is stored as HHmmss.SSS, where:\r\n *      HH 24 hour time:\r\n *        m mm        0..59   Minutes\r\n *        s ss        0..59   Seconds\r\n *        S SS SSS    0..999  Fractional seconds\r\n *\r\n *        Goal: '24:12:12'\r\n *\r\n * @param {*} time\r\n * @param {string} strFormat\r\n * @returns {string} formatted name.\r\n */\r\nexport function formatDICOMTime(time, strFormat = 'HH:mm:ss') {\r\n  return moment(time, 'HH:mm:ss').format(strFormat);\r\n}\r\n\r\n/**\r\n * Gets compression type\r\n *\r\n * @param {number} imageId\r\n * @returns {string} compression type.\r\n */\r\nexport function getCompression(imageId) {\r\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\r\n  const { lossyImageCompression, lossyImageCompressionRatio, lossyImageCompressionMethod } =\r\n    generalImageModule;\r\n\r\n  if (lossyImageCompression === '01' && lossyImageCompressionRatio !== '') {\r\n    const compressionMethod = lossyImageCompressionMethod || 'Lossy: ';\r\n    const compressionRatio = formatNumberPrecision(lossyImageCompressionRatio, 2);\r\n    return compressionMethod + compressionRatio + ' : 1';\r\n  }\r\n\r\n  return 'Lossless / Uncompressed';\r\n}\r\n","import React, { useCallback, useEffect, useState, useRef } from 'react';\r\nimport { useCine } from '@ohif/ui-next';\r\nimport { Enums, eventTarget, cache } from '@cornerstonejs/core';\r\nimport { useAppConfig } from '@state';\r\n\r\nfunction WrappedCinePlayer({\r\n  enabledVPElement,\r\n  viewportId,\r\n  servicesManager,\r\n}: withAppTypes<{\r\n  enabledVPElement: HTMLElement;\r\n  viewportId: string;\r\n}>) {\r\n  const { customizationService, displaySetService, viewportGridService } = servicesManager.services;\r\n  const [{ isCineEnabled, cines }, cineService] = useCine();\r\n  const [newStackFrameRate, setNewStackFrameRate] = useState(24);\r\n  const [dynamicInfo, setDynamicInfo] = useState(null);\r\n  const [appConfig] = useAppConfig();\r\n  const isMountedRef = useRef(null);\r\n\r\n  const cineHandler = () => {\r\n    if (!cines?.[viewportId] || !enabledVPElement) {\r\n      return;\r\n    }\r\n\r\n    const { isPlaying = false, frameRate = 24 } = cines[viewportId];\r\n    const validFrameRate = Math.max(frameRate, 1);\r\n\r\n    return isPlaying\r\n      ? cineService.playClip(enabledVPElement, { framesPerSecond: validFrameRate, viewportId })\r\n      : cineService.stopClip(enabledVPElement);\r\n  };\r\n\r\n  const newDisplaySetHandler = useCallback(() => {\r\n    if (!enabledVPElement || !isCineEnabled) {\r\n      return;\r\n    }\r\n\r\n    const { viewports } = viewportGridService.getState();\r\n    const { displaySetInstanceUIDs } = viewports.get(viewportId);\r\n    let frameRate = 24;\r\n    let isPlaying = cines[viewportId]?.isPlaying || false;\r\n    displaySetInstanceUIDs.forEach(displaySetInstanceUID => {\r\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n      if (displaySet.FrameRate) {\r\n        // displaySet.FrameRate corresponds to DICOM tag (0018,1063) which is defined as the the frame time in milliseconds\r\n        // So a bit of math to get the actual frame rate.\r\n        frameRate = Math.round(1000 / displaySet.FrameRate);\r\n        isPlaying ||= !!appConfig.autoPlayCine;\r\n      }\r\n\r\n      // check if the displaySet is dynamic and set the dynamic info\r\n      if (displaySet.isDynamicVolume) {\r\n        const { dynamicVolumeInfo } = displaySet;\r\n        const numDimensionGroups = dynamicVolumeInfo.timePoints.length;\r\n        const label = dynamicVolumeInfo.splittingTag;\r\n        const dimensionGroupNumber = dynamicVolumeInfo.dimensionGroupNumber || 1;\r\n        setDynamicInfo({\r\n          volumeId: displaySet.displaySetInstanceUID,\r\n          dimensionGroupNumber,\r\n          numDimensionGroups,\r\n          label,\r\n        });\r\n      } else {\r\n        setDynamicInfo(null);\r\n      }\r\n    });\r\n\r\n    if (isPlaying) {\r\n      cineService.setIsCineEnabled(isPlaying);\r\n    }\r\n    cineService.setCine({ id: viewportId, isPlaying, frameRate });\r\n    setNewStackFrameRate(frameRate);\r\n  }, [displaySetService, viewportId, viewportGridService, cines, isCineEnabled, enabledVPElement]);\r\n\r\n  useEffect(() => {\r\n    isMountedRef.current = true;\r\n\r\n    newDisplaySetHandler();\r\n\r\n    return () => {\r\n      isMountedRef.current = false;\r\n    };\r\n  }, [isCineEnabled, newDisplaySetHandler]);\r\n\r\n  useEffect(() => {\r\n    if (!isCineEnabled) {\r\n      return;\r\n    }\r\n\r\n    cineHandler();\r\n  }, [isCineEnabled, cineHandler, enabledVPElement]);\r\n\r\n  /**\r\n   * Use effect for handling new display set\r\n   */\r\n  useEffect(() => {\r\n    if (!enabledVPElement) {\r\n      return;\r\n    }\r\n\r\n    enabledVPElement.addEventListener(Enums.Events.VIEWPORT_NEW_IMAGE_SET, newDisplaySetHandler);\r\n    // this doesn't makes sense that we are listening to this event on viewport element\r\n    enabledVPElement.addEventListener(\r\n      Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n      newDisplaySetHandler\r\n    );\r\n\r\n    return () => {\r\n      cineService.setCine({ id: viewportId, isPlaying: false });\r\n\r\n      enabledVPElement.removeEventListener(\r\n        Enums.Events.VIEWPORT_NEW_IMAGE_SET,\r\n        newDisplaySetHandler\r\n      );\r\n      enabledVPElement.removeEventListener(\r\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n        newDisplaySetHandler\r\n      );\r\n    };\r\n  }, [enabledVPElement, newDisplaySetHandler, viewportId]);\r\n\r\n  useEffect(() => {\r\n    if (!cines || !cines[viewportId] || !enabledVPElement || !isMountedRef.current) {\r\n      return;\r\n    }\r\n\r\n    cineHandler();\r\n\r\n    return () => {\r\n      cineService.stopClip(enabledVPElement, { viewportId });\r\n    };\r\n  }, [cines, viewportId, cineService, enabledVPElement, cineHandler]);\r\n\r\n  if (!isCineEnabled) {\r\n    return null;\r\n  }\r\n\r\n  const cine = cines[viewportId];\r\n  const isPlaying = cine?.isPlaying || false;\r\n\r\n  return (\r\n    <RenderCinePlayer\r\n      viewportId={viewportId}\r\n      cineService={cineService}\r\n      newStackFrameRate={newStackFrameRate}\r\n      isPlaying={isPlaying}\r\n      dynamicInfo={dynamicInfo}\r\n      customizationService={customizationService}\r\n    />\r\n  );\r\n}\r\n\r\nfunction RenderCinePlayer({\r\n  viewportId,\r\n  cineService,\r\n  newStackFrameRate,\r\n  isPlaying,\r\n  dynamicInfo: dynamicInfoProp,\r\n  customizationService,\r\n}) {\r\n  const CinePlayerComponent = customizationService.getCustomization('cinePlayer');\r\n\r\n  const [dynamicInfo, setDynamicInfo] = useState(dynamicInfoProp);\r\n\r\n  useEffect(() => {\r\n    setDynamicInfo(dynamicInfoProp);\r\n  }, [dynamicInfoProp]);\r\n\r\n  /**\r\n   * Use effect for handling 4D time index changed\r\n   */\r\n  useEffect(() => {\r\n    if (!dynamicInfo) {\r\n      return;\r\n    }\r\n\r\n    const handleDimensionGroupChange = evt => {\r\n      const { volumeId, dimensionGroupNumber, numDimensionGroups, splittingTag } = evt.detail;\r\n      setDynamicInfo({ volumeId, dimensionGroupNumber, numDimensionGroups, label: splittingTag });\r\n    };\r\n\r\n    eventTarget.addEventListener(\r\n      Enums.Events.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED,\r\n      handleDimensionGroupChange\r\n    );\r\n\r\n    return () => {\r\n      eventTarget.removeEventListener(\r\n        Enums.Events.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED,\r\n        handleDimensionGroupChange\r\n      );\r\n    };\r\n  }, [dynamicInfo]);\r\n\r\n  useEffect(() => {\r\n    if (!dynamicInfo) {\r\n      return;\r\n    }\r\n\r\n    const { volumeId, dimensionGroupNumber, numDimensionGroups, splittingTag } = dynamicInfo || {};\r\n    const volume = cache.getVolume(volumeId, true);\r\n    volume.dimensionGroupNumber = dimensionGroupNumber;\r\n\r\n    setDynamicInfo({ volumeId, dimensionGroupNumber, numDimensionGroups, label: splittingTag });\r\n  }, []);\r\n\r\n  const updateDynamicInfo = useCallback(props => {\r\n    const { volumeId, dimensionGroupNumber } = props;\r\n    const volume = cache.getVolume(volumeId, true);\r\n    volume.dimensionGroupNumber = dimensionGroupNumber;\r\n  }, []);\r\n\r\n  return (\r\n    <CinePlayerComponent\r\n      className=\"absolute left-1/2 bottom-3 -translate-x-1/2\"\r\n      frameRate={newStackFrameRate}\r\n      isPlaying={isPlaying}\r\n      onClose={() => {\r\n        // also stop the clip\r\n        cineService.setCine({\r\n          id: viewportId,\r\n          isPlaying: false,\r\n        });\r\n        cineService.setIsCineEnabled(false);\r\n        cineService.setViewportCineClosed(viewportId);\r\n      }}\r\n      onPlayPauseChange={isPlaying => {\r\n        cineService.setCine({\r\n          id: viewportId,\r\n          isPlaying,\r\n        });\r\n      }}\r\n      onFrameRateChange={frameRate =>\r\n        cineService.setCine({\r\n          id: viewportId,\r\n          frameRate,\r\n        })\r\n      }\r\n      dynamicInfo={dynamicInfo}\r\n      updateDynamicInfo={updateDynamicInfo}\r\n    />\r\n  );\r\n}\r\n\r\nexport default WrappedCinePlayer;","import CinePlayer from './CinePlayer';\r\n\r\nexport default CinePlayer;\r\n","import React, { memo } from 'react';\r\nimport { ViewportActionCorners, IconPresentationProvider, ToolButton } from '@ohif/ui-next';\r\nimport { Toolbar } from '@ohif/extension-default/src/Toolbar/Toolbar';\r\nimport { ButtonLocation } from '@ohif/core/src/services/ToolBarService/ToolbarService';\r\nimport { useViewportHover } from '../hooks';\r\n\r\nexport type OHIFViewportActionCornersProps = {\r\n  viewportId: string;\r\n};\r\n\r\nfunction OHIFViewportActionCornersComponent({ viewportId }: OHIFViewportActionCornersProps) {\r\n  // Use the viewport hover hook to track if viewport is hovered or active\r\n  const { isHovered, isActive } = useViewportHover(viewportId);\r\n\r\n  const shouldShowCorners = isHovered || isActive;\r\n\r\n  if (!shouldShowCorners) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <IconPresentationProvider\r\n      size=\"medium\"\r\n      IconContainer={ToolButton}\r\n      containerProps={{\r\n        size: 'tiny',\r\n        className: 'font-normal text-primary hover:bg-primary/25',\r\n      }}\r\n    >\r\n      <ViewportActionCorners.Container>\r\n        <ViewportActionCorners.TopLeft>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.topLeft\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.TopLeft}\r\n          />\r\n        </ViewportActionCorners.TopLeft>\r\n        <ViewportActionCorners.TopMiddle>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.topMiddle\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.TopMiddle}\r\n          />\r\n        </ViewportActionCorners.TopMiddle>\r\n        <ViewportActionCorners.TopRight>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.topRight\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.TopRight}\r\n          />\r\n        </ViewportActionCorners.TopRight>\r\n        <ViewportActionCorners.LeftMiddle>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.leftMiddle\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.LeftMiddle}\r\n          />\r\n        </ViewportActionCorners.LeftMiddle>\r\n        <ViewportActionCorners.RightMiddle>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.rightMiddle\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.RightMiddle}\r\n          />\r\n        </ViewportActionCorners.RightMiddle>\r\n        <ViewportActionCorners.BottomLeft>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.bottomLeft\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.BottomLeft}\r\n          />\r\n        </ViewportActionCorners.BottomLeft>\r\n        <ViewportActionCorners.BottomMiddle>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.bottomMiddle\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.BottomMiddle}\r\n          />\r\n        </ViewportActionCorners.BottomMiddle>\r\n        <ViewportActionCorners.BottomRight>\r\n          <Toolbar\r\n            buttonSection=\"viewportActionMenu.bottomRight\"\r\n            viewportId={viewportId}\r\n            location={ButtonLocation.BottomRight}\r\n          />\r\n        </ViewportActionCorners.BottomRight>\r\n      </ViewportActionCorners.Container>\r\n    </IconPresentationProvider>\r\n  );\r\n}\r\n\r\nconst OHIFViewportActionCorners = memo(OHIFViewportActionCornersComponent);\r\n\r\nexport default OHIFViewportActionCorners;\r\n","import { useEffect, useState, memo, useCallback } from 'react';\r\n\r\nconst ActiveViewportBehavior = memo(\r\n  ({ servicesManager, viewportId }: withAppTypes<{ viewportId: string }>) => {\r\n    const {\r\n      displaySetService,\r\n      cineService,\r\n      viewportGridService,\r\n      customizationService,\r\n      cornerstoneViewportService,\r\n    } = servicesManager.services;\r\n\r\n    const [activeViewportId, setActiveViewportId] = useState(viewportId);\r\n\r\n    const handleCineEnable = useCallback(() => {\r\n      if (cineService.isViewportCineClosed(activeViewportId)) {\r\n        return;\r\n      }\r\n\r\n      const displaySetInstanceUIDs =\r\n        viewportGridService.getDisplaySetsUIDsForViewport(activeViewportId);\r\n\r\n      if (!displaySetInstanceUIDs) {\r\n        return;\r\n      }\r\n\r\n      const displaySets = displaySetInstanceUIDs.map(uid =>\r\n        displaySetService.getDisplaySetByUID(uid)\r\n      );\r\n\r\n      if (!displaySets.length) {\r\n        return;\r\n      }\r\n\r\n      const modalities = displaySets.map(displaySet => displaySet?.Modality);\r\n      const isDynamicVolume = displaySets.some(displaySet => displaySet?.isDynamicVolume);\r\n\r\n      const sourceModalities = customizationService.getCustomization('autoCineModalities');\r\n\r\n      const requiresCine = modalities.some(modality => sourceModalities.includes(modality));\r\n\r\n      if ((requiresCine || isDynamicVolume) && !cineService.getState().isCineEnabled) {\r\n        cineService.setIsCineEnabled(true);\r\n      }\r\n    }, [\r\n      activeViewportId,\r\n      cineService,\r\n      viewportGridService,\r\n      displaySetService,\r\n      customizationService,\r\n    ]);\r\n\r\n    useEffect(() => {\r\n      const subscription = viewportGridService.subscribe(\r\n        viewportGridService.EVENTS.ACTIVE_VIEWPORT_ID_CHANGED,\r\n        ({ viewportId }) => setActiveViewportId(viewportId)\r\n      );\r\n\r\n      return () => subscription.unsubscribe();\r\n    }, [viewportId, viewportGridService]);\r\n\r\n    useEffect(() => {\r\n      const subscription = cornerstoneViewportService.subscribe(\r\n        cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\r\n        () => {\r\n          const activeViewportId = viewportGridService.getActiveViewportId();\r\n          setActiveViewportId(activeViewportId);\r\n          handleCineEnable();\r\n        }\r\n      );\r\n\r\n      return () => subscription.unsubscribe();\r\n    }, [viewportId, cornerstoneViewportService, viewportGridService, handleCineEnable]);\r\n\r\n    useEffect(() => {\r\n      handleCineEnable();\r\n    }, [handleCineEnable]);\r\n\r\n    return null;\r\n  },\r\n  arePropsEqual\r\n);\r\n\r\nActiveViewportBehavior.displayName = 'ActiveViewportBehavior';\r\n\r\nfunction arePropsEqual(prevProps, nextProps) {\r\n  return (\r\n    prevProps.viewportId === nextProps.viewportId &&\r\n    prevProps.servicesManager === nextProps.servicesManager\r\n  );\r\n}\r\n\r\nexport default ActiveViewportBehavior;\r\n","import { usePositionPresentationStore } from '../../stores/usePositionPresentationStore';\r\nimport { useLutPresentationStore } from '../../stores/useLutPresentationStore';\r\nimport { useSegmentationPresentationStore } from '../../stores/useSegmentationPresentationStore';\r\n\r\nexport function getViewportPresentations(\r\n  viewportId: string,\r\n  viewportOptions: AppTypes.ViewportGrid.GridViewportOptions\r\n) {\r\n  const { lutPresentationStore } = useLutPresentationStore.getState();\r\n  const { positionPresentationStore } = usePositionPresentationStore.getState();\r\n  const { segmentationPresentationStore } = useSegmentationPresentationStore.getState();\r\n\r\n  // NOTE: this is the new viewport state, we should not get the presentationIds from the cornerstoneViewportService\r\n  // since that has the old viewport state\r\n  const { presentationIds } = viewportOptions;\r\n\r\n  if (!presentationIds) {\r\n    return {\r\n      positionPresentation: null,\r\n      lutPresentation: null,\r\n      segmentationPresentation: null,\r\n    };\r\n  }\r\n\r\n  const { lutPresentationId, positionPresentationId, segmentationPresentationId } = presentationIds;\r\n\r\n  const positionPresentation = positionPresentationStore[positionPresentationId];\r\n  const lutPresentation = lutPresentationStore[lutPresentationId];\r\n  const segmentationPresentation = segmentationPresentationStore[segmentationPresentationId];\r\n\r\n  return {\r\n    positionPresentation,\r\n    lutPresentation,\r\n    segmentationPresentation,\r\n  };\r\n}\r\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.viewport-wrapper {\r\n  width: 100%;\r\n  height: 100%; /* MUST have \\`height\\` to prevent resize infinite loop */\r\n  position: relative;\r\n  /* Prevent text selection on the entire viewport wrapper */\r\n  user-select: none;\r\n  -webkit-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n}\r\n\r\n.cornerstone-viewport-element {\r\n  outline: 0 !important;\r\n}\r\n\r\n.cornerstone-viewport-element {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n  background-color: black;\r\n\r\n  /* Prevent the blue outline in Chrome when a viewport is selected */\r\n\r\n  /* Prevents the entire page from getting larger\r\n     when the magnify tool is near the sides/corners of the page */\r\n  overflow: hidden;\r\n  \r\n  /* Prevent text selection on the viewport element */\r\n  user-select: none;\r\n  -webkit-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n}\r\n\r\n/* Prevent text selection on overlay elements */\r\n\r\n.noselect {\r\n  user-select: none;\r\n  -webkit-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n}\r\n\r\n/* Ensure all elements within viewport wrapper prevent text selection */\r\n\r\n.viewport-wrapper * {\r\n  user-select: none;\r\n  -webkit-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n}\r\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./../../../extensions/cornerstone/src/Viewport/OHIFCornerstoneViewport.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,WAAW;EACX,YAAY,EAAE,uDAAuD;EACrE,kBAAkB;EAClB,0DAA0D;EAC1D,iBAAiB;EACjB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;AACvB;;AAEA;EAOE,qBAAqB;AAWvB;;AAlBA;EACE,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,uBAAuB;;EAEvB,mEAAmE;;EAGnE;kEACgE;EAChE,gBAAgB;;EAEhB,mDAAmD;EACnD,iBAAiB;EACjB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;AACvB;;AAEA,+CAA+C;;AAC/C;EACE,iBAAiB;EACjB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;AACvB;;AAEA,uEAAuE;;AACvE;EACE,iBAAiB;EACjB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;AACvB\",\"sourcesContent\":[\".viewport-wrapper {\\r\\n  width: 100%;\\r\\n  height: 100%; /* MUST have `height` to prevent resize infinite loop */\\r\\n  position: relative;\\r\\n  /* Prevent text selection on the entire viewport wrapper */\\r\\n  user-select: none;\\r\\n  -webkit-user-select: none;\\r\\n  -moz-user-select: none;\\r\\n  -ms-user-select: none;\\r\\n}\\r\\n\\r\\n.cornerstone-viewport-element {\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  position: relative;\\r\\n  background-color: black;\\r\\n\\r\\n  /* Prevent the blue outline in Chrome when a viewport is selected */\\r\\n  outline: 0 !important;\\r\\n\\r\\n  /* Prevents the entire page from getting larger\\r\\n     when the magnify tool is near the sides/corners of the page */\\r\\n  overflow: hidden;\\r\\n  \\r\\n  /* Prevent text selection on the viewport element */\\r\\n  user-select: none;\\r\\n  -webkit-user-select: none;\\r\\n  -moz-user-select: none;\\r\\n  -ms-user-select: none;\\r\\n}\\r\\n\\r\\n/* Prevent text selection on overlay elements */\\r\\n.noselect {\\r\\n  user-select: none;\\r\\n  -webkit-user-select: none;\\r\\n  -moz-user-select: none;\\r\\n  -ms-user-select: none;\\r\\n}\\r\\n\\r\\n/* Ensure all elements within viewport wrapper prevent text selection */\\r\\n.viewport-wrapper * {\\r\\n  user-select: none;\\r\\n  -webkit-user-select: none;\\r\\n  -moz-user-select: none;\\r\\n  -ms-user-select: none;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/*\r\ncustom overlay panels: top-left, top-right, bottom-left and bottom-right\r\nIf any text to be displayed on the overlay is too long to hold on a single\r\nline, it will be truncated with ellipsis in the end.\r\n*/\r\n.viewport-overlay {\r\n  max-width: 40%;\r\n}\r\n.viewport-overlay span {\r\n  max-width: 100%;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.viewport-overlay.left-viewport {\r\n  text-align: left;\r\n}\r\n.viewport-overlay.right-viewport-scrollbar {\r\n  text-align: right;\r\n}\r\n.viewport-overlay.right-viewport-scrollbar .flex.flex-row {\r\n  -webkit-box-pack: end;\r\n      -ms-flex-pack: end;\r\n          justify-content: flex-end;\r\n}\r\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./../../../extensions/cornerstone/src/Viewport/Overlays/CustomizableViewportOverlay.css\"],\"names\":[],\"mappings\":\"AAAA;;;;CAIC;AACD;EACE,cAAc;AAChB;AACA;EACE,eAAe;EACf,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;AACrB;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,iBAAiB;AACnB;AACA;EACE,qBAAyB;MAAzB,kBAAyB;UAAzB,yBAAyB;AAC3B\",\"sourcesContent\":[\"/*\\r\\ncustom overlay panels: top-left, top-right, bottom-left and bottom-right\\r\\nIf any text to be displayed on the overlay is too long to hold on a single\\r\\nline, it will be truncated with ellipsis in the end.\\r\\n*/\\r\\n.viewport-overlay {\\r\\n  max-width: 40%;\\r\\n}\\r\\n.viewport-overlay span {\\r\\n  max-width: 100%;\\r\\n  overflow: hidden;\\r\\n  text-overflow: ellipsis;\\r\\n  white-space: nowrap;\\r\\n}\\r\\n\\r\\n.viewport-overlay.left-viewport {\\r\\n  text-align: left;\\r\\n}\\r\\n\\r\\n.viewport-overlay.right-viewport-scrollbar {\\r\\n  text-align: right;\\r\\n}\\r\\n.viewport-overlay.right-viewport-scrollbar .flex.flex-row {\\r\\n  justify-content: flex-end;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.ViewportOrientationMarkers {\r\n  --marker-width: 100px;\r\n  --marker-height: 100px;\r\n  --scrollbar-width: 20px;\r\n  pointer-events: none;\r\n  line-height: 18px;\r\n}\r\n.ViewportOrientationMarkers .orientation-marker {\r\n  position: absolute;\r\n}\r\n.ViewportOrientationMarkers .top-mid {\r\n  top: 0.38rem;\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n.ViewportOrientationMarkers .left-mid {\r\n  top: 50%;\r\n  left: 0.38rem;\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n}\r\n.ViewportOrientationMarkers .right-mid {\r\n  top: 50%;\r\n  left: calc(100% - var(--marker-width) - var(--scrollbar-width));\r\n  -webkit-transform: translateY(-50%);\r\n          transform: translateY(-50%);\r\n}\r\n.ViewportOrientationMarkers .bottom-mid {\r\n  top: calc(100% - var(--marker-height) - 0.6rem);\r\n  left: 50%;\r\n  -webkit-transform: translateX(-50%);\r\n          transform: translateX(-50%);\r\n}\r\n.ViewportOrientationMarkers .right-mid .orientation-marker-value {\r\n  display: -webkit-box;\r\n  display: -ms-flexbox;\r\n  display: flex;\r\n  -webkit-box-pack: end;\r\n      -ms-flex-pack: end;\r\n          justify-content: flex-end;\r\n  min-width: var(--marker-width);\r\n}\r\n.ViewportOrientationMarkers .bottom-mid .orientation-marker-value {\r\n  display: -webkit-box;\r\n  display: -ms-flexbox;\r\n  display: flex;\r\n  -webkit-box-pack: start;\r\n      -ms-flex-pack: start;\r\n          justify-content: flex-start;\r\n  min-height: var(--marker-height);\r\n  -webkit-box-orient: vertical;\r\n  -webkit-box-direction: reverse;\r\n      -ms-flex-direction: column-reverse;\r\n          flex-direction: column-reverse;\r\n}\r\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./../../../extensions/cornerstone/src/Viewport/Overlays/ViewportOrientationMarkers.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,qBAAqB;EACrB,sBAAsB;EACtB,uBAAuB;EACvB,oBAAoB;EACpB,iBAAiB;AACnB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,YAAY;EACZ,SAAS;EACT,mCAA2B;UAA3B,2BAA2B;AAC7B;AACA;EACE,QAAQ;EACR,aAAa;EACb,mCAA2B;UAA3B,2BAA2B;AAC7B;AACA;EACE,QAAQ;EACR,+DAA+D;EAC/D,mCAA2B;UAA3B,2BAA2B;AAC7B;AACA;EACE,+CAA+C;EAC/C,SAAS;EACT,mCAA2B;UAA3B,2BAA2B;AAC7B;AACA;EACE,oBAAa;EAAb,oBAAa;EAAb,aAAa;EACb,qBAAyB;MAAzB,kBAAyB;UAAzB,yBAAyB;EACzB,8BAA8B;AAChC;AACA;EACE,oBAAa;EAAb,oBAAa;EAAb,aAAa;EACb,uBAA2B;MAA3B,oBAA2B;UAA3B,2BAA2B;EAC3B,gCAAgC;EAChC,4BAA8B;EAA9B,8BAA8B;MAA9B,kCAA8B;UAA9B,8BAA8B;AAChC\",\"sourcesContent\":[\".ViewportOrientationMarkers {\\r\\n  --marker-width: 100px;\\r\\n  --marker-height: 100px;\\r\\n  --scrollbar-width: 20px;\\r\\n  pointer-events: none;\\r\\n  line-height: 18px;\\r\\n}\\r\\n.ViewportOrientationMarkers .orientation-marker {\\r\\n  position: absolute;\\r\\n}\\r\\n.ViewportOrientationMarkers .top-mid {\\r\\n  top: 0.38rem;\\r\\n  left: 50%;\\r\\n  transform: translateX(-50%);\\r\\n}\\r\\n.ViewportOrientationMarkers .left-mid {\\r\\n  top: 50%;\\r\\n  left: 0.38rem;\\r\\n  transform: translateY(-50%);\\r\\n}\\r\\n.ViewportOrientationMarkers .right-mid {\\r\\n  top: 50%;\\r\\n  left: calc(100% - var(--marker-width) - var(--scrollbar-width));\\r\\n  transform: translateY(-50%);\\r\\n}\\r\\n.ViewportOrientationMarkers .bottom-mid {\\r\\n  top: calc(100% - var(--marker-height) - 0.6rem);\\r\\n  left: 50%;\\r\\n  transform: translateX(-50%);\\r\\n}\\r\\n.ViewportOrientationMarkers .right-mid .orientation-marker-value {\\r\\n  display: flex;\\r\\n  justify-content: flex-end;\\r\\n  min-width: var(--marker-width);\\r\\n}\\r\\n.ViewportOrientationMarkers .bottom-mid .orientation-marker-value {\\r\\n  display: flex;\\r\\n  justify-content: flex-start;\\r\\n  min-height: var(--marker-height);\\r\\n  flex-direction: column-reverse;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","var api = require(\"!../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./OHIFCornerstoneViewport.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./OHIFCornerstoneViewport.css\",\n      function () {\n        content = require(\"!!../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./OHIFCornerstoneViewport.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};","var api = require(\"!../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./CustomizableViewportOverlay.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./CustomizableViewportOverlay.css\",\n      function () {\n        content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./CustomizableViewportOverlay.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};","var api = require(\"!../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./ViewportOrientationMarkers.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./ViewportOrientationMarkers.css\",\n      function () {\n        content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[5].use[2]!./ViewportOrientationMarkers.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};"],"names":[],"sourceRoot":""}