{"version":3,"file":"vendors-node_modules_cornerstonejs_adapters_dist_esm_index_js-node_modules_cornerstonejs_tool-7ad6ae.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdA;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3pCA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACLA;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CAngle.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CArrowAnnotate.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CBaseAdapter3D.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CBidirectional.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CCircleROI.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CCobbAngle.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CCodingScheme.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CEllipticalROI.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CKeyImage.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CLength.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CMeasurementReport.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CParametricMap%5CgenerateToolState.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CParametricMap%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CPlanarFreehandROI.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CProbe.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5CRTSS.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5Cutilities%5CgetPatientModule.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5Cutilities%5CgetRTROIObservationsSequence.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5Cutilities%5CgetRTSeriesModule.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5Cutilities%5CgetReferencedFrameOfReferenceSequence.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5Cutilities%5CgetReferencedSeriesSequence.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRTStruct%5Cutilities%5CgetStructureSetModule.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CRectangleROI.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CSegmentation%5CcompactMergeSegData.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CSegmentation%5CgenerateLabelMaps2DFrom3D.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CSegmentation%5CgenerateSegmentation.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CSegmentation%5CgenerateToolState.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CSegmentation%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CSegmentation%5ClabelmapImagesFromBuffer.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5CUltrasoundDirectional.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5Cconstants%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5Ccornerstone3DTag.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone3D%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CAngle.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CArrowAnnotate.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CBidirectional.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CCircleRoi.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CCobbAngle.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CEllipticalRoi.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CFreehandRoi.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CLength.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CMeasurementReport.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CParametricMap.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CRectangleRoi.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CSegmentation.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CSegmentation_3X.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5CSegmentation_4X.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5Ccornerstone4Tag.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CCornerstone%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CVTKjs%5CSegmentation.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5CVTKjs%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Cenums%5CEvents.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Cenums%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CcheckIfPerpendicular.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CcheckOrientation.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CcodeMeaningEquals.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CcompareArrays.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CcopySeriesTags.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CcopyStudyTags.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CdownloadDICOMData.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CgetDatasetsFromImages.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CgraphicTypeEquals.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Chelpers%5CtoArray.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cadapters%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cadapters%5Cdist%5Cesm%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CAnnotationStyleStates.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CChangeTypes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CEvents.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CSegmentationRepresentations.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CStrategyCallbacks.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CToolBindings.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CToolModes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CTouch.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CWorkerTypes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5Ciota-array%5Ciota.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5Cis-buffer%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5Cndarray%5Cndarray.js"],"sourcesContent":["import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Angle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass Angle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Angle.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n    const middle = worldToImageCoords(referencedImageId, handles.points[1]);\n    const end = worldToImageCoords(referencedImageId, handles.points[2]);\n    const point1 = {\n      x: start1[0],\n      y: start1[1]\n    };\n    const point2 = {\n      x: middle[0],\n      y: middle[1]\n    };\n    const point3 = point2;\n    const point4 = {\n      x: end[0],\n      y: end[1]\n    };\n    const {\n      angle\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const start = handles.points[0];\n    const middle = handles.points[1];\n    const end = handles.points[2];\n    const point1 = {\n      x: start[0],\n      y: start[1],\n      z: start[2]\n    };\n    const point2 = {\n      x: middle[0],\n      y: middle[1],\n      z: middle[2]\n    };\n    const point3 = point2;\n    const point4 = {\n      x: end[0],\n      y: end[1],\n      z: end[2]\n    };\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      angle\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Angle = Angle;\n(() => {\n  _Angle.init(\"Angle\", TID300CobbAngle);\n  _Angle.registerLegacy();\n})();\n\nexport { Angle as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport { utilities } from 'dcmjs';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport CodingScheme from './CodingScheme.js';\n\nvar _ArrowAnnotate;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst {\n  codeValues\n} = CodingScheme;\nclass ArrowAnnotate extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, _trackingIdentifier) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, ArrowAnnotate.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const text = defaultState.annotation.metadata.label;\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        SCOORDGroup,\n        referencedImageId,\n        metadata,\n        imageToWorldCoords,\n        defaultState,\n        text,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        SCOORD3DGroup,\n        defaultState,\n        text\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord3D(_ref) {\n    let {\n      SCOORD3DGroup,\n      defaultState,\n      text\n    } = _ref;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      text,\n      handles: {\n        arrowFirst: true,\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      }\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord(_ref2) {\n    let {\n      SCOORDGroup,\n      referencedImageId,\n      metadata,\n      imageToWorldCoords,\n      defaultState,\n      text,\n      ReferencedFrameNumber\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    if (worldCoords.length === 1) {\n      const imagePixelModule = metadata.get(\"imagePixelModule\", referencedImageId);\n      let xOffset = 10;\n      let yOffset = 10;\n      if (imagePixelModule) {\n        const {\n          columns,\n          rows\n        } = imagePixelModule;\n        xOffset = columns / 10;\n        yOffset = rows / 10;\n      }\n      const secondPoint = imageToWorldCoords(referencedImageId, [GraphicData[0] + xOffset, GraphicData[1] + yOffset]);\n      worldCoords.push(secondPoint);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      text,\n      handles: {\n        arrowFirst: true,\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata,\n      findingSites\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const {\n      points,\n      arrowFirst\n    } = data.handles;\n    let point;\n    let point2;\n    if (arrowFirst) {\n      point = points[0];\n      point2 = points[1];\n    } else {\n      point = points[1];\n      point2 = points[0];\n    }\n    const pointImage = worldToImageCoords(referencedImageId, point);\n    const pointImage2 = worldToImageCoords(referencedImageId, point2);\n    const TID300RepresentationArguments = {\n      points: [{\n        x: pointImage[0],\n        y: pointImage[1]\n      }, {\n        x: pointImage2[0],\n        y: pointImage2[1]\n      }],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      use3DSpatialCoordinates: false\n    };\n    if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: codeValues.CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: CodingScheme.CodingSchemeDesignator,\n        CodeMeaning: data.text\n      };\n    }\n    return TID300RepresentationArguments;\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      findingSites,\n      metadata\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const {\n      points,\n      arrowFirst\n    } = data.handles;\n    let point;\n    let point2;\n    if (arrowFirst) {\n      point = points[0];\n      point2 = points[1];\n    } else {\n      point = points[1];\n      point2 = points[0];\n    }\n    const pointImage = point;\n    const pointImage2 = point2;\n    const TID300RepresentationArguments = {\n      points: [{\n        x: pointImage[0],\n        y: pointImage[1],\n        z: pointImage[2]\n      }, {\n        x: pointImage2[0],\n        y: pointImage2[1],\n        z: pointImage2[2]\n      }],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n    if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: codeValues.CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: CodingScheme.CodingSchemeDesignator,\n        CodeMeaning: data.text\n      };\n    }\n    return TID300RepresentationArguments;\n  }\n}\n_ArrowAnnotate = ArrowAnnotate;\n(() => {\n  _ArrowAnnotate.init(\"ArrowAnnotate\", TID300Point);\n  _ArrowAnnotate.registerLegacy();\n})();\n\nexport { ArrowAnnotate as default };\n","import CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport MeasurementReport from './MeasurementReport.js';\n\nclass BaseAdapter3D {\n  static init(toolType, representation, options) {\n    this.toolType = toolType;\n    if (BaseAdapter3D.toolType) {\n      throw new Error(`Base adapter tool type set to ${this.toolType} while setting ${toolType}`);\n    }\n    this.parentType = options?.parentType;\n    this.trackingIdentifiers = new Set();\n    this.TID300Representation = representation;\n    if (this.parentType) {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${this.parentType}:${this.toolType}`;\n      const alternateTrackingIdentifier = `${CORNERSTONE_3D_TAG}:${this.toolType}`;\n      this.trackingIdentifiers.add(alternateTrackingIdentifier);\n    } else {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${toolType}`;\n    }\n    this.trackingIdentifiers.add(this.trackingIdentifierTextValue);\n    MeasurementReport.registerTool(this);\n  }\n  static registerLegacy() {\n    this.trackingIdentifiers.add(`cornerstoneTools@^4.0.0:${this.toolType}`);\n  }\n  static registerSubType(adapter, toolType, replace) {\n    const subAdapter = Object.create(adapter);\n    subAdapter.init(toolType, adapter.TID300Representation, {\n      parentType: adapter.parentType || adapter.toolType,\n      replace\n    });\n    return subAdapter;\n  }\n  static isValidCornerstoneTrackingIdentifier(trackingIdentifier) {\n    if (this.trackingIdentifiers.has(trackingIdentifier)) {\n      return true;\n    }\n    if (!trackingIdentifier.includes(\":\")) {\n      return false;\n    }\n    return trackingIdentifier.startsWith(this.trackingIdentifierTextValue);\n  }\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, _imageToWorldCoords, metadata, trackingIdentifier) {\n    const {\n      defaultState: state,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    state.annotation.data = {\n      cachedStats: {},\n      frameNumber: ReferencedFrameNumber,\n      seriesLevel: trackingIdentifier?.indexOf(\":Series\") > 0\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata\n    } = tool;\n    const {\n      finding,\n      findingSites\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const pointsImage = points.map(point => {\n      const pointImage = worldToImageCoords(referencedImageId, point);\n      return {\n        x: pointImage[0],\n        y: pointImage[1]\n      };\n    });\n    const tidArguments = {\n      points: pointsImage,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding\n    };\n    return tidArguments;\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const point = points[0];\n    const pointXYZ = {\n      x: point[0],\n      y: point[1],\n      z: point[2]\n    };\n    return {\n      points: [pointXYZ],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding\n    };\n  }\n}\n\nexport { BaseAdapter3D as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Bidirectional;\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nclass Bidirectional extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Bidirectional.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    if (longAxisSCOORDGroup && shortAxisSCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        longAxisNUMGroup,\n        shortAxisNUMGroup,\n        longAxisSCOORDGroup,\n        shortAxisSCOORDGroup,\n        referencedImageId,\n        imageToWorldCoords,\n        ReferencedFrameNumber,\n        defaultState\n      });\n    } else {\n      return this.getMeasurementDataFromScoord3d({\n        longAxisNUMGroup,\n        shortAxisNUMGroup,\n        defaultState\n      });\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      longAxisNUMGroup,\n      shortAxisNUMGroup,\n      longAxisSCOORDGroup,\n      shortAxisSCOORDGroup,\n      referencedImageId,\n      imageToWorldCoords,\n      ReferencedFrameNumber,\n      defaultState\n    } = _ref;\n    const worldCoords = [];\n    [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(group => {\n      const {\n        GraphicData\n      } = group;\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n        worldCoords.push(point);\n      }\n    });\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n          width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3d(_ref2) {\n    let {\n      longAxisNUMGroup,\n      shortAxisNUMGroup,\n      defaultState\n    } = _ref2;\n    const worldCoords = [];\n    const longAxisSCOORD3DGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\");\n    const shortAxisSCOORD3DGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\");\n    [longAxisSCOORD3DGroup, shortAxisSCOORD3DGroup].forEach(group => {\n      const {\n        GraphicData\n      } = group;\n      for (let i = 0; i < GraphicData.length; i += 3) {\n        const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n        worldCoords.push(point);\n      }\n    });\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    const {\n      points\n    } = handles;\n    const firstPointPairs = [points[0], points[1]];\n    const secondPointPairs = [points[2], points[3]];\n    const firstPointPairsDistance = Math.sqrt(Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) + Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) + Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2));\n    const secondPointPairsDistance = Math.sqrt(Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) + Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) + Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2));\n    let shortAxisPoints;\n    let longAxisPoints;\n    if (firstPointPairsDistance > secondPointPairsDistance) {\n      shortAxisPoints = firstPointPairs;\n      longAxisPoints = secondPointPairs;\n    } else {\n      shortAxisPoints = secondPointPairs;\n      longAxisPoints = firstPointPairs;\n    }\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D({\n        tool,\n        shortAxisPoints,\n        longAxisPoints\n      });\n    }\n    const longAxisStartImage = worldToImageCoords(referencedImageId, shortAxisPoints[0]);\n    const longAxisEndImage = worldToImageCoords(referencedImageId, shortAxisPoints[1]);\n    const shortAxisStartImage = worldToImageCoords(referencedImageId, longAxisPoints[0]);\n    const shortAxisEndImage = worldToImageCoords(referencedImageId, longAxisPoints[1]);\n    const {\n      length,\n      width\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      longAxis: {\n        point1: {\n          x: longAxisStartImage[0],\n          y: longAxisStartImage[1]\n        },\n        point2: {\n          x: longAxisEndImage[0],\n          y: longAxisEndImage[1]\n        }\n      },\n      shortAxis: {\n        point1: {\n          x: shortAxisStartImage[0],\n          y: shortAxisStartImage[1]\n        },\n        point2: {\n          x: shortAxisEndImage[0],\n          y: shortAxisEndImage[1]\n        }\n      },\n      longAxisLength: length,\n      shortAxisLength: width,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(_ref3) {\n    let {\n      tool,\n      shortAxisPoints,\n      longAxisPoints\n    } = _ref3;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {}\n    } = data;\n    const longAxisStart = shortAxisPoints[0];\n    const longAxisEnd = shortAxisPoints[1];\n    const shortAxisStart = longAxisPoints[0];\n    const shortAxisEnd = longAxisPoints[1];\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      length,\n      width\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      longAxis: {\n        point1: {\n          x: longAxisStart[0],\n          y: longAxisStart[1],\n          z: longAxisStart[2]\n        },\n        point2: {\n          x: longAxisEnd[0],\n          y: longAxisEnd[1],\n          z: longAxisEnd[2]\n        }\n      },\n      shortAxis: {\n        point1: {\n          x: shortAxisStart[0],\n          y: shortAxisStart[1],\n          z: shortAxisStart[2]\n        },\n        point2: {\n          x: shortAxisEnd[0],\n          y: shortAxisEnd[1],\n          z: shortAxisEnd[2]\n        }\n      },\n      longAxisLength: length,\n      shortAxisLength: width,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Bidirectional = Bidirectional;\n(() => {\n  _Bidirectional.init(\"Bidirectional\", TID300Bidirectional);\n  _Bidirectional.registerLegacy();\n})();\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _CircleROI;\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nclass CircleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CircleROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const worldPos = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      pointsWorld.push(worldPos);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...pointsWorld],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n          radius: 0,\n          perimeter: 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const worldPos = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      pointsWorld.push(worldPos);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...pointsWorld],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const center = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const points = [];\n    points.push({\n      x: center[0],\n      y: center[1]\n    });\n    points.push({\n      x: end[0],\n      y: end[1]\n    });\n    const {\n      area,\n      radius\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    const perimeter = 2 * Math.PI * radius;\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const center = handles.points[0];\n    const end = handles.points[1];\n    const points = [];\n    points.push({\n      x: center[0],\n      y: center[1],\n      z: center[2]\n    });\n    points.push({\n      x: end[0],\n      y: end[1],\n      z: center[2]\n    });\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      area,\n      radius\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    const perimeter = 2 * Math.PI * radius;\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_CircleROI = CircleROI;\n(() => {\n  _CircleROI.init(\"CircleROI\", TID300Circle);\n  _CircleROI.registerLegacy();\n})();\n\nexport { CircleROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _CobbAngle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass CobbAngle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CobbAngle.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end1 = worldToImageCoords(referencedImageId, handles.points[1]);\n    const start2 = worldToImageCoords(referencedImageId, handles.points[2]);\n    const end2 = worldToImageCoords(referencedImageId, handles.points[3]);\n    const point1 = {\n      x: start1[0],\n      y: start1[1]\n    };\n    const point2 = {\n      x: end1[0],\n      y: end1[1]\n    };\n    const point3 = {\n      x: start2[0],\n      y: start2[1]\n    };\n    const point4 = {\n      x: end2[0],\n      y: end2[1]\n    };\n    const {\n      angle\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const start1 = handles.points[0];\n    const end1 = handles.points[1];\n    const start2 = handles.points[2];\n    const end2 = handles.points[3];\n    const point1 = {\n      x: start1[0],\n      y: start1[1],\n      z: start1[2]\n    };\n    const point2 = {\n      x: end1[0],\n      y: end1[1],\n      z: end1[2]\n    };\n    const point3 = {\n      x: start2[0],\n      y: start2[1],\n      z: start2[2]\n    };\n    const point4 = {\n      x: end2[0],\n      y: end2[1],\n      z: end2[2]\n    };\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      angle\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_CobbAngle = CobbAngle;\n(() => {\n  _CobbAngle.init(\"CobbAngle\", TID300CobbAngle);\n  _CobbAngle.registerLegacy();\n})();\n\nexport { CobbAngle as default };\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\nconst CodingScheme = {\n  CodingSchemeDesignator,\n  codeValues: {\n    CORNERSTONEFREETEXT\n  }\n};\n\nexport { CodingScheme as default };\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _EllipticalROI;\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nconst EPSILON = 1e-4;\nclass EllipticalROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, EllipticalROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        metadata,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      metadata,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const worldPos = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      pointsWorld.push(worldPos);\n    }\n    const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n    const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n    const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n    const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n    const majorAxisVec = vec3.create();\n    vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n    if (!imagePlaneModule) {\n      throw new Error(\"imageId does not have imagePlaneModule metadata\");\n    }\n    const {\n      columnCosines\n    } = imagePlaneModule;\n    const columnCosinesVec = vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);\n    const projectedMajorAxisOnColVec = vec3.dot(columnCosinesVec, majorAxisVec);\n    const projectedMinorAxisOnColVec = vec3.dot(columnCosinesVec, minorAxisVec);\n    const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n    const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n    let ellipsePoints = [];\n    if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n      ellipsePoints = [pointsWorld[0], pointsWorld[1], pointsWorld[2], pointsWorld[3]];\n    } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n      ellipsePoints = [pointsWorld[2], pointsWorld[3], pointsWorld[0], pointsWorld[1]];\n    } else {\n      console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [...ellipsePoints],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const pointsWorld = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const worldPos = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      pointsWorld.push(worldPos);\n    }\n    const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n    const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n    const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n    const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n    const majorAxisVec = vec3.create();\n    vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [majorAxisStart, majorAxisEnd, minorAxisStart, minorAxisEnd],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const rotation = data.initialRotation || 0;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    let top, bottom, left, right;\n    if (rotation == 90 || rotation == 270) {\n      bottom = worldToImageCoords(referencedImageId, handles.points[2]);\n      top = worldToImageCoords(referencedImageId, handles.points[3]);\n      left = worldToImageCoords(referencedImageId, handles.points[0]);\n      right = worldToImageCoords(referencedImageId, handles.points[1]);\n    } else {\n      top = worldToImageCoords(referencedImageId, handles.points[0]);\n      bottom = worldToImageCoords(referencedImageId, handles.points[1]);\n      left = worldToImageCoords(referencedImageId, handles.points[2]);\n      right = worldToImageCoords(referencedImageId, handles.points[3]);\n    }\n    const topBottomLength = Math.abs(top[1] - bottom[1]);\n    const leftRightLength = Math.abs(left[0] - right[0]);\n    const points = [];\n    if (topBottomLength > leftRightLength) {\n      points.push({\n        x: top[0],\n        y: top[1]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1]\n      });\n      points.push({\n        x: left[0],\n        y: left[1]\n      });\n      points.push({\n        x: right[0],\n        y: right[1]\n      });\n    } else {\n      points.push({\n        x: left[0],\n        y: left[1]\n      });\n      points.push({\n        x: right[0],\n        y: right[1]\n      });\n      points.push({\n        x: top[0],\n        y: top[1]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1]\n      });\n    }\n    const {\n      area\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats,\n      handles\n    } = data;\n    const rotation = data.initialRotation || 0;\n    let top, bottom, left, right;\n    if (rotation == 90 || rotation == 270) {\n      bottom = handles.points[2];\n      top = handles.points[3];\n      left = handles.points[0];\n      right = handles.points[1];\n    } else {\n      top = handles.points[0];\n      bottom = handles.points[1];\n      left = handles.points[2];\n      right = handles.points[3];\n    }\n    const topBottomLength = Math.sqrt((top[0] - bottom[0]) ** 2 + (top[1] - bottom[1]) ** 2 + (top[2] - bottom[2]) ** 2);\n    const leftRightLength = Math.sqrt((left[0] - right[0]) ** 2 + (left[1] - right[1]) ** 2 + (left[2] - right[2]) ** 2);\n    const points = [];\n    if (topBottomLength > leftRightLength) {\n      points.push({\n        x: top[0],\n        y: top[1],\n        z: top[2]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1],\n        z: bottom[2]\n      });\n      points.push({\n        x: left[0],\n        y: left[1],\n        z: left[2]\n      });\n      points.push({\n        x: right[0],\n        y: right[1],\n        z: right[2]\n      });\n    } else {\n      points.push({\n        x: left[0],\n        y: left[1],\n        z: left[2]\n      });\n      points.push({\n        x: right[0],\n        y: right[1],\n        z: right[2]\n      });\n      points.push({\n        x: top[0],\n        y: top[1],\n        z: top[2]\n      });\n      points.push({\n        x: bottom[0],\n        y: bottom[1],\n        z: bottom[2]\n      });\n    }\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      area\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_EllipticalROI = EllipticalROI;\n_EllipticalROI.init(\"EllipticalROI\", TID300Ellipse);\n\nexport { EllipticalROI as default };\n","import { utilities } from 'dcmjs';\nimport Probe from './Probe.js';\n\nvar _KeyImage;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass KeyImage extends Probe {\n  static getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier) {\n    const baseData = super.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier);\n    const {\n      data\n    } = baseData.annotation;\n    data.isPoint = trackingIdentifier.indexOf(\"Point\") !== -1;\n    return baseData;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const tid300Arguments = super.getTID300RepresentationArguments(tool, worldToImageCoords);\n    const {\n      data\n    } = tool;\n    if (data.isPoint) {\n      if (data.seriesLevel) {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesPointIdentifier;\n      } else {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingPointIdentifier;\n      }\n    }\n    if (data.seriesLevel) {\n      tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesIdentifier;\n    }\n    if (!tid300Arguments.points.length) {\n      tid300Arguments.points.push({\n        x: 0,\n        y: 0\n      });\n    }\n    return tid300Arguments;\n  }\n}\n_KeyImage = KeyImage;\n_KeyImage.init(\"KeyImage\", TID300Point, {\n  parentType: Probe.toolType\n});\n_KeyImage.trackingSeriesIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Series`;\n_KeyImage.trackingPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Point`;\n_KeyImage.trackingSeriesPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:SeriesPoint`;\n\nexport { KeyImage, KeyImage as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Length;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length extends BaseAdapter3D {\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedFrameNumber,\n      imageToWorldCoords\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          length: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3d(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = GraphicData;\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords.slice(0, 3), worldCoords.slice(3, 6)],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        NUMGroup,\n        SCOORDGroup,\n        ReferencedFrameNumber,\n        imageToWorldCoords\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3d({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const start = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const point1 = {\n      x: start[0],\n      y: start[1]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1]\n    };\n    const {\n      length: distance\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const start = handles.points[0];\n    const end = handles.points[1];\n    const point1 = {\n      x: start[0],\n      y: start[1],\n      z: start[2]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1],\n      z: end[2]\n    };\n    const cachedStatsKeys = Object.keys(cachedStats)[0];\n    const {\n      length: distance\n    } = cachedStatsKeys ? cachedStats[cachedStatsKeys] : {};\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Length = Length;\n(() => {\n  _Length.init(LENGTH, TID300Length);\n  _Length.registerLegacy();\n})();\n\nexport { Length as default };\n","import { utilities, derivations, normalizers, data } from 'dcmjs';\nimport { cache } from '@cornerstonejs/core';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\nimport { copyStudyTags } from '../helpers/copyStudyTags.js';\nimport { copySeriesTags } from '../helpers/copySeriesTags.js';\nimport CodingScheme from './CodingScheme.js';\nimport { NO_IMAGE_ID } from './constants/index.js';\n\nvar _MeasurementReport;\nconst {\n  TID1500,\n  addAccessors\n} = utilities;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nclass MeasurementReport {\n  static getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, worldToImageCoords) {\n    const args = toolClass.getTID300RepresentationArguments(tool, worldToImageCoords);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n    const TID300Measurement = new toolClass.TID300Representation(args);\n    return TID300Measurement;\n  }\n  static getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords) {\n    const toolTypeData = toolData[toolType];\n    const toolClass = this.measurementAdapterByToolType.get(toolType);\n    if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n      return;\n    }\n    const Measurements = toolTypeData.data.map(tool => {\n      return this.getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, worldToImageCoords);\n    });\n    return new TID1501MeasurementGroup(Measurements);\n  }\n  static getCornerstoneLabelFromDefaultState(defaultState) {\n    const {\n      findingSites = [],\n      finding\n    } = defaultState;\n    const cornersoneFreeTextCodingValue = CodingScheme.codeValues.CORNERSTONEFREETEXT;\n    const freeTextLabel = findingSites.find(fs => fs.CodeValue === cornersoneFreeTextCodingValue);\n    if (freeTextLabel) {\n      return freeTextLabel.CodeMeaning;\n    }\n    if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n      return finding.CodeMeaning;\n    }\n  }\n  static generateDatasetMeta() {\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    return _meta;\n  }\n  static processSCOORDGroup(_ref) {\n    let {\n      SCOORDGroup,\n      toolType,\n      sopInstanceUIDToImageIdMap,\n      metadata\n    } = _ref;\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n    const referencedImageId = sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\n    const imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n    return {\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      state: {\n        description: undefined,\n        sopInstanceUid: ReferencedSOPInstanceUID,\n        annotation: {\n          annotationUID: DicomMetaDictionary.uid(),\n          metadata: {\n            toolName: toolType,\n            referencedImageId,\n            FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n            label: \"\"\n          }\n        }\n      }\n    };\n  }\n  static processSCOORD3DGroup(_ref2) {\n    let {\n      SCOORD3DGroup,\n      toolType\n    } = _ref2;\n    return {\n      SCOORD3DGroup,\n      FrameOfReferenceUID: SCOORD3DGroup.ReferencedFrameOfReferenceUID,\n      state: {\n        description: undefined,\n        annotation: {\n          annotationUID: DicomMetaDictionary.uid(),\n          metadata: {\n            toolName: toolType,\n            FrameOfReferenceUID: SCOORD3DGroup.ReferencedFrameOfReferenceUID,\n            label: \"\"\n          }\n        }\n      }\n    };\n  }\n  static getSpatialCoordinatesState(_ref3) {\n    let {\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      toolType\n    } = _ref3;\n    const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const SCOORD3DGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\");\n    if (SCOORDGroup) {\n      return this.processSCOORDGroup({\n        SCOORDGroup,\n        toolType,\n        metadata,\n        sopInstanceUIDToImageIdMap\n      });\n    } else if (SCOORD3DGroup) {\n      return this.processSCOORD3DGroup({\n        SCOORD3DGroup,\n        toolType\n      });\n    } else {\n      throw new Error(\"No spatial coordinates group found.\");\n    }\n  }\n  static processSpatialCoordinatesGroup(_ref4) {\n    let {\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      findingGroup,\n      findingSiteGroups,\n      toolType\n    } = _ref4;\n    const {\n      state,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      SCOORD3DGroup,\n      FrameOfReferenceUID\n    } = this.getSpatialCoordinatesState({\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      toolType\n    });\n    const finding = findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined;\n    const findingSites = findingSiteGroups.map(fsg => {\n      return addAccessors(fsg.ConceptCodeSequence);\n    });\n    const defaultState = {\n      ...state,\n      finding,\n      findingSites\n    };\n    if (defaultState.finding) {\n      defaultState.description = defaultState.finding.CodeMeaning;\n    }\n    defaultState.annotation.metadata.label = MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\n    return {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      SCOORD3DGroup,\n      FrameOfReferenceUID\n    };\n  }\n  static getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, toolType) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => this.codeValueMatch(group, FINDING));\n    const findingSiteGroups = contentSequenceArr.filter(group => this.codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\");\n    return this.processSpatialCoordinatesGroup({\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      findingGroup,\n      findingSiteGroups,\n      toolType\n    });\n  }\n  static generateReferencedSOPSequence(_ref5) {\n    let {\n      toolData,\n      toolTypes,\n      metadataProvider,\n      imageId,\n      sopInstanceUIDsToSeriesInstanceUIDMap,\n      derivationSourceDatasets\n    } = _ref5;\n    const effectiveImageId = imageId === NO_IMAGE_ID ? this.getImageIdFromVolume({\n      toolData,\n      toolTypes\n    }) : imageId;\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", effectiveImageId);\n    const instance = metadataProvider.get(\"instance\", effectiveImageId);\n    const {\n      sopInstanceUID,\n      sopClassUID\n    } = sopCommonModule;\n    const {\n      SeriesInstanceUID: seriesInstanceUID\n    } = instance;\n    sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] = seriesInstanceUID;\n    if (!derivationSourceDatasets.find(dsd => dsd.SeriesInstanceUID === seriesInstanceUID)) {\n      const derivationSourceDataset = MeasurementReport.generateDerivationSourceDataset(instance);\n      derivationSourceDatasets.push(derivationSourceDataset);\n    }\n    const frameNumber = metadataProvider.get(\"frameNumber\", effectiveImageId);\n    const ReferencedSOPSequence = {\n      ReferencedSOPClassUID: sopClassUID,\n      ReferencedSOPInstanceUID: sopInstanceUID,\n      ReferencedFrameNumber: undefined\n    };\n    if (instance && instance.NumberOfFrames && instance.NumberOfFrames > 1 || Normalizer.isMultiframeSOPClassUID(sopClassUID)) {\n      ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n    }\n    return ReferencedSOPSequence;\n  }\n  static getImageIdFromVolume(_ref6) {\n    let {\n      toolData,\n      toolTypes\n    } = _ref6;\n    const referenceToolData = toolData?.[toolTypes?.[0]]?.data?.[0];\n    const volumeId = referenceToolData?.metadata?.volumeId;\n    const volume = cache.getVolume(volumeId);\n    const imageId = volume.imageIds[0];\n    return imageId;\n  }\n  static generateReport(toolState, metadataProvider, worldToImageCoords, options) {\n    let allMeasurementGroups = [];\n    const sopInstanceUIDsToSeriesInstanceUIDMap = {};\n    const derivationSourceDatasets = [];\n    const _meta = MeasurementReport.generateDatasetMeta();\n    let is3DSR = false;\n    Object.keys(toolState).forEach(imageId => {\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const ReferencedSOPSequence = this.generateReferencedSOPSequence({\n        toolData,\n        toolTypes,\n        metadataProvider,\n        imageId,\n        sopInstanceUIDsToSeriesInstanceUIDMap,\n        derivationSourceDatasets\n      });\n      if (imageId === NO_IMAGE_ID) {\n        is3DSR = true;\n      }\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = this.getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const tid1500MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n    const report = new StructuredReport(derivationSourceDatasets, options);\n    const contentItem = tid1500MeasurementReport.contentItem(derivationSourceDatasets, {\n      ...options,\n      sopInstanceUIDsToSeriesInstanceUIDMap\n    });\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.SpecificCharacterSet = \"ISO_IR 192\";\n    if (is3DSR) {\n      report.dataset.SOPClassUID = DicomMetaDictionary.sopClassUIDsByName.Comprehensive3DSR;\n    }\n    return report;\n  }\n  static generateToolState(dataset, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, hooks) {\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n    const TRACKING_UNIQUE_IDENTIFIER = \"Tracking Unique Identifier\";\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n    const measurementData = {};\n    measurementGroups.forEach(measurementGroup => {\n      try {\n        const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n        const trackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n        const {\n          TextValue: trackingIdentifierValue\n        } = trackingIdentifierGroup;\n        const trackingUniqueIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_UNIQUE_IDENTIFIER);\n        const trackingUniqueIdentifierValue = trackingUniqueIdentifierGroup?.UID;\n        const toolAdapter = hooks?.getToolClass?.(measurementGroup, dataset, this.measurementAdapterByToolType) || this.getAdapterForTrackingIdentifier(trackingIdentifierValue);\n        if (toolAdapter) {\n          const measurement = toolAdapter.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifierValue);\n          measurement.TrackingUniqueIdentifier = trackingUniqueIdentifierValue;\n          console.log(`=== ${toolAdapter.toolType} ===`);\n          console.log(measurement);\n          measurementData[toolAdapter.toolType] ||= [];\n          measurementData[toolAdapter.toolType].push(measurement);\n        }\n      } catch (e) {\n        console.warn(\"Unable to generate tool state for\", measurementGroup, e);\n      }\n    });\n    return measurementData;\n  }\n  static registerTool(toolAdapter) {\n    let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const registerName = toolAdapter.toolType;\n    if (this.measurementAdapterByToolType.has(registerName)) {\n      if (!replace) {\n        throw new Error(`The registered tool name ${registerName} already exists in adapters, use a different toolType or use replace`);\n      }\n      if (typeof replace === \"function\") {\n        replace(this.measurementAdapterByToolType.get(registerName));\n      }\n    }\n    this.measurementAdapterByToolType.set(toolAdapter.toolType, toolAdapter);\n    this.measurementAdapterByTrackingIdentifier.set(toolAdapter.trackingIdentifierTextValue, toolAdapter);\n  }\n  static registerTrackingIdentifier(toolClass) {\n    for (var _len = arguments.length, trackingIdentifiers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      trackingIdentifiers[_key - 1] = arguments[_key];\n    }\n    for (const identifier of trackingIdentifiers) {\n      this.measurementAdapterByTrackingIdentifier.set(identifier, toolClass);\n    }\n  }\n  static getAdapterForTrackingIdentifier(trackingIdentifier) {\n    const adapter = this.measurementAdapterByTrackingIdentifier.get(trackingIdentifier);\n    if (adapter) {\n      return adapter;\n    }\n    for (const adapterTest of [...this.measurementAdapterByToolType.values()]) {\n      if (adapterTest.isValidCornerstoneTrackingIdentifier(trackingIdentifier)) {\n        this.measurementAdapterByTrackingIdentifier.set(trackingIdentifier, adapterTest);\n        return adapterTest;\n      }\n    }\n  }\n}\n_MeasurementReport = MeasurementReport;\n_MeasurementReport.CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n_MeasurementReport.measurementAdapterByToolType = new Map();\n_MeasurementReport.measurementAdapterByTrackingIdentifier = new Map();\n_MeasurementReport.codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\n_MeasurementReport.generateDerivationSourceDataset = instance => {\n  const studyTags = copyStudyTags(instance);\n  const seriesTags = copySeriesTags(instance);\n  return {\n    ...studyTags,\n    ...seriesTags\n  };\n};\n\nexport { MeasurementReport as default };\n","import { CornerstonePMAP } from '../../Cornerstone/index.js';\n\nconst {\n  ParametricMap\n} = CornerstonePMAP;\nconst {\n  generateToolState: generateToolStateCornerstone\n} = ParametricMap;\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  return generateToolStateCornerstone(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n}\n\nexport { generateToolState };\n","export { generateToolState } from './generateToolState.js';\n","import MeasurementReport from './MeasurementReport.js';\nimport { utilities } from 'dcmjs';\nimport { vec3 } from 'gl-matrix';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _PlanarFreehandROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass PlanarFreehandROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, PlanarFreehandROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        defaultState,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const distanceBetweenFirstAndLastPoint = vec3.distance(worldCoords[worldCoords.length - 1], worldCoords[0]);\n    let isOpenContour = true;\n    if (distanceBetweenFirstAndLastPoint < this.closedContourThreshold) {\n      worldCoords.pop();\n      isOpenContour = false;\n    }\n    const points = [];\n    if (isOpenContour) {\n      points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      contour: {\n        polyline: worldCoords,\n        closed: !isOpenContour\n      },\n      handles: {\n        points,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      defaultState,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const distanceBetweenFirstAndLastPoint = vec3.distance(worldCoords[worldCoords.length - 1], worldCoords[0]);\n    let isOpenContour = true;\n    if (distanceBetweenFirstAndLastPoint < this.closedContourThreshold) {\n      worldCoords.pop();\n      isOpenContour = false;\n    }\n    const points = [];\n    if (isOpenContour) {\n      points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      contour: {\n        polyline: worldCoords,\n        closed: !isOpenContour\n      },\n      handles: {\n        points,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      polyline,\n      closed\n    } = data.contour;\n    const isOpenContour = closed !== true;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const points = polyline.map(worldPos => worldToImageCoords(referencedImageId, worldPos));\n    if (!isOpenContour) {\n      const firstPoint = points[0];\n      points.push([firstPoint[0], firstPoint[1]]);\n    }\n    const {\n      area,\n      areaUnit,\n      modalityUnit,\n      perimeter,\n      mean,\n      max,\n      stdDev\n    } = data.cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      points,\n      area,\n      areaUnit,\n      perimeter,\n      modalityUnit,\n      mean,\n      max,\n      stdDev,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      polyline,\n      closed\n    } = data.contour;\n    const isOpenContour = closed !== true;\n    const points = polyline;\n    if (!isOpenContour) {\n      const firstPoint = points[0];\n      points.push([firstPoint[0], firstPoint[1], firstPoint[2]]);\n    }\n    const cachedStatsKeys = Object.keys(data.cachedStats)[0];\n    const {\n      area,\n      areaUnit,\n      modalityUnit,\n      perimeter,\n      mean,\n      max,\n      stdDev\n    } = cachedStatsKeys ? data.cachedStats[cachedStatsKeys] : {};\n    return {\n      points,\n      area,\n      areaUnit,\n      perimeter,\n      modalityUnit,\n      mean,\n      max,\n      stdDev,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_PlanarFreehandROI = PlanarFreehandROI;\n_PlanarFreehandROI.closedContourThreshold = 1e-5;\n_PlanarFreehandROI.init(\"PlanarFreehandROI\", TID300Polyline);\n\nexport { PlanarFreehandROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Probe;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass Probe extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier) {\n    const state = super.getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, trackingIdentifier);\n    const {\n      defaultState,\n      SCOORDGroup,\n      SCOORD3DGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Probe.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        state,\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        state,\n        SCOORD3DGroup\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      state,\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        points: worldCoords,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      }\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      state,\n      SCOORD3DGroup\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        points: worldCoords,\n        activeHandleIndex: null,\n        textBox: {\n          hasMoved: false\n        }\n      }\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      metadata\n    } = tool;\n    const {\n      finding,\n      findingSites\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const pointsImage = points.map(point => {\n      const pointImage = worldToImageCoords(referencedImageId, point);\n      return {\n        x: pointImage[0],\n        y: pointImage[1]\n      };\n    });\n    return {\n      points: pointsImage,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const point = points[0];\n    const pointXYZ = {\n      x: point[0],\n      y: point[1],\n      z: point[2]\n    };\n    return {\n      points: [pointXYZ],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      findingSites: findingSites || [],\n      finding,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_Probe = Probe;\n(() => {\n  _Probe.init(\"Probe\", TID300Point);\n  _Probe.registerLegacy();\n})();\n\nexport { Probe as default };\n","import { utilities } from '@cornerstonejs/tools';\nimport dcmjs from 'dcmjs';\nimport getPatientModule from './utilities/getPatientModule.js';\nimport getReferencedFrameOfReferenceSequence from './utilities/getReferencedFrameOfReferenceSequence.js';\nimport getReferencedSeriesSequence from './utilities/getReferencedSeriesSequence.js';\nimport getRTROIObservationsSequence from './utilities/getRTROIObservationsSequence.js';\nimport getRTSeriesModule from './utilities/getRTSeriesModule.js';\nimport getStructureSetModule from './utilities/getStructureSetModule.js';\n\nconst {\n  generateContourSetsFromLabelmap,\n  AnnotationToPointData\n} = utilities.contours;\nconst {\n  DicomMetaDictionary\n} = dcmjs.data;\nasync function generateRTSSFromSegmentations(segmentations, metadataProvider, DicomMetadataStore) {\n  const roiContours = [];\n  const contourSets = await generateContourSetsFromLabelmap({\n    segmentations\n  });\n  contourSets.forEach((contourSet, segIndex) => {\n    if (contourSet) {\n      const contourSequence = [];\n      contourSet.sliceContours.forEach(sliceContour => {\n        const sopCommon = metadataProvider.get(\"sopCommonModule\", sliceContour.referencedImageId);\n        const ReferencedSOPClassUID = sopCommon.sopClassUID;\n        const ReferencedSOPInstanceUID = sopCommon.sopInstanceUID;\n        const ContourImageSequence = [{\n          ReferencedSOPClassUID,\n          ReferencedSOPInstanceUID\n        }];\n        const sliceContourPolyData = sliceContour.polyData;\n        sliceContour.contours.forEach((contour, index) => {\n          const ContourGeometricType = contour.type;\n          const NumberOfContourPoints = contour.contourPoints.length;\n          const ContourData = [];\n          contour.contourPoints.forEach(point => {\n            const pointData = sliceContourPolyData.points[point];\n            pointData[0] = +pointData[0].toFixed(2);\n            pointData[1] = +pointData[1].toFixed(2);\n            pointData[2] = +pointData[2].toFixed(2);\n            ContourData.push(pointData[0]);\n            ContourData.push(pointData[1]);\n            ContourData.push(pointData[2]);\n          });\n          contourSequence.push({\n            ContourImageSequence,\n            ContourGeometricType,\n            NumberOfContourPoints,\n            ContourNumber: index + 1,\n            ContourData\n          });\n        });\n      });\n      const segLabel = contourSet.label || `Segment ${segIndex + 1}`;\n      const ROIContour = {\n        name: segLabel,\n        description: segLabel,\n        contourSequence,\n        color: contourSet.color,\n        metadata: contourSet.metadata\n      };\n      roiContours.push(ROIContour);\n    }\n  });\n  const rtMetadata = {\n    name: segmentations.label,\n    label: segmentations.label\n  };\n  const dataset = _initializeDataset(rtMetadata, roiContours[0].metadata, metadataProvider);\n  roiContours.forEach((contour, index) => {\n    const roiContour = {\n      ROIDisplayColor: contour.color || [255, 0, 0],\n      ContourSequence: contour.contourSequence,\n      ReferencedROINumber: index + 1\n    };\n    dataset.StructureSetROISequence.push(getStructureSetModule(contour, index));\n    dataset.ROIContourSequence.push(roiContour);\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(contour.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(contour.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction generateRTSSFromAnnotations(annotations, metadataProvider, DicomMetadataStore) {\n  const rtMetadata = {\n    name: \"RTSS from Annotations\",\n    label: \"RTSS from Annotations\"\n  };\n  const dataset = _initializeDataset(rtMetadata, annotations[0].metadata, metadataProvider);\n  annotations.forEach((annotation, index) => {\n    const ContourSequence = AnnotationToPointData.convert(annotation, index, metadataProvider);\n    dataset.StructureSetROISequence.push(getStructureSetModule(annotation, index));\n    dataset.ROIContourSequence.push(ContourSequence);\n    dataset.RTROIObservationsSequence.push(getRTROIObservationsSequence(annotation, index));\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(annotation.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(annotation.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction _initializeDataset(rtMetadata, imgMetadata, metadataProvider) {\n  const rtSOPInstanceUID = DicomMetaDictionary.uid();\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = imgMetadata;\n  const {\n    studyInstanceUID\n  } = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const patientModule = getPatientModule(imageId, metadataProvider);\n  const rtSeriesModule = getRTSeriesModule(DicomMetaDictionary);\n  return {\n    StructureSetROISequence: [],\n    ROIContourSequence: [],\n    RTROIObservationsSequence: [],\n    ReferencedSeriesSequence: [],\n    ReferencedFrameOfReferenceSequence: [],\n    ...patientModule,\n    ...rtSeriesModule,\n    StudyInstanceUID: studyInstanceUID,\n    SOPClassUID: \"1.2.840.10008.5.1.4.1.1.481.3\",\n    SOPInstanceUID: rtSOPInstanceUID,\n    Manufacturer: \"dcmjs\",\n    Modality: \"RTSTRUCT\",\n    FrameOfReferenceUID,\n    PositionReferenceIndicator: \"\",\n    StructureSetLabel: rtMetadata.label || \"\",\n    StructureSetName: rtMetadata.name || \"\",\n    ReferringPhysicianName: \"\",\n    OperatorsName: \"\",\n    StructureSetDate: DicomMetaDictionary.date(),\n    StructureSetTime: DicomMetaDictionary.time(),\n    _meta: null\n  };\n}\n\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations };\n","import { utilities } from '@cornerstonejs/tools';\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations } from './RTSS.js';\n\nconst {\n  generateContourSetsFromLabelmap\n} = utilities.contours;\n\nexport { generateContourSetsFromLabelmap };\n","function getPatientModule(imageId, metadataProvider) {\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const generalStudyModule = metadataProvider.get(\"generalStudyModule\", imageId);\n  const patientStudyModule = metadataProvider.get(\"patientStudyModule\", imageId);\n  const patientModule = metadataProvider.get(\"patientModule\", imageId);\n  const patientDemographicModule = metadataProvider.get(\"patientDemographicModule\", imageId);\n  return {\n    Modality: generalSeriesModule.modality,\n    PatientID: patientModule.patientId,\n    PatientName: patientModule.patientName,\n    PatientBirthDate: \"\",\n    PatientAge: patientStudyModule.patientAge,\n    PatientSex: patientDemographicModule.patientSex,\n    PatientWeight: patientStudyModule.patientWeight,\n    StudyDate: generalStudyModule.studyDate,\n    StudyTime: generalStudyModule.studyTime,\n    StudyID: \"ToDo\",\n    AccessionNumber: generalStudyModule.accessionNumber\n  };\n}\n\nexport { getPatientModule as default };\n","function getRTROIObservationsSequence(toolData, index) {\n  return {\n    ObservationNumber: index + 1,\n    ReferencedROINumber: index + 1,\n    RTROIInterpretedType: \"Todo: type\",\n    ROIInterpreter: \"Todo: interpreter\"\n  };\n}\n\nexport { getRTROIObservationsSequence as default };\n","function getRTSeriesModule(DicomMetaDictionary) {\n  return {\n    SeriesInstanceUID: DicomMetaDictionary.uid(),\n    // generate a new series instance uid\n    SeriesNumber: \"99\" // Todo:: what should be the series number?\n  };\n}\n\nexport { getRTSeriesModule as default };\n","function getReferencedFrameOfReferenceSequence(metadata, metadataProvider, dataset) {\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID\n  } = instance;\n  const {\n    ReferencedSeriesSequence\n  } = dataset;\n  return [{\n    FrameOfReferenceUID,\n    RTReferencedStudySequence: [{\n      ReferencedSOPClassUID: dataset.SOPClassUID,\n      ReferencedSOPInstanceUID: dataset.SOPInstanceUID,\n      RTReferencedSeriesSequence: [{\n        SeriesInstanceUID,\n        ContourImageSequence: [...ReferencedSeriesSequence[0].ReferencedInstanceSequence]\n      }]\n    }]\n  }];\n}\n\nexport { getReferencedFrameOfReferenceSequence as default };\n","function getReferencedSeriesSequence(metadata, _index, metadataProvider, DicomMetadataStore) {\n  // grab imageId from toolData\n  const {\n    referencedImageId: imageId\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID,\n    StudyInstanceUID\n  } = instance;\n  const ReferencedSeriesSequence = [];\n  if (SeriesInstanceUID) {\n    const series = DicomMetadataStore.getSeries(StudyInstanceUID, SeriesInstanceUID);\n    const ReferencedSeries = {\n      SeriesInstanceUID,\n      ReferencedInstanceSequence: []\n    };\n    series.instances.forEach(instance => {\n      const {\n        SOPInstanceUID,\n        SOPClassUID\n      } = instance;\n      ReferencedSeries.ReferencedInstanceSequence.push({\n        ReferencedSOPClassUID: SOPClassUID,\n        ReferencedSOPInstanceUID: SOPInstanceUID\n      });\n    });\n    ReferencedSeriesSequence.push(ReferencedSeries);\n  }\n  return ReferencedSeriesSequence;\n}\n\nexport { getReferencedSeriesSequence as default };\n","function getStructureSetModule(contour, index) {\n  const {\n    FrameOfReferenceUID\n  } = contour.metadata;\n  return {\n    ROINumber: index + 1,\n    ROIName: contour.name || `Todo: name ${index + 1}`,\n    ROIDescription: `Todo: description ${index + 1}`,\n    ROIGenerationAlgorithm: \"Todo: algorithm\",\n    ReferencedFrameOfReferenceUID: FrameOfReferenceUID\n  };\n}\n\nexport { getStructureSetModule as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _RectangleROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup,\n      SCOORD3DGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, RectangleROI.toolType);\n    if (SCOORDGroup) {\n      return this.getMeasurementDataFromScoord({\n        defaultState,\n        SCOORDGroup,\n        imageToWorldCoords,\n        NUMGroup,\n        ReferencedFrameNumber\n      });\n    } else if (SCOORD3DGroup) {\n      return this.getMeasurementDataFromScoord3D({\n        SCOORD3DGroup,\n        defaultState\n      });\n    } else {\n      throw new Error(\"Can't get measurement data with missing SCOORD and SCOORD3D groups.\");\n    }\n  }\n  static getMeasurementDataFromScoord(_ref) {\n    let {\n      defaultState,\n      SCOORDGroup,\n      imageToWorldCoords,\n      NUMGroup,\n      ReferencedFrameNumber\n    } = _ref;\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3], worldCoords[2]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getMeasurementDataFromScoord3D(_ref2) {\n    let {\n      SCOORD3DGroup,\n      defaultState\n    } = _ref2;\n    const {\n      GraphicData\n    } = SCOORD3DGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1], worldCoords[3], worldCoords[2]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {}\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      return this.getTID300RepresentationArgumentsSCOORD3D(tool);\n    }\n    const corners = handles.points.map(point => worldToImageCoords(referencedImageId, point));\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    return {\n      points: [corners[0], corners[1], corners[3], corners[2], corners[0]],\n      area,\n      perimeter,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: false\n    };\n  }\n  static getTID300RepresentationArgumentsSCOORD3D(tool) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const corners = handles.points;\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    return {\n      points: [corners[0], corners[1], corners[3], corners[2], corners[0]],\n      area,\n      perimeter,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: metadata.FrameOfReferenceUID,\n      use3DSpatialCoordinates: true\n    };\n  }\n}\n_RectangleROI = RectangleROI;\n(() => {\n  _RectangleROI.init(\"RectangleROI\", TID300Polyline);\n  _RectangleROI.registerLegacy();\n})();\n\nexport { RectangleROI as default };\n","const checkHasOverlapping = _ref => {\n  let {\n    largerArray,\n    currentTestedArray,\n    newArray\n  } = _ref;\n  return largerArray.some((_, currentImageIndex) => {\n    const originalImagePixelData = currentTestedArray[currentImageIndex];\n    const newImagePixelData = newArray[currentImageIndex];\n    if (!originalImagePixelData || !newImagePixelData) {\n      return false;\n    }\n    return originalImagePixelData.some((originalPixel, currentPixelIndex) => {\n      const newPixel = newImagePixelData[currentPixelIndex];\n      return originalPixel && newPixel;\n    });\n  });\n};\nconst compactMergeSegmentDataWithoutInformationLoss = _ref2 => {\n  let {\n    arrayOfSegmentData,\n    newSegmentData\n  } = _ref2;\n  if (arrayOfSegmentData.length === 0) {\n    arrayOfSegmentData.push(newSegmentData);\n    return;\n  }\n  for (let currentTestedIndex = 0; currentTestedIndex < arrayOfSegmentData.length; currentTestedIndex++) {\n    const currentTestedArray = arrayOfSegmentData[currentTestedIndex];\n    const originalArrayIsLarger = currentTestedArray.length > newSegmentData.length;\n    const largerArray = originalArrayIsLarger ? currentTestedArray : newSegmentData;\n    const hasOverlapping = checkHasOverlapping({\n      currentTestedArray,\n      largerArray,\n      newArray: newSegmentData\n    });\n    if (hasOverlapping) {\n      continue;\n    }\n    largerArray.forEach((_, currentImageIndex) => {\n      const originalImagePixelData = currentTestedArray[currentImageIndex];\n      const newImagePixelData = newSegmentData[currentImageIndex];\n      if (!originalImagePixelData && !newImagePixelData || !newImagePixelData) {\n        return;\n      }\n      if (!originalImagePixelData) {\n        currentTestedArray[currentImageIndex] = newImagePixelData;\n        return;\n      }\n      const mergedPixelData = originalImagePixelData.map((originalPixel, currentPixelIndex) => {\n        const newPixel = newImagePixelData[currentPixelIndex];\n        return originalPixel || newPixel;\n      });\n      currentTestedArray[currentImageIndex] = mergedPixelData;\n    });\n    return;\n  }\n  arrayOfSegmentData.push(newSegmentData);\n};\n\nexport { compactMergeSegmentDataWithoutInformationLoss };\n","function generateLabelMaps2DFrom3D(labelmap3D) {\n  const {\n    scalarData,\n    dimensions\n  } = labelmap3D;\n  const labelmaps2D = [];\n  const segmentsOnLabelmap3D = new Set();\n  for (let z = 0; z < dimensions[2]; z++) {\n    const pixelData = scalarData.slice(z * dimensions[0] * dimensions[1], (z + 1) * dimensions[0] * dimensions[1]);\n    const segmentsOnLabelmap = [];\n    for (let i = 0; i < pixelData.length; i++) {\n      const segment = pixelData[i];\n      if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\n        segmentsOnLabelmap.push(segment);\n      }\n    }\n    const labelmap2D = {\n      segmentsOnLabelmap,\n      pixelData,\n      rows: dimensions[1],\n      columns: dimensions[0]\n    };\n    if (segmentsOnLabelmap.length === 0) {\n      continue;\n    }\n    segmentsOnLabelmap.forEach(segmentIndex => {\n      segmentsOnLabelmap3D.add(segmentIndex);\n    });\n    labelmaps2D[dimensions[2] - 1 - z] = labelmap2D;\n  }\n  labelmap3D.segmentsOnLabelmap = Array.from(segmentsOnLabelmap3D);\n  labelmap3D.labelmaps2D = labelmaps2D;\n  return labelmap3D;\n}\n\nexport { generateLabelMaps2DFrom3D };\n","import { normalizers, derivations } from 'dcmjs';\nimport { fillSegmentation } from '../../Cornerstone/Segmentation_4X.js';\n\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nfunction generateSegmentation(images, labelmaps, metadata) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const segmentation = _createMultiframeSegmentationFromReferencedImages(images, metadata, options);\n  return fillSegmentation(segmentation, labelmaps, options);\n}\nfunction _createMultiframeSegmentationFromReferencedImages(images, metadata, options) {\n  const datasets = images.map(image => {\n    const instance = metadata.get(\"instance\", image.imageId);\n    return {\n      ...image,\n      ...instance,\n      SOPClassUID: instance.SopClassUID || instance.SOPClassUID,\n      SOPInstanceUID: instance.SopInstanceUID || instance.SOPInstanceUID,\n      PixelData: image.voxelManager.getScalarData(),\n      _vrMap: {\n        PixelData: \"OW\"\n      },\n      _meta: {}\n    };\n  });\n  const multiframe = Normalizer.normalizeToDataset(datasets);\n  if (!multiframe) {\n    throw new Error(\"Failed to normalize the multiframe dataset, the data is not multi-frame.\");\n  }\n  return new SegmentationDerivation([multiframe], options);\n}\n\nexport { generateSegmentation };\n","import { generateToolState as generateToolState$1 } from '../../Cornerstone/Segmentation.js';\nimport { createLabelmapsFromBufferInternal } from './labelmapImagesFromBuffer.js';\n\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cs3dVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  return generateToolState$1(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance, cs3dVersion);\n}\nfunction createFromDICOMSegBuffer(referencedImageIds, arrayBuffer, _ref) {\n  let {\n    metadataProvider,\n    tolerance = 1e-3\n  } = _ref;\n  return createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, {\n    tolerance\n  });\n}\n\nexport { createFromDICOMSegBuffer, generateToolState };\n","export { generateSegmentation } from './generateSegmentation.js';\nexport { generateLabelMaps2DFrom3D } from './generateLabelMaps2DFrom3D.js';\nexport { createFromDICOMSegBuffer, generateToolState } from './generateToolState.js';\n","import { triggerEvent, eventTarget, imageLoader } from '@cornerstonejs/core';\nimport { utilities as utilities$1 } from '@cornerstonejs/tools';\nimport { utilities, data, normalizers } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport checkOrientation from '../../helpers/checkOrientation.js';\nimport { getValidOrientations, getSegmentMetadata, unpackPixelData, calculateCentroid, readFromUnpackedChunks, alignPixelDataWithSourceData, getSegmentIndex, findReferenceSourceImageId } from '../../Cornerstone/Segmentation_4X.js';\nimport { compactMergeSegmentDataWithoutInformationLoss } from './compactMergeSegData.js';\nimport { Events } from '../../enums/Events.js';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  decode\n} = utilities.compression;\nconst updateSegmentsOnFrame = _ref => {\n  let {\n    segmentsOnFrame,\n    imageIdIndex,\n    segmentIndex\n  } = _ref;\n  if (!segmentsOnFrame[imageIdIndex]) {\n    segmentsOnFrame[imageIdIndex] = [];\n  }\n  segmentsOnFrame[imageIdIndex].push(segmentIndex);\n};\nconst updateSegmentsPixelIndices = _ref2 => {\n  let {\n    segmentsPixelIndices,\n    segmentIndex,\n    imageIdIndex,\n    indexCache\n  } = _ref2;\n  if (!segmentsPixelIndices.has(segmentIndex)) {\n    segmentsPixelIndices.set(segmentIndex, {});\n  }\n  const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n  segmentIndexObject[imageIdIndex] = indexCache;\n  segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n};\nconst extractInfoFromPerFrameFunctionalGroups = _ref3 => {\n  let {\n    PerFrameFunctionalGroups,\n    sequenceIndex,\n    sopUIDImageIdIndexMap,\n    multiframe\n  } = _ref3;\n  const referencedSOPInstanceUid = PerFrameFunctionalGroups.DerivationImageSequence[0].SourceImageSequence[0].ReferencedSOPInstanceUID;\n  const referencedImageId = sopUIDImageIdIndexMap[referencedSOPInstanceUid];\n  const segmentIndex = getSegmentIndex(multiframe, sequenceIndex);\n  return {\n    referencedSOPInstanceUid,\n    referencedImageId,\n    segmentIndex\n  };\n};\nasync function createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bit packing.\");\n      return;\n    }\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      insertFunction = insertPixelDataPlanar;\n      break;\n    case \"Perpendicular\":\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n  const segmentsOnFrame = [];\n  const imageIdMaps = {\n    indices: {},\n    metadata: {}\n  };\n  const labelMapImages = [];\n  for (let i = 0; i < referencedImageIds.length; i++) {\n    const referenceImageId = referencedImageIds[i];\n    imageIdMaps.indices[referenceImageId] = i;\n    imageIdMaps.metadata[referenceImageId] = metadataProvider.get(\"instance\", referenceImageId);\n    const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referenceImageId);\n    labelMapImages.push(labelMapImage);\n  }\n  const segmentsPixelIndices = new Map();\n  const {\n    hasOverlappingSegments,\n    arrayOfLabelMapImages\n  } = await insertFunction({\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps,\n    TypedArrayConstructor\n  });\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelMapImages: arrayOfLabelMapImages,\n    segMetadata,\n    segmentsOnFrame,\n    centroids: centroidXYZ,\n    overlappingSegments: hasOverlappingSegments\n  };\n}\nconst throttledTriggerLoadProgressEvent = utilities$1.throttle(percentComplete => {\n  triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n    percentComplete\n  });\n}, 200);\nfunction insertPixelDataPlanar(_ref4) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref4;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  let overlapping = false;\n  return new Promise(resolve => {\n    const percentImagesPerChunk = 0.1;\n    const imagesPerChunk = Math.ceil(groupsLen * percentImagesPerChunk);\n    const processChunk = firstIndex => {\n      for (let i = firstIndex; i < firstIndex + imagesPerChunk && i < groupsLen; i++) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelDataChunks, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, referencedImageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          return;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const labelmapImage = labelMapImages[imageIdIndex];\n        const labelmap2DView = labelmapImage.getPixelData();\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let k = 0, len = alignedPixelDataI.data.length; k < len; ++k) {\n          if (data[k]) {\n            for (let x = k; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                  return resolve(insertOverlappingPixelDataPlanar({\n                    segmentsOnFrame,\n                    labelMapImages,\n                    pixelDataChunks,\n                    multiframe,\n                    referencedImageIds,\n                    validOrientations,\n                    metadataProvider,\n                    tolerance,\n                    segmentsPixelIndices,\n                    sopUIDImageIdIndexMap,\n                    imageIdMaps\n                  }));\n                }\n                labelmap2DView[x] = segmentIndex;\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n      const percentComplete = Math.round(firstIndex / groupsLen * 100);\n      throttledTriggerLoadProgressEvent(percentComplete);\n      if (firstIndex < groupsLen) {\n        setTimeout(() => processChunk(firstIndex + imagesPerChunk), 0);\n      } else {\n        resolve({\n          hasOverlappingSegments: false,\n          arrayOfLabelMapImages: [labelMapImages]\n        });\n      }\n    };\n    processChunk(0);\n  });\n}\nconst getAlignedPixelData = _ref5 => {\n  let {\n    sharedImageOrientationPatient,\n    PerFrameFunctionalGroups,\n    pixelDataChunks,\n    sequenceIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance\n  } = _ref5;\n  const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const view = readFromUnpackedChunks(pixelDataChunks, sequenceIndex * sliceLength, sliceLength);\n  const pixelDataI2D = ndarray(view, [Rows, Columns]);\n  const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n  if (!alignedPixelDataI) {\n    throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n  }\n  return alignedPixelDataI;\n};\nconst checkImageDimensions = _ref6 => {\n  let {\n    metadataProvider,\n    imageId,\n    Rows,\n    Columns\n  } = _ref6;\n  const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n  if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n    throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n  }\n};\nconst getArrayOfLabelMapImagesWithSegmentData = _ref7 => {\n  let {\n    arrayOfSegmentData,\n    referencedImageIds\n  } = _ref7;\n  let largestArray = [];\n  for (let i = 0; i < arrayOfSegmentData.length; i++) {\n    const segmentData = arrayOfSegmentData[i];\n    if (segmentData.length > largestArray.length) {\n      largestArray = segmentData;\n    }\n  }\n  return arrayOfSegmentData.map(arr => {\n    const labelMapImages = referencedImageIds.map((referencedImageId, i) => {\n      const hasEmptySegmentData = !arr[i];\n      const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referencedImageId);\n      const pixelData = labelMapImage.getPixelData();\n      if (!hasEmptySegmentData) {\n        for (let j = 0; j < pixelData.length; j++) {\n          pixelData[j] = arr[i][j];\n        }\n      }\n      return labelMapImage;\n    }).filter(Boolean);\n    return labelMapImages;\n  });\n};\nfunction insertOverlappingPixelDataPlanar(_ref8) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref8;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayOfSegmentData = getArrayOfSegmentData({\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  });\n  const arrayOfLabelMapImagesWithSegmentData = getArrayOfLabelMapImagesWithSegmentData({\n    arrayOfSegmentData,\n    referencedImageIds\n  });\n  return {\n    arrayOfLabelMapImages: arrayOfLabelMapImagesWithSegmentData,\n    hasOverlappingSegments: true\n  };\n}\nconst getArrayOfSegmentData = _ref9 => {\n  let {\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  } = _ref9;\n  const arrayOfSegmentData = [];\n  const numberOfSegments = multiframe.SegmentSequence.length;\n  for (let currentSegmentIndex = 1; currentSegmentIndex <= numberOfSegments; ++currentSegmentIndex) {\n    const segmentData = getSegmentData({\n      PerFrameFunctionalGroupsSequence,\n      labelMapImages,\n      sopUIDImageIdIndexMap,\n      multiframe,\n      segmentIndex: currentSegmentIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance,\n      pixelDataChunks,\n      sharedImageOrientationPatient,\n      metadataProvider,\n      imageIdMaps,\n      segmentsOnFrame,\n      segmentsPixelIndices\n    });\n    compactMergeSegmentDataWithoutInformationLoss({\n      arrayOfSegmentData,\n      newSegmentData: segmentData\n    });\n  }\n  return arrayOfSegmentData;\n};\nconst getSegmentData = _ref10 => {\n  let {\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    segmentIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance,\n    pixelDataChunks,\n    sharedImageOrientationPatient,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    segmentsPixelIndices\n  } = _ref10;\n  const segmentData = [];\n  for (let currentLabelMapImageIndex = 0; currentLabelMapImageIndex < labelMapImages.length; currentLabelMapImageIndex++) {\n    const currentLabelMapImage = labelMapImages[currentLabelMapImageIndex];\n    const referencedImageId = currentLabelMapImage.referencedImageId;\n    const PerFrameFunctionalGroupsIndex = PerFrameFunctionalGroupsSequence.findIndex((PerFrameFunctionalGroups, currentSequenceIndex) => {\n      const {\n        segmentIndex: groupsSegmentIndex,\n        referencedImageId: groupsReferenceImageId\n      } = extractInfoFromPerFrameFunctionalGroups({\n        PerFrameFunctionalGroups,\n        sequenceIndex: currentSequenceIndex,\n        sopUIDImageIdIndexMap,\n        multiframe\n      });\n      const isCorrectPerFrameFunctionalGroup = groupsSegmentIndex === segmentIndex && groupsReferenceImageId === currentLabelMapImage.referencedImageId;\n      return isCorrectPerFrameFunctionalGroup;\n    });\n    if (PerFrameFunctionalGroupsIndex === -1) {\n      continue;\n    }\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[PerFrameFunctionalGroupsIndex];\n    const alignedPixelDataI = getAlignedPixelData({\n      sharedImageOrientationPatient,\n      PerFrameFunctionalGroups,\n      pixelDataChunks,\n      sequenceIndex: PerFrameFunctionalGroupsIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance\n    });\n    checkImageDimensions({\n      metadataProvider,\n      Rows,\n      Columns,\n      imageId: referencedImageId\n    });\n    const indexCache = [];\n    const segmentationDataForImageId = alignedPixelDataI.data.map((pixel, pixelIndex) => {\n      const pixelValue = pixel ? segmentIndex : 0;\n      if (pixelValue) {\n        indexCache.push(pixelIndex);\n      }\n      return pixel ? segmentIndex : 0;\n    });\n    const hasWrittenSegmentationData = indexCache.length > 0;\n    if (hasWrittenSegmentationData) {\n      segmentData[currentLabelMapImageIndex] = segmentationDataForImageId;\n    }\n    const imageIdIndex = imageIdMaps.indices[referencedImageId];\n    updateSegmentsOnFrame({\n      imageIdIndex,\n      segmentIndex,\n      segmentsOnFrame\n    });\n    updateSegmentsPixelIndices({\n      imageIdIndex,\n      segmentIndex,\n      segmentsPixelIndices,\n      indexCache\n    });\n  }\n  return segmentData;\n};\n\nexport { createLabelmapsFromBufferInternal, insertOverlappingPixelDataPlanar, insertPixelDataPlanar };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _UltrasoundDirectional;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nclass UltrasoundDirectional extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, UltrasoundDirectional.toolType);\n    const referencedImageId = defaultState.annotation.metadata.referencedImageId;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const worldCoords = [];\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n    const state = defaultState;\n    state.annotation.data = {\n      handles: {\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0,\n        textBox: {\n          hasMoved: false\n        }\n      },\n      cachedStats: {},\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, worldToImageCoords) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"UltrasoundDirectionalTool.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const start = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const point1 = {\n      x: start[0],\n      y: start[1]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1]\n    };\n    return {\n      point1,\n      point2,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_UltrasoundDirectional = UltrasoundDirectional;\n_UltrasoundDirectional.init(\"UltrasoundDirectionalTool\", TID300Length);\n\nexport { UltrasoundDirectional as default };\n","const NO_IMAGE_ID = \"none\";\n\nexport { NO_IMAGE_ID };\n","var CORNERSTONE_3D_TAG = \"Cornerstone3DTools@^0.1.0\";\n\nexport { CORNERSTONE_3D_TAG as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport CodingScheme from './CodingScheme.js';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport Bidirectional from './Bidirectional.js';\nimport Angle from './Angle.js';\nimport CobbAngle from './CobbAngle.js';\nimport CircleROI from './CircleROI.js';\nimport EllipticalROI from './EllipticalROI.js';\nimport RectangleROI from './RectangleROI.js';\nimport Length from './Length.js';\nimport PlanarFreehandROI from './PlanarFreehandROI.js';\nimport Probe from './Probe.js';\nimport UltrasoundDirectional from './UltrasoundDirectional.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport * as index from './Segmentation/index.js';\nimport * as index$1 from './ParametricMap/index.js';\nimport * as index$2 from './RTStruct/index.js';\nimport KeyImage from './KeyImage.js';\n\nconst Cornerstone3DSR = {\n  BaseAdapter3D,\n  Bidirectional,\n  CobbAngle,\n  Angle,\n  Length,\n  CircleROI,\n  EllipticalROI,\n  RectangleROI,\n  ArrowAnnotate,\n  Probe,\n  PlanarFreehandROI,\n  UltrasoundDirectional,\n  KeyImage,\n  MeasurementReport,\n  CodeScheme: CodingScheme,\n  CORNERSTONE_3D_TAG\n};\nconst Cornerstone3DSEG = {\n  Segmentation: index\n};\nconst Cornerstone3DPMAP = {\n  ParametricMap: index$1\n};\nconst Cornerstone3DRT = {\n  RTSS: index$2\n};\n\nexport { Cornerstone3DPMAP, Cornerstone3DRT, Cornerstone3DSEG, Cornerstone3DSR };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Angle: TID300Angle\n} = utilities.TID300;\nconst ANGLE = \"Angle\";\nclass Angle {\n  /**\n   * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n   */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Angle.toolType,\n      handles: {\n        start: {},\n        middle: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.middle.x, state.handles.middle.y, state.handles.middle.x, state.handles.middle.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.middle;\n    const point3 = handles.middle;\n    const point4 = handles.end;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nAngle.toolType = ANGLE;\nAngle.utilityToolType = ANGLE;\nAngle.TID300Representation = TID300Angle;\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ANGLE;\n};\nMeasurementReport.registerTool(Angle);\n\nexport { Angle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\nclass ArrowAnnotate {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      findingGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const text = findingGroup.ConceptCodeSequence.CodeMeaning;\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const state = {\n      ...defaultState,\n      toolType: ArrowAnnotate.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: GraphicData[0],\n          y: GraphicData[1],\n          highlight: true,\n          active: false\n        },\n        // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n        // use the actual endpoint.\n        end: {\n          x: GraphicData.length == 4 ? GraphicData[2] : GraphicData[0] + 20,\n          y: GraphicData.length == 4 ? GraphicData[3] : GraphicData[1] + 20,\n          highlight: true,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      text,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const points = [tool.handles.start, tool.handles.end];\n    const {\n      findingSites\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const TID300RepresentationArguments = {\n      points,\n      trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\n      findingSites: findingSites || []\n    };\n\n    // If freetext finding isn't present, add it from the tool text.\n    if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: \"CST4\",\n        CodeMeaning: tool.text\n      };\n    }\n    TID300RepresentationArguments.finding = finding;\n    return TID300RepresentationArguments;\n  }\n}\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ARROW_ANNOTATE;\n};\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport { ArrowAnnotate as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\n\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst FINDING = \"121071\";\nconst FINDING_SITE = \"G-C0E3\";\nclass Bidirectional {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const findingGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeValue === FINDING);\n    const findingSiteGroups = toArray(ContentSequence).filter(group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE);\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = longAxisSCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n\n    // Long axis\n\n    const longestDiameter = String(longAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const shortestDiameter = String(shortAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const bottomRight = {\n      x: Math.max(longAxisSCOORDGroup.GraphicData[0], longAxisSCOORDGroup.GraphicData[2], shortAxisSCOORDGroup.GraphicData[0], shortAxisSCOORDGroup.GraphicData[2]),\n      y: Math.max(longAxisSCOORDGroup.GraphicData[1], longAxisSCOORDGroup.GraphicData[3], shortAxisSCOORDGroup.GraphicData[1], shortAxisSCOORDGroup.GraphicData[3])\n    };\n    const state = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      toolType: Bidirectional.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: longAxisSCOORDGroup.GraphicData[0],\n          y: longAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 0\n        },\n        end: {\n          x: longAxisSCOORDGroup.GraphicData[2],\n          y: longAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 1\n        },\n        perpendicularStart: {\n          x: shortAxisSCOORDGroup.GraphicData[0],\n          y: shortAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 2\n        },\n        perpendicularEnd: {\n          x: shortAxisSCOORDGroup.GraphicData[2],\n          y: shortAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 3\n        },\n        textBox: {\n          highlight: false,\n          hasMoved: true,\n          active: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true,\n          x: bottomRight.x + 10,\n          y: bottomRight.y + 10\n        }\n      },\n      invalidated: false,\n      isCreating: false,\n      longestDiameter,\n      shortestDiameter,\n      toolName: \"Bidirectional\",\n      visible: true,\n      finding: findingGroup ? findingGroup.ConceptCodeSequence : undefined,\n      findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      start,\n      end,\n      perpendicularStart,\n      perpendicularEnd\n    } = tool.handles;\n    const {\n      shortestDiameter,\n      longestDiameter,\n      finding,\n      findingSites\n    } = tool;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Bidirectional\";\n    return {\n      longAxis: {\n        point1: start,\n        point2: end\n      },\n      shortAxis: {\n        point1: perpendicularStart,\n        point2: perpendicularEnd\n      },\n      longAxisLength: longestDiameter,\n      shortAxisLength: shortestDiameter,\n      trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nBidirectional.toolType = BIDIRECTIONAL;\nBidirectional.utilityToolType = BIDIRECTIONAL;\nBidirectional.TID300Representation = TID300Bidirectional;\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === BIDIRECTIONAL;\n};\nMeasurementReport.registerTool(Bidirectional);\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nconst CIRCLEROI = \"CircleRoi\";\nclass CircleRoi {\n  /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const center = {\n      x: GraphicData[0],\n      y: GraphicData[1]\n    };\n    const end = {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    };\n    const state = {\n      ...defaultState,\n      toolType: CircleRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n        // Dummy values to be updated by cornerstone\n        radius: 0,\n        perimeter: 0\n      },\n      handles: {\n        end: {\n          ...end,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          ...center,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n\n  /**\n   * Gets the TID 300 representation of a circle, given the cornerstone representation.\n   *\n   * @param {Object} tool\n   * @returns\n   */\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start: center,\n      end\n    } = handles;\n    const {\n      area,\n      radius\n    } = cachedStats;\n    const perimeter = 2 * Math.PI * radius;\n    const points = [];\n    points.push(center);\n    points.push(end);\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCircleRoi.toolType = CIRCLEROI;\nCircleRoi.utilityToolType = CIRCLEROI;\nCircleRoi.TID300Representation = TID300Circle;\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === CIRCLEROI;\n};\nMeasurementReport.registerTool(CircleRoi);\n\nexport { CircleRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nconst COBB_ANGLE = \"CobbAngle\";\nclass CobbAngle {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: CobbAngle.toolType,\n      handles: {\n        start: {},\n        end: {},\n        start2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        end2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y, state.handles.start2.x, state.handles.start2.y, state.handles.end2.x, state.handles.end2.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const point3 = handles.start2;\n    const point4 = handles.end2;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCobbAngle.toolType = COBB_ANGLE;\nCobbAngle.utilityToolType = COBB_ANGLE;\nCobbAngle.TID300Representation = TID300CobbAngle;\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === COBB_ANGLE;\n};\nMeasurementReport.registerTool(CobbAngle);\n\nexport { CobbAngle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nconst ELLIPTICALROI = \"EllipticalRoi\";\nclass EllipticalRoi {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const majorAxis = [{\n      x: GraphicData[0],\n      y: GraphicData[1]\n    }, {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    }];\n    const minorAxis = [{\n      x: GraphicData[4],\n      y: GraphicData[5]\n    }, {\n      x: GraphicData[6],\n      y: GraphicData[7]\n    }];\n\n    // Calculate two opposite corners of box defined by two axes.\n\n    const minorAxisLength = Math.sqrt(Math.pow(minorAxis[0].x - minorAxis[1].x, 2) + Math.pow(minorAxis[0].y - minorAxis[1].y, 2));\n    const minorAxisDirection = {\n      x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n      y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n    };\n    const halfMinorAxisLength = minorAxisLength / 2;\n\n    // First end point of major axis + half minor axis vector\n    const corner1 = {\n      x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n    };\n\n    // Second end point of major axis - half of minor axis vector\n    const corner2 = {\n      x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n    };\n    const state = {\n      ...defaultState,\n      toolType: EllipticalRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      handles: {\n        end: {\n          x: corner1.x,\n          y: corner1.y,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          x: corner2.x,\n          y: corner2.y,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const {\n      area\n    } = cachedStats;\n    const halfXLength = Math.abs(start.x - end.x) / 2;\n    const halfYLength = Math.abs(start.y - end.y) / 2;\n    const points = [];\n    const center = {\n      x: (start.x + end.x) / 2,\n      y: (start.y + end.y) / 2\n    };\n    if (halfXLength > halfYLength) {\n      // X-axis major\n      // Major axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n      // Minor axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n    } else {\n      // Y-axis major\n      // Major axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n      // Minor axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n    }\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nEllipticalRoi.toolType = ELLIPTICALROI;\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\nEllipticalRoi.TID300Representation = TID300Ellipse;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ELLIPTICALROI;\n};\nMeasurementReport.registerTool(EllipticalRoi);\n\nexport { EllipticalRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass FreehandRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: FreehandRoi.toolType,\n      handles: {\n        points: [],\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      state.handles.points.push({\n        x: GraphicData[i],\n        y: GraphicData[i + 1]\n      });\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites,\n      cachedStats = {}\n    } = tool;\n    const {\n      points\n    } = handles;\n    const {\n      area = 0,\n      perimeter = 0\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:FreehandRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === FreehandRoi.toolType;\n};\nMeasurementReport.registerTool(FreehandRoi);\n\nexport { FreehandRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      length: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Length.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const distance = tool.length;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === LENGTH;\n};\nMeasurementReport.registerTool(Length);\n\nexport { Length as default };\n","import { utilities, derivations, normalizers, data } from 'dcmjs';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\n\nconst {\n  TID1500,\n  addAccessors\n} = utilities;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nconst codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\nfunction getTID300ContentItem(tool, ReferencedSOPSequence, adapterClass) {\n  const args = adapterClass.getTID300RepresentationArguments(tool);\n  args.ReferencedSOPSequence = ReferencedSOPSequence;\n  const TID300Measurement = new adapterClass.TID300Representation(args);\n  return TID300Measurement;\n}\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\n  const toolTypeData = toolData[toolType];\n  const toolClass = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n  if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n    return;\n  }\n\n  // Loop through the array of tool instances\n  // for this tool\n  const Measurements = toolTypeData.data.map(tool => {\n    return getTID300ContentItem(tool, ReferencedSOPSequence, toolClass);\n  });\n  return new TID1501MeasurementGroup(Measurements);\n}\nclass MeasurementReport {\n  static getSetupMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => codeValueMatch(group, FINDING));\n    const findingSiteGroups = contentSequenceArr.filter(group => codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\");\n    const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n    const defaultState = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      complete: true,\n      finding: findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined,\n      findingSites: findingSiteGroups.map(fsg => {\n        return addAccessors(fsg.ConceptCodeSequence);\n      })\n    };\n    if (defaultState.finding) {\n      defaultState.description = defaultState.finding.CodeMeaning;\n    }\n    const findingSite = defaultState.findingSites && defaultState.findingSites[0];\n    if (findingSite) {\n      defaultState.location = findingSite[0] && findingSite[0].CodeMeaning || findingSite.CodeMeaning;\n    }\n    return {\n      defaultState,\n      findingGroup,\n      findingSiteGroups,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    };\n  }\n  static generateReport(toolState, metadataProvider, options) {\n    // ToolState for array of imageIDs to a Report\n    // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n    let allMeasurementGroups = [];\n    const firstImageId = Object.keys(toolState)[0];\n    if (!firstImageId) {\n      throw new Error(\"No measurements provided.\");\n    }\n\n    /* Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n     */\n    const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", firstImageId);\n\n    //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n    // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n    // which means that if the toolState is for multiple series, the report will have the incorrect\n    // SeriesInstanceUIDs\n    const {\n      studyInstanceUID,\n      seriesInstanceUID\n    } = generalSeriesModule;\n\n    // Loop through each image in the toolData\n    Object.keys(toolState).forEach(imageId => {\n      const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n      const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const ReferencedSOPSequence = {\n        ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n      };\n      if (Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)) {\n        ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n      }\n\n      // Loop through each tool type for the image\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = getMeasurementGroup(toolType, toolData, ReferencedSOPSequence);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n\n    // TODO: what is the correct metaheader\n    // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n    // TODO: move meta creation to happen in derivations.js\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const derivationSourceDataset = {\n      StudyInstanceUID: studyInstanceUID,\n      SeriesInstanceUID: seriesInstanceUID\n      //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n      //SOPClassUID: sopClassUID,\n    };\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      //MediaStorageSOPClassUID\n      //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        // TODO: could be git hash or other valid id\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    const _vrMap = {\n      PixelData: \"OW\"\n    };\n    derivationSourceDataset._meta = _meta;\n    derivationSourceDataset._vrMap = _vrMap;\n    const report = new StructuredReport([derivationSourceDataset]);\n    const contentItem = MeasurementReport.contentItem(derivationSourceDataset);\n\n    // Merge the derived dataset with the content from the Measurement Report\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    return report;\n  }\n\n  /**\n   * Generate Cornerstone tool state from dataset\n   * @param {object} dataset dataset\n   * @param {object} hooks\n   * @param {function} hooks.getToolClass Function to map dataset to a tool class\n   * @returns\n   */\n  static generateToolState(dataset) {\n    let hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // For now, bail out if the dataset is not a TID1500 SR with length measurements\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n    // Identify the Imaging Measurements\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n\n    // Retrieve the Measurements themselves\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n\n    // For each of the supported measurement types, compute the measurement data\n    const measurementData = {};\n    const cornerstoneToolClasses = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n    const registeredToolClasses = [];\n    Object.keys(cornerstoneToolClasses).forEach(key => {\n      registeredToolClasses.push(cornerstoneToolClasses[key]);\n      measurementData[key] = [];\n    });\n    measurementGroups.forEach(measurementGroup => {\n      const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n      const TrackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n      const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n      const toolClass = hooks.getToolClass ? hooks.getToolClass(measurementGroup, dataset, registeredToolClasses) : registeredToolClasses.find(tc => tc.isValidCornerstoneTrackingIdentifier(TrackingIdentifierValue));\n      if (toolClass) {\n        const measurement = toolClass.getMeasurementData(measurementGroup);\n        console.log(`=== ${toolClass.toolType} ===`);\n        console.log(measurement);\n        measurementData[toolClass.toolType].push(measurement);\n      }\n    });\n\n    // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n    // That is up to the consumer to derive from the SOPInstanceUIDs.\n    return measurementData;\n  }\n  static registerTool(toolClass) {\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[toolClass.utilityToolType] = toolClass;\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolClass.toolType] = toolClass;\n    MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] = toolClass.utilityToolType;\n  }\n}\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\nexport { MeasurementReport as default };\n","import { log, data, normalizers } from 'dcmjs';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport compareArrays from '../helpers/compareArrays.js';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nasync function generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-3;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = [ImageOrientationPatient];\n  const pixelData = getPixelData(multiframe);\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  if (orientation !== \"Planar\") {\n    const orientationText = {\n      Perpendicular: \"orthogonal\",\n      Oblique: \"oblique\"\n    };\n    throw new Error(`Parametric maps ${orientationText[orientation]} to the acquisition plane of the source data are not yet supported.`);\n  }\n  const imageIdMaps = imageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n  await insertPixelDataPlanar(pixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps);\n  return {\n    pixelData\n  };\n}\nfunction insertPixelDataPlanar(sourcePixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps) {\n  const targetPixelData = new sourcePixelData.constructor(sourcePixelData.length);\n  const {\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sliceLength = Columns * Rows;\n  const numSlices = PerFrameFunctionalGroupsSequence.length;\n  for (let i = 0; i < numSlices; i++) {\n    const sourceSliceDataView = new sourcePixelData.constructor(sourcePixelData.buffer, i * sliceLength, sliceLength);\n    const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n      continue;\n    }\n    const sourceImageMetadata = imageIdMaps.metadata[imageId];\n    if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n      throw new Error(\"Parametric map have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported.\");\n    }\n    const imageIdIndex = imageIdMaps.indices[imageId];\n    const byteOffset = sliceLength * imageIdIndex * targetPixelData.BYTES_PER_ELEMENT;\n    const targetSliceDataView = new targetPixelData.constructor(targetPixelData.buffer, byteOffset, sliceLength);\n    targetSliceDataView.set(sourceSliceDataView);\n  }\n  return targetPixelData;\n}\nfunction getPixelData(multiframe) {\n  let TypedArrayClass;\n  let data;\n  if (multiframe.PixelData) {\n    const validTypedArrays = multiframe.BitsAllocated === 16 ? [Uint16Array, Int16Array] : [Uint32Array, Int32Array];\n    TypedArrayClass = validTypedArrays[multiframe.PixelRepresentation ?? 0];\n    data = multiframe.PixelData;\n  } else if (multiframe.FloatPixelData) {\n    TypedArrayClass = Float32Array;\n    data = multiframe.FloatPixelData;\n  } else if (multiframe.DoubleFloatPixelData) {\n    TypedArrayClass = Float64Array;\n    data = multiframe.DoubleFloatPixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This parametric map pixel data is undefined.\");\n  }\n  if (Array.isArray(data)) {\n    data = data[0];\n  }\n  return new TypedArrayClass(data);\n}\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, sopUIDImageIdIndexMap) : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n}\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (ReferencedSeriesInstanceUID === undefined || PerFrameFunctionalGroup.PlanePositionSequence === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient === undefined) {\n    return undefined;\n  }\n  for (let imageIdsIndex = 0; imageIdsIndex < imageIds.length; ++imageIdsIndex) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageIds[imageIdsIndex]);\n    if (sourceImageMetadata === undefined || sourceImageMetadata.ImagePositionPatient === undefined || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n    if (compareArrays(PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageIds[imageIdsIndex];\n    }\n  }\n}\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, sopUIDImageIdIndexMap) {\n  const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\n  if (!imageId) {\n    return;\n  }\n  const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n  return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\n}\nconst ParametricMapObj = {\n  generateToolState\n};\n\nexport { ParametricMapObj as ParametricMap, ParametricMapObj as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: RectangleRoi.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        },\n        initialRotation: 0\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const intermediate = {};\n    [state.handles.start.x, state.handles.start.y, intermediate.x, intermediate.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      finding,\n      findingSites,\n      cachedStats = {},\n      handles\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const points = [start, {\n      x: start.x,\n      y: end.y\n    }, end, {\n      x: end.x,\n      y: start.y\n    }];\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:RectangleRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === RectangleRoi.toolType;\n};\nMeasurementReport.registerTool(RectangleRoi);\n\nexport { RectangleRoi as default };\n","import Segmentation$1 from './Segmentation_3X.js';\nimport Segmentation from './Segmentation_4X.js';\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(images, labelmaps3DorBrushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {boolean} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cornerstoneToolsVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateToolState(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateToolState(imageIds, arrayBuffer, metadataProvider);\n  }\n  console.warn(`No generateToolState adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.fillSegmentation(segmentation, inputLabelmaps3D, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\nexport { fillSegmentation, generateSegmentation, generateToolState };\n","import { utilities, log, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  datasetToBlob,\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = utilities;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState\n};\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation(images, brushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  const {\n    toolState,\n    segments\n  } = brushData;\n\n  // Calculate the dimensions of the data cube.\n  const image0 = images[0];\n  const dims = {\n    x: image0.columns,\n    y: image0.rows,\n    z: images.length\n  };\n  dims.xy = dims.x * dims.y;\n  const numSegments = _getSegCount(seg, segments);\n  if (!numSegments) {\n    throw new Error(\"No segments to export!\");\n  }\n  const isMultiframe = image0.imageId.includes(\"?frame\");\n  const seg = _createSegFromImages(images, isMultiframe, options);\n  const {\n    referencedFramesPerSegment,\n    segmentIndicies\n  } = _getNumberOfFramesPerSegment(toolState, images, segments);\n  let NumberOfFrames = 0;\n  for (let i = 0; i < referencedFramesPerSegment.length; i++) {\n    NumberOfFrames += referencedFramesPerSegment[i].length;\n  }\n  seg.setNumberOfFrames(NumberOfFrames);\n  for (let i = 0; i < segmentIndicies.length; i++) {\n    const segmentIndex = segmentIndicies[i];\n    const referencedFrameIndicies = referencedFramesPerSegment[i];\n\n    // Frame numbers start from 1.\n    const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n      return element + 1;\n    });\n    const segment = segments[segmentIndex];\n    seg.addSegment(segment, _extractCornerstoneToolsPixelData(segmentIndex, referencedFrameIndicies, toolState, images, dims), referencedFrameNumbers);\n  }\n  seg.bitPackPixelData();\n  const segBlob = datasetToBlob(seg.dataset);\n  return segBlob;\n}\nfunction _extractCornerstoneToolsPixelData(segmentIndex, referencedFrames, toolState, images, dims) {\n  const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n  let pixelDataIndex = 0;\n  for (let i = 0; i < referencedFrames.length; i++) {\n    const frame = referencedFrames[i];\n    const imageId = images[frame].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    const brushPixelData = imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n    for (let p = 0; p < brushPixelData.length; p++) {\n      pixelData[pixelDataIndex] = brushPixelData[p];\n      pixelDataIndex++;\n    }\n  }\n  return pixelData;\n}\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n  const segmentIndicies = [];\n  const referencedFramesPerSegment = [];\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      segmentIndicies.push(i);\n      referencedFramesPerSegment.push([]);\n    }\n  }\n  for (let z = 0; z < images.length; z++) {\n    const imageId = images[z].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    for (let i = 0; i < segmentIndicies.length; i++) {\n      const segIdx = segmentIndicies[i];\n      if (imageIdSpecificToolState && imageIdSpecificToolState.brush && imageIdSpecificToolState.brush.data && imageIdSpecificToolState.brush.data[segIdx] && imageIdSpecificToolState.brush.data[segIdx].pixelData) {\n        referencedFramesPerSegment[i].push(z);\n      }\n    }\n  }\n  return {\n    referencedFramesPerSegment,\n    segmentIndicies\n  };\n}\nfunction _getSegCount(seg, segments) {\n  let numSegments = 0;\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      numSegments++;\n    }\n  }\n  return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe);\n  const pixelData = unpackPixelData(multiframe);\n  const PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence;\n  const toolState = {};\n  let inPlane = true;\n  for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n    const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n    const pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength), [multiframe.Rows, multiframe.Columns]);\n    const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations);\n    if (!alignedPixelDataI) {\n      console.warn(\"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \");\n      inPlane = false;\n      break;\n    }\n    const segmentIndex = PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber - 1;\n    let SourceImageSequence;\n    if (SharedFunctionalGroupsSequence.DerivationImageSequence && SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence) {\n      SourceImageSequence = SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence[i];\n    } else {\n      SourceImageSequence = PerFrameFunctionalGroups.DerivationImageSequence.SourceImageSequence;\n    }\n    const imageId = getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider);\n    addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, alignedPixelDataI);\n  }\n  if (!inPlane) {\n    return;\n  }\n  return {\n    toolState,\n    segMetadata\n  };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n  const segType = multiframe.SegmentationType;\n  if (segType === \"BINARY\") {\n    return BitArray.unpack(multiframe.PixelData);\n  }\n  const pixelData = new Uint8Array(multiframe.PixelData);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    log.warn(\"This is a fractional segmentation, which is not currently supported.\");\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, pixelData2D) {\n  if (!toolState[imageId]) {\n    toolState[imageId] = {};\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush) {\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush.data) {\n    toolState[imageId].brush.data = [];\n  }\n  toolState[imageId].brush.data[segmentIndex] = {};\n  const brushDataI = toolState[imageId].brush.data[segmentIndex];\n  brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n  const cToolsPixelData = brushDataI.pixelData;\n  for (let p = 0; p < cToolsPixelData.length; p++) {\n    if (pixelData2D.data[p]) {\n      cToolsPixelData[p] = 1;\n    } else {\n      cToolsPixelData[p] = 0;\n    }\n  }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, imageIds, metadataProvider) : getImageIdOfReferencedSingleFramedSOPInstance(ReferencedSOPInstanceUID, imageIds, metadataProvider);\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(sopInstanceUid, imageIds, metadataProvider) {\n  return imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    return sopCommonModule.sopInstanceUID === sopInstanceUid;\n  });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, imageIds, metadataProvider) {\n  const imageId = imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n    return (\n      //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n      sopCommonModule.sopInstanceUID === sopInstanceUid && imageIdFrameNumber === frameNumber - 1\n    );\n  });\n  return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\n  if (compareIOP(iop, orientations[0])) {\n    //Same orientation.\n    return pixelData2D;\n  } else if (compareIOP(iop, orientations[1])) {\n    //Flipped vertically.\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareIOP(iop, orientations[2])) {\n    //Flipped horizontally.\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareIOP(iop, orientations[3])) {\n    //Rotated 90 degrees.\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareIOP(iop, orientations[4])) {\n    //Rotated 90 degrees and fliped horizontally.\n    return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[5])) {\n    //Rotated 90 degrees and fliped vertically.\n    return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[6])) {\n    //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[7])) {\n    //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nconst dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n  return Math.abs(iop1[0] - iop2[0]) < dx && Math.abs(iop1[1] - iop2[1]) < dx && Math.abs(iop1[2] - iop2[2]) < dx && Math.abs(iop1[3] - iop2[3]) < dx && Math.abs(iop1[4] - iop2[4]) < dx && Math.abs(iop1[5] - iop2[5]) < dx;\n}\nfunction getSegmentMetadata(multiframe) {\n  const data = [];\n  const segmentSequence = multiframe.SegmentSequence;\n  if (Array.isArray(segmentSequence)) {\n    for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n      data.push(segmentSequence[segIdx]);\n    }\n  } else {\n    // Only one segment, will be stored as an object.\n    data.push(segmentSequence);\n  }\n  return {\n    seriesInstanceUid: multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n    data\n  };\n}\n\nexport { Segmentation as default };\n","import { utilities, log, data, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport compareArrays from '../helpers/compareArrays.js';\nimport { Events } from '../enums/Events.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst {\n  encode,\n  decode\n} = utilities.compression;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\nconst generateSegmentationDefaultOptions = {\n  includeSliceSpacing: true,\n  rleEncode: false\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation(images, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const isMultiframe = isMultiframeImage(images[0]);\n  const segmentation = _createSegFromImages(images, isMultiframe, userOptions);\n  return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * Fills a given segmentation object with data from the input labelmaps3D\n *\n * @param segmentation - The segmentation object to be filled.\n * @param inputLabelmaps3D - An array of 3D labelmaps, or a single 3D labelmap.\n * @param userOptions - Optional configuration settings. Will override the default options.\n *\n * @returns {object} The filled segmentation object.\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const options = Object.assign({}, generateSegmentationDefaultOptions, userOptions);\n\n  // Use another variable so we don't redefine labelmaps3D.\n  const labelmaps3D = Array.isArray(inputLabelmaps3D) ? inputLabelmaps3D : [inputLabelmaps3D];\n  let numberOfFrames = 0;\n  const referencedFramesPerLabelmap = [];\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      labelmaps2D,\n      metadata\n    } = labelmap3D;\n    const referencedFramesPerSegment = [];\n    for (let i = 1; i < metadata.length; i++) {\n      if (metadata[i]) {\n        referencedFramesPerSegment[i] = [];\n      }\n    }\n    for (let i = 0; i < labelmaps2D.length; i++) {\n      const labelmap2D = labelmaps2D[i];\n      if (labelmaps2D[i]) {\n        const {\n          segmentsOnLabelmap\n        } = labelmap2D;\n        segmentsOnLabelmap.forEach(segmentIndex => {\n          if (segmentIndex !== 0) {\n            referencedFramesPerSegment[segmentIndex].push(i);\n            numberOfFrames++;\n          }\n        });\n      }\n    }\n    referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n  }\n  segmentation.setNumberOfFrames(numberOfFrames);\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const referencedFramesPerSegment = referencedFramesPerLabelmap[labelmapIndex];\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      metadata\n    } = labelmap3D;\n    for (let segmentIndex = 1; segmentIndex < referencedFramesPerSegment.length; segmentIndex++) {\n      const referencedFrameIndicies = referencedFramesPerSegment[segmentIndex];\n      if (referencedFrameIndicies) {\n        // Frame numbers start from 1.\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n          return element + 1;\n        });\n        const segmentMetadata = metadata[segmentIndex];\n        const labelmaps = _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies);\n        segmentation.addSegmentFromLabelmap(segmentMetadata, labelmaps, segmentIndex, referencedFrameNumbers);\n      }\n    }\n  }\n  if (options.rleEncode) {\n    const rleEncodedFrames = encode(segmentation.dataset.PixelData, numberOfFrames, segmentation.dataset.Rows, segmentation.dataset.Columns);\n\n    // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n    // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n    // added to the standard.\n    segmentation.assignToDataset({\n      BitsAllocated: \"8\",\n      BitsStored: \"8\",\n      HighBit: \"7\",\n      SegmentationType: \"FRACTIONAL\",\n      SegmentationFractionalType: \"PROBABILITY\",\n      MaximumFractionalValue: \"255\"\n    });\n    segmentation.dataset._meta.TransferSyntaxUID = {\n      Value: [\"1.2.840.10008.1.2.5\"],\n      vr: \"UI\"\n    };\n    segmentation.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    segmentation.dataset._vrMap.PixelData = \"OB\";\n    segmentation.dataset.PixelData = rleEncodedFrames;\n  } else {\n    // If no rleEncoding, at least bitpack the data.\n    segmentation.bitPackPixelData();\n  }\n  return segmentation;\n}\nfunction _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies) {\n  const {\n    labelmaps2D\n  } = labelmap3D;\n  const labelmaps = [];\n  for (let i = 0; i < referencedFrameIndicies.length; i++) {\n    const frame = referencedFrameIndicies[i];\n    labelmaps.push(labelmaps2D[frame].pixelData);\n  }\n  return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} referencedImageIds - An array for referenced image imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {obj} options - Options object.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nasync function generateToolState(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    skipOverlapping = false,\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000,\n    eventTarget = null,\n    triggerEvent = null\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bitbacking.\");\n      return;\n    }\n\n    // Todo: need to test this with rle data\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n\n  // Pre-compute the sop UID to imageId index map so that in the for loop\n  // we don't have to call metadataProvider.get() for each imageId over\n  // and over again.\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let overlapping = false;\n  if (!skipOverlapping) {\n    overlapping = checkSEGsOverlapping(pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap);\n  }\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      if (overlapping) {\n        insertFunction = insertOverlappingPixelDataPlanar;\n      } else {\n        insertFunction = insertPixelDataPlanar;\n      }\n      break;\n    case \"Perpendicular\":\n      //insertFunction = insertPixelDataPerpendicular;\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n\n  /* if SEGs are overlapping:\n  1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n  2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n  3) insertFunction will return the number of LabelMaps\n  4) generateToolState return is an array*/\n\n  const segmentsOnFrameArray = [];\n  segmentsOnFrameArray[0] = [];\n  const segmentsOnFrame = [];\n  const arrayBufferLength = sliceLength * referencedImageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  const labelmapBufferArray = [];\n  labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n\n  // Pre-compute the indices and metadata so that we don't have to call\n  // a function for each imageId in the for loop.\n  const imageIdMaps = referencedImageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n\n  // This is the centroid calculation for each segment Index, the data structure\n  // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\n  // later on we will use this data structure to calculate the centroid of the\n  // segment in the labelmapBuffer\n  const segmentsPixelIndices = new Map();\n  const overlappingSegments = await insertFunction(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent);\n\n  // calculate the centroid of each segment\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelmapBufferArray,\n    segMetadata,\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    centroids: centroidXYZ,\n    overlappingSegments\n  };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    SegmentSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  let numberOfSegs = SegmentSequence.length;\n  if (numberOfSegs < 2) {\n    return false;\n  }\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n  /** sort groupsLen to have all the segments for each frame in an array\n   * frame 2 : 1, 2\n   * frame 4 : 1, 3\n   * frame 5 : 4\n   */\n\n  let frameSegmentsMapping = new Map();\n  for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n    const segmentIndex = getSegmentIndex(multiframe, frameSegment);\n    if (segmentIndex === undefined) {\n      console.warn(\"Could not retrieve the segment index for frame segment \" + frameSegment + \", skipping this frame.\");\n      continue;\n    }\n    const imageId = findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + frameSegment + \".\");\n      continue;\n    }\n    const imageIdIndex = imageIds.findIndex(element => element === imageId);\n    if (frameSegmentsMapping.has(imageIdIndex)) {\n      let segmentArray = frameSegmentsMapping.get(imageIdIndex);\n      if (!segmentArray.includes(frameSegment)) {\n        segmentArray.push(frameSegment);\n        frameSegmentsMapping.set(imageIdIndex, segmentArray);\n      }\n    } else {\n      frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n    }\n  }\n  for (let [, role] of frameSegmentsMapping.entries()) {\n    let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\n    for (let i = 0; i < role.length; ++i) {\n      const frameSegment = role[i];\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frameSegment];\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n      const view = readFromUnpackedChunks(pixelData, frameSegment * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        console.warn(\"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\");\n        continue;\n      }\n      const data = alignedPixelDataI.data;\n      for (let j = 0, len = data.length; j < len; ++j) {\n        if (data[j] !== 0) {\n          temp2DArray[j]++;\n          if (temp2DArray[j] > 1) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction insertOverlappingPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayBufferLength = sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  // indicate the number of labelMaps\n  let M = 1;\n\n  // indicate the current labelMap array index;\n  let m = 0;\n\n  // temp array for checking overlaps\n  let tempBuffer = labelmapBufferArray[m].slice(0);\n\n  // temp list for checking overlaps\n  let tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n\n  /** split overlapping SEGs algorithm for each segment:\n   *  A) copy the labelmapBuffer in the array with index 0\n   *  B) add the segment pixel per pixel on the copied buffer from (A)\n   *  C) if no overlap, copy the results back on the orignal array from (A)\n   *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n   */\n\n  let numberOfSegs = multiframe.SegmentSequence.length;\n  for (let segmentIndexToProcess = 1; segmentIndexToProcess <= numberOfSegs; ++segmentIndexToProcess) {\n    for (let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length; i < groupsLen; ++i) {\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n      const segmentIndex = getSegmentIndex(multiframe, i);\n      if (segmentIndex === undefined) {\n        throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n      }\n      if (segmentIndex !== segmentIndexToProcess) {\n        continue;\n      }\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n\n      // Since we moved to the chunks approach, we need to read the data\n      // and handle scenarios where the portion of data is in one chunk\n      // and the other portion is in another chunk\n      const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n      }\n      const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n      if (!imageId) {\n        console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n        continue;\n      }\n      const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n      if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n        throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n      }\n      const imageIdIndex = imageIds.findIndex(element => element === imageId);\n      const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n      const labelmap2DView = new TypedArrayConstructor(tempBuffer, byteOffset, sliceLength);\n      const data = alignedPixelDataI.data;\n      let segmentOnFrame = false;\n      for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n        if (data[j]) {\n          if (labelmap2DView[j] !== 0) {\n            m++;\n            if (m >= M) {\n              labelmapBufferArray[m] = new ArrayBuffer(arrayBufferLength);\n              segmentsOnFrameArray[m] = [];\n              M++;\n            }\n            tempBuffer = labelmapBufferArray[m].slice(0);\n            tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n            i = 0;\n            break;\n          } else {\n            labelmap2DView[j] = segmentIndex;\n            segmentOnFrame = true;\n          }\n        }\n      }\n      if (segmentOnFrame) {\n        if (!tempSegmentsOnFrame[imageIdIndex]) {\n          tempSegmentsOnFrame[imageIdIndex] = [];\n        }\n        tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n        if (!segmentsOnFrame[imageIdIndex]) {\n          segmentsOnFrame[imageIdIndex] = [];\n        }\n        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n      }\n    }\n    labelmapBufferArray[m] = tempBuffer.slice(0);\n    segmentsOnFrameArray[m] = structuredClone(tempSegmentsOnFrame);\n\n    // reset temp variables/buffers for new segment\n    m = 0;\n    tempBuffer = labelmapBufferArray[m].slice(0);\n    tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n  }\n}\nconst getSegmentIndex = (multiframe, frame) => {\n  const {\n    PerFrameFunctionalGroupsSequence,\n    SharedFunctionalGroupsSequence\n  } = multiframe;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n  return PerFrameFunctionalGroups && PerFrameFunctionalGroups.SegmentIdentificationSequence ? PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber : SharedFunctionalGroupsSequence.SegmentIdentificationSequence ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence.ReferencedSegmentNumber : undefined;\n};\nfunction insertPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  let i = 0;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\n\n  const shouldTriggerEvent = triggerEvent && eventTarget;\n  let overlapping = false;\n  // Below, we chunk the processing of the frames to avoid blocking the main thread\n  // if the segmentation is large. We also use a promise to allow the caller to\n  // wait for the processing to finish.\n  return new Promise(resolve => {\n    function processInChunks() {\n      // process one chunk\n      for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          continue;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n        const labelmap2DView = new TypedArrayConstructor(labelmapBufferArray[0], byteOffset, sliceLength);\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n          if (data[j]) {\n            for (let x = j; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                }\n                labelmap2DView[x] = segmentIndex;\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n\n      // trigger an event after each chunk\n      if (shouldTriggerEvent) {\n        const percentComplete = Math.round(i / groupsLen * 100);\n        triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n          percentComplete\n        });\n      }\n\n      // schedule next chunk\n      if (i < groupsLen) {\n        setTimeout(processInChunks, 0);\n      } else {\n        // resolve the Promise when all chunks have been processed\n        resolve(overlapping);\n      }\n    }\n    processInChunks();\n  });\n}\n\n/**\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @param  {Object} options    Options for the unpacking.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe, options) {\n  const segType = multiframe.SegmentationType;\n  let data;\n  if (Array.isArray(multiframe.PixelData)) {\n    data = multiframe.PixelData[0];\n  } else {\n    data = multiframe.PixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This segmentation pixelData is undefined.\");\n  }\n  if (segType === \"BINARY\") {\n    // For extreme big data, we can't unpack the data at once and we need to\n    // chunk it and unpack each chunk separately.\n    // MAX 2GB is the limit right now to allocate a buffer\n    return getUnpackedChunks(data, options.maxBytesPerChunk);\n  }\n  const pixelData = new Uint8Array(data);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    // This is a fractional segmentation, which is not currently supported.\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\n  var bitArray = new Uint8Array(data);\n  var chunks = [];\n  var maxBitsPerChunk = maxBytesPerChunk * 8;\n  var numberOfChunks = Math.ceil(bitArray.length * 8 / maxBitsPerChunk);\n  for (var i = 0; i < numberOfChunks; i++) {\n    var startBit = i * maxBitsPerChunk;\n    var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\n    var startByte = Math.floor(startBit / 8);\n    var endByte = Math.ceil(endBit / 8);\n    var chunk = bitArray.slice(startByte, endByte);\n    var unpackedChunk = BitArray.unpack(chunk);\n    chunks.push(unpackedChunk);\n  }\n  return chunks;\n}\n\n/**\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  const baseImageId = sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n  if (!baseImageId) {\n    console.warn(`No imageId found for SOPInstanceUID: ${ReferencedSOPInstanceUID}`);\n    return undefined;\n  }\n  if (ReferencedFrameNumber !== undefined) {\n    if (baseImageId.includes(\"frames/\")) {\n      return baseImageId.replace(/frames\\/\\d+/, `frames/${ReferencedFrameNumber}`);\n    } else if (baseImageId.includes(\"frame=\")) {\n      return baseImageId.replace(/frame=\\d+/, `frame=${ReferencedFrameNumber - 1}`);\n    } else {\n      if (baseImageId.includes(\"wadors:\")) {\n        return `${baseImageId}/frames/${ReferencedFrameNumber}`;\n      } else {\n        return `${baseImageId}?frame=${ReferencedFrameNumber - 1}`;\n      }\n    }\n  }\n  return baseImageId;\n}\n\n/**\n * Determines if an image is a multiframe image based on its metadata.\n *\n * @param {Object} imageMetadata - The metadata object for the image\n * @param {number} [imageMetadata.NumberOfFrames] - The number of frames in the image\n * @returns {boolean} True if the image is a multiframe image (NumberOfFrames > 1)\n */\nfunction isMultiframeImage(imageMetadata) {\n  return imageMetadata && imageMetadata.NumberOfFrames > 1;\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (!ReferencedSeriesInstanceUID || !PerFrameFunctionalGroup.PlanePositionSequence?.[0]?.ImagePositionPatient) {\n    return undefined;\n  }\n  const segFramePosition = PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient;\n  for (let imageId of imageIds) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n    if (!sourceImageMetadata) {\n      continue;\n    }\n    const isMultiframe = isMultiframeImage(sourceImageMetadata);\n    if (!sourceImageMetadata.ImagePositionPatient || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n\n    // For multiframe images, check each frame's position\n    if (isMultiframe) {\n      const framePosition = metadataProvider.get(\"imagePlaneModule\", imageId)?.imagePositionPatient;\n      if (framePosition && compareArrays(segFramePosition, framePosition, tolerance)) {\n        return imageId;\n      }\n    } else if (compareArrays(segFramePosition, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageId;\n    }\n  }\n  return undefined;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations, tolerance) {\n  if (compareArrays(iop, orientations[0], tolerance)) {\n    return pixelData2D;\n  } else if (compareArrays(iop, orientations[1], tolerance)) {\n    // Flipped vertically.\n\n    // Undo Flip\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareArrays(iop, orientations[2], tolerance)) {\n    // Flipped horizontally.\n\n    // Unfo flip\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareArrays(iop, orientations[3], tolerance)) {\n    //Rotated 90 degrees\n\n    // Rotate back\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareArrays(iop, orientations[4], tolerance)) {\n    //Rotated 90 degrees and fliped horizontally.\n\n    // Undo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n  } else if (compareArrays(iop, orientations[5], tolerance)) {\n    // Rotated 90 degrees and fliped vertically\n\n    // Unfo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n  } else if (compareArrays(iop, orientations[6], tolerance)) {\n    // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareArrays(iop, orientations[7], tolerance)) {\n    // Rotated 270 degrees\n\n    // Rotate back.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n  const segmentSequence = multiframe.SegmentSequence;\n  let data = [];\n  if (Array.isArray(segmentSequence)) {\n    data = [undefined, ...segmentSequence];\n  } else {\n    // Only one segment, will be stored as an object.\n    data = [undefined, segmentSequence];\n  }\n  return {\n    seriesInstanceUid,\n    data\n  };\n}\n\n/**\n * Reads a range of bytes from an array of ArrayBuffer chunks and\n * aggregate them into a new Uint8Array.\n *\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\n * @param {number} offset - The offset of the first byte to read.\n * @param {number} length - The number of bytes to read.\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\n */\nfunction readFromUnpackedChunks(chunks, offset, length) {\n  const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\n\n  // If all the data is in one chunk, we can just slice that chunk\n  if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\n    return new Uint8Array(chunks[mapping.start.chunkIndex].buffer, mapping.start.offset, length);\n  } else {\n    // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\n    let result = new Uint8Array(length);\n    let resultOffset = 0;\n    for (let i = mapping.start.chunkIndex; i <= mapping.end.chunkIndex; i++) {\n      let start = i === mapping.start.chunkIndex ? mapping.start.offset : 0;\n      let end = i === mapping.end.chunkIndex ? mapping.end.offset : chunks[i].length;\n      result.set(new Uint8Array(chunks[i].buffer, start, end - start), resultOffset);\n      resultOffset += end - start;\n    }\n    return result;\n  }\n}\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\n  var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\n  if (offset < 0 || offset + length > totalBytes) {\n    throw new Error(\"Offset and length out of bounds\");\n  }\n  var startChunkIndex = 0;\n  var startOffsetInChunk = offset;\n  while (startOffsetInChunk >= chunks[startChunkIndex].length) {\n    startOffsetInChunk -= chunks[startChunkIndex].length;\n    startChunkIndex++;\n  }\n  var endChunkIndex = startChunkIndex;\n  var endOffsetInChunk = startOffsetInChunk + length;\n  while (endOffsetInChunk > chunks[endChunkIndex].length) {\n    endOffsetInChunk -= chunks[endChunkIndex].length;\n    endChunkIndex++;\n  }\n  return {\n    start: {\n      chunkIndex: startChunkIndex,\n      offset: startOffsetInChunk\n    },\n    end: {\n      chunkIndex: endChunkIndex,\n      offset: endOffsetInChunk\n    }\n  };\n}\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, imageIds) {\n  let xAcc = 0;\n  let yAcc = 0;\n  let zAcc = 0;\n  let worldXAcc = 0;\n  let worldYAcc = 0;\n  let worldZAcc = 0;\n  let count = 0;\n  for (const [imageIdIndex, bufferIndices] of Object.entries(imageIdIndexBufferIndex)) {\n    const z = Number(imageIdIndex);\n    if (!bufferIndices || bufferIndices.length === 0) {\n      continue;\n    }\n\n    // Get metadata for this slice\n    const imageId = imageIds[z];\n    const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageId);\n    if (!imagePlaneModule) {\n      console.debug(\"Missing imagePlaneModule metadata for centroid calculation\");\n      continue;\n    }\n    const {\n      imagePositionPatient,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing\n    } = imagePlaneModule;\n    for (const bufferIndex of bufferIndices) {\n      const y = Math.floor(bufferIndex / multiframe.Rows);\n      const x = bufferIndex % multiframe.Rows;\n\n      // Image coordinates\n      xAcc += x;\n      yAcc += y;\n      zAcc += z;\n\n      // Calculate world coordinates\n      // P(world) = P(image) * IOP * spacing + IPP\n      const worldX = imagePositionPatient[0] + x * rowCosines[0] * columnPixelSpacing + y * columnCosines[0] * rowPixelSpacing;\n      const worldY = imagePositionPatient[1] + x * rowCosines[1] * columnPixelSpacing + y * columnCosines[1] * rowPixelSpacing;\n      const worldZ = imagePositionPatient[2] + x * rowCosines[2] * columnPixelSpacing + y * columnCosines[2] * rowPixelSpacing;\n      worldXAcc += worldX;\n      worldYAcc += worldY;\n      worldZAcc += worldZ;\n      count++;\n    }\n  }\n  return {\n    image: {\n      x: Math.floor(xAcc / count),\n      y: Math.floor(yAcc / count),\n      z: Math.floor(zAcc / count)\n    },\n    world: {\n      x: worldXAcc / count,\n      y: worldYAcc / count,\n      z: worldZAcc / count\n    },\n    count\n  };\n}\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState,\n  fillSegmentation\n};\n\nexport { _createSegFromImages, _getLabelmapsFromReferencedFrameIndicies, alignPixelDataWithSourceData, calculateCentroid, checkSEGsOverlapping, Segmentation as default, fillSegmentation, findReferenceSourceImageId, generateSegmentation, generateToolState, getImageIdOfSourceImageBySourceImageSequence, getImageIdOfSourceImagebyGeometry, getSegmentIndex, getSegmentMetadata, getUnpackedChunks, getUnpackedOffsetAndLength, getValidOrientations, insertOverlappingPixelDataPlanar, insertPixelDataPlanar, readFromUnpackedChunks, unpackPixelData };\n","var CORNERSTONE_4_TAG = \"cornerstoneTools@^4.0.0\";\n\nexport { CORNERSTONE_4_TAG as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport Length from './Length.js';\nimport FreehandRoi from './FreehandRoi.js';\nimport Bidirectional from './Bidirectional.js';\nimport EllipticalRoi from './EllipticalRoi.js';\nimport CircleRoi from './CircleRoi.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport CobbAngle from './CobbAngle.js';\nimport Angle from './Angle.js';\nimport RectangleRoi from './RectangleRoi.js';\nimport * as Segmentation from './Segmentation.js';\nimport ParametricMapObj from './ParametricMap.js';\n\nconst CornerstoneSR = {\n  Length,\n  FreehandRoi,\n  Bidirectional,\n  EllipticalRoi,\n  CircleRoi,\n  ArrowAnnotate,\n  MeasurementReport,\n  CobbAngle,\n  Angle,\n  RectangleRoi\n};\nconst CornerstoneSEG = {\n  Segmentation\n};\nconst CornerstonePMAP = {\n  ParametricMap: ParametricMapObj\n};\n\nexport { CornerstonePMAP, CornerstoneSEG, CornerstoneSR };\n","import { data } from 'dcmjs';\n\nconst {\n  Colors,\n  BitArray\n} = data;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n  const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n  rgba.push(255);\n  return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n  const Zx = x[1] * y[2] - x[2] * y[1];\n  const Zy = x[2] * y[0] - x[0] * y[2];\n  const Zz = x[0] * y[1] - x[1] * y[0];\n  out[0] = Zx;\n  out[1] = Zy;\n  out[2] = Zz;\n}\nfunction norm(x) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  switch (n) {\n    case 1:\n      return Math.abs(x);\n    case 2:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n    case 3:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n    default:\n      {\n        let sum = 0;\n        for (let i = 0; i < n; i++) {\n          sum += x[i] * x[i];\n        }\n        return Math.sqrt(sum);\n      }\n  }\n}\nfunction normalize(x) {\n  const den = norm(x);\n  if (den !== 0.0) {\n    x[0] /= den;\n    x[1] /= den;\n    x[2] /= den;\n  }\n  return den;\n}\nfunction subtract(a, b, out) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n  const geometry = {};\n  const pixelMeasures = dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n  const planeOrientation = dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n  // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n  //\n  // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n  // sort them to obtain the first and last position along the acquisition axis.\n  const firstFunctionalGroup = PerFrameFunctionalGroups[0];\n  const lastFunctionalGroup = PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n  const firstPosition = firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  const lastPosition = lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  geometry.origin = firstPosition;\n\n  // NB: DICOM PixelSpacing is defined as Row then Column,\n  // unlike ImageOrientationPatient\n  geometry.spacing = [pixelMeasures.PixelSpacing[1], pixelMeasures.PixelSpacing[0], pixelMeasures.SpacingBetweenSlices].map(Number);\n  geometry.dimensions = [dataset.Columns, dataset.Rows, PerFrameFunctionalGroups.length].map(Number);\n  const orientation = planeOrientation.ImageOrientationPatient.map(Number);\n  const columnStepToPatient = orientation.slice(0, 3);\n  const rowStepToPatient = orientation.slice(3, 6);\n  geometry.planeNormal = [];\n  cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n  geometry.sliceStep = [];\n  subtract(lastPosition, firstPosition, geometry.sliceStep);\n  normalize(geometry.sliceStep);\n  geometry.direction = columnStepToPatient.concat(rowStepToPatient).concat(geometry.sliceStep);\n  return geometry;\n}\nclass Segmentation {\n  constructor() {}\n\n  /**\n   * Produces an array of Segments from an input DICOM Segmentation dataset\n   *\n   * Segments are returned with Geometry values that can be used to create\n   * VTK Image Data objects.\n   *\n   * @example Example usage to create VTK Volume actors from each segment:\n   *\n   * const actors = [];\n   * const segments = generateToolState(dataset);\n   * segments.forEach(segment => {\n   *   // now make actors using the segment information\n   *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n   *        name: \"Scalars\",\n   *        numberOfComponents: 1,\n   *        values: segment.pixelData,\n   *    });\n   *\n   *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n   *    imageData.getPointData().setScalars(scalarArray);\n   *    imageData.setDimensions(geometry.dimensions);\n   *    imageData.setSpacing(geometry.spacing);\n   *    imageData.setOrigin(geometry.origin);\n   *    imageData.setDirection(geometry.direction);\n   *\n   *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n   *    mapper.setInputData(imageData);\n   *    mapper.setSampleDistance(2.);\n   *\n   *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n   *    actor.setMapper(mapper);\n   *\n   *    actors.push(actor);\n   * });\n   *\n   * @param dataset\n   * @return {{}}\n   */\n  static generateSegments(dataset) {\n    if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n      dataset.SegmentSequence = [dataset.SegmentSequence];\n    }\n    dataset.SegmentSequence.forEach(segment => {\n      // TODO: other interesting fields could be extracted from the segment\n      // TODO: Read SegmentsOverlay field\n      // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n      // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n      // Why was this example converting to RGBA with 0-255 values?\n      const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n      segments[segment.SegmentNumber] = {\n        color,\n        functionalGroups: [],\n        offset: null,\n        size: null,\n        pixelData: null\n      };\n    });\n\n    // make a list of functional groups per segment\n    dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n      const segmentNumber = functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\n      segments[segmentNumber].functionalGroups.push(functionalGroup);\n    });\n\n    // determine per-segment index into the pixel data\n    // TODO: only handles one-bit-per pixel\n    const frameSize = Math.ceil(dataset.Rows * dataset.Columns / 8);\n    let nextOffset = 0;\n    Object.keys(segments).forEach(segmentNumber => {\n      const segment = segments[segmentNumber];\n      segment.numberOfFrames = segment.functionalGroups.length;\n      segment.size = segment.numberOfFrames * frameSize;\n      segment.offset = nextOffset;\n      nextOffset = segment.offset + segment.size;\n      const packedSegment = dataset.PixelData.slice(segment.offset, nextOffset);\n      segment.pixelData = BitArray.unpack(packedSegment);\n      const geometry = geometryFromFunctionalGroups(dataset, segment.functionalGroups);\n      segment.geometry = geometry;\n    });\n    return segments;\n  }\n}\n\nexport { Segmentation as default };\n","import Segmentation from './Segmentation.js';\n\nconst VTKjsSEG = {\n  Segmentation\n};\n\nexport { VTKjsSEG };\n","var Events;\n(function (Events) {\n  Events[\"SEGMENTATION_LOAD_PROGRESS\"] = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\";\n})(Events || (Events = {}));\n\nexport { Events };\n","export { Events } from './Events.js';\n","function checkIfPerpendicular(iop1, iop2, tolerance) {\n  const absDotColumnCosines = Math.abs(iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]);\n  const absDotRowCosines = Math.abs(iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]);\n  return (absDotColumnCosines < tolerance || Math.abs(absDotColumnCosines - 1) < tolerance) && (absDotRowCosines < tolerance || Math.abs(absDotRowCosines - 1) < tolerance);\n}\n\nexport { checkIfPerpendicular as default };\n","import checkIfPerpendicular from './checkIfPerpendicular.js';\nimport compareArrays from './compareArrays.js';\n\nfunction checkOrientation(multiframe, validOrientations, sourceDataDimensions, tolerance) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n  const iop = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const inPlane = validOrientations.some(operation => compareArrays(iop, operation, tolerance));\n  if (inPlane) {\n    return \"Planar\";\n  }\n  if (checkIfPerpendicular(iop, validOrientations[0], tolerance) && sourceDataDimensions.includes(multiframe.Rows) && sourceDataDimensions.includes(multiframe.Columns)) {\n    return \"Perpendicular\";\n  }\n  return \"Oblique\";\n}\n\nexport { checkOrientation as default };\n","const codeMeaningEquals = codeMeaningName => {\n  return contentItem => {\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\n  };\n};\n\nexport { codeMeaningEquals };\n","import { utilities } from 'dcmjs';\n\nconst {\n  nearlyEqual\n} = utilities.orientation;\nfunction compareArrays(array1, array2, tolerance) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; ++i) {\n    if (!nearlyEqual(array1[i], array2[i], tolerance)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { compareArrays as default };\n","const seriesTags = [\"SeriesInstanceUID\", \"SeriesNumber\", \"SeriesDescription\", \"Modality\", \"SeriesDate\", \"SeriesTime\"];\nfunction copySeriesTags(src) {\n  const study = {\n    _meta: src._meta,\n    _vrMap: src._vrMap\n  };\n  for (const tagKey of seriesTags) {\n    const value = src[tagKey];\n    if (value === undefined) {\n      continue;\n    }\n    study[tagKey] = value;\n  }\n  return study;\n}\n\nexport { copySeriesTags, seriesTags };\n","const patientTags = [\"PatientName\", \"PatientID\", \"PatientBirthDate\", \"PatientBirthTime\", \"PatientID\", \"IssuerOfPatientID\", \"OtherPatientIDs\", \"OtherPatientIDsSequence\", \"PatientSex\", \"PatientIdentityRemoved\", \"DeidentificationMethodCodeSequence\"];\nconst studyTags = [\"StudyDate\", \"StudyTime\", \"StudyStatusID\", \"StudyPriorityID\", \"StudyInstanceUID\", \"StudyDescription\", \"AccessionNumber\", \"StudyID\", \"ReferringPhysicianName\", \"BodyPartExamined\", \"TimezoneOffsetFromUTC\"];\nconst patientStudyTags = [...patientTags, ...studyTags];\nfunction copyStudyTags(src) {\n  const study = {\n    _meta: src._meta,\n    _vrMap: src._vrMap\n  };\n  for (const tagKey of patientStudyTags) {\n    const value = src[tagKey];\n    if (value === undefined) {\n      continue;\n    }\n    study[tagKey] = value;\n  }\n  return study;\n}\n\nexport { copyStudyTags, patientStudyTags, patientTags, studyTags };\n","import { data } from 'dcmjs';\nimport { Buffer } from 'buffer';\n\nconst {\n  datasetToDict\n} = data;\nfunction downloadDICOMData(bufferOrDataset, filename) {\n  let blob;\n  if (bufferOrDataset instanceof ArrayBuffer) {\n    blob = new Blob([bufferOrDataset], {\n      type: \"application/dicom\"\n    });\n  } else {\n    if (!bufferOrDataset._meta) {\n      throw new Error(\"Dataset must have a _meta property\");\n    }\n    const buffer = Buffer.from(datasetToDict(bufferOrDataset).write());\n    blob = new Blob([buffer], {\n      type: \"application/dicom\"\n    });\n  }\n  const link = document.createElement(\"a\");\n  link.href = window.URL.createObjectURL(blob);\n  link.download = filename;\n  link.click();\n}\n\nexport { downloadDICOMData };\n","import { data, normalizers } from 'dcmjs';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nfunction getDatasetsFromImages(images, isMultiframe, options) {\n  const datasets = [];\n  if (isMultiframe) {\n    const image = images[0];\n    const arrayBuffer = image.data.byteArray.buffer;\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    datasets.push(dataset);\n  } else {\n    for (let i = 0; i < images.length; i++) {\n      const image = images[i];\n      const arrayBuffer = image.data.byteArray.buffer;\n      const dicomData = DicomMessage.readFile(arrayBuffer);\n      const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n      dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n      datasets.push(dataset);\n    }\n  }\n  if (options?.SpecificCharacterSet) {\n    datasets.forEach(dataset => dataset.SpecificCharacterSet = options.SpecificCharacterSet);\n  }\n  return Normalizer.normalizeToDataset(datasets);\n}\n\nexport { getDatasetsFromImages as default };\n","const graphicTypeEquals = graphicType => {\n  return contentItem => {\n    return contentItem && contentItem.GraphicType === graphicType;\n  };\n};\n\nexport { graphicTypeEquals };\n","export { toArray } from './toArray.js';\nexport { codeMeaningEquals } from './codeMeaningEquals.js';\nexport { graphicTypeEquals } from './graphicTypeEquals.js';\nexport { downloadDICOMData } from './downloadDICOMData.js';\nexport { copyStudyTags } from './copyStudyTags.js';\nexport { copySeriesTags } from './copySeriesTags.js';\n","const toArray = x => Array.isArray(x) ? x : [x];\n\nexport { toArray };\n","import { CornerstoneSR, CornerstoneSEG, CornerstonePMAP } from './Cornerstone/index.js';\nimport { Cornerstone3DSR, Cornerstone3DSEG, Cornerstone3DPMAP, Cornerstone3DRT } from './Cornerstone3D/index.js';\nimport { VTKjsSEG } from './VTKjs/index.js';\nimport './enums/Events.js';\nimport 'dcmjs';\nimport 'buffer';\n\nconst adaptersSR = {\n  Cornerstone: CornerstoneSR,\n  Cornerstone3D: Cornerstone3DSR\n};\nconst adaptersSEG = {\n  Cornerstone: CornerstoneSEG,\n  Cornerstone3D: Cornerstone3DSEG,\n  VTKjs: VTKjsSEG\n};\nconst adaptersPMAP = {\n  Cornerstone: CornerstonePMAP,\n  Cornerstone3D: Cornerstone3DPMAP\n};\nconst adaptersRT = {\n  Cornerstone3D: Cornerstone3DRT\n};\n\nexport { adaptersPMAP, adaptersRT, adaptersSEG, adaptersSR };\n","export { adaptersPMAP, adaptersRT, adaptersSEG, adaptersSR } from './adapters/index.js';\nimport * as index from './adapters/enums/index.js';\nexport { index as Enums };\nimport * as index$1 from './adapters/helpers/index.js';\nexport { index$1 as helpers };\nexport { NO_IMAGE_ID } from './adapters/Cornerstone3D/constants/index.js';\n","var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"CROSSHAIR_TOOL_CENTER_CHANGED\"] = \"CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"HISTORY_UNDO\"] = \"CORNERSTONE_TOOLS_HISTORY_UNDO\";\n    Events[\"HISTORY_REDO\"] = \"CORNERSTONE_TOOLS_HISTORY_REDO\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"Labelmap\";\n    SegmentationRepresentations[\"Contour\"] = \"Contour\";\n    SegmentationRepresentations[\"Surface\"] = \"Surface\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n","var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"Interpolate\"] = \"interpolate\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"AddPreview\"] = \"addPreview\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n    StrategyCallbacks[\"GetStatistics\"] = \"getStatistics\";\n    StrategyCallbacks[\"EnsureImageVolumeFor3DManipulation\"] = \"ensureImageVolumeFor3DManipulation\";\n    StrategyCallbacks[\"EnsureSegmentationVolumeFor3DManipulation\"] = \"ensureSegmentationVolumeFor3DManipulation\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n","var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n    MouseBindings[MouseBindings[\"Wheel\"] = 524288] = \"Wheel\";\n    MouseBindings[MouseBindings[\"Wheel_Primary\"] = 524289] = \"Wheel_Primary\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n    ChangeTypes[\"COMPUTE_STATISTICS\"] = \"Computing Statistics\";\n    ChangeTypes[\"INTERPOLATE_LABELMAP\"] = \"Interpolating Labelmap\";\n    ChangeTypes[\"COMPUTE_LARGEST_BIDIRECTIONAL\"] = \"Computing Largest Bidirectional\";\n    ChangeTypes[\"GENERATE_CONTOUR_SETS\"] = \"Generating Contour Sets\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","import { MouseBindings, KeyboardBindings } from './ToolBindings';\nimport ToolModes from './ToolModes';\nimport AnnotationStyleStates from './AnnotationStyleStates';\nimport Events from './Events';\nimport SegmentationRepresentations from './SegmentationRepresentations';\nimport { Swipe } from './Touch';\nimport StrategyCallbacks from './StrategyCallbacks';\nimport ChangeTypes from './ChangeTypes';\nimport WorkerTypes from './WorkerTypes';\nexport { MouseBindings, KeyboardBindings, ToolModes, AnnotationStyleStates, Events, SegmentationRepresentations, Swipe, StrategyCallbacks, ChangeTypes, WorkerTypes, };\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n"],"names":[],"sourceRoot":""}