{"version":3,"file":"vendors-node_modules_cornerstonejs_polymorphic-segmentation_dist_esm_workers_polySegConverter-30c086.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Cpolymorphic-segmentation%5Cdist%5Cesm%5Cworkers%5CpolySegConverters.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CAnnotationStyleStates.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CChangeTypes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CEvents.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CSegmentationRepresentations.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CStrategyCallbacks.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CToolBindings.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CToolModes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CTouch.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CWorkerTypes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@kitware%5Cvtk.js%5CFilters%5CGeneral%5CContourLoopExtraction.js"],"sourcesContent":["import { expose } from 'comlink';\nimport { utilities } from '@cornerstonejs/core';\nimport { utilities as ToolsUtilities } from '@cornerstonejs/tools';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkContourLoopExtraction from '@kitware/vtk.js/Filters/General/ContourLoopExtraction';\nimport vtkCutter from '@kitware/vtk.js/Filters/Core/Cutter';\nconst { math: { polyline: { containsPoint, getAABB, projectTo2D }, }, geometricSurfaceUtils: { checkStandardBasis, rotatePoints }, boundingBox: { getBoundingBoxAroundShapeWorld }, planar: { isPlaneIntersectingAABB }, } = ToolsUtilities;\nasync function peerImport(moduleId) {\n    try {\n        if (moduleId === '@icr/polyseg-wasm') {\n            return import('@icr/polyseg-wasm');\n        }\n    }\n    catch (error) {\n        console.warn('Error importing module:', error);\n        return null;\n    }\n}\nconst polySegConverters = {\n    polySeg: null,\n    polySegInitializing: false,\n    polySegInitializingPromise: null,\n    async initializePolySeg(progressCallback) {\n        let ICRPolySeg;\n        try {\n            ICRPolySeg = (await peerImport('@icr/polyseg-wasm')).default;\n        }\n        catch (error) {\n            console.error(error);\n            console.debug(\"Warning: '@icr/polyseg-wasm' module not found. Please install it separately.\");\n            return;\n        }\n        if (this.polySegInitializing) {\n            await this.polySegInitializingPromise;\n            return;\n        }\n        if (this.polySeg?.instance) {\n            return;\n        }\n        this.polySegInitializing = true;\n        this.polySegInitializingPromise = new Promise((resolve) => {\n            this.polySeg = new ICRPolySeg();\n            this.polySeg\n                .initialize({\n                updateProgress: progressCallback,\n            })\n                .then(() => {\n                this.polySegInitializing = false;\n                resolve();\n            });\n        });\n        await this.polySegInitializingPromise;\n    },\n    async convertContourToSurface(args, ...callbacks) {\n        const { polylines, numPointsArray } = args;\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = await this.polySeg.instance.convertContourRoiToSurface(polylines, numPointsArray);\n        return results;\n    },\n    async convertLabelmapToSurface(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = this.polySeg.instance.convertLabelmapToSurface(args.scalarData, args.dimensions, args.spacing, args.direction, args.origin, [args.segmentIndex]);\n        const rotationInfo = checkStandardBasis(args.direction);\n        if (!rotationInfo.isStandard) {\n            const rotatedPoints = rotatePoints(rotationInfo.rotationMatrix, args.origin, results.points);\n            results.points = [...rotatedPoints];\n        }\n        return results;\n    },\n    async convertContourToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentIndices, scalarData, annotationUIDsInSegmentMap, dimensions, origin, direction, spacing, } = args;\n        const segmentationVoxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n        const imageData = vtkImageData.newInstance();\n        imageData.setDimensions(dimensions);\n        imageData.setOrigin(origin);\n        imageData.setDirection(direction);\n        imageData.setSpacing(spacing);\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Pixels',\n            numberOfComponents: 1,\n            values: scalarData,\n        });\n        imageData.getPointData().setScalars(scalarArray);\n        imageData.modified();\n        for (const index of segmentIndices) {\n            const annotations = annotationUIDsInSegmentMap.get(index);\n            for (const annotation of annotations) {\n                if (!annotation.polyline) {\n                    continue;\n                }\n                const { polyline, holesPolyline } = annotation;\n                const bounds = getBoundingBoxAroundShapeWorld(polyline);\n                const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][0],\n                    bounds[1][0],\n                    bounds[2][0],\n                ]);\n                const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][1],\n                    bounds[1][1],\n                    bounds[2][1],\n                ]);\n                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);\n                const holes = holesPolyline?.map((hole) => {\n                    const { projectedPolyline: projectedHole } = projectTo2D(hole);\n                    return projectedHole;\n                });\n                const firstDim = (sharedDimensionIndex + 1) % 3;\n                const secondDim = (sharedDimensionIndex + 2) % 3;\n                const voxels = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                    dimensions,\n                    scalarData,\n                });\n                voxels.forEach(({ pointIJK }) => {\n                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n                }, {\n                    imageData,\n                    isInObject: (pointLPS) => {\n                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n                        const isInside = containsPoint(projectedPolyline, point2D, {\n                            holes,\n                        });\n                        return isInside;\n                    },\n                    boundsIJK: [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ],\n                });\n            }\n        }\n        return segmentationVoxelManager.scalarData;\n    },\n    async convertContourToStackLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } = args;\n        const segmentationVoxelManagers = new Map();\n        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n            const { dimensions, scalarData, direction, spacing, origin } = segmentationInfo;\n            const manager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                dimensions,\n                scalarData,\n            });\n            const imageData = vtkImageData.newInstance();\n            imageData.setDimensions(dimensions);\n            imageData.setOrigin(origin);\n            imageData.setDirection(direction);\n            imageData.setSpacing(spacing);\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: scalarData,\n            });\n            imageData.getPointData().setScalars(scalarArray);\n            imageData.modified();\n            segmentationVoxelManagers.set(referencedImageId, { manager, imageData });\n        });\n        for (const index of segmentIndices) {\n            const annotations = annotationUIDsInSegmentMap.get(index);\n            for (const annotation of annotations) {\n                if (!annotation.polyline) {\n                    continue;\n                }\n                const { polyline, holesPolyline, referencedImageId } = annotation;\n                const bounds = getBoundingBoxAroundShapeWorld(polyline);\n                const { manager: segmentationVoxelManager, imageData } = segmentationVoxelManagers.get(referencedImageId);\n                const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][0],\n                    bounds[1][0],\n                    bounds[2][0],\n                ]);\n                const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][1],\n                    bounds[1][1],\n                    bounds[2][1],\n                ]);\n                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);\n                const holes = holesPolyline?.map((hole) => {\n                    const { projectedPolyline: projectedHole } = projectTo2D(hole);\n                    return projectedHole;\n                });\n                const firstDim = (sharedDimensionIndex + 1) % 3;\n                const secondDim = (sharedDimensionIndex + 2) % 3;\n                const voxels = utilities.VoxelManager.createImageVoxelManager({\n                    width: imageData.getDimensions()[0],\n                    height: imageData.getDimensions()[1],\n                    scalarData: imageData.getPointData().getScalars().getData(),\n                });\n                voxels.forEach(({ pointIJK }) => {\n                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n                }, {\n                    imageData,\n                    isInObject: (pointLPS) => {\n                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n                        const isInside = containsPoint(projectedPolyline, point2D, {\n                            holes,\n                        });\n                        return isInside;\n                    },\n                    boundsIJK: [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ],\n                });\n            }\n        }\n        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n            const { manager: segmentationVoxelManager } = segmentationVoxelManagers.get(referencedImageId);\n            segmentationInfo.scalarData = segmentationVoxelManager.scalarData;\n        });\n        return segmentationsInfo;\n    },\n    async convertSurfaceToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = this.polySeg.instance.convertSurfaceToLabelmap(args.points, args.polys, args.dimensions, args.spacing, args.direction, args.origin);\n        return results;\n    },\n    async convertSurfacesToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentsInfo } = args;\n        const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {\n            const { points, polys } = segmentsInfo.get(segmentIndex);\n            const result = this.polySeg.instance.convertSurfaceToLabelmap(points, polys, args.dimensions, args.spacing, args.direction, args.origin);\n            return {\n                ...result,\n                segmentIndex,\n            };\n        });\n        const results = await Promise.all(promises);\n        const targetImageData = vtkImageData.newInstance();\n        targetImageData.setDimensions(args.dimensions);\n        targetImageData.setOrigin(args.origin);\n        targetImageData.setSpacing(args.spacing);\n        targetImageData.setDirection(args.direction);\n        const totalSize = args.dimensions[0] * args.dimensions[1] * args.dimensions[2];\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Pixels',\n            numberOfComponents: 1,\n            values: new Uint8Array(totalSize),\n        });\n        targetImageData.getPointData().setScalars(scalarArray);\n        targetImageData.modified();\n        const { dimensions } = args;\n        const scalarData = targetImageData.getPointData().getScalars().getData();\n        const segmentationVoxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n        const outputVolumesInfo = results.map((result) => {\n            const { data, dimensions, direction, origin, spacing } = result;\n            const volume = vtkImageData.newInstance();\n            volume.setDimensions(dimensions);\n            volume.setOrigin(origin);\n            volume.setSpacing(spacing);\n            volume.setDirection(direction);\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: data,\n            });\n            volume.getPointData().setScalars(scalarArray);\n            volume.modified();\n            const voxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                dimensions,\n                scalarData: data,\n            });\n            const extent = volume.getExtent();\n            return {\n                volume,\n                voxelManager,\n                extent,\n                scalarData: data,\n                segmentIndex: result.segmentIndex,\n            };\n        });\n        const voxels = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions: targetImageData.getDimensions(),\n            scalarData: targetImageData.getPointData().getScalars().getData(),\n        });\n        voxels.forEach(({ pointIJK, pointLPS }) => {\n            try {\n                for (const volumeInfo of outputVolumesInfo) {\n                    const { volume, extent, voxelManager, segmentIndex } = volumeInfo;\n                    const index = volume.worldToIndex(pointLPS);\n                    if (index[0] < extent[0] ||\n                        index[0] > extent[1] ||\n                        index[1] < extent[2] ||\n                        index[1] > extent[3] ||\n                        index[2] < extent[4] ||\n                        index[2] > extent[5]) {\n                        continue;\n                    }\n                    const roundedIndex = index.map(Math.round);\n                    const value = voxelManager.getAtIJK(...roundedIndex);\n                    if (value > 0) {\n                        segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);\n                        break;\n                    }\n                }\n            }\n            catch (error) {\n            }\n        }, { imageData: targetImageData });\n        return segmentationVoxelManager.scalarData;\n    },\n    getSurfacesAABBs({ surfacesInfo }) {\n        const aabbs = new Map();\n        for (const { points, id } of surfacesInfo) {\n            const aabb = getAABB(points, { numDimensions: 3 });\n            aabbs.set(id, aabb);\n        }\n        return aabbs;\n    },\n    cutSurfacesIntoPlanes({ planesInfo, surfacesInfo, surfacesAABB = new Map() }, progressCallback, updateCacheCallback) {\n        const numberOfPlanes = planesInfo.length;\n        const cutter = vtkCutter.newInstance();\n        const plane1 = vtkPlane.newInstance();\n        cutter.setCutFunction(plane1);\n        const surfacePolyData = vtkPolyData.newInstance();\n        try {\n            for (const [index, planeInfo] of planesInfo.entries()) {\n                const { sliceIndex, planes } = planeInfo;\n                const polyDataResults = new Map();\n                for (const polyDataInfo of surfacesInfo) {\n                    const { points, polys, id, segmentIndex } = polyDataInfo;\n                    const aabb3 = surfacesAABB.get(id) || getAABB(points, { numDimensions: 3 });\n                    if (!surfacesAABB.has(id)) {\n                        surfacesAABB.set(id, aabb3);\n                    }\n                    const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;\n                    const { origin, normal } = planes[0];\n                    if (!isPlaneIntersectingAABB(origin, normal, minX, minY, minZ, maxX, maxY, maxZ)) {\n                        continue;\n                    }\n                    surfacePolyData.getPoints().setData(points, 3);\n                    surfacePolyData.getPolys().setData(polys, 3);\n                    surfacePolyData.modified();\n                    cutter.setInputData(surfacePolyData);\n                    plane1.setOrigin(origin);\n                    plane1.setNormal(normal);\n                    try {\n                        cutter.update();\n                    }\n                    catch (e) {\n                        console.warn('Error during clipping', e);\n                        continue;\n                    }\n                    const polyData = cutter.getOutputData();\n                    const cutterOutput = polyData;\n                    cutterOutput.buildLinks();\n                    const loopExtraction = vtkContourLoopExtraction.newInstance();\n                    loopExtraction.setInputData(cutterOutput);\n                    const loopOutput = loopExtraction.getOutputData();\n                    if (polyData) {\n                        polyDataResults.set(segmentIndex, {\n                            points: loopOutput.getPoints().getData(),\n                            lines: loopOutput.getLines().getData(),\n                            numberOfCells: loopOutput.getLines().getNumberOfCells(),\n                            segmentIndex,\n                        });\n                    }\n                }\n                progressCallback({ progress: (index + 1) / numberOfPlanes });\n                updateCacheCallback({ sliceIndex, polyDataResults });\n            }\n        }\n        catch (e) {\n            console.warn('Error during processing', e);\n        }\n        finally {\n            surfacesInfo = null;\n            plane1.delete();\n        }\n    },\n};\nexpose(polySegConverters);\n","var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"CROSSHAIR_TOOL_CENTER_CHANGED\"] = \"CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"HISTORY_UNDO\"] = \"CORNERSTONE_TOOLS_HISTORY_UNDO\";\n    Events[\"HISTORY_REDO\"] = \"CORNERSTONE_TOOLS_HISTORY_REDO\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"Labelmap\";\n    SegmentationRepresentations[\"Contour\"] = \"Contour\";\n    SegmentationRepresentations[\"Surface\"] = \"Surface\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n","var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"Interpolate\"] = \"interpolate\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"AddPreview\"] = \"addPreview\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n    StrategyCallbacks[\"GetStatistics\"] = \"getStatistics\";\n    StrategyCallbacks[\"EnsureImageVolumeFor3DManipulation\"] = \"ensureImageVolumeFor3DManipulation\";\n    StrategyCallbacks[\"EnsureSegmentationVolumeFor3DManipulation\"] = \"ensureSegmentationVolumeFor3DManipulation\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n","var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n    MouseBindings[MouseBindings[\"Wheel\"] = 524288] = \"Wheel\";\n    MouseBindings[MouseBindings[\"Wheel_Primary\"] = 524289] = \"Wheel_Primary\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n    ChangeTypes[\"COMPUTE_STATISTICS\"] = \"Computing Statistics\";\n    ChangeTypes[\"INTERPOLATE_LABELMAP\"] = \"Interpolating Labelmap\";\n    ChangeTypes[\"COMPUTE_LARGEST_BIDIRECTIONAL\"] = \"Computing Largest Bidirectional\";\n    ChangeTypes[\"GENERATE_CONTOUR_SETS\"] = \"Generating Contour Sets\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","import { MouseBindings, KeyboardBindings } from './ToolBindings';\nimport ToolModes from './ToolModes';\nimport AnnotationStyleStates from './AnnotationStyleStates';\nimport Events from './Events';\nimport SegmentationRepresentations from './SegmentationRepresentations';\nimport { Swipe } from './Touch';\nimport StrategyCallbacks from './StrategyCallbacks';\nimport ChangeTypes from './ChangeTypes';\nimport WorkerTypes from './WorkerTypes';\nexport { MouseBindings, KeyboardBindings, ToolModes, AnnotationStyleStates, Events, SegmentationRepresentations, Swipe, StrategyCallbacks, ChangeTypes, WorkerTypes, };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nconst Dir = {\n  Forward: 1,\n  Backward: -1\n};\nconst visited = new Set();\nfunction vtkContourLoopExtraction(publicAPI, model) {\n  publicAPI.requestData = (inData, outData) => {\n    const [input] = inData;\n    if (!outData[0]) {\n      outData[0] = vtkPolyData.newInstance();\n    }\n    const [output] = outData;\n    publicAPI.extractContours(input, output);\n    output.modified();\n  };\n  publicAPI.traverseLoop = (pd, dir, startLineId, startPtId, loopPoints) => {\n    let lineId = startLineId;\n    let lastPtId = startPtId;\n    let terminated = false;\n    let numInserted = 0;\n    while (!terminated) {\n      const {\n        cellPointIds\n      } = pd.getCellPoints(lineId);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      lastPtId = cellPointIds[0] !== lastPtId ? cellPointIds[0] : cellPointIds[1];\n      numInserted++;\n\n      // parametric point value\n      const t = dir * numInserted;\n      loopPoints.push({\n        t,\n        ptId: lastPtId\n      });\n      const lineCell = pd.getPointCells(lastPtId);\n      if (lineCell.length !== 2 || lastPtId === startPtId) {\n        // looped\n        return lastPtId;\n      }\n      if (lineCell.length === 2) {\n        // continue along loop\n        lineId = lineCell[0] !== lineId ? lineCell[0] : lineCell[1];\n        visited.add(lineId);\n      } else {\n        // empty or invalid cell\n        terminated = true;\n      }\n    }\n    return lastPtId;\n  };\n  publicAPI.extractContours = (input, output) => {\n    const loops = [];\n    visited.clear();\n    const inLines = input.getLines();\n    output.getPoints().setData(Float32Array.from(input.getPoints().getData()));\n\n    // TODO skip if cached input mtime hasn't changed.\n    // iterate over input lines\n    for (let li = 0; li < inLines.getNumberOfCells(); li++) {\n      if (visited.has(li)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const {\n        cellPointIds\n      } = input.getCellPoints(li);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      visited.add(li);\n      const startPtId = cellPointIds[0];\n      const loopPoints = [];\n      loopPoints.push({\n        t: 0,\n        ptId: startPtId\n      });\n      const endPtId = publicAPI.traverseLoop(input, Dir.Forward, li, startPtId, loopPoints);\n      if (startPtId !== endPtId) {\n        // didn't find a loop. Go other direction to see where we end up\n        publicAPI.traverseLoop(input, Dir.Backward, li, startPtId, loopPoints);\n        loopPoints.sort((a, b) => a.t < b.t ? -1 : 1);\n        // make closed contour\n        if (loopPoints.length && loopPoints[0].ptId !== loopPoints[loopPoints.length - 1]?.ptId) {\n          loopPoints.push({\n            ...loopPoints[loopPoints.length - 1]\n          });\n        }\n      }\n      if (loopPoints.length) {\n        loops.push(loopPoints);\n      }\n    }\n\n    // clear output lines\n    const outLines = output.getLines();\n    outLines.resize(0);\n    loops.forEach(loop => {\n      outLines.insertNextCell(loop.map(pt => pt.ptId));\n    });\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 1, 1);\n  vtkContourLoopExtraction(publicAPI);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkContourLoopExtraction');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\nexport { index as default, extend, newInstance };\n"],"names":[],"sourceRoot":""}