"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_cornerstonejs_tools_dist_esm_enums_index_js-node_modules_cornerstonejs_t-d98942"],{

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var AnnotationStyleStates;
(function (AnnotationStyleStates) {
    AnnotationStyleStates["Default"] = "";
    AnnotationStyleStates["Highlighted"] = "Highlighted";
    AnnotationStyleStates["Selected"] = "Selected";
    AnnotationStyleStates["Locked"] = "Locked";
    AnnotationStyleStates["AutoGenerated"] = "AutoGenerated";
})(AnnotationStyleStates || (AnnotationStyleStates = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationStyleStates);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["Interaction"] = "Interaction";
    ChangeTypes["HandlesUpdated"] = "HandlesUpdated";
    ChangeTypes["StatsUpdated"] = "StatsUpdated";
    ChangeTypes["InitialSetup"] = "InitialSetup";
    ChangeTypes["Completed"] = "Completed";
    ChangeTypes["InterpolationUpdated"] = "InterpolationUpdated";
    ChangeTypes["History"] = "History";
    ChangeTypes["MetadataReferenceModified"] = "MetadataReferenceModified";
    ChangeTypes["LabelChange"] = "LabelChange";
})(ChangeTypes || (ChangeTypes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChangeTypes);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["TOOL_ACTIVATED"] = "CORNERSTONE_TOOLS_TOOL_ACTIVATED";
    Events["TOOLGROUP_VIEWPORT_ADDED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED";
    Events["TOOLGROUP_VIEWPORT_REMOVED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED";
    Events["TOOL_MODE_CHANGED"] = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED";
    Events["CROSSHAIR_TOOL_CENTER_CHANGED"] = "CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED";
    Events["ANNOTATION_ADDED"] = "CORNERSTONE_TOOLS_ANNOTATION_ADDED";
    Events["ANNOTATION_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED";
    Events["ANNOTATION_MODIFIED"] = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED";
    Events["ANNOTATION_REMOVED"] = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED";
    Events["ANNOTATION_SELECTION_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE";
    Events["ANNOTATION_LOCK_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE";
    Events["ANNOTATION_VISIBILITY_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE";
    Events["ANNOTATION_RENDERED"] = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED";
    Events["ANNOTATION_INTERPOLATION_PROCESS_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED";
    Events["INTERPOLATED_ANNOTATIONS_REMOVED"] = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED";
    Events["SEGMENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED";
    Events["SEGMENTATION_RENDERED"] = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED";
    Events["SEGMENTATION_REPRESENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED";
    Events["SEGMENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_ADDED";
    Events["SEGMENTATION_REPRESENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED";
    Events["SEGMENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED";
    Events["SEGMENTATION_REPRESENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED";
    Events["SEGMENTATION_DATA_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED";
    Events["HISTORY_UNDO"] = "CORNERSTONE_TOOLS_HISTORY_UNDO";
    Events["HISTORY_REDO"] = "CORNERSTONE_TOOLS_HISTORY_REDO";
    Events["KEY_DOWN"] = "CORNERSTONE_TOOLS_KEY_DOWN";
    Events["KEY_UP"] = "CORNERSTONE_TOOLS_KEY_UP";
    Events["MOUSE_DOWN"] = "CORNERSTONE_TOOLS_MOUSE_DOWN";
    Events["MOUSE_UP"] = "CORNERSTONE_TOOLS_MOUSE_UP";
    Events["MOUSE_DOWN_ACTIVATE"] = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE";
    Events["MOUSE_DRAG"] = "CORNERSTONE_TOOLS_MOUSE_DRAG";
    Events["MOUSE_MOVE"] = "CORNERSTONE_TOOLS_MOUSE_MOVE";
    Events["MOUSE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_CLICK";
    Events["MOUSE_DOUBLE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK";
    Events["MOUSE_WHEEL"] = "CORNERSTONE_TOOLS_MOUSE_WHEEL";
    Events["TOUCH_START"] = "CORNERSTONE_TOOLS_TOUCH_START";
    Events["TOUCH_START_ACTIVATE"] = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE";
    Events["TOUCH_PRESS"] = "CORNERSTONE_TOOLS_TOUCH_PRESS";
    Events["TOUCH_DRAG"] = "CORNERSTONE_TOOLS_TOUCH_DRAG";
    Events["TOUCH_END"] = "CORNERSTONE_TOOLS_TOUCH_END";
    Events["TOUCH_TAP"] = "CORNERSTONE_TOOLS_TAP";
    Events["TOUCH_SWIPE"] = "CORNERSTONE_TOOLS_SWIPE";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var SegmentationRepresentations;
(function (SegmentationRepresentations) {
    SegmentationRepresentations["Labelmap"] = "Labelmap";
    SegmentationRepresentations["Contour"] = "Contour";
    SegmentationRepresentations["Surface"] = "Surface";
})(SegmentationRepresentations || (SegmentationRepresentations = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentationRepresentations);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var StrategyCallbacks;
(function (StrategyCallbacks) {
    StrategyCallbacks["OnInteractionStart"] = "onInteractionStart";
    StrategyCallbacks["OnInteractionEnd"] = "onInteractionEnd";
    StrategyCallbacks["Preview"] = "preview";
    StrategyCallbacks["RejectPreview"] = "rejectPreview";
    StrategyCallbacks["AcceptPreview"] = "acceptPreview";
    StrategyCallbacks["Fill"] = "fill";
    StrategyCallbacks["Interpolate"] = "interpolate";
    StrategyCallbacks["StrategyFunction"] = "strategyFunction";
    StrategyCallbacks["CreateIsInThreshold"] = "createIsInThreshold";
    StrategyCallbacks["Initialize"] = "initialize";
    StrategyCallbacks["INTERNAL_setValue"] = "setValue";
    StrategyCallbacks["AddPreview"] = "addPreview";
    StrategyCallbacks["ComputeInnerCircleRadius"] = "computeInnerCircleRadius";
    StrategyCallbacks["GetStatistics"] = "getStatistics";
    StrategyCallbacks["EnsureImageVolumeFor3DManipulation"] = "ensureImageVolumeFor3DManipulation";
    StrategyCallbacks["EnsureSegmentationVolumeFor3DManipulation"] = "ensureSegmentationVolumeFor3DManipulation";
})(StrategyCallbacks || (StrategyCallbacks = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StrategyCallbacks);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyboardBindings: () => (/* binding */ KeyboardBindings),
/* harmony export */   MouseBindings: () => (/* binding */ MouseBindings)
/* harmony export */ });
var MouseBindings;
(function (MouseBindings) {
    MouseBindings[MouseBindings["Primary"] = 1] = "Primary";
    MouseBindings[MouseBindings["Secondary"] = 2] = "Secondary";
    MouseBindings[MouseBindings["Primary_And_Secondary"] = 3] = "Primary_And_Secondary";
    MouseBindings[MouseBindings["Auxiliary"] = 4] = "Auxiliary";
    MouseBindings[MouseBindings["Primary_And_Auxiliary"] = 5] = "Primary_And_Auxiliary";
    MouseBindings[MouseBindings["Secondary_And_Auxiliary"] = 6] = "Secondary_And_Auxiliary";
    MouseBindings[MouseBindings["Primary_And_Secondary_And_Auxiliary"] = 7] = "Primary_And_Secondary_And_Auxiliary";
    MouseBindings[MouseBindings["Fourth_Button"] = 8] = "Fourth_Button";
    MouseBindings[MouseBindings["Fifth_Button"] = 16] = "Fifth_Button";
    MouseBindings[MouseBindings["Wheel"] = 524288] = "Wheel";
    MouseBindings[MouseBindings["Wheel_Primary"] = 524289] = "Wheel_Primary";
})(MouseBindings || (MouseBindings = {}));
var KeyboardBindings;
(function (KeyboardBindings) {
    KeyboardBindings[KeyboardBindings["Shift"] = 16] = "Shift";
    KeyboardBindings[KeyboardBindings["Ctrl"] = 17] = "Ctrl";
    KeyboardBindings[KeyboardBindings["Alt"] = 18] = "Alt";
    KeyboardBindings[KeyboardBindings["Meta"] = 91] = "Meta";
    KeyboardBindings[KeyboardBindings["ShiftCtrl"] = 1617] = "ShiftCtrl";
    KeyboardBindings[KeyboardBindings["ShiftAlt"] = 1618] = "ShiftAlt";
    KeyboardBindings[KeyboardBindings["ShiftMeta"] = 1691] = "ShiftMeta";
    KeyboardBindings[KeyboardBindings["CtrlAlt"] = 1718] = "CtrlAlt";
    KeyboardBindings[KeyboardBindings["CtrlMeta"] = 1791] = "CtrlMeta";
    KeyboardBindings[KeyboardBindings["AltMeta"] = 1891] = "AltMeta";
})(KeyboardBindings || (KeyboardBindings = {}));



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ToolModes;
(function (ToolModes) {
    ToolModes["Active"] = "Active";
    ToolModes["Passive"] = "Passive";
    ToolModes["Enabled"] = "Enabled";
    ToolModes["Disabled"] = "Disabled";
})(ToolModes || (ToolModes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolModes);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Swipe: () => (/* binding */ Swipe)
/* harmony export */ });
var Swipe;
(function (Swipe) {
    Swipe["UP"] = "UP";
    Swipe["DOWN"] = "DOWN";
    Swipe["LEFT"] = "LEFT";
    Swipe["RIGHT"] = "RIGHT";
})(Swipe || (Swipe = {}));



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["POLYSEG_CONTOUR_TO_LABELMAP"] = "Converting Contour to Labelmap";
    ChangeTypes["POLYSEG_SURFACE_TO_LABELMAP"] = "Converting Surfaces to Labelmap";
    ChangeTypes["POLYSEG_CONTOUR_TO_SURFACE"] = "Converting Contour to Surface";
    ChangeTypes["POLYSEG_LABELMAP_TO_SURFACE"] = "Converting Labelmap to Surface";
    ChangeTypes["SURFACE_CLIPPING"] = "Clipping Surfaces";
    ChangeTypes["COMPUTE_STATISTICS"] = "Computing Statistics";
    ChangeTypes["INTERPOLATE_LABELMAP"] = "Interpolating Labelmap";
    ChangeTypes["COMPUTE_LARGEST_BIDIRECTIONAL"] = "Computing Largest Bidirectional";
    ChangeTypes["GENERATE_CONTOUR_SETS"] = "Generating Contour Sets";
})(ChangeTypes || (ChangeTypes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChangeTypes);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotationStyleStates: () => (/* reexport safe */ _AnnotationStyleStates__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   ChangeTypes: () => (/* reexport safe */ _ChangeTypes__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   Events: () => (/* reexport safe */ _Events__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   KeyboardBindings: () => (/* reexport safe */ _ToolBindings__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings),
/* harmony export */   MouseBindings: () => (/* reexport safe */ _ToolBindings__WEBPACK_IMPORTED_MODULE_0__.MouseBindings),
/* harmony export */   SegmentationRepresentations: () => (/* reexport safe */ _SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   StrategyCallbacks: () => (/* reexport safe */ _StrategyCallbacks__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   Swipe: () => (/* reexport safe */ _Touch__WEBPACK_IMPORTED_MODULE_5__.Swipe),
/* harmony export */   ToolModes: () => (/* reexport safe */ _ToolModes__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   WorkerTypes: () => (/* reexport safe */ _WorkerTypes__WEBPACK_IMPORTED_MODULE_8__["default"])
/* harmony export */ });
/* harmony import */ var _ToolBindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ToolBindings */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js");
/* harmony import */ var _ToolModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ToolModes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js");
/* harmony import */ var _AnnotationStyleStates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnnotationStyleStates */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js");
/* harmony import */ var _Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _Touch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Touch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js");
/* harmony import */ var _StrategyCallbacks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _ChangeTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ChangeTypes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js");
/* harmony import */ var _WorkerTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./WorkerTypes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js");












/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/workers/computeWorker.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/workers/computeWorker.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ "../../../node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_segmentation_SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/segmentation/SegmentStatsCalculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js");
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _kitware_vtk_js_Filters_General_ImageMarchingSquares__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @kitware/vtk.js/Filters/General/ImageMarchingSquares */ "../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/DataArray */ "../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js");
/* harmony import */ var _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @kitware/vtk.js/Common/DataModel/ImageData */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js");
/* harmony import */ var _utilities_contours_getDeduplicatedVTKPolyDataPoints__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/contours/getDeduplicatedVTKPolyDataPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js");
/* harmony import */ var _utilities_contours_contourFinder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities/contours/contourFinder */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js");
/* harmony import */ var _utilities_segmentation_findLargestBidirectional__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities/segmentation/findLargestBidirectional */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js");
/* harmony import */ var _utilities_segmentation_isLineInSegment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utilities/segmentation/isLineInSegment */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js");











const { VoxelManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const computeWorker = {
    createVoxelManager: (dimensions, scalarData) => {
        return VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData,
        });
    },
    createDataStructure: (info) => {
        const { scalarData, dimensions, spacing, origin, direction } = info;
        const voxelManager = computeWorker.createVoxelManager(dimensions, scalarData);
        return {
            voxelManager,
            dimensions,
            spacing,
            origin,
            direction,
            scalarData,
        };
    },
    createVTKImageData: (dimensions, origin, direction, spacing, scalarData) => {
        const imageData = _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance();
        imageData.setDimensions(dimensions);
        imageData.setOrigin(origin);
        imageData.setDirection(direction);
        imageData.setSpacing(spacing);
        if (!scalarData) {
            return imageData;
        }
        const scalarArray = _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance({
            name: 'Scalars',
            numberOfComponents: 1,
            values: scalarData,
        });
        imageData.getPointData().setScalars(scalarArray);
        return imageData;
    },
    processSegmentStatistics: ({ segVoxelManager, imageVoxelManager, indices, bounds, imageData, }) => {
        segVoxelManager.forEach(({ value, pointIJK, pointLPS, index }) => {
            if (indices.indexOf(value) === -1) {
                return;
            }
            const imageValue = imageVoxelManager.getAtIndex(index);
            _utilities_segmentation_SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_2__["default"].statsCallback({
                segmentIndex: value,
                value: imageValue,
                pointIJK,
                pointLPS,
            });
        }, {
            boundsIJK: bounds || imageVoxelManager.getDefaultBounds(),
            imageData,
        });
    },
    performMarchingSquares: (imageData, sliceIndex = null, slicingMode = null) => {
        const options = {};
        if (sliceIndex !== null) {
            options.slice = sliceIndex;
        }
        if (slicingMode !== null) {
            options.slicingMode = slicingMode;
        }
        const mSquares = _kitware_vtk_js_Filters_General_ImageMarchingSquares__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance(options);
        mSquares.setInputData(imageData);
        mSquares.setContourValues([1]);
        mSquares.setMergePoints(false);
        return mSquares.getOutputData();
    },
    createContoursFromPolyData: (msOutput, sliceIndex = null) => {
        const reducedSet = (0,_utilities_contours_getDeduplicatedVTKPolyDataPoints__WEBPACK_IMPORTED_MODULE_7__.getDeduplicatedVTKPolyDataPoints)(msOutput);
        if (reducedSet.points?.length) {
            const contours = (0,_utilities_contours_contourFinder__WEBPACK_IMPORTED_MODULE_8__.findContoursFromReducedSet)(reducedSet.lines);
            return {
                contours,
                polyData: reducedSet,
            };
        }
        return null;
    },
    createSegmentsFromIndices: (indices) => {
        return [null, ...indices.map((index) => ({ segmentIndex: index }))];
    },
    getArgsFromInfo: (args) => {
        const { segmentationInfo, imageInfo } = args;
        const getSegmentationData = () => {
            return computeWorker.createDataStructure(segmentationInfo);
        };
        const getImageData = () => {
            return computeWorker.createDataStructure(imageInfo);
        };
        return {
            segmentation: segmentationInfo && getSegmentationData(),
            image: imageInfo && getImageData(),
        };
    },
    calculateSegmentsStatisticsVolume: (args) => {
        const { mode, indices, unit } = args;
        const { segmentation, image } = computeWorker.getArgsFromInfo(args);
        const { voxelManager: segVoxelManager, spacing: segmentationSpacing } = segmentation;
        const { voxelManager: imageVoxelManager } = image;
        const imageData = computeWorker.createVTKImageData(segmentation.dimensions, segmentation.origin, segmentation.direction, segmentation.spacing);
        _utilities_segmentation_SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_2__["default"].statsInit({ storePointData: false, indices, mode });
        computeWorker.processSegmentStatistics({
            segVoxelManager,
            imageVoxelManager,
            indices,
            imageData,
        });
        const stats = _utilities_segmentation_SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_2__["default"].getStatistics({
            spacing: segmentationSpacing,
            mode,
            unit,
        });
        return stats;
    },
    computeMetabolicStats({ segmentationInfo, imageInfo }) {
        const { scalarData, dimensions, spacing, origin, direction } = segmentationInfo;
        const { spacing: imageSpacing, dimensions: imageDimensions, direction: imageDirection, origin: imageOrigin, scalarData: imageScalarData, } = imageInfo;
        const segVoxelManager = computeWorker.createVoxelManager(segmentationInfo.dimensions, segmentationInfo.scalarData);
        const refVoxelManager = computeWorker.createVoxelManager(imageDimensions, imageScalarData);
        let suv = 0;
        let numVoxels = 0;
        const scalarDataLength = segVoxelManager.getScalarDataLength();
        for (let i = 0; i < scalarDataLength; i++) {
            if (segVoxelManager.getAtIndex(i) !== 0) {
                suv += refVoxelManager.getAtIndex(i);
                numVoxels++;
            }
        }
        const tmtv = 1e-3 * numVoxels * spacing[0] * spacing[1] * spacing[2];
        const averageSuv = numVoxels > 0 ? suv / numVoxels : 0;
        const tlg = averageSuv *
            numVoxels *
            imageSpacing[0] *
            imageSpacing[1] *
            imageSpacing[2] *
            1e-3;
        return {
            tmtv,
            tlg,
        };
    },
    calculateSegmentsStatisticsStack: (args) => {
        const { segmentationInfo, imageInfo, indices, mode } = args;
        _utilities_segmentation_SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_2__["default"].statsInit({ storePointData: true, indices, mode });
        for (let i = 0; i < segmentationInfo.length; i++) {
            const segInfo = segmentationInfo[i];
            const imgInfo = imageInfo[i];
            const segDimensions = [
                segInfo.dimensions[0],
                segInfo.dimensions[1],
                1,
            ];
            const segVoxelManager = computeWorker.createVoxelManager(segDimensions, segInfo.scalarData);
            const imageVoxelManager = computeWorker.createVoxelManager(segDimensions, imgInfo.scalarData);
            const imageData = computeWorker.createVTKImageData(segDimensions, segInfo.origin, segInfo.direction, segInfo.spacing);
            computeWorker.processSegmentStatistics({
                segVoxelManager,
                imageVoxelManager,
                indices,
                imageData,
            });
        }
        const spacing = segmentationInfo[0].spacing;
        const stats = _utilities_segmentation_SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_2__["default"].getStatistics({
            spacing,
            mode,
        });
        return stats;
    },
    getSegmentLargestBidirectionalInternal: (args) => {
        const { segmentationInfo, imageInfo, indices, mode, isStack } = args;
        let segmentation;
        if (!isStack) {
            ({ segmentation } = computeWorker.getArgsFromInfo(args));
        }
        else {
            ({ segmentation } = computeWorker.getArgsFromInfo({
                segmentationInfo: segmentationInfo[0],
            }));
        }
        return isStack
            ? computeWorker.calculateBidirectionalStack({
                segmentationInfo,
                indices,
                mode,
            })
            : computeWorker.calculateVolumetricBidirectional({
                segmentation,
                indices,
                mode,
            });
    },
    findLargestBidirectionalFromContours: (contours, isInSegment, segmentIndex) => {
        let maxBidirectional;
        for (const sliceContour of contours) {
            const bidirectional = (0,_utilities_segmentation_findLargestBidirectional__WEBPACK_IMPORTED_MODULE_9__.createBidirectionalForSlice)(sliceContour, isInSegment, maxBidirectional);
            if (!bidirectional) {
                continue;
            }
            maxBidirectional = bidirectional;
        }
        if (maxBidirectional) {
            return {
                segmentIndex,
                majorAxis: maxBidirectional.majorAxis,
                minorAxis: maxBidirectional.minorAxis,
                maxMajor: maxBidirectional.maxMajor,
                maxMinor: maxBidirectional.maxMinor,
            };
        }
        return null;
    },
    calculateBidirectionalStack: ({ segmentationInfo, indices, mode }) => {
        const segments = computeWorker.createSegmentsFromIndices(indices);
        let bidirectionalResults = [];
        for (let i = 0; i < segmentationInfo.length; i++) {
            const segInfo = segmentationInfo[i];
            const dimensions = segInfo.dimensions;
            const segScalarData = segInfo.scalarData;
            const { spacing, direction, origin } = segInfo;
            const voxelManager = computeWorker.createVoxelManager(dimensions, segScalarData);
            const pixelsPerSlice = dimensions[0] * dimensions[1];
            for (let segIndex = 1; segIndex < segments.length; segIndex++) {
                const segment = segments[segIndex];
                if (!segment) {
                    continue;
                }
                const segmentIndex = segment.segmentIndex;
                if (computeWorker.isSliceEmptyForSegmentVolume(0, segScalarData, pixelsPerSlice, segmentIndex)) {
                    continue;
                }
                const sliceContours = [];
                const filteredData = new Uint8Array(segScalarData.length);
                for (let i = 0; i < segScalarData.length; i++) {
                    filteredData[i] = segScalarData[i] === segmentIndex ? 1 : 0;
                }
                const scalarArray = _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance({
                    name: 'Pixels',
                    numberOfComponents: 1,
                    values: filteredData,
                });
                const imageData = computeWorker.createVTKImageData(dimensions, origin, direction, [spacing[0], spacing[1], 1]);
                imageData.getPointData().setScalars(scalarArray);
                try {
                    const msOutput = computeWorker.performMarchingSquares(imageData, null, 2);
                    const contourData = computeWorker.createContoursFromPolyData(msOutput);
                    if (contourData) {
                        sliceContours.push(contourData);
                    }
                }
                catch (e) {
                    console.warn(e);
                }
                const isInSegment = (0,_utilities_segmentation_isLineInSegment__WEBPACK_IMPORTED_MODULE_10__.createIsInSegmentMetadata)({
                    dimensions,
                    imageData,
                    voxelManager,
                    segmentIndex,
                });
                const bidirectionalResult = computeWorker.findLargestBidirectionalFromContours(sliceContours, isInSegment, segmentIndex);
                if (bidirectionalResult) {
                    bidirectionalResults.push(bidirectionalResult);
                }
            }
        }
        return bidirectionalResults;
    },
    calculateVolumetricBidirectional: ({ segmentation, indices, mode }) => {
        const { voxelManager, dimensions, origin, direction, spacing } = segmentation;
        const imageData = computeWorker.createVTKImageData(dimensions, origin, direction, spacing);
        const contourSets = computeWorker.generateContourSetsFromLabelmapVolume({
            segmentation,
            indices,
            imageData,
            mode,
        });
        const bidirectionalResults = [];
        for (let i = 0; i < contourSets.length; i++) {
            const contourSet = contourSets[i];
            const { segmentIndex } = contourSet.segment;
            const contours = contourSet.sliceContours;
            const isInSegment = (0,_utilities_segmentation_isLineInSegment__WEBPACK_IMPORTED_MODULE_10__.createIsInSegmentMetadata)({
                dimensions,
                imageData,
                voxelManager,
                segmentIndex,
            });
            const bidirectionalResult = computeWorker.findLargestBidirectionalFromContours(contours, isInSegment, segmentIndex);
            if (bidirectionalResult) {
                bidirectionalResults.push(bidirectionalResult);
            }
        }
        return bidirectionalResults;
    },
    generateContourSetsFromLabelmapVolume: (args) => {
        const { segmentation, indices } = args;
        const { dimensions, scalarData, origin, direction, spacing } = segmentation;
        let imageData = args.imageData;
        if (!imageData) {
            imageData = computeWorker.createVTKImageData(dimensions, origin, direction, spacing);
        }
        const numSlices = dimensions[2];
        const pixelsPerSlice = dimensions[0] * dimensions[1];
        const segments = computeWorker.createSegmentsFromIndices(indices);
        for (let z = 0; z < numSlices; z++) {
            for (let y = 0; y < dimensions[1]; y++) {
                const index = y * dimensions[0] + z * pixelsPerSlice;
                scalarData[index] = 0;
                scalarData[index + dimensions[0] - 1] = 0;
            }
        }
        const ContourSets = [];
        const numSegments = segments.length;
        for (let segIndex = 0; segIndex < numSegments; segIndex++) {
            const segment = segments[segIndex];
            if (!segment) {
                continue;
            }
            const segmentIndex = segment.segmentIndex;
            const sliceContours = [];
            const scalars = _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance({
                name: 'Scalars',
                numberOfComponents: 1,
                size: pixelsPerSlice * numSlices,
                dataType: 'Uint8Array',
            });
            for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {
                if (computeWorker.isSliceEmptyForSegmentVolume(sliceIndex, scalarData, pixelsPerSlice, segmentIndex)) {
                    continue;
                }
                const frameStart = sliceIndex * pixelsPerSlice;
                try {
                    for (let i = 0; i < pixelsPerSlice; i++) {
                        const value = scalarData[i + frameStart];
                        if (value === segmentIndex) {
                            scalars.setValue(i + frameStart, 1);
                        }
                        else {
                            scalars.setValue(i, 0);
                        }
                    }
                    const imageDataCopy = _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance();
                    imageDataCopy.shallowCopy(imageData);
                    imageDataCopy.getPointData().setScalars(scalars);
                    const msOutput = computeWorker.performMarchingSquares(imageDataCopy, sliceIndex);
                    const contourData = computeWorker.createContoursFromPolyData(msOutput, sliceIndex);
                    if (contourData) {
                        sliceContours.push(contourData);
                    }
                }
                catch (e) {
                    console.warn(sliceIndex);
                    console.warn(e);
                }
            }
            const ContourSet = {
                sliceContours,
                segment,
            };
            ContourSets.push(ContourSet);
        }
        return ContourSets;
    },
    isSliceEmptyForSegmentVolume: (sliceIndex, segData, pixelsPerSlice, segIndex) => {
        const startIdx = sliceIndex * pixelsPerSlice;
        const endIdx = startIdx + pixelsPerSlice;
        for (let i = startIdx; i < endIdx; i++) {
            if (segData[i] === segIndex) {
                return false;
            }
        }
        return true;
    },
};
(0,comlink__WEBPACK_IMPORTED_MODULE_0__.expose)(computeWorker);


/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkEdgeLocator)
/* harmony export */ });
class EdgeLocator {
  constructor() {
    let oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.oriented = oriented;
    this.edgeMap = new Map();
  }
  initialize() {
    this.edgeMap.clear();
  }
  computeEdgeKey(pointId0, pointId1) {
    return this.oriented || pointId0 < pointId1 ?
    // Cantor pairing function:
    0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;
  }
  insertUniqueEdge(pointId0, pointId1, newEdgeValue) {
    // Generate a unique key
    const key = this.computeEdgeKey(pointId0, pointId1);
    let node = this.edgeMap.get(key);
    if (!node) {
      // Didn't find key, so add a new edge entry
      node = {
        key,
        edgeId: this.edgeMap.size,
        value: newEdgeValue
      };
      this.edgeMap.set(key, node);
    }
    return node;
  }
  insertEdge(pointId0, pointId1, newEdgeValue) {
    // Generate a unique key
    const key = this.computeEdgeKey(pointId0, pointId1);
    const node = {
      key,
      edgeId: this.edgeMap.size,
      value: newEdgeValue
    };
    this.edgeMap.set(key, node);
    return node;
  }
  isInsertedEdge(pointId0, pointId1) {
    const key = this.computeEdgeKey(pointId0, pointId1);
    return this.edgeMap.get(key);
  }
  static getEdgePointIds(node) {
    const n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));
    const pointId0 = node.key - 0.5 * (n + 1) * n;
    const pointId1 = n - pointId0;
    return [pointId0, pointId1];
  }
}
function newInstance() {
  let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new EdgeLocator(initialValues.oriented);
}
var vtkEdgeLocator = {
  newInstance
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkImageMarchingSquares$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Common/DataModel/PolyData.js */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js");
/* harmony import */ var _Common_DataModel_EdgeLocator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Common/DataModel/EdgeLocator.js */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js");
/* harmony import */ var _ImageMarchingSquares_caseTable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ImageMarchingSquares/caseTable.js */ "../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js");





const {
  vtkErrorMacro,
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// vtkImageMarchingSquares methods
// ----------------------------------------------------------------------------

function vtkImageMarchingSquares(publicAPI, model) {
  /**
   * Get the X,Y kernels based on the set slicing mode.
   * @returns {[number, number]}
   */
  function getKernels() {
    let kernelX = 0; // default K slicing mode
    let kernelY = 1;
    if (model.slicingMode === 1) {
      kernelX = 0;
      kernelY = 2;
    } else if (model.slicingMode === 0) {
      kernelX = 1;
      kernelY = 2;
    }
    return [kernelX, kernelY];
  }

  // Set our className
  model.classHierarchy.push('vtkImageMarchingSquares');

  /**
   * Get the list of contour values.
   * @returns {number[]}
   */
  publicAPI.getContourValues = () => model.contourValues;

  /**
   * Set the list contour values.
   * @param {number[]} cValues
   */
  publicAPI.setContourValues = cValues => {
    model.contourValues = cValues;
    publicAPI.modified();
  };
  const ids = [];
  const pixelScalars = [];
  const pixelPts = [];
  const edgeLocator = _Common_DataModel_EdgeLocator_js__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();

  /**
   * Retrieve scalars and pixel coordinates.
   * @param {Vector3} ijk origin of the pixel
   * @param {Vector3} dims dimensions of the image
   * @param {TypedArray} scalars list of scalar values
   * @param {Vector3} increments IJK slice increments
   * @param {number} kernelX index of the X element
   * @param {number} kernelY index of the Y element
   */
  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {
    const [i, j, k] = ijk;

    // First get the indices for the pixel
    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k
    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k
    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k
    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k

    // Now retrieve the scalars
    for (let ii = 0; ii < 4; ++ii) {
      pixelScalars[ii] = scalars[ids[ii]];
    }
  };

  /**
   * Retrieve pixel coordinates.
   * @param {Vector3} ijk origin of the pixel
   * @param {Vector3} origin origin of the image
   * @param {Vector3} spacing spacing of the image
   * @param {number} kernelX index of the X element
   * @param {number} kernelY index of the Y element
   */
  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {
    const i = ijk[kernelX];
    const j = ijk[kernelY];

    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k
    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0
    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];
    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1
    pixelPts[3] = pixelPts[1];
    pixelPts[4] = pixelPts[0]; // 2
    pixelPts[5] = pixelPts[1] + spacing[kernelY];
    pixelPts[6] = pixelPts[2]; // 3
    pixelPts[7] = pixelPts[5];
  };

  /**
   * Produce points and lines for the polydata.
   * @param {number[]} cVal list of contour values
   * @param {Vector3} ijk origin of the pixel
   * @param {Vector3} dims dimensions of the image
   * @param {Vector3} origin origin of the image
   * @param {Vector3} spacing sapcing of the image
   * @param {TypedArray} scalars list of scalar values
   * @param {number[]} points list of points
   * @param {number[]} lines list of lines
   * @param {Vector3} increments IJK slice increments
   * @param {number} kernelX index of the X element
   * @param {number} kernelY index of the Y element
   */
  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {
    const k = ijk[model.slicingMode];
    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad
    const xyz = [];
    let pId;
    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);
    let index = 0;
    for (let idx = 0; idx < 4; idx++) {
      if (pixelScalars[idx] >= cVal) {
        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise
      }
    }

    const pixelLines = _ImageMarchingSquares_caseTable_js__WEBPACK_IMPORTED_MODULE_3__["default"].getCase(index);
    if (pixelLines[0] < 0) {
      return; // don't get the pixel coordinates, nothing to do
    }

    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);
    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];
    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {
      lines.push(2);
      for (let eid = 0; eid < 2; eid++) {
        const edgeVerts = _ImageMarchingSquares_caseTable_js__WEBPACK_IMPORTED_MODULE_3__["default"].getEdge(pixelLines[idx + eid]);
        pId = undefined;
        if (model.mergePoints) {
          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;
        }
        if (pId === undefined) {
          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);
          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);
          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);
          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);
          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);
          xyz[model.slicingMode] = z;
          pId = points.length / 3;
          points.push(xyz[0], xyz[1], xyz[2]);
          if (model.mergePoints) {
            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);
          }
        }
        lines.push(pId);
      }
    }
  };
  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const input = inData[0];
    if (!input) {
      vtkErrorMacro('Invalid or missing input');
      return;
    }
    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {
      vtkErrorMacro('Invalid or missing slicing mode');
      return;
    }
    console.time('msquares');

    // Retrieve output and volume data
    const origin = input.getOrigin();
    const spacing = input.getSpacing();
    const dims = input.getDimensions();
    const extent = input.getExtent();
    const increments = input.computeIncrements(extent);
    const scalars = input.getPointData().getScalars().getData();
    const [kernelX, kernelY] = getKernels();

    // Points - dynamic array
    const points = [];

    // Cells - dynamic array
    const lines = [];

    // Ensure slice is valid
    let k = Math.round(model.slice);
    if (k >= dims[model.slicingMode]) {
      k = 0;
    }

    // Loop over all contour values, and then pixels, determine case and process
    const ijk = [0, 0, 0];
    ijk[model.slicingMode] = k;
    for (let cv = 0; cv < model.contourValues.length; ++cv) {
      for (let j = 0; j < dims[kernelY] - 1; ++j) {
        ijk[kernelY] = j;
        for (let i = 0; i < dims[kernelX] - 1; ++i) {
          ijk[kernelX] = i;
          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);
        }
      }
      edgeLocator.initialize();
    }

    // Update output
    const polydata = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
    polydata.getPoints().setData(new Float32Array(points), 3);
    polydata.getLines().setData(new Uint32Array(lines));
    outData[0] = polydata;
    vtkDebugMacro('Produced output');
    console.timeEnd('msquares');
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  contourValues: [],
  slicingMode: 2,
  slice: 0,
  mergePoints: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Make this a VTK object
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Also make it an algorithm with one input and one output
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 1, 1);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);

  // Object specific methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 1, 1);
  vtkImageMarchingSquares(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkImageMarchingSquares');

// ----------------------------------------------------------------------------

var vtkImageMarchingSquares$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkCaseTable)
/* harmony export */ });
// ----------------------------------------------------------------------------
// Marching squares case functions (using lines to generate the 2D tessellation).
// For each case, a list of edge ids that form the triangles. A -1 marks the
// end of the list of edges. Edges are taken three at a time to generate
// triangle points.
// ----------------------------------------------------------------------------
const MARCHING_SQUARES_CASES = [[-1, -1, -1, -1, -1] /* 0 */, [0, 3, -1, -1, -1] /* 1 */, [1, 0, -1, -1, -1] /* 2 */, [1, 3, -1, -1, -1] /* 3 */, [2, 1, -1, -1, -1] /* 4 */, [0, 3, 2, 1, -1] /* 5 */, [2, 0, -1, -1, -1] /* 6 */, [2, 3, -1, -1, -1] /* 7 */, [3, 2, -1, -1, -1] /* 8 */, [0, 2, -1, -1, -1] /* 9 */, [1, 0, 3, 2, -1] /* 10 */, [1, 2, -1, -1, -1] /* 11 */, [3, 1, -1, -1, -1] /* 12 */, [0, 1, -1, -1, -1] /* 13 */, [3, 0, -1, -1, -1] /* 14 */, [-1, -1, -1, -1, -1] /* 15 */];

const EDGES = [[0, 1], [1, 3], [2, 3], [0, 2]];
function getCase(index) {
  return MARCHING_SQUARES_CASES[index];
}

// Define the four edges of the pixel by the following pairs of vertices
function getEdge(eid) {
  return EDGES[eid];
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------
var vtkCaseTable = {
  getCase,
  getEdge
};




/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_cornerstonejs_tools_dist_esm_enums_index_js-node_modules_cornerstonejs_t-d98942.js.map