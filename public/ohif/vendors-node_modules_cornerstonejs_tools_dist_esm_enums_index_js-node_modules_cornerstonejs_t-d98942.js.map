{"version":3,"file":"vendors-node_modules_cornerstonejs_tools_dist_esm_enums_index_js-node_modules_cornerstonejs_t-d98942.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CAnnotationStyleStates.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CChangeTypes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CEvents.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CSegmentationRepresentations.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CStrategyCallbacks.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CToolBindings.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CToolModes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CTouch.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5CWorkerTypes.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cenums%5Cindex.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@cornerstonejs%5Ctools%5Cdist%5Cesm%5Cworkers%5CcomputeWorker.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@kitware%5Cvtk.js%5CCommon%5CDataModel%5CEdgeLocator.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@kitware%5Cvtk.js%5CFilters%5CGeneral%5CImageMarchingSquares.js","file:///D:%5CUsers%5Ccjohnson%5CGitRepositories%5COHIF-Viewer-Dev%5Cohif%5Cnode_modules%5C@kitware%5Cvtk.js%5CFilters%5CGeneral%5CImageMarchingSquares%5CcaseTable.js"],"sourcesContent":["var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"CROSSHAIR_TOOL_CENTER_CHANGED\"] = \"CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"HISTORY_UNDO\"] = \"CORNERSTONE_TOOLS_HISTORY_UNDO\";\n    Events[\"HISTORY_REDO\"] = \"CORNERSTONE_TOOLS_HISTORY_REDO\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"Labelmap\";\n    SegmentationRepresentations[\"Contour\"] = \"Contour\";\n    SegmentationRepresentations[\"Surface\"] = \"Surface\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n","var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"Interpolate\"] = \"interpolate\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"AddPreview\"] = \"addPreview\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n    StrategyCallbacks[\"GetStatistics\"] = \"getStatistics\";\n    StrategyCallbacks[\"EnsureImageVolumeFor3DManipulation\"] = \"ensureImageVolumeFor3DManipulation\";\n    StrategyCallbacks[\"EnsureSegmentationVolumeFor3DManipulation\"] = \"ensureSegmentationVolumeFor3DManipulation\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n","var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n    MouseBindings[MouseBindings[\"Wheel\"] = 524288] = \"Wheel\";\n    MouseBindings[MouseBindings[\"Wheel_Primary\"] = 524289] = \"Wheel_Primary\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n    ChangeTypes[\"COMPUTE_STATISTICS\"] = \"Computing Statistics\";\n    ChangeTypes[\"INTERPOLATE_LABELMAP\"] = \"Interpolating Labelmap\";\n    ChangeTypes[\"COMPUTE_LARGEST_BIDIRECTIONAL\"] = \"Computing Largest Bidirectional\";\n    ChangeTypes[\"GENERATE_CONTOUR_SETS\"] = \"Generating Contour Sets\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","import { MouseBindings, KeyboardBindings } from './ToolBindings';\nimport ToolModes from './ToolModes';\nimport AnnotationStyleStates from './AnnotationStyleStates';\nimport Events from './Events';\nimport SegmentationRepresentations from './SegmentationRepresentations';\nimport { Swipe } from './Touch';\nimport StrategyCallbacks from './StrategyCallbacks';\nimport ChangeTypes from './ChangeTypes';\nimport WorkerTypes from './WorkerTypes';\nexport { MouseBindings, KeyboardBindings, ToolModes, AnnotationStyleStates, Events, SegmentationRepresentations, Swipe, StrategyCallbacks, ChangeTypes, WorkerTypes, };\n","import { expose } from 'comlink';\nimport { utilities } from '@cornerstonejs/core';\nimport SegmentStatsCalculator from '../utilities/segmentation/SegmentStatsCalculator';\nimport { getSegmentLargestBidirectional } from '../utilities/segmentation';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { getDeduplicatedVTKPolyDataPoints } from '../utilities/contours/getDeduplicatedVTKPolyDataPoints';\nimport { findContoursFromReducedSet } from '../utilities/contours/contourFinder';\nimport { createBidirectionalForSlice } from '../utilities/segmentation/findLargestBidirectional';\nimport { createIsInSegmentMetadata } from '../utilities/segmentation/isLineInSegment';\nconst { VoxelManager } = utilities;\nconst computeWorker = {\n    createVoxelManager: (dimensions, scalarData) => {\n        return VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n    },\n    createDataStructure: (info) => {\n        const { scalarData, dimensions, spacing, origin, direction } = info;\n        const voxelManager = computeWorker.createVoxelManager(dimensions, scalarData);\n        return {\n            voxelManager,\n            dimensions,\n            spacing,\n            origin,\n            direction,\n            scalarData,\n        };\n    },\n    createVTKImageData: (dimensions, origin, direction, spacing, scalarData) => {\n        const imageData = vtkImageData.newInstance();\n        imageData.setDimensions(dimensions);\n        imageData.setOrigin(origin);\n        imageData.setDirection(direction);\n        imageData.setSpacing(spacing);\n        if (!scalarData) {\n            return imageData;\n        }\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Scalars',\n            numberOfComponents: 1,\n            values: scalarData,\n        });\n        imageData.getPointData().setScalars(scalarArray);\n        return imageData;\n    },\n    processSegmentStatistics: ({ segVoxelManager, imageVoxelManager, indices, bounds, imageData, }) => {\n        segVoxelManager.forEach(({ value, pointIJK, pointLPS, index }) => {\n            if (indices.indexOf(value) === -1) {\n                return;\n            }\n            const imageValue = imageVoxelManager.getAtIndex(index);\n            SegmentStatsCalculator.statsCallback({\n                segmentIndex: value,\n                value: imageValue,\n                pointIJK,\n                pointLPS,\n            });\n        }, {\n            boundsIJK: bounds || imageVoxelManager.getDefaultBounds(),\n            imageData,\n        });\n    },\n    performMarchingSquares: (imageData, sliceIndex = null, slicingMode = null) => {\n        const options = {};\n        if (sliceIndex !== null) {\n            options.slice = sliceIndex;\n        }\n        if (slicingMode !== null) {\n            options.slicingMode = slicingMode;\n        }\n        const mSquares = vtkImageMarchingSquares.newInstance(options);\n        mSquares.setInputData(imageData);\n        mSquares.setContourValues([1]);\n        mSquares.setMergePoints(false);\n        return mSquares.getOutputData();\n    },\n    createContoursFromPolyData: (msOutput, sliceIndex = null) => {\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n            const contours = findContoursFromReducedSet(reducedSet.lines);\n            return {\n                contours,\n                polyData: reducedSet,\n            };\n        }\n        return null;\n    },\n    createSegmentsFromIndices: (indices) => {\n        return [null, ...indices.map((index) => ({ segmentIndex: index }))];\n    },\n    getArgsFromInfo: (args) => {\n        const { segmentationInfo, imageInfo } = args;\n        const getSegmentationData = () => {\n            return computeWorker.createDataStructure(segmentationInfo);\n        };\n        const getImageData = () => {\n            return computeWorker.createDataStructure(imageInfo);\n        };\n        return {\n            segmentation: segmentationInfo && getSegmentationData(),\n            image: imageInfo && getImageData(),\n        };\n    },\n    calculateSegmentsStatisticsVolume: (args) => {\n        const { mode, indices, unit } = args;\n        const { segmentation, image } = computeWorker.getArgsFromInfo(args);\n        const { voxelManager: segVoxelManager, spacing: segmentationSpacing } = segmentation;\n        const { voxelManager: imageVoxelManager } = image;\n        const imageData = computeWorker.createVTKImageData(segmentation.dimensions, segmentation.origin, segmentation.direction, segmentation.spacing);\n        SegmentStatsCalculator.statsInit({ storePointData: false, indices, mode });\n        computeWorker.processSegmentStatistics({\n            segVoxelManager,\n            imageVoxelManager,\n            indices,\n            imageData,\n        });\n        const stats = SegmentStatsCalculator.getStatistics({\n            spacing: segmentationSpacing,\n            mode,\n            unit,\n        });\n        return stats;\n    },\n    computeMetabolicStats({ segmentationInfo, imageInfo }) {\n        const { scalarData, dimensions, spacing, origin, direction } = segmentationInfo;\n        const { spacing: imageSpacing, dimensions: imageDimensions, direction: imageDirection, origin: imageOrigin, scalarData: imageScalarData, } = imageInfo;\n        const segVoxelManager = computeWorker.createVoxelManager(segmentationInfo.dimensions, segmentationInfo.scalarData);\n        const refVoxelManager = computeWorker.createVoxelManager(imageDimensions, imageScalarData);\n        let suv = 0;\n        let numVoxels = 0;\n        const scalarDataLength = segVoxelManager.getScalarDataLength();\n        for (let i = 0; i < scalarDataLength; i++) {\n            if (segVoxelManager.getAtIndex(i) !== 0) {\n                suv += refVoxelManager.getAtIndex(i);\n                numVoxels++;\n            }\n        }\n        const tmtv = 1e-3 * numVoxels * spacing[0] * spacing[1] * spacing[2];\n        const averageSuv = numVoxels > 0 ? suv / numVoxels : 0;\n        const tlg = averageSuv *\n            numVoxels *\n            imageSpacing[0] *\n            imageSpacing[1] *\n            imageSpacing[2] *\n            1e-3;\n        return {\n            tmtv,\n            tlg,\n        };\n    },\n    calculateSegmentsStatisticsStack: (args) => {\n        const { segmentationInfo, imageInfo, indices, mode } = args;\n        SegmentStatsCalculator.statsInit({ storePointData: true, indices, mode });\n        for (let i = 0; i < segmentationInfo.length; i++) {\n            const segInfo = segmentationInfo[i];\n            const imgInfo = imageInfo[i];\n            const segDimensions = [\n                segInfo.dimensions[0],\n                segInfo.dimensions[1],\n                1,\n            ];\n            const segVoxelManager = computeWorker.createVoxelManager(segDimensions, segInfo.scalarData);\n            const imageVoxelManager = computeWorker.createVoxelManager(segDimensions, imgInfo.scalarData);\n            const imageData = computeWorker.createVTKImageData(segDimensions, segInfo.origin, segInfo.direction, segInfo.spacing);\n            computeWorker.processSegmentStatistics({\n                segVoxelManager,\n                imageVoxelManager,\n                indices,\n                imageData,\n            });\n        }\n        const spacing = segmentationInfo[0].spacing;\n        const stats = SegmentStatsCalculator.getStatistics({\n            spacing,\n            mode,\n        });\n        return stats;\n    },\n    getSegmentLargestBidirectionalInternal: (args) => {\n        const { segmentationInfo, imageInfo, indices, mode, isStack } = args;\n        let segmentation;\n        if (!isStack) {\n            ({ segmentation } = computeWorker.getArgsFromInfo(args));\n        }\n        else {\n            ({ segmentation } = computeWorker.getArgsFromInfo({\n                segmentationInfo: segmentationInfo[0],\n            }));\n        }\n        return isStack\n            ? computeWorker.calculateBidirectionalStack({\n                segmentationInfo,\n                indices,\n                mode,\n            })\n            : computeWorker.calculateVolumetricBidirectional({\n                segmentation,\n                indices,\n                mode,\n            });\n    },\n    findLargestBidirectionalFromContours: (contours, isInSegment, segmentIndex) => {\n        let maxBidirectional;\n        for (const sliceContour of contours) {\n            const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);\n            if (!bidirectional) {\n                continue;\n            }\n            maxBidirectional = bidirectional;\n        }\n        if (maxBidirectional) {\n            return {\n                segmentIndex,\n                majorAxis: maxBidirectional.majorAxis,\n                minorAxis: maxBidirectional.minorAxis,\n                maxMajor: maxBidirectional.maxMajor,\n                maxMinor: maxBidirectional.maxMinor,\n            };\n        }\n        return null;\n    },\n    calculateBidirectionalStack: ({ segmentationInfo, indices, mode }) => {\n        const segments = computeWorker.createSegmentsFromIndices(indices);\n        let bidirectionalResults = [];\n        for (let i = 0; i < segmentationInfo.length; i++) {\n            const segInfo = segmentationInfo[i];\n            const dimensions = segInfo.dimensions;\n            const segScalarData = segInfo.scalarData;\n            const { spacing, direction, origin } = segInfo;\n            const voxelManager = computeWorker.createVoxelManager(dimensions, segScalarData);\n            const pixelsPerSlice = dimensions[0] * dimensions[1];\n            for (let segIndex = 1; segIndex < segments.length; segIndex++) {\n                const segment = segments[segIndex];\n                if (!segment) {\n                    continue;\n                }\n                const segmentIndex = segment.segmentIndex;\n                if (computeWorker.isSliceEmptyForSegmentVolume(0, segScalarData, pixelsPerSlice, segmentIndex)) {\n                    continue;\n                }\n                const sliceContours = [];\n                const filteredData = new Uint8Array(segScalarData.length);\n                for (let i = 0; i < segScalarData.length; i++) {\n                    filteredData[i] = segScalarData[i] === segmentIndex ? 1 : 0;\n                }\n                const scalarArray = vtkDataArray.newInstance({\n                    name: 'Pixels',\n                    numberOfComponents: 1,\n                    values: filteredData,\n                });\n                const imageData = computeWorker.createVTKImageData(dimensions, origin, direction, [spacing[0], spacing[1], 1]);\n                imageData.getPointData().setScalars(scalarArray);\n                try {\n                    const msOutput = computeWorker.performMarchingSquares(imageData, null, 2);\n                    const contourData = computeWorker.createContoursFromPolyData(msOutput);\n                    if (contourData) {\n                        sliceContours.push(contourData);\n                    }\n                }\n                catch (e) {\n                    console.warn(e);\n                }\n                const isInSegment = createIsInSegmentMetadata({\n                    dimensions,\n                    imageData,\n                    voxelManager,\n                    segmentIndex,\n                });\n                const bidirectionalResult = computeWorker.findLargestBidirectionalFromContours(sliceContours, isInSegment, segmentIndex);\n                if (bidirectionalResult) {\n                    bidirectionalResults.push(bidirectionalResult);\n                }\n            }\n        }\n        return bidirectionalResults;\n    },\n    calculateVolumetricBidirectional: ({ segmentation, indices, mode }) => {\n        const { voxelManager, dimensions, origin, direction, spacing } = segmentation;\n        const imageData = computeWorker.createVTKImageData(dimensions, origin, direction, spacing);\n        const contourSets = computeWorker.generateContourSetsFromLabelmapVolume({\n            segmentation,\n            indices,\n            imageData,\n            mode,\n        });\n        const bidirectionalResults = [];\n        for (let i = 0; i < contourSets.length; i++) {\n            const contourSet = contourSets[i];\n            const { segmentIndex } = contourSet.segment;\n            const contours = contourSet.sliceContours;\n            const isInSegment = createIsInSegmentMetadata({\n                dimensions,\n                imageData,\n                voxelManager,\n                segmentIndex,\n            });\n            const bidirectionalResult = computeWorker.findLargestBidirectionalFromContours(contours, isInSegment, segmentIndex);\n            if (bidirectionalResult) {\n                bidirectionalResults.push(bidirectionalResult);\n            }\n        }\n        return bidirectionalResults;\n    },\n    generateContourSetsFromLabelmapVolume: (args) => {\n        const { segmentation, indices } = args;\n        const { dimensions, scalarData, origin, direction, spacing } = segmentation;\n        let imageData = args.imageData;\n        if (!imageData) {\n            imageData = computeWorker.createVTKImageData(dimensions, origin, direction, spacing);\n        }\n        const numSlices = dimensions[2];\n        const pixelsPerSlice = dimensions[0] * dimensions[1];\n        const segments = computeWorker.createSegmentsFromIndices(indices);\n        for (let z = 0; z < numSlices; z++) {\n            for (let y = 0; y < dimensions[1]; y++) {\n                const index = y * dimensions[0] + z * pixelsPerSlice;\n                scalarData[index] = 0;\n                scalarData[index + dimensions[0] - 1] = 0;\n            }\n        }\n        const ContourSets = [];\n        const numSegments = segments.length;\n        for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n            const segment = segments[segIndex];\n            if (!segment) {\n                continue;\n            }\n            const segmentIndex = segment.segmentIndex;\n            const sliceContours = [];\n            const scalars = vtkDataArray.newInstance({\n                name: 'Scalars',\n                numberOfComponents: 1,\n                size: pixelsPerSlice * numSlices,\n                dataType: 'Uint8Array',\n            });\n            for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n                if (computeWorker.isSliceEmptyForSegmentVolume(sliceIndex, scalarData, pixelsPerSlice, segmentIndex)) {\n                    continue;\n                }\n                const frameStart = sliceIndex * pixelsPerSlice;\n                try {\n                    for (let i = 0; i < pixelsPerSlice; i++) {\n                        const value = scalarData[i + frameStart];\n                        if (value === segmentIndex) {\n                            scalars.setValue(i + frameStart, 1);\n                        }\n                        else {\n                            scalars.setValue(i, 0);\n                        }\n                    }\n                    const imageDataCopy = vtkImageData.newInstance();\n                    imageDataCopy.shallowCopy(imageData);\n                    imageDataCopy.getPointData().setScalars(scalars);\n                    const msOutput = computeWorker.performMarchingSquares(imageDataCopy, sliceIndex);\n                    const contourData = computeWorker.createContoursFromPolyData(msOutput, sliceIndex);\n                    if (contourData) {\n                        sliceContours.push(contourData);\n                    }\n                }\n                catch (e) {\n                    console.warn(sliceIndex);\n                    console.warn(e);\n                }\n            }\n            const ContourSet = {\n                sliceContours,\n                segment,\n            };\n            ContourSets.push(ContourSet);\n        }\n        return ContourSets;\n    },\n    isSliceEmptyForSegmentVolume: (sliceIndex, segData, pixelsPerSlice, segIndex) => {\n        const startIdx = sliceIndex * pixelsPerSlice;\n        const endIdx = startIdx + pixelsPerSlice;\n        for (let i = startIdx; i < endIdx; i++) {\n            if (segData[i] === segIndex) {\n                return false;\n            }\n        }\n        return true;\n    },\n};\nexpose(computeWorker);\n","class EdgeLocator {\n  constructor() {\n    let oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.oriented = oriented;\n    this.edgeMap = new Map();\n  }\n  initialize() {\n    this.edgeMap.clear();\n  }\n  computeEdgeKey(pointId0, pointId1) {\n    return this.oriented || pointId0 < pointId1 ?\n    // Cantor pairing function:\n    0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;\n  }\n  insertUniqueEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    let node = this.edgeMap.get(key);\n    if (!node) {\n      // Didn't find key, so add a new edge entry\n      node = {\n        key,\n        edgeId: this.edgeMap.size,\n        value: newEdgeValue\n      };\n      this.edgeMap.set(key, node);\n    }\n    return node;\n  }\n  insertEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    const node = {\n      key,\n      edgeId: this.edgeMap.size,\n      value: newEdgeValue\n    };\n    this.edgeMap.set(key, node);\n    return node;\n  }\n  isInsertedEdge(pointId0, pointId1) {\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    return this.edgeMap.get(key);\n  }\n  static getEdgePointIds(node) {\n    const n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));\n    const pointId0 = node.key - 0.5 * (n + 1) * n;\n    const pointId1 = n - pointId0;\n    return [pointId0, pointId1];\n  }\n}\nfunction newInstance() {\n  let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new EdgeLocator(initialValues.oriented);\n}\nvar vtkEdgeLocator = {\n  newInstance\n};\n\nexport { vtkEdgeLocator as default };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n","// ----------------------------------------------------------------------------\n// Marching squares case functions (using lines to generate the 2D tessellation).\n// For each case, a list of edge ids that form the triangles. A -1 marks the\n// end of the list of edges. Edges are taken three at a time to generate\n// triangle points.\n// ----------------------------------------------------------------------------\nconst MARCHING_SQUARES_CASES = [[-1, -1, -1, -1, -1] /* 0 */, [0, 3, -1, -1, -1] /* 1 */, [1, 0, -1, -1, -1] /* 2 */, [1, 3, -1, -1, -1] /* 3 */, [2, 1, -1, -1, -1] /* 4 */, [0, 3, 2, 1, -1] /* 5 */, [2, 0, -1, -1, -1] /* 6 */, [2, 3, -1, -1, -1] /* 7 */, [3, 2, -1, -1, -1] /* 8 */, [0, 2, -1, -1, -1] /* 9 */, [1, 0, 3, 2, -1] /* 10 */, [1, 2, -1, -1, -1] /* 11 */, [3, 1, -1, -1, -1] /* 12 */, [0, 1, -1, -1, -1] /* 13 */, [3, 0, -1, -1, -1] /* 14 */, [-1, -1, -1, -1, -1] /* 15 */];\n\nconst EDGES = [[0, 1], [1, 3], [2, 3], [0, 2]];\nfunction getCase(index) {\n  return MARCHING_SQUARES_CASES[index];\n}\n\n// Define the four edges of the pixel by the following pairs of vertices\nfunction getEdge(eid) {\n  return EDGES[eid];\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\nvar vtkCaseTable = {\n  getCase,\n  getEdge\n};\n\nexport { vtkCaseTable as default };\n"],"names":[],"sourceRoot":""}