(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_cornerstonejs_tools_dist_esm_index_js"],{

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/constants/index.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COLOR_LUT: () => (/* reexport safe */ _COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./COLOR_LUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/segmentation/InterpolationManager/InterpolationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js");



const enable = function () {
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_COMPLETED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__["default"].handleAnnotationCompleted);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_MODIFIED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__["default"].handleAnnotationUpdate);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_REMOVED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__["default"].handleAnnotationDelete);
};
const disable = function () {
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_COMPLETED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__["default"].handleAnnotationCompleted);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_MODIFIED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__["default"].handleAnnotationUpdate);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_REMOVED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__["default"].handleAnnotationDelete);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/getToolsWithModesForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js");



const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
const onCameraModified = function (evt) {
    const enabledTools = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__["default"])(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onCameraModified) {
            tool.onCameraModified(evt);
        }
    });
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/getToolsWithModesForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js");



const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
const onCameraReset = function (evt) {
    const enabledTools = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__["default"])(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onResetCamera) {
            tool.onResetCamera(evt);
        }
    });
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_RESET, onCameraReset);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_RESET, onCameraReset);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/triggerAnnotationRender */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js");


const onImageRendered = function (evt) {
    (0,_utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__["default"])(evt.detail.element);
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/getToolsWithModesForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js");



const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
const onImageSpacingCalibrated = function (evt) {
    const enabledTools = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__["default"])(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onImageSpacingCalibrated) {
            tool.onImageSpacingCalibrated(evt);
        }
    });
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotationInterpolationEventDispatcher: () => (/* reexport safe */ _annotationInterpolationEventDispatcher__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   cameraModifiedEventDispatcher: () => (/* reexport safe */ _cameraModifiedEventDispatcher__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   cameraResetEventDispatcher: () => (/* reexport safe */ _cameraResetEventDispatcher__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   imageRenderedEventDispatcher: () => (/* reexport safe */ _imageRenderedEventDispatcher__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   imageSpacingCalibratedEventDispatcher: () => (/* reexport safe */ _imageSpacingCalibratedEventDispatcher__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   keyboardToolEventDispatcher: () => (/* reexport safe */ _keyboardToolEventDispatcher__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   mouseToolEventDispatcher: () => (/* reexport safe */ _mouseToolEventDispatcher__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   touchToolEventDispatcher: () => (/* reexport safe */ _touchToolEventDispatcher__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _imageRenderedEventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageRenderedEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js");
/* harmony import */ var _mouseToolEventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouseToolEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js");
/* harmony import */ var _keyboardToolEventDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keyboardToolEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js");
/* harmony import */ var _cameraModifiedEventDispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cameraModifiedEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js");
/* harmony import */ var _imageSpacingCalibratedEventDispatcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./imageSpacingCalibratedEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js");
/* harmony import */ var _touchToolEventDispatcher__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./touchToolEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js");
/* harmony import */ var _annotationInterpolationEventDispatcher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./annotationInterpolationEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js");
/* harmony import */ var _cameraResetEventDispatcher__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cameraResetEventDispatcher */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js");











/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/index.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keyDown: () => (/* reexport safe */ _keyDown__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   keyUp: () => (/* reexport safe */ _keyUp__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _keyDown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyDown */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyDown.js");
/* harmony import */ var _keyUp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyUp */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyUp.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyDown.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyDown.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ keyDown)
/* harmony export */ });
/* harmony import */ var _shared_getActiveToolForKeyboardEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/getActiveToolForKeyboardEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForKeyboardEvent.js");
/* harmony import */ var _shared_getToolsWithActionsForKeyboardEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/getToolsWithActionsForKeyboardEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForKeyboardEvents.js");
/* harmony import */ var _enums_ToolModes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/ToolModes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");




function keyDown(evt) {
    const activeTool = (0,_shared_getActiveToolForKeyboardEvent__WEBPACK_IMPORTED_MODULE_0__["default"])(evt);
    if (activeTool) {
        const { renderingEngineId, viewportId } = evt.detail;
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroupForViewport)(viewportId, renderingEngineId);
        const toolName = activeTool.getToolName();
        if (Object.keys(toolGroup.toolOptions).includes(toolName)) {
            toolGroup.setViewportsCursorByToolName(toolName);
        }
    }
    const activeToolsWithEventBinding = (0,_shared_getToolsWithActionsForKeyboardEvents__WEBPACK_IMPORTED_MODULE_1__["default"])(evt, [
        _enums_ToolModes__WEBPACK_IMPORTED_MODULE_2__["default"].Active,
    ]);
    if (activeToolsWithEventBinding?.size) {
        const { element } = evt.detail;
        for (const [key, value] of [...activeToolsWithEventBinding.entries()]) {
            const method = typeof value.method === 'function' ? value.method : key[value.method];
            method.call(key, element, value, evt);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyUp.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyUp.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ keyUp)
/* harmony export */ });
/* harmony import */ var _eventListeners_keyboard_keyDownListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../eventListeners/keyboard/keyDownListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/keyDownListener.js");
/* harmony import */ var _shared_getActiveToolForKeyboardEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/getActiveToolForKeyboardEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForKeyboardEvent.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");



function keyUp(evt) {
    const activeTool = (0,_shared_getActiveToolForKeyboardEvent__WEBPACK_IMPORTED_MODULE_1__["default"])(evt);
    if (!activeTool) {
        return;
    }
    const { renderingEngineId, viewportId } = evt.detail;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupForViewport)(viewportId, renderingEngineId);
    (0,_eventListeners_keyboard_keyDownListener__WEBPACK_IMPORTED_MODULE_0__.resetModifierKey)();
    const toolName = activeTool.getToolName();
    if (Object.keys(toolGroup.toolOptions).includes(toolName)) {
        toolGroup.setViewportsCursorByToolName(toolName);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboardEventHandlers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/index.js");


const enable = function (element) {
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].KEY_DOWN, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__.keyDown);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].KEY_UP, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__.keyUp);
};
const disable = function (element) {
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].KEY_DOWN, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__.keyDown);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].KEY_UP, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__.keyUp);
};
const keyboardToolEventDispatcher = {
    enable,
    disable,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keyboardToolEventDispatcher);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/index.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mouseClick: () => (/* reexport safe */ _mouseClick__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   mouseDoubleClick: () => (/* reexport safe */ _mouseDoubleClick__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   mouseDown: () => (/* reexport safe */ _mouseDown__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   mouseDownActivate: () => (/* reexport safe */ _mouseDownActivate__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mouseDrag: () => (/* reexport safe */ _mouseDrag__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   mouseMove: () => (/* reexport safe */ _mouseMove__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   mouseUp: () => (/* reexport safe */ _mouseUp__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   mouseWheel: () => (/* reexport safe */ _mouseWheel__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _mouseClick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouseClick */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseClick.js");
/* harmony import */ var _mouseDoubleClick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouseDoubleClick */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDoubleClick.js");
/* harmony import */ var _mouseDown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mouseDown */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDown.js");
/* harmony import */ var _mouseDownActivate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mouseDownActivate */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownActivate.js");
/* harmony import */ var _mouseDrag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mouseDrag */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDrag.js");
/* harmony import */ var _mouseMove__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mouseMove */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseMove.js");
/* harmony import */ var _mouseUp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mouseUp */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseUp.js");
/* harmony import */ var _mouseWheel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mouseWheel */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseWheel.js");











/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseClick.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseClick.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/customCallbackHandler */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js");

const mouseClick = _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__["default"].bind(null, 'Mouse', 'mouseClickCallback');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseClick);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDoubleClick.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDoubleClick.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/customCallbackHandler */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js");

const mouseDoubleClick = _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__["default"].bind(null, 'Mouse', 'doubleClickCallback');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseDoubleClick);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDown.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDown.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mouseDown)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _store_filterToolsWithMoveableHandles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../store/filterToolsWithMoveableHandles */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithMoveableHandles.js");
/* harmony import */ var _store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../store/filterToolsWithAnnotationsForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js");
/* harmony import */ var _store_filterMoveableAnnotationTools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/filterMoveableAnnotationTools */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js");
/* harmony import */ var _shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shared/getActiveToolForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js");
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shared/getToolsWithModesForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js");
/* harmony import */ var _mouseDownAnnotationAction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mouseDownAnnotationAction */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.js");











const { Active, Passive } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
function mouseDown(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isInteractingWithTool) {
        return;
    }
    const activeTool = (0,_shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_8__["default"])(evt);
    if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {
        const consumedEvent = activeTool.preMouseDownCallback(evt);
        if (consumedEvent) {
            return;
        }
    }
    const isPrimaryClick = evt.detail.event.buttons === 1;
    const activeToolsWithEventBinding = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_9__["default"])(evt, [Active], evt.detail.event.buttons);
    const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick
        ? (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_9__["default"])(evt, [Passive])
        : undefined;
    const applicableTools = [
        ...(activeToolsWithEventBinding || []),
        ...(passiveToolsIfEventWasPrimaryMouseButton || []),
    ];
    const actionExecuted = (0,_mouseDownAnnotationAction__WEBPACK_IMPORTED_MODULE_10__["default"])(evt);
    if (actionExecuted) {
        return;
    }
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const annotationToolsWithAnnotations = (0,_store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_6__["default"])(element, applicableTools);
    const canvasCoords = eventDetail.currentPoints.canvas;
    const annotationToolsWithMoveableHandles = (0,_store_filterToolsWithMoveableHandles__WEBPACK_IMPORTED_MODULE_5__["default"])(element, annotationToolsWithAnnotations, canvasCoords, 'mouse');
    const isMultiSelect = !!evt.detail.event.shiftKey;
    if (annotationToolsWithMoveableHandles.length > 0) {
        const { tool, annotation, handle } = getAnnotationForSelection(annotationToolsWithMoveableHandles);
        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);
        tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');
        return;
    }
    const moveableAnnotationTools = (0,_store_filterMoveableAnnotationTools__WEBPACK_IMPORTED_MODULE_7__["default"])(element, annotationToolsWithAnnotations, canvasCoords, 'mouse');
    if (moveableAnnotationTools.length > 0) {
        const { tool, annotation } = getAnnotationForSelection(moveableAnnotationTools);
        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);
        tool.toolSelectedCallback(evt, annotation, 'Mouse', canvasCoords);
        return;
    }
    if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {
        const consumedEvent = activeTool.postMouseDownCallback(evt);
        if (consumedEvent) {
            return;
        }
    }
}
function getAnnotationForSelection(toolsWithMovableHandles) {
    if (toolsWithMovableHandles.length > 1) {
        const unlockAndVisibleAnnotation = toolsWithMovableHandles.find((item) => {
            const isUnlocked = !(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(item.annotation.annotationUID);
            const isVisible = (0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__.isAnnotationVisible)(item.annotation.annotationUID);
            return isUnlocked && isVisible;
        });
        if (unlockAndVisibleAnnotation) {
            return unlockAndVisibleAnnotation;
        }
    }
    return toolsWithMovableHandles[0];
}
function toggleAnnotationSelection(annotationUID, isMultiSelect = false) {
    if (isMultiSelect) {
        if ((0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.isAnnotationSelected)(annotationUID)) {
            (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID, false);
        }
        else {
            const preserveSelected = true;
            (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID, true, preserveSelected);
        }
    }
    else {
        const preserveSelected = false;
        (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID, true, preserveSelected);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownActivate.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownActivate.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mouseDownActivate)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/getActiveToolForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js");
/* harmony import */ var _stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");



function mouseDownActivate(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isInteractingWithTool) {
        return;
    }
    const activeTool = (0,_shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_1__["default"])(evt);
    if (!activeTool) {
        return;
    }
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isMultiPartToolActive) {
        return;
    }
    if (activeTool.addNewAnnotation) {
        const annotation = activeTool.addNewAnnotation(evt, 'mouse');
        (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotation.annotationUID);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.js":
/*!****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mouseDownAnnotationAction)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../store/filterToolsWithAnnotationsForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js");
/* harmony import */ var _store_filterMoveableAnnotationTools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../store/filterMoveableAnnotationTools */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js");
/* harmony import */ var _shared_getToolsWithActionsForMouseEvent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/getToolsWithActionsForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForMouseEvent.js");






const { Active, Passive } = _enums__WEBPACK_IMPORTED_MODULE_2__.ToolModes;
function mouseDownAnnotationAction(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_1__.state.isInteractingWithTool) {
        return false;
    }
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { canvas: canvasCoords } = eventDetail.currentPoints;
    if (!enabledElement) {
        return false;
    }
    const toolsWithActions = (0,_shared_getToolsWithActionsForMouseEvent__WEBPACK_IMPORTED_MODULE_5__["default"])(evt, [
        Active,
        Passive,
    ]);
    const tools = Array.from(toolsWithActions.keys());
    const annotationToolsWithAnnotations = (0,_store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_3__["default"])(element, tools);
    const moveableAnnotationTools = (0,_store_filterMoveableAnnotationTools__WEBPACK_IMPORTED_MODULE_4__["default"])(element, annotationToolsWithAnnotations, canvasCoords);
    if (moveableAnnotationTools.length > 0) {
        const { tool, annotation } = moveableAnnotationTools[0];
        const action = toolsWithActions.get(tool);
        const method = typeof action.method === 'string' ? tool[action.method] : action.method;
        method.call(tool, evt, annotation);
        return true;
    }
    return false;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDrag.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDrag.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mouseDrag)
/* harmony export */ });
/* harmony import */ var _shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/getActiveToolForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");


function mouseDrag(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_1__.state.isInteractingWithTool) {
        return;
    }
    const activeTool = (0,_shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_0__["default"])(evt);
    const noFoundToolOrDoesNotHaveMouseDragCallback = !activeTool || typeof activeTool.mouseDragCallback !== 'function';
    if (noFoundToolOrDoesNotHaveMouseDragCallback) {
        return;
    }
    activeTool.mouseDragCallback(evt);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseMove.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseMove.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mouseMove)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/filterToolsWithAnnotationsForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js");
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/getToolsWithModesForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js");
/* harmony import */ var _utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRender */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js");





const { Active, Passive } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
function mouseMove(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isInteractingWithTool || _store_state__WEBPACK_IMPORTED_MODULE_0__.state.isMultiPartToolActive) {
        return;
    }
    const activeAndPassiveTools = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, [
        Active,
        Passive,
    ]);
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const toolsWithAnnotations = (0,_store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_2__["default"])(element, activeAndPassiveTools);
    const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {
        const doesNotHaveAnnotations = !toolsWithAnnotations.some((toolAndAnnotation) => toolAndAnnotation.tool.getToolName() === tool.getToolName());
        return doesNotHaveAnnotations;
    });
    let annotationsNeedToBeRedrawn = false;
    for (const { tool, annotations } of toolsWithAnnotations) {
        if (typeof tool.mouseMoveCallback === 'function') {
            annotationsNeedToBeRedrawn =
                tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;
        }
    }
    toolsWithoutAnnotations.forEach((tool) => {
        if (typeof tool.mouseMoveCallback === 'function') {
            tool.mouseMoveCallback(evt);
        }
    });
    if (annotationsNeedToBeRedrawn === true) {
        (0,_utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_4__["default"])(element);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseUp.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseUp.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/customCallbackHandler */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js");

const mouseUp = _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__["default"].bind(null, 'Mouse', 'mouseUpCallback');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseUp);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseWheel.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseWheel.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/getActiveToolForMouseEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js");
/* harmony import */ var _enums_ToolBindings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/ToolBindings */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js");



function mouseWheel(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isInteractingWithTool) {
        return;
    }
    evt.detail.buttons =
        _enums_ToolBindings__WEBPACK_IMPORTED_MODULE_2__.MouseBindings.Wheel | (evt.detail.event.buttons || 0);
    const activeTool = (0,_shared_getActiveToolForMouseEvent__WEBPACK_IMPORTED_MODULE_1__["default"])(evt);
    if (!activeTool) {
        return;
    }
    return activeTool.mouseWheelCallback(evt);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseWheel);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouseEventHandlers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/index.js");


const enable = function (element) {
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseClick);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DOWN, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDown);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DOWN_ACTIVATE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDownActivate);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DOUBLE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDoubleClick);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DRAG, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDrag);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_MOVE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseMove);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_UP, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseUp);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_WHEEL, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseWheel);
};
const disable = function (element) {
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseClick);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DOWN, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDown);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DOWN_ACTIVATE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDownActivate);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DOUBLE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDoubleClick);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_DRAG, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseDrag);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_MOVE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseMove);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_UP, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseUp);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].MOUSE_WHEEL, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__.mouseWheel);
};
const mouseToolEventDispatcher = {
    enable,
    disable,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseToolEventDispatcher);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ customCallbackHandler)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/ToolModes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");



const { Active } = _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__["default"];
function customCallbackHandler(handlerType, customFunction, evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isInteractingWithTool) {
        return false;
    }
    const { renderingEngineId, viewportId } = evt.detail;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return false;
    }
    let activeTool;
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const tool = toolGroup.toolOptions[toolName];
        const toolInstance = toolGroup.getToolInstance(toolName);
        if (tool.mode === Active &&
            typeof toolInstance[customFunction] === 'function') {
            activeTool = toolGroup.getToolInstance(toolName);
            break;
        }
    }
    if (!activeTool) {
        return;
    }
    activeTool[customFunction](evt);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForKeyboardEvent.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForKeyboardEvent.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getActiveToolForKeyboardEvent)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../eventListeners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js");
/* harmony import */ var _eventListeners_mouse_mouseDownListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../eventListeners/mouse/mouseDownListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");




const { Active } = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes;
function getActiveToolForKeyboardEvent(evt) {
    const { renderingEngineId, viewportId } = evt.detail;
    const mouseButton = (0,_eventListeners_mouse_mouseDownListener__WEBPACK_IMPORTED_MODULE_2__.getMouseButton)();
    const modifierKey = _eventListeners__WEBPACK_IMPORTED_MODULE_1__.keyEventListener.getModifierKey();
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return null;
    }
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const toolOptions = toolGroup.toolOptions[toolName];
        if (toolOptions.mode !== Active) {
            continue;
        }
        const correctBinding = toolOptions.bindings.length &&
            toolOptions.bindings.some((binding) => binding.mouseButton === (mouseButton ?? defaultMousePrimary) &&
                binding.modifierKey === modifierKey);
        if (correctBinding) {
            return toolGroup.getToolInstance(toolName);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getActiveToolForMouseEvent)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../eventListeners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _getMouseModifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMouseModifier */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js");




const { Active } = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes;
function getActiveToolForMouseEvent(evt) {
    const { renderingEngineId, viewportId, event: mouseEvent } = evt.detail;
    const modifierKey = (0,_getMouseModifier__WEBPACK_IMPORTED_MODULE_3__["default"])(mouseEvent) || _eventListeners__WEBPACK_IMPORTED_MODULE_1__.keyEventListener.getModifierKey();
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return null;
    }
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
    const mouseButton = evt.detail.buttons ?? mouseEvent?.buttons ?? defaultMousePrimary;
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const toolOptions = toolGroup.toolOptions[toolName];
        const correctBinding = toolOptions.bindings.length &&
            toolOptions.bindings.some((binding) => {
                return (binding.mouseButton === mouseButton &&
                    binding.modifierKey === modifierKey);
            });
        if (toolOptions.mode === Active && correctBinding) {
            return toolGroup.getToolInstance(toolName);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getActiveToolForTouchEvent)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _getMouseModifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getMouseModifier */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js");
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../eventListeners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");




const { Active } = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes;
function getActiveToolForTouchEvent(evt) {
    const { renderingEngineId, viewportId } = evt.detail;
    const touchEvent = evt.detail.event;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return null;
    }
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    const numTouchPoints = Object.keys(touchEvent.touches).length;
    const modifierKey = (0,_getMouseModifier__WEBPACK_IMPORTED_MODULE_1__["default"])(touchEvent) || _eventListeners__WEBPACK_IMPORTED_MODULE_2__.keyEventListener.getModifierKey();
    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const toolOptions = toolGroup.toolOptions[toolName];
        const correctBinding = toolOptions.bindings.length &&
            toolOptions.bindings.some((binding) => (binding.numTouchPoints === numTouchPoints ||
                (numTouchPoints === 1 &&
                    binding.mouseButton === defaultMousePrimary)) &&
                binding.modifierKey === modifierKey);
        if (toolOptions.mode === Active && correctBinding) {
            return toolGroup.getToolInstance(toolName);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForKeyboardEvents.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForKeyboardEvents.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getToolsWithModesForKeyboardEvent)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");

function getToolsWithModesForKeyboardEvent(evt, toolModes) {
    const toolsWithActions = new Map();
    const { renderingEngineId, viewportId } = evt.detail;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return toolsWithActions;
    }
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    const key = evt.detail.key;
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const tool = toolGroup.getToolInstance(toolName);
        const actionsConfig = tool.configuration?.actions;
        if (!actionsConfig) {
            continue;
        }
        const actions = Object.values(actionsConfig);
        if (!actions?.length || !toolModes.includes(tool.mode)) {
            continue;
        }
        const action = actions.find((action) => action.bindings?.some((binding) => binding.key === key));
        if (action) {
            toolsWithActions.set(tool, action);
        }
    }
    return toolsWithActions;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForMouseEvent.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForMouseEvent.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getToolsWithActionsForMouseEvent)
/* harmony export */ });
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../eventListeners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js");
/* harmony import */ var _getMouseModifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getMouseModifier */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");



function getToolsWithActionsForMouseEvent(evt, toolModes) {
    const toolsWithActions = new Map();
    const { renderingEngineId, viewportId } = evt.detail;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return toolsWithActions;
    }
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
    const mouseEvent = evt.detail.event;
    const mouseButton = mouseEvent?.buttons ?? defaultMousePrimary;
    const modifierKey = (0,_getMouseModifier__WEBPACK_IMPORTED_MODULE_1__["default"])(mouseEvent) || _eventListeners__WEBPACK_IMPORTED_MODULE_0__.keyEventListener.getModifierKey();
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const tool = toolGroup.getToolInstance(toolName);
        const actionsConfig = tool.configuration?.actions ?? {};
        const actions = Object.values(actionsConfig);
        if (!actions?.length || !toolModes.includes(tool.mode)) {
            continue;
        }
        const action = actions.find((action) => action.bindings?.length &&
            action.bindings.some((binding) => binding.mouseButton === mouseButton &&
                binding.modifierKey === modifierKey));
        if (action) {
            toolsWithActions.set(tool, action);
        }
    }
    return toolsWithActions;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getToolsWithModesForMouseEvent)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");

function getToolsWithModesForMouseEvent(evt, modesFilter, evtButton) {
    const { renderingEngineId, viewportId } = evt.detail;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return [];
    }
    const enabledTools = [];
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const tool = toolGroup.toolOptions[toolName];
        const correctBinding = evtButton != null &&
            tool.bindings.length &&
            tool.bindings.some((binding) => binding.mouseButton === evtButton);
        if (modesFilter.includes(tool.mode) &&
            (!evtButton || correctBinding)) {
            const toolInstance = toolGroup.getToolInstance(toolName);
            enabledTools.push(toolInstance);
        }
    }
    return enabledTools;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForTouchEvent.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForTouchEvent.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getToolsWithModesForTouchEvent)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");

function getToolsWithModesForTouchEvent(evt, modesFilter, numTouchPoints) {
    const { renderingEngineId, viewportId } = evt.detail;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return [];
    }
    const enabledTools = [];
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const tool = toolGroup.toolOptions[toolName];
        const correctBinding = numTouchPoints != null &&
            tool.bindings.length &&
            tool.bindings.some((binding) => binding.numTouchPoints === numTouchPoints);
        if (modesFilter.includes(tool.mode) &&
            (!numTouchPoints || correctBinding)) {
            const toolInstance = toolGroup.getToolInstance(toolName);
            enabledTools.push(toolInstance);
        }
    }
    return enabledTools;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/index.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   touchDrag: () => (/* reexport safe */ _touchDrag__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   touchEnd: () => (/* reexport safe */ _touchEnd__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   touchPress: () => (/* reexport safe */ _touchPress__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   touchStart: () => (/* reexport safe */ _touchStart__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   touchStartActivate: () => (/* reexport safe */ _touchStartActivate__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   touchTap: () => (/* reexport safe */ _touchTap__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _touchStart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./touchStart */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStart.js");
/* harmony import */ var _touchStartActivate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./touchStartActivate */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStartActivate.js");
/* harmony import */ var _touchDrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./touchDrag */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchDrag.js");
/* harmony import */ var _touchEnd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./touchEnd */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchEnd.js");
/* harmony import */ var _touchTap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./touchTap */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchTap.js");
/* harmony import */ var _touchPress__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./touchPress */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchPress.js");









/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchDrag.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchDrag.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ touchDrag)
/* harmony export */ });
/* harmony import */ var _shared_getActiveToolForTouchEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/getActiveToolForTouchEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");


function touchDrag(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_1__.state.isInteractingWithTool) {
        return;
    }
    const activeTool = (0,_shared_getActiveToolForTouchEvent__WEBPACK_IMPORTED_MODULE_0__["default"])(evt);
    const noFoundToolOrDoesNotHaveTouchDragCallback = !activeTool || typeof activeTool.touchDragCallback !== 'function';
    if (noFoundToolOrDoesNotHaveTouchDragCallback) {
        return;
    }
    activeTool.touchDragCallback(evt);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchEnd.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchEnd.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/customCallbackHandler */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js");

const touchEnd = _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__["default"].bind(null, 'Touch', 'touchEndCallback');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (touchEnd);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchPress.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchPress.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/customCallbackHandler */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js");

const touchPress = _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__["default"].bind(null, 'Touch', 'touchPressCallback');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (touchPress);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStart.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStart.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ touchStart)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _store_filterToolsWithMoveableHandles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../store/filterToolsWithMoveableHandles */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithMoveableHandles.js");
/* harmony import */ var _store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../store/filterToolsWithAnnotationsForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js");
/* harmony import */ var _store_filterMoveableAnnotationTools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/filterMoveableAnnotationTools */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js");
/* harmony import */ var _shared_getActiveToolForTouchEvent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shared/getActiveToolForTouchEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js");
/* harmony import */ var _shared_getToolsWithModesForTouchEvent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shared/getToolsWithModesForTouchEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForTouchEvent.js");










const { Active, Passive } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
function touchStart(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isInteractingWithTool) {
        return;
    }
    const activeTool = (0,_shared_getActiveToolForTouchEvent__WEBPACK_IMPORTED_MODULE_8__["default"])(evt);
    if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {
        const consumedEvent = activeTool.preTouchStartCallback(evt);
        if (consumedEvent) {
            return;
        }
    }
    const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;
    const activeToolsWithEventBinding = (0,_shared_getToolsWithModesForTouchEvent__WEBPACK_IMPORTED_MODULE_9__["default"])(evt, [Active], Object.keys(evt.detail.event.touches).length);
    const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick
        ? (0,_shared_getToolsWithModesForTouchEvent__WEBPACK_IMPORTED_MODULE_9__["default"])(evt, [Passive])
        : undefined;
    const applicableTools = [
        ...(activeToolsWithEventBinding || []),
        ...(passiveToolsIfEventWasPrimaryTouchButton || []),
        activeTool,
    ];
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const annotationToolsWithAnnotations = (0,_store_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_6__["default"])(element, applicableTools);
    const canvasCoords = eventDetail.currentPoints.canvas;
    const annotationToolsWithMoveableHandles = (0,_store_filterToolsWithMoveableHandles__WEBPACK_IMPORTED_MODULE_5__["default"])(element, annotationToolsWithAnnotations, canvasCoords, 'touch');
    const isMultiSelect = false;
    if (annotationToolsWithMoveableHandles.length > 0) {
        const { tool, annotation, handle } = getAnnotationForSelection(annotationToolsWithMoveableHandles);
        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);
        tool.handleSelectedCallback(evt, annotation, handle, 'Touch');
        return;
    }
    const moveableAnnotationTools = (0,_store_filterMoveableAnnotationTools__WEBPACK_IMPORTED_MODULE_7__["default"])(element, annotationToolsWithAnnotations, canvasCoords, 'touch');
    if (moveableAnnotationTools.length > 0) {
        const { tool, annotation } = getAnnotationForSelection(moveableAnnotationTools);
        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);
        tool.toolSelectedCallback(evt, annotation, 'Touch', canvasCoords);
        return;
    }
    if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {
        const consumedEvent = activeTool.postTouchStartCallback(evt);
        if (consumedEvent) {
            return;
        }
    }
}
function getAnnotationForSelection(toolsWithMovableHandles) {
    return ((toolsWithMovableHandles.length > 1 &&
        toolsWithMovableHandles.find((item) => !(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(item.annotation.annotationUID) &&
            (0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__.isAnnotationVisible)(item.annotation.annotationUID))) ||
        toolsWithMovableHandles[0]);
}
function toggleAnnotationSelection(annotationUID, isMultiSelect = false) {
    if (isMultiSelect) {
        if ((0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.isAnnotationSelected)(annotationUID)) {
            (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID, false);
        }
        else {
            const preserveSelected = true;
            (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID, true, preserveSelected);
        }
    }
    else {
        const preserveSelected = false;
        (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID, true, preserveSelected);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStartActivate.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStartActivate.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ touchStartActivate)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _shared_getActiveToolForTouchEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/getActiveToolForTouchEvent */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js");



function touchStartActivate(evt) {
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isInteractingWithTool) {
        return;
    }
    const activeTool = (0,_shared_getActiveToolForTouchEvent__WEBPACK_IMPORTED_MODULE_2__["default"])(evt);
    if (!activeTool) {
        return;
    }
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.isMultiPartToolActive) {
        return;
    }
    if (activeTool.addNewAnnotation) {
        const annotation = activeTool.addNewAnnotation(evt, 'touch');
        (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_1__.setAnnotationSelected)(annotation.annotationUID);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchTap.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchTap.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/customCallbackHandler */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js");

const touchTap = _shared_customCallbackHandler__WEBPACK_IMPORTED_MODULE_0__["default"].bind(null, 'Touch', 'touchTapCallback');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (touchTap);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./touchEventHandlers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/index.js");


const enable = function (element) {
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_START, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchStart);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_START_ACTIVATE, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchStartActivate);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_DRAG, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchDrag);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_END, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchEnd);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_TAP, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchTap);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_PRESS, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchPress);
};
const disable = function (element) {
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_START, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchStart);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_START_ACTIVATE, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchStartActivate);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_DRAG, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchDrag);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_END, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchEnd);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__["default"].TOUCH_PRESS, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__.touchPress);
};
const touchToolEventDispatcher = {
    enable,
    disable,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (touchToolEventDispatcher);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ annotationCompletedListener)
/* harmony export */ });
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");
/* harmony import */ var _contourSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/index.js");


function annotationCompletedListener(evt) {
    const annotation = evt.detail.annotation;
    if (_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_0__.isContourSegmentationAnnotation(annotation)) {
        (0,_contourSegmentation__WEBPACK_IMPORTED_MODULE_1__.contourSegmentationCompleted)(evt);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");

function annotationModifiedListener(evt) {
    const { viewportId } = evt.detail;
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_0__["default"])([viewportId]);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (annotationModifiedListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ annotationRemovedListener)
/* harmony export */ });
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");
/* harmony import */ var _contourSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/index.js");


function annotationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    if (_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_0__.isContourSegmentationAnnotation(annotation)) {
        (0,_contourSegmentation__WEBPACK_IMPORTED_MODULE_1__.contourSegmentationRemoved)(evt);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");


function annotationSelectionListener(evt) {
    const deselectedAnnotation = evt.detail.removed;
    if (!deselectedAnnotation.length) {
        return;
    }
    const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)();
    renderingEngines.forEach((renderingEngine) => {
        const viewports = renderingEngine.getViewports();
        const viewportIds = viewports.map((vp) => vp.id);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRenderForViewportIds)(viewportIds);
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (annotationSelectionListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js":
/*!****************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contourSegmentationRemovedListener)
/* harmony export */ });
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utilities/contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");

function contourSegmentationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_0__.removeContourSegmentationAnnotation)(annotation);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/index.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/index.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contourSegmentationCompleted: () => (/* reexport safe */ _contourSegmentationCompleted__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   contourSegmentationRemoved: () => (/* reexport safe */ _contourSegmentationRemoved__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _contourSegmentationCompleted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contourSegmentationCompleted */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js");
/* harmony import */ var _contourSegmentationRemoved__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contourSegmentationRemoved */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/index.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotationCompletedListener: () => (/* reexport safe */ _annotationCompletedListener__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   annotationModifiedListener: () => (/* reexport safe */ _annotationModifiedListener__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   annotationRemovedListener: () => (/* reexport safe */ _annotationRemovedListener__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   annotationSelectionListener: () => (/* reexport safe */ _annotationSelectionListener__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _annotationCompletedListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationCompletedListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js");
/* harmony import */ var _annotationSelectionListener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotationSelectionListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js");
/* harmony import */ var _annotationModifiedListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationModifiedListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js");
/* harmony import */ var _annotationRemovedListener__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./annotationRemovedListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js");







/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotationCompletedListener: () => (/* reexport safe */ _annotations__WEBPACK_IMPORTED_MODULE_5__.annotationCompletedListener),
/* harmony export */   annotationModifiedListener: () => (/* reexport safe */ _annotations__WEBPACK_IMPORTED_MODULE_5__.annotationModifiedListener),
/* harmony export */   annotationRemovedListener: () => (/* reexport safe */ _annotations__WEBPACK_IMPORTED_MODULE_5__.annotationRemovedListener),
/* harmony export */   annotationSelectionListener: () => (/* reexport safe */ _annotations__WEBPACK_IMPORTED_MODULE_5__.annotationSelectionListener),
/* harmony export */   imageChangeEventListener: () => (/* reexport safe */ _segmentation__WEBPACK_IMPORTED_MODULE_4__.imageChangeEventListener),
/* harmony export */   keyEventListener: () => (/* reexport safe */ _keyboard__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mouseEventListeners: () => (/* reexport safe */ _mouse__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   segmentationDataModifiedEventListener: () => (/* reexport safe */ _segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentationDataModifiedEventListener),
/* harmony export */   segmentationModifiedListener: () => (/* reexport safe */ _segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentationModifiedListener),
/* harmony export */   touchEventListeners: () => (/* reexport safe */ _touch__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   wheelEventListener: () => (/* reexport safe */ _wheel__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js");
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./touch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js");
/* harmony import */ var _wheel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wheel */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js");
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keyboard */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js");
/* harmony import */ var _segmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/index.js");
/* harmony import */ var _annotations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./annotations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/index.js");









/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _keyDownListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyDownListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/keyDownListener.js");

function enable(element) {
    disable(element);
    element.addEventListener('keydown', _keyDownListener__WEBPACK_IMPORTED_MODULE_0__["default"]);
}
function disable(element) {
    element.removeEventListener('keydown', _keyDownListener__WEBPACK_IMPORTED_MODULE_0__["default"]);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
    getModifierKey: _keyDownListener__WEBPACK_IMPORTED_MODULE_0__.getModifierKey,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/keyDownListener.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/keyDownListener.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getModifierKey: () => (/* binding */ getModifierKey),
/* harmony export */   resetModifierKey: () => (/* binding */ resetModifierKey)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");


const defaultState = {
    renderingEngineId: undefined,
    viewportId: undefined,
    key: undefined,
    keyCode: undefined,
    element: null,
};
let state = {
    renderingEngineId: undefined,
    viewportId: undefined,
    key: undefined,
    keyCode: undefined,
    element: null,
};
function keyListener(evt) {
    state.element = evt.currentTarget;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(state.element);
    const { renderingEngineId, viewportId } = enabledElement;
    state.renderingEngineId = renderingEngineId;
    state.viewportId = viewportId;
    state.key = evt.key;
    state.keyCode = evt.keyCode;
    evt.preventDefault();
    const eventDetail = {
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        element: state.element,
        key: state.key,
        keyCode: state.keyCode,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(eventDetail.element, _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].KEY_DOWN, eventDetail);
    document.addEventListener('keyup', _onKeyUp);
    document.addEventListener('visibilitychange', _onVisibilityChange);
    state.element.removeEventListener('keydown', keyListener);
}
function _onVisibilityChange() {
    document.removeEventListener('visibilitychange', _onVisibilityChange);
    if (document.visibilityState === 'hidden') {
        resetModifierKey();
    }
}
function _onKeyUp(evt) {
    const eventDetail = {
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        element: state.element,
        key: state.key,
        keyCode: state.keyCode,
    };
    document.removeEventListener('keyup', _onKeyUp);
    document.removeEventListener('visibilitychange', _onVisibilityChange);
    state.element.addEventListener('keydown', keyListener);
    state = structuredClone(defaultState);
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(eventDetail.element, _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].KEY_UP, eventDetail);
}
function getModifierKey() {
    return state.keyCode;
}
function resetModifierKey() {
    state.keyCode = undefined;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keyListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMouseEventPoints)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function getMouseEventPoints(evt, element) {
    const elementToUse = element || evt.currentTarget;
    const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(elementToUse) || {};
    if (!viewport) {
        return;
    }
    const clientPoint = _clientToPoint(evt);
    const pagePoint = _pageToPoint(evt);
    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);
    const worldPoint = viewport.canvasToWorld(canvasPoint);
    return {
        page: pagePoint,
        client: clientPoint,
        canvas: canvasPoint,
        world: worldPoint,
    };
}
function _pagePointsToCanvasPoints(element, pagePoint) {
    const rect = element.getBoundingClientRect();
    return [
        pagePoint[0] - rect.left - window.pageXOffset,
        pagePoint[1] - rect.top - window.pageYOffset,
    ];
}
function _pageToPoint(evt) {
    return [evt.pageX, evt.pageY];
}
function _clientToPoint(evt) {
    return [evt.clientX, evt.clientY];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _mouseDoubleClickListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouseDoubleClickListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js");
/* harmony import */ var _mouseDownListener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouseDownListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js");
/* harmony import */ var _mouseMoveListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mouseMoveListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js");



function disable(element) {
    element.removeEventListener('dblclick', _mouseDoubleClickListener__WEBPACK_IMPORTED_MODULE_0__["default"]);
    element.removeEventListener('mousedown', _mouseDownListener__WEBPACK_IMPORTED_MODULE_1__["default"]);
    element.removeEventListener('mousemove', _mouseMoveListener__WEBPACK_IMPORTED_MODULE_2__["default"]);
    element.removeEventListener('dblclick', _mouseDownListener__WEBPACK_IMPORTED_MODULE_1__.mouseDoubleClickIgnoreListener, {
        capture: true,
    });
}
function enable(element) {
    disable(element);
    element.addEventListener('dblclick', _mouseDoubleClickListener__WEBPACK_IMPORTED_MODULE_0__["default"]);
    element.addEventListener('mousedown', _mouseDownListener__WEBPACK_IMPORTED_MODULE_1__["default"]);
    element.addEventListener('mousemove', _mouseMoveListener__WEBPACK_IMPORTED_MODULE_2__["default"]);
    element.addEventListener('dblclick', _mouseDownListener__WEBPACK_IMPORTED_MODULE_1__.mouseDoubleClickIgnoreListener, {
        capture: true,
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _getMouseEventPoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMouseEventPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js");



function mouseDoubleClickListener(evt) {
    const element = evt.currentTarget;
    const { viewportId, renderingEngineId } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const startPoints = (0,_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_2__["default"])(evt, element);
    const deltaPoints = {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    };
    const eventDetail = {
        event: evt,
        eventName: _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].MOUSE_DOUBLE_CLICK,
        viewportId,
        renderingEngineId,
        camera: {},
        element,
        startPoints,
        lastPoints: startPoints,
        currentPoints: startPoints,
        deltaPoints,
    };
    const consumed = !(0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(element, _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].MOUSE_DOUBLE_CLICK, eventDetail);
    if (consumed) {
        evt.stopImmediatePropagation();
        evt.preventDefault();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseDoubleClickListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getMouseButton: () => (/* binding */ getMouseButton),
/* harmony export */   mouseDoubleClickIgnoreListener: () => (/* binding */ mouseDoubleClickIgnoreListener)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _mouseMoveListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mouseMoveListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js");
/* harmony import */ var _getMouseEventPoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMouseEventPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js");




const { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } = _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"];
const DOUBLE_CLICK_TOLERANCE_MS = 400;
const MULTI_BUTTON_TOLERANCE_MS = 150;
const DOUBLE_CLICK_DRAG_TOLERANCE = 3;
const defaultState = {
    mouseButton: undefined,
    element: null,
    renderingEngineId: undefined,
    viewportId: undefined,
    isClickEvent: true,
    clickDelay: 200,
    preventClickTimeout: null,
    startPoints: {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    },
    lastPoints: {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    },
};
let state = {
    mouseButton: undefined,
    renderingEngineId: undefined,
    viewportId: undefined,
    isClickEvent: true,
    clickDelay: 200,
    element: null,
    preventClickTimeout: null,
    startPoints: {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    },
    lastPoints: {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    },
};
const doubleClickState = {
    doubleClickTimeout: null,
    mouseDownEvent: null,
    mouseUpEvent: null,
    ignoreDoubleClick: false,
};
function mouseDownListener(evt) {
    if (doubleClickState.doubleClickTimeout) {
        if (evt.buttons === doubleClickState.mouseDownEvent.buttons) {
            return;
        }
        doubleClickState.mouseDownEvent = evt;
        _doStateMouseDownAndUp();
        return;
    }
    doubleClickState.doubleClickTimeout = setTimeout(_doStateMouseDownAndUp, evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS);
    doubleClickState.mouseDownEvent = evt;
    doubleClickState.ignoreDoubleClick = false;
    state.element = evt.currentTarget;
    state.mouseButton = evt.buttons;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(state.element);
    const { renderingEngineId, viewportId } = enabledElement;
    state.renderingEngineId = renderingEngineId;
    state.viewportId = viewportId;
    state.preventClickTimeout = setTimeout(_preventClickHandler, state.clickDelay);
    state.element.removeEventListener('mousemove', _mouseMoveListener__WEBPACK_IMPORTED_MODULE_2__["default"]);
    const startPoints = (0,_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, state.element);
    state.startPoints = _copyPoints(startPoints);
    state.lastPoints = _copyPoints(startPoints);
    document.addEventListener('mouseup', _onMouseUp);
    document.addEventListener('mousemove', _onMouseDrag);
}
function _doMouseDown(evt) {
    const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);
    const eventDetail = {
        event: evt,
        eventName: MOUSE_DOWN,
        element: state.element,
        mouseButton: state.mouseButton,
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        camera: {},
        startPoints: state.startPoints,
        lastPoints: state.startPoints,
        currentPoints: state.startPoints,
        deltaPoints,
    };
    state.lastPoints = _copyPoints(eventDetail.lastPoints);
    const notConsumed = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(eventDetail.element, MOUSE_DOWN, eventDetail);
    if (notConsumed) {
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);
    }
}
function _onMouseDrag(evt) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(state.element);
    if (!enabledElement?.viewport) {
        return;
    }
    const currentPoints = (0,_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, state.element);
    const lastPoints = _updateMouseEventsLastPoints(state.element, state.lastPoints);
    const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);
    if (doubleClickState.doubleClickTimeout) {
        if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {
            _doStateMouseDownAndUp();
        }
        else {
            return;
        }
    }
    const eventDetail = {
        event: evt,
        eventName: MOUSE_DRAG,
        mouseButton: state.mouseButton,
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        camera: {},
        element: state.element,
        startPoints: _copyPoints(state.startPoints),
        lastPoints: _copyPoints(lastPoints),
        currentPoints,
        deltaPoints,
    };
    const consumed = !(0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(state.element, MOUSE_DRAG, eventDetail);
    if (consumed) {
        evt.stopImmediatePropagation();
        evt.preventDefault();
    }
    state.lastPoints = _copyPoints(currentPoints);
}
function _onMouseUp(evt) {
    clearTimeout(state.preventClickTimeout);
    if (doubleClickState.doubleClickTimeout) {
        if (!doubleClickState.mouseUpEvent) {
            doubleClickState.mouseUpEvent = evt;
            state.element.addEventListener('mousemove', _onMouseMove);
        }
        else {
            _cleanUp();
        }
    }
    else {
        const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;
        const currentPoints = (0,_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, state.element);
        const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);
        const eventDetail = {
            event: evt,
            eventName,
            mouseButton: state.mouseButton,
            element: state.element,
            renderingEngineId: state.renderingEngineId,
            viewportId: state.viewportId,
            camera: {},
            startPoints: _copyPoints(state.startPoints),
            lastPoints: _copyPoints(state.lastPoints),
            currentPoints,
            deltaPoints,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(eventDetail.element, eventName, eventDetail);
        _cleanUp();
    }
    document.removeEventListener('mousemove', _onMouseDrag);
}
function _onMouseMove(evt) {
    const currentPoints = (0,_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, state.element);
    const lastPoints = _updateMouseEventsLastPoints(state.element, state.lastPoints);
    const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);
    if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {
        return;
    }
    _doStateMouseDownAndUp();
    (0,_mouseMoveListener__WEBPACK_IMPORTED_MODULE_2__["default"])(evt);
}
function _isDragPastDoubleClickTolerance(delta) {
    return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;
}
function _preventClickHandler() {
    state.isClickEvent = false;
}
function _doStateMouseDownAndUp() {
    doubleClickState.ignoreDoubleClick = true;
    const mouseDownEvent = doubleClickState.mouseDownEvent;
    const mouseUpEvent = doubleClickState.mouseUpEvent;
    _clearDoubleClickTimeoutAndEvents();
    _doMouseDown(mouseDownEvent);
    if (mouseUpEvent) {
        _onMouseUp(mouseUpEvent);
    }
}
function _clearDoubleClickTimeoutAndEvents() {
    if (doubleClickState.doubleClickTimeout) {
        clearTimeout(doubleClickState.doubleClickTimeout);
        doubleClickState.doubleClickTimeout = null;
    }
    doubleClickState.mouseDownEvent = null;
    doubleClickState.mouseUpEvent = null;
}
function _cleanUp() {
    document.removeEventListener('mouseup', _onMouseUp);
    state.element?.removeEventListener('mousemove', _onMouseMove);
    state.element?.addEventListener('mousemove', _mouseMoveListener__WEBPACK_IMPORTED_MODULE_2__["default"]);
    _clearDoubleClickTimeoutAndEvents();
    state = JSON.parse(JSON.stringify(defaultState));
}
function _copyPoints(points) {
    return JSON.parse(JSON.stringify(points));
}
function _updateMouseEventsLastPoints(element, lastPoints) {
    const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element) || {};
    if (!viewport) {
        return lastPoints;
    }
    const world = viewport.canvasToWorld(lastPoints.canvas);
    return {
        page: lastPoints.page,
        client: lastPoints.client,
        canvas: lastPoints.canvas,
        world,
    };
}
function _getDeltaPoints(currentPoints, lastPoints) {
    if (!currentPoints || !lastPoints) {
        return {
            page: [0, 0],
            client: [0, 0],
            canvas: [0, 0],
            world: [0, 0, 0],
        };
    }
    return {
        page: _subtractPoints2D(currentPoints.page, lastPoints.page),
        client: _subtractPoints2D(currentPoints.client, lastPoints.client),
        canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),
        world: _subtractPoints3D(currentPoints.world, lastPoints.world),
    };
}
function _subtractPoints2D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1]];
}
function _subtractPoints3D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];
}
function getMouseButton() {
    return state.mouseButton;
}
function mouseDoubleClickIgnoreListener(evt) {
    if (doubleClickState.ignoreDoubleClick) {
        doubleClickState.ignoreDoubleClick = false;
        evt.stopImmediatePropagation();
        evt.preventDefault();
    }
    else {
        _cleanUp();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseDownListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _getMouseEventPoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMouseEventPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js");



const eventName = _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].MOUSE_MOVE;
function mouseMoveListener(evt) {
    const element = evt.currentTarget;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const { renderingEngineId, viewportId } = enabledElement;
    const currentPoints = (0,_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_2__["default"])(evt);
    const eventDetail = {
        renderingEngineId,
        viewportId,
        camera: {},
        element,
        currentPoints,
        eventName,
        event: evt,
    };
    const consumed = !(0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(element, eventName, eventDetail);
    if (consumed) {
        evt.stopImmediatePropagation();
        evt.preventDefault();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseMoveListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/DataArray */ "../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js");
/* harmony import */ var _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kitware/vtk.js/Common/DataModel/ImageData */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation/SegmentationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js");
/* harmony import */ var _stateManagement_segmentation_updateLabelmapSegmentationImageReferences__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation/updateLabelmapSegmentationImageReferences */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js");
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/segmentation/helpers/getSegmentationActor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");









const enable = function (element) {
    if (!element) {
        return;
    }
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.BaseVolumeViewport) {
        return;
    }
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const perViewportManualTriggers = new Map();
function _imageChangeEventListener(evt) {
    const eventData = evt.detail;
    const { viewportId, renderingEngineId } = eventData;
    const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(viewportId, renderingEngineId);
    const representations = (0,_stateManagement_segmentation_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_8__.getSegmentationRepresentations)(viewportId);
    if (!representations?.length) {
        return;
    }
    const labelmapRepresentations = representations.filter((representation) => representation.type === _enums__WEBPACK_IMPORTED_MODULE_6__.SegmentationRepresentations.Labelmap);
    const actors = viewport.getActors();
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        (0,_stateManagement_segmentation_updateLabelmapSegmentationImageReferences__WEBPACK_IMPORTED_MODULE_4__.updateLabelmapSegmentationImageReferences)(viewportId, segmentationId);
    });
    const labelmapActors = labelmapRepresentations
        .flatMap((representation) => {
        return (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_7__.getLabelmapActorEntries)(viewportId, representation.segmentationId);
    })
        .filter((actor) => actor !== undefined);
    if (!labelmapActors.length) {
        return;
    }
    labelmapActors.forEach((actor) => {
        const validActor = labelmapRepresentations.find((representation) => {
            const derivedImageIds = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__.getCurrentLabelmapImageIdsForViewport)(viewportId, representation.segmentationId);
            return derivedImageIds?.includes(actor.referencedId);
        });
        if (!validActor) {
            viewport.removeActors([actor.uid]);
        }
    });
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        const currentImageId = viewport.getCurrentImageId();
        const derivedImageIds = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__.getCurrentLabelmapImageIdsForViewport)(viewportId, segmentationId);
        if (!derivedImageIds) {
            return;
        }
        const updateSegmentationActor = (derivedImageId) => {
            const derivedImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.cache.getImage(derivedImageId);
            if (!derivedImage) {
                console.warn('No derived image found in the cache for segmentation representation', representation);
                return;
            }
            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);
            if (!segmentationActorInput) {
                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);
                const currentImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.cache.getImage(currentImageId) ||
                    {
                        imageId: currentImageId,
                    };
                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);
                const originToUse = currentOrigin;
                const constructor = derivedImage.voxelManager.getConstructor();
                const newPixelData = derivedImage.voxelManager.getScalarData();
                const scalarArray = _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance({
                    name: 'Pixels',
                    numberOfComponents: 1,
                    values: new constructor(newPixelData),
                });
                const imageData = _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
                imageData.setDimensions(dimensions[0], dimensions[1], 1);
                imageData.setSpacing(spacing);
                imageData.setDirection(direction);
                imageData.setOrigin(originToUse);
                imageData.getPointData().setScalars(scalarArray);
                imageData.modified();
                viewport.addImages([
                    {
                        imageId: derivedImageId,
                        representationUID: `${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_6__.SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,
                        callback: ({ imageActor }) => {
                            imageActor.getMapper().setInputData(imageData);
                        },
                    },
                ]);
                (0,_stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRender)(viewportId);
                return;
            }
            else {
                const segmentationImageData = segmentationActorInput.actor
                    .getMapper()
                    .getInputData();
                if (segmentationImageData.setDerivedImage) {
                    segmentationImageData.setDerivedImage(derivedImage);
                }
                else {
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);
                }
            }
        };
        derivedImageIds.forEach(updateSegmentationActor);
        viewport.render();
        if (evt.type === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.Events.IMAGE_RENDERED) {
            viewport.element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/index.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imageChangeEventListener: () => (/* reexport safe */ _imageChangeEventListener__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   segmentationDataModifiedEventListener: () => (/* reexport safe */ _segmentationDataModifiedEventListener__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   segmentationModifiedListener: () => (/* reexport safe */ _segmentationModifiedEventListener__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _segmentationDataModifiedEventListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./segmentationDataModifiedEventListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js");
/* harmony import */ var _segmentationModifiedEventListener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segmentationModifiedEventListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js");
/* harmony import */ var _imageChangeEventListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imageChangeEventListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _performVolumeLabelmapUpdate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./performVolumeLabelmapUpdate */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js");
/* harmony import */ var _performStackLabelmapUpdate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./performStackLabelmapUpdate */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getViewportIdsWithSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js");






const onLabelmapSegmentationDataModified = function (evt) {
    const { segmentationId, modifiedSlicesToUse } = evt.detail;
    const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__.getSegmentation)(segmentationId);
    const viewportIds = (0,_stateManagement_segmentation_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_5__.getViewportIdsWithSegmentation)(segmentationId);
    const hasVolumeViewport = viewportIds.some((viewportId) => {
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        return viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport;
    });
    const hasStackViewport = viewportIds.some((viewportId) => {
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        return viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport;
    });
    const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;
    viewportIds.forEach((viewportId) => {
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            (0,_performVolumeLabelmapUpdate__WEBPACK_IMPORTED_MODULE_2__.performVolumeLabelmapUpdate)({
                modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,
                representationData,
                type: _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap,
            });
        }
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
            (0,_performStackLabelmapUpdate__WEBPACK_IMPORTED_MODULE_3__.performStackLabelmapUpdate)({
                viewportIds,
                segmentationId,
            });
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (onLabelmapSegmentationDataModified);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js":
/*!******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   performStackLabelmapUpdate: () => (/* binding */ performStackLabelmapUpdate)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../stateManagement/segmentation/helpers/getSegmentationActor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");





function performStackLabelmapUpdate({ viewportIds, segmentationId, }) {
    viewportIds.forEach((viewportId) => {
        let representations = (0,_stateManagement_segmentation_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__.getSegmentationRepresentations)(viewportId, {
            segmentationId,
        });
        representations = representations.filter((representation) => representation.type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap);
        representations.forEach((representation) => {
            if (representation.segmentationId !== segmentationId) {
                return;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
                return;
            }
            const actorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_2__.getLabelmapActorEntries)(viewportId, segmentationId);
            if (!actorEntries?.length) {
                return;
            }
            actorEntries.forEach((actorEntry, i) => {
                const segImageData = actorEntry.actor.getMapper().getInputData();
                const currentSegmentationImageIds = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_4__.getCurrentLabelmapImageIdsForViewport)(viewportId, segmentationId);
                const segmentationImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(currentSegmentationImageIds[i]);
                segImageData.modified();
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);
            });
        });
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   performVolumeLabelmapUpdate: () => (/* binding */ performVolumeLabelmapUpdate)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type, }) {
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(representationData[type].volumeId);
    if (!segmentationVolume) {
        console.warn('segmentation not found in cache');
        return;
    }
    const { imageData, vtkOpenGLTexture } = segmentationVolume;
    let slicesToUpdate;
    if (modifiedSlicesToUse?.length > 0) {
        slicesToUpdate = modifiedSlicesToUse;
    }
    else {
        const numSlices = imageData.getDimensions()[2];
        slicesToUpdate = [...Array(numSlices).keys()];
    }
    slicesToUpdate.forEach((i) => {
        vtkOpenGLTexture.setUpdatedFrame(i);
    });
    imageData.modified();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js":
/*!********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/SegmentationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js");
/* harmony import */ var _labelmap_onLabelmapSegmentationDataModified__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./labelmap/onLabelmapSegmentationDataModified */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");



const onSegmentationDataModified = function (evt) {
    const { segmentationId } = evt.detail;
    const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
    if (representationData.Labelmap) {
        (0,_labelmap_onLabelmapSegmentationDataModified__WEBPACK_IMPORTED_MODULE_1__["default"])(evt);
    }
    (0,_stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationRenderBySegmentationId)(segmentationId);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (onSegmentationDataModified);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js":
/*!****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/SegmentationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js");

const segmentationModifiedListener = function (evt) {
    const { segmentationId } = evt.detail;
    (0,_stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationRenderBySegmentationId)(segmentationId);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (segmentationModifiedListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/SegmentationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js");

const segmentationRepresentationModifiedListener = function (evt) {
    const { viewportId } = evt.detail;
    (0,_stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationRender)(viewportId);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (segmentationRepresentationModifiedListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/getTouchEventPoints.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/getTouchEventPoints.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTouchEventPoints)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function getTouchEventPoints(evt, element) {
    const elementToUse = element || evt.currentTarget;
    const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;
    return Object.keys(touches).map((i) => {
        const clientPoint = _clientToPoint(touches[i]);
        const pagePoint = _pageToPoint(touches[i]);
        const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(elementToUse);
        const worldPoint = viewport.canvasToWorld(canvasPoint);
        return {
            page: pagePoint,
            client: clientPoint,
            canvas: canvasPoint,
            world: worldPoint,
            touch: {
                identifier: i,
                radiusX: touches[i].radiusX,
                radiusY: touches[i].radiusY,
                force: touches[i].force,
                rotationAngle: touches[i].rotationAngle,
            },
        };
    });
}
function _pagePointsToCanvasPoints(element, pagePoint) {
    const rect = element.getBoundingClientRect();
    return [
        pagePoint[0] - rect.left - window.pageXOffset,
        pagePoint[1] - rect.top - window.pageYOffset,
    ];
}
function _pageToPoint(touch) {
    return [touch.pageX, touch.pageY];
}
function _clientToPoint(touch) {
    return [touch.clientX, touch.clientY];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _preventGhostClick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./preventGhostClick */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js");
/* harmony import */ var _touchStartListener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./touchStartListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js");


function disable(element) {
    _preventGhostClick__WEBPACK_IMPORTED_MODULE_0__["default"].disable(element);
    element.removeEventListener('touchstart', _touchStartListener__WEBPACK_IMPORTED_MODULE_1__["default"]);
}
function enable(element) {
    disable(element);
    _preventGhostClick__WEBPACK_IMPORTED_MODULE_0__["default"].enable(element);
    element.addEventListener('touchstart', _touchStartListener__WEBPACK_IMPORTED_MODULE_1__["default"], {
        passive: false,
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const antiGhostDelay = 2000, pointerType = {
    mouse: 0,
    touch: 1,
};
let lastInteractionType, lastInteractionTime;
function handleTap(type, e) {
    const now = Date.now();
    if (type !== lastInteractionType) {
        if (now - lastInteractionTime <= antiGhostDelay) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }
        lastInteractionType = type;
    }
    lastInteractionTime = now;
}
const handleTapMouse = handleTap.bind(null, pointerType.mouse);
const handleTapTouch = handleTap.bind(null, pointerType.touch);
function attachEvents(element, eventList, interactionType) {
    const tapHandler = interactionType ? handleTapMouse : handleTapTouch;
    eventList.forEach(function (eventName) {
        element.addEventListener(eventName, tapHandler, { passive: false });
    });
}
function removeEvents(element, eventList, interactionType) {
    const tapHandler = interactionType ? handleTapMouse : handleTapTouch;
    eventList.forEach(function (eventName) {
        element.removeEventListener(eventName, tapHandler);
    });
}
const mouseEvents = ['mousedown', 'mouseup', 'mousemove'];
const touchEvents = ['touchstart', 'touchend'];
function disable(element) {
    removeEvents(element, mouseEvents, pointerType.mouse);
    removeEvents(element, touchEvents, pointerType.touch);
}
function enable(element) {
    disable(element);
    attachEvents(element, mouseEvents, pointerType.mouse);
    attachEvents(element, touchEvents, pointerType.touch);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _enums_Touch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/Touch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js");
/* harmony import */ var _getTouchEventPoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getTouchEventPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/getTouchEventPoints.js");
/* harmony import */ var _utilities_touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/touch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js");






const runtimeSettings = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Settings.getRuntimeSettings();
const { TOUCH_START, TOUCH_START_ACTIVATE, TOUCH_PRESS, TOUCH_DRAG, TOUCH_END, TOUCH_TAP, TOUCH_SWIPE, } = _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"];
const zeroIPoint = {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0],
};
const zeroIDistance = {
    page: 0,
    client: 0,
    canvas: 0,
    world: 0,
};
const defaultState = {
    renderingEngineId: undefined,
    viewportId: undefined,
    element: null,
    startPointsList: [
        {
            ...zeroIPoint,
            touch: null,
        },
    ],
    lastPointsList: [
        {
            ...zeroIPoint,
            touch: null,
        },
    ],
    isTouchStart: false,
    startTime: null,
    pressTimeout: null,
    pressDelay: 700,
    pressMaxDistance: 5,
    accumulatedDistance: zeroIDistance,
    swipeDistanceThreshold: 48,
    swiped: false,
    swipeToleranceMs: 300,
};
const defaultTapState = {
    renderingEngineId: undefined,
    viewportId: undefined,
    element: null,
    startPointsList: [
        {
            ...zeroIPoint,
            touch: null,
        },
    ],
    taps: 0,
    tapTimeout: null,
    tapMaxDistance: 24,
    tapToleranceMs: 300,
};
let state = JSON.parse(JSON.stringify(defaultState));
let tapState = JSON.parse(JSON.stringify(defaultTapState));
function triggerEventCallback(ele, name, eventDetail) {
    return (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(ele, name, eventDetail);
}
function touchStartListener(evt) {
    state.element = evt.currentTarget;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(state.element);
    const { renderingEngineId, viewportId } = enabledElement;
    state.renderingEngineId = renderingEngineId;
    state.viewportId = viewportId;
    if (state.isTouchStart) {
        return;
    }
    clearTimeout(state.pressTimeout);
    state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);
    _onTouchStart(evt);
    document.addEventListener('touchmove', _onTouchDrag);
    document.addEventListener('touchend', _onTouchEnd);
}
function _onTouchPress(evt) {
    const totalDistance = state.accumulatedDistance.canvas;
    if (totalDistance > state.pressMaxDistance) {
        return;
    }
    const eventDetail = {
        event: evt,
        eventName: TOUCH_PRESS,
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        camera: {},
        element: state.element,
        startPointsList: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(state.startPointsList),
        lastPointsList: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(state.lastPointsList),
        startPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPoints)((0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(state.startPointsList)),
        lastPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPoints)((0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(state.lastPointsList)),
    };
    triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);
}
function _onTouchStart(evt) {
    state.isTouchStart = true;
    state.startTime = new Date();
    const startPointsList = (0,_getTouchEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, state.element);
    const startPoints = (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(startPointsList);
    const deltaPoints = zeroIPoint;
    const deltaDistance = zeroIDistance;
    const eventDetail = {
        event: evt,
        eventName: TOUCH_START,
        element: state.element,
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        camera: {},
        startPointsList: startPointsList,
        lastPointsList: startPointsList,
        currentPointsList: startPointsList,
        startPoints: startPoints,
        lastPoints: startPoints,
        currentPoints: startPoints,
        deltaPoints,
        deltaDistance,
    };
    state.startPointsList = (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(eventDetail.startPointsList);
    state.lastPointsList = (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(eventDetail.lastPointsList);
    const eventDidPropagate = triggerEventCallback(eventDetail.element, TOUCH_START, eventDetail);
    if (eventDidPropagate) {
        triggerEventCallback(eventDetail.element, TOUCH_START_ACTIVATE, eventDetail);
    }
}
function _onTouchDrag(evt) {
    const currentPointsList = (0,_getTouchEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, state.element);
    const lastPointsList = _updateTouchEventsLastPoints(state.element, state.lastPointsList);
    const deltaPoints = currentPointsList.length === lastPointsList.length
        ? (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaPoints)(currentPointsList, lastPointsList)
        : zeroIPoint;
    const deltaDistance = currentPointsList.length === lastPointsList.length
        ? (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaDistanceBetweenIPoints)(currentPointsList, lastPointsList)
        : zeroIDistance;
    const totalDistance = currentPointsList.length === lastPointsList.length
        ? (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaDistance)(currentPointsList, state.lastPointsList)
        : zeroIDistance;
    state.accumulatedDistance = {
        page: state.accumulatedDistance.page + totalDistance.page,
        client: state.accumulatedDistance.client + totalDistance.client,
        canvas: state.accumulatedDistance.canvas + totalDistance.canvas,
        world: state.accumulatedDistance.world + totalDistance.world,
    };
    const eventDetail = {
        event: evt,
        eventName: TOUCH_DRAG,
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        camera: {},
        element: state.element,
        startPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(state.startPointsList),
        lastPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(lastPointsList),
        currentPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(currentPointsList),
        startPointsList: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(state.startPointsList),
        lastPointsList: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(lastPointsList),
        currentPointsList,
        deltaPoints: deltaPoints,
        deltaDistance: deltaDistance,
    };
    triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);
    _checkTouchSwipe(evt, deltaPoints);
    state.lastPointsList = (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(currentPointsList);
}
function _onTouchEnd(evt) {
    clearTimeout(state.pressTimeout);
    const currentPointsList = (0,_getTouchEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, state.element);
    const lastPointsList = _updateTouchEventsLastPoints(state.element, state.lastPointsList);
    const deltaPoints = currentPointsList.length === lastPointsList.length
        ? (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaPoints)(currentPointsList, lastPointsList)
        : (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaPoints)(currentPointsList, currentPointsList);
    const deltaDistance = currentPointsList.length === lastPointsList.length
        ? (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaDistanceBetweenIPoints)(currentPointsList, lastPointsList)
        : (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaDistanceBetweenIPoints)(currentPointsList, currentPointsList);
    const eventDetail = {
        event: evt,
        eventName: TOUCH_END,
        element: state.element,
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        camera: {},
        startPointsList: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(state.startPointsList),
        lastPointsList: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.copyPointsList)(lastPointsList),
        currentPointsList,
        startPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(state.startPointsList),
        lastPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(lastPointsList),
        currentPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(currentPointsList),
        deltaPoints,
        deltaDistance,
    };
    triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);
    _checkTouchTap(evt);
    state = JSON.parse(JSON.stringify(defaultState));
    document.removeEventListener('touchmove', _onTouchDrag);
    document.removeEventListener('touchend', _onTouchEnd);
}
function _checkTouchTap(evt) {
    const currentTime = new Date().getTime();
    const startTime = state.startTime.getTime();
    if (currentTime - startTime > tapState.tapToleranceMs) {
        return;
    }
    if (tapState.taps === 0) {
        tapState.element = state.element;
        tapState.renderingEngineId = state.renderingEngineId;
        tapState.viewportId = state.viewportId;
        tapState.startPointsList = state.startPointsList;
    }
    if (tapState.taps > 0 &&
        !(tapState.element == state.element &&
            tapState.renderingEngineId == state.renderingEngineId &&
            tapState.viewportId == state.viewportId)) {
        return;
    }
    const currentPointsList = (0,_getTouchEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt, tapState.element);
    const distanceFromStart = (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getDeltaDistance)(currentPointsList, tapState.startPointsList).canvas;
    if (distanceFromStart > tapState.tapMaxDistance) {
        return;
    }
    clearTimeout(tapState.tapTimeout);
    tapState.taps += 1;
    tapState.tapTimeout = setTimeout(() => {
        const eventDetail = {
            event: evt,
            eventName: TOUCH_TAP,
            element: tapState.element,
            renderingEngineId: tapState.renderingEngineId,
            viewportId: tapState.viewportId,
            camera: {},
            currentPointsList,
            currentPoints: (0,_utilities_touch__WEBPACK_IMPORTED_MODULE_4__.getMeanTouchPoints)(currentPointsList),
            taps: tapState.taps,
        };
        triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);
        tapState = JSON.parse(JSON.stringify(defaultTapState));
    }, tapState.tapToleranceMs);
}
function _checkTouchSwipe(evt, deltaPoints) {
    const currentTime = new Date().getTime();
    const startTime = state.startTime.getTime();
    if (state.swiped || currentTime - startTime > state.swipeToleranceMs) {
        return;
    }
    const [x, y] = deltaPoints.canvas;
    const eventDetail = {
        event: evt,
        eventName: TOUCH_SWIPE,
        renderingEngineId: state.renderingEngineId,
        viewportId: state.viewportId,
        camera: {},
        element: state.element,
        swipe: null,
    };
    if (Math.abs(x) > state.swipeDistanceThreshold) {
        eventDetail.swipe = x > 0 ? _enums_Touch__WEBPACK_IMPORTED_MODULE_2__.Swipe.RIGHT : _enums_Touch__WEBPACK_IMPORTED_MODULE_2__.Swipe.LEFT;
        triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);
        state.swiped = true;
    }
    if (Math.abs(y) > state.swipeDistanceThreshold) {
        eventDetail.swipe = y > 0 ? _enums_Touch__WEBPACK_IMPORTED_MODULE_2__.Swipe.DOWN : _enums_Touch__WEBPACK_IMPORTED_MODULE_2__.Swipe.UP;
        triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);
        state.swiped = true;
    }
}
function _updateTouchEventsLastPoints(element, lastPoints) {
    const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    return lastPoints.map((lp) => {
        const world = viewport.canvasToWorld(lp.canvas);
        return {
            page: lp.page,
            client: lp.client,
            canvas: lp.canvas,
            world,
            touch: lp.touch,
        };
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (touchStartListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wheelListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wheelListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js");

function enable(element) {
    disable(element);
    element.addEventListener('wheel', _wheelListener__WEBPACK_IMPORTED_MODULE_0__["default"], { passive: false });
}
function disable(element) {
    element.removeEventListener('wheel', _wheelListener__WEBPACK_IMPORTED_MODULE_0__["default"]);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/normalizeWheel.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/normalizeWheel.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeWheel)
/* harmony export */ });
const PIXEL_STEP = 10;
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;
function normalizeWheel(event) {
    let spinX = 0, spinY = 0, pixelX = 0, pixelY = 0;
    if ('detail' in event) {
        spinY = event.detail;
    }
    if ('wheelDelta' in event) {
        spinY = -event.wheelDelta / 120;
    }
    if ('wheelDeltaY' in event) {
        spinY = -event.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in event) {
        spinX = -event.wheelDeltaX / 120;
    }
    pixelX = spinX * PIXEL_STEP;
    pixelY = spinY * PIXEL_STEP;
    if ('deltaY' in event) {
        pixelY = event.deltaY;
    }
    if ('deltaX' in event) {
        pixelX = event.deltaX;
    }
    if ((pixelX || pixelY) && event.deltaMode) {
        if (event.deltaMode === 1) {
            pixelX *= LINE_HEIGHT;
            pixelY *= LINE_HEIGHT;
        }
        else {
            pixelX *= PAGE_HEIGHT;
            pixelY *= PAGE_HEIGHT;
        }
    }
    if (pixelX && !spinX) {
        spinX = pixelX < 1 ? -1 : 1;
    }
    if (pixelY && !spinY) {
        spinY = pixelY < 1 ? -1 : 1;
    }
    return {
        spinX,
        spinY,
        pixelX,
        pixelY,
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _normalizeWheel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalizeWheel */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/normalizeWheel.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _mouse_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mouse/getMouseEventPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js");




function wheelListener(evt) {
    const element = evt.currentTarget;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngineId, viewportId } = enabledElement;
    if (evt.deltaY > -1 && evt.deltaY < 1) {
        return;
    }
    evt.preventDefault();
    const { spinX, spinY, pixelX, pixelY } = (0,_normalizeWheel__WEBPACK_IMPORTED_MODULE_1__["default"])(evt);
    const direction = spinY < 0 ? -1 : 1;
    const eventDetail = {
        event: evt,
        eventName: _enums_Events__WEBPACK_IMPORTED_MODULE_2__["default"].MOUSE_WHEEL,
        renderingEngineId,
        viewportId,
        element,
        camera: {},
        detail: evt,
        wheel: {
            spinX,
            spinY,
            pixelX,
            pixelY,
            direction,
        },
        points: (0,_mouse_getMouseEventPoints__WEBPACK_IMPORTED_MODULE_3__["default"])(evt),
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(element, _enums_Events__WEBPACK_IMPORTED_MODULE_2__["default"].MOUSE_WHEEL, eventDetail);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wheelListener);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/index.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdvancedMagnifyTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.AdvancedMagnifyTool),
/* harmony export */   AngleTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.AngleTool),
/* harmony export */   AnnotationDisplayTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.AnnotationDisplayTool),
/* harmony export */   AnnotationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.AnnotationTool),
/* harmony export */   ArrowAnnotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.ArrowAnnotateTool),
/* harmony export */   BaseTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.BaseTool),
/* harmony export */   BidirectionalTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.BidirectionalTool),
/* harmony export */   BrushTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.BrushTool),
/* harmony export */   CONSTANTS: () => (/* reexport module object */ _constants__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   CircleROIStartEndThresholdTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.CircleROIStartEndThresholdTool),
/* harmony export */   CircleROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.CircleROITool),
/* harmony export */   CircleScissorsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.CircleScissorsTool),
/* harmony export */   CobbAngleTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.CobbAngleTool),
/* harmony export */   CrosshairsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.CrosshairsTool),
/* harmony export */   DragProbeTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.DragProbeTool),
/* harmony export */   ETDRSGridTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.ETDRSGridTool),
/* harmony export */   EllipticalROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.EllipticalROITool),
/* harmony export */   Enums: () => (/* reexport module object */ _enums__WEBPACK_IMPORTED_MODULE_15__),
/* harmony export */   EraserTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.EraserTool),
/* harmony export */   HeightTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.HeightTool),
/* harmony export */   KeyImageTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.KeyImageTool),
/* harmony export */   LabelTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.LabelTool),
/* harmony export */   LabelmapBaseTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.LabelmapBaseTool),
/* harmony export */   LengthTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.LengthTool),
/* harmony export */   LivewireContourSegmentationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.LivewireContourSegmentationTool),
/* harmony export */   LivewireContourTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.LivewireContourTool),
/* harmony export */   MIPJumpToClickTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.MIPJumpToClickTool),
/* harmony export */   MagnifyTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.MagnifyTool),
/* harmony export */   OrientationMarkerTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.OrientationMarkerTool),
/* harmony export */   OverlayGridTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.OverlayGridTool),
/* harmony export */   PaintFillTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.PaintFillTool),
/* harmony export */   PanTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.PanTool),
/* harmony export */   PlanarFreehandContourSegmentationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.PlanarFreehandContourSegmentationTool),
/* harmony export */   PlanarFreehandROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.PlanarFreehandROITool),
/* harmony export */   PlanarRotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.PlanarRotateTool),
/* harmony export */   ProbeTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.ProbeTool),
/* harmony export */   RectangleROIStartEndThresholdTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.RectangleROIStartEndThresholdTool),
/* harmony export */   RectangleROIThresholdTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.RectangleROIThresholdTool),
/* harmony export */   RectangleROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.RectangleROITool),
/* harmony export */   RectangleScissorsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.RectangleScissorsTool),
/* harmony export */   ReferenceCursors: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.ReferenceCursors),
/* harmony export */   ReferenceLinesTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.ReferenceLinesTool),
/* harmony export */   RegionSegmentPlusTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.RegionSegmentPlusTool),
/* harmony export */   RegionSegmentTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.RegionSegmentTool),
/* harmony export */   ScaleOverlayTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.ScaleOverlayTool),
/* harmony export */   SculptorTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SculptorTool),
/* harmony export */   SegmentBidirectionalTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SegmentBidirectionalTool),
/* harmony export */   SegmentLabelTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SegmentLabelTool),
/* harmony export */   SegmentSelectTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SegmentSelectTool),
/* harmony export */   SegmentationIntersectionTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SegmentationIntersectionTool),
/* harmony export */   SphereScissorsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SphereScissorsTool),
/* harmony export */   SplineContourSegmentationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SplineContourSegmentationTool),
/* harmony export */   SplineROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.SplineROITool),
/* harmony export */   StackScrollTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.StackScrollTool),
/* harmony export */   Synchronizer: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.Synchronizer),
/* harmony export */   SynchronizerManager: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.SynchronizerManager),
/* harmony export */   ToolGroupManager: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.ToolGroupManager),
/* harmony export */   TrackballRotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.TrackballRotateTool),
/* harmony export */   Types: () => (/* reexport module object */ _types__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   UltrasoundDirectionalTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.UltrasoundDirectionalTool),
/* harmony export */   VideoRedactionTool: () => (/* reexport safe */ _tools_annotation_VideoRedactionTool__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   VolumeRotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.VolumeRotateTool),
/* harmony export */   WholeBodySegmentTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.WholeBodySegmentTool),
/* harmony export */   WindowLevelRegionTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.WindowLevelRegionTool),
/* harmony export */   WindowLevelTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.WindowLevelTool),
/* harmony export */   ZoomTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_13__.ZoomTool),
/* harmony export */   addTool: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.addTool),
/* harmony export */   annotation: () => (/* reexport module object */ _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_10__),
/* harmony export */   cancelActiveManipulations: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.cancelActiveManipulations),
/* harmony export */   cursors: () => (/* reexport module object */ _cursors__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   destroy: () => (/* reexport safe */ _init__WEBPACK_IMPORTED_MODULE_0__.destroy),
/* harmony export */   drawing: () => (/* reexport module object */ _drawingSvg__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   init: () => (/* reexport safe */ _init__WEBPACK_IMPORTED_MODULE_0__.init),
/* harmony export */   removeTool: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.removeTool),
/* harmony export */   segmentation: () => (/* reexport module object */ _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_11__),
/* harmony export */   splines: () => (/* reexport module object */ _tools_annotation_splines__WEBPACK_IMPORTED_MODULE_12__),
/* harmony export */   state: () => (/* reexport safe */ _store_state__WEBPACK_IMPORTED_MODULE_2__.state),
/* harmony export */   store: () => (/* reexport module object */ _store__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   synchronizers: () => (/* reexport module object */ _synchronizers__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   utilities: () => (/* reexport module object */ _utilities__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   version: () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_4__.version)
/* harmony export */ });
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "../../../node_modules/@cornerstonejs/tools/dist/esm/init.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "../../../node_modules/@cornerstonejs/tools/dist/esm/constants/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./version */ "../../../node_modules/@cornerstonejs/tools/dist/esm/version.js");
/* harmony import */ var _synchronizers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./synchronizers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js");
/* harmony import */ var _cursors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cursors */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types */ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./stateManagement/annotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js");
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./stateManagement/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js");
/* harmony import */ var _tools_annotation_splines__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/annotation/splines */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/index.js");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tools */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/index.js");
/* harmony import */ var _tools_annotation_VideoRedactionTool__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tools/annotation/VideoRedactionTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");




















/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/init.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/init.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./store */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./eventListeners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js");
/* harmony import */ var _eventDispatchers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./eventDispatchers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./stateManagement/segmentation/SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./eventListeners/segmentation/segmentationRepresentationModifiedListener */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/config.js");











let csToolsInitialized = false;
function init(defaultConfiguration = {}) {
    if (csToolsInitialized) {
        return;
    }
    (0,_config__WEBPACK_IMPORTED_MODULE_10__.setConfig)(defaultConfiguration);
    _addCornerstoneEventListeners();
    _addCornerstoneToolsEventListeners();
    csToolsInitialized = true;
}
function destroy() {
    _removeCornerstoneEventListeners();
    _removeCornerstoneToolsEventListeners();
    _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__.destroy();
    (0,_store_state__WEBPACK_IMPORTED_MODULE_4__.resetCornerstoneToolsState)();
    const annotationManager = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotationManager)();
    const segmentationStateManager = _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_8__.defaultSegmentationStateManager;
    annotationManager.restoreAnnotations({});
    segmentationStateManager.resetState();
    csToolsInitialized = false;
}
function _addCornerstoneEventListeners() {
    _removeCornerstoneEventListeners();
    const elementEnabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED;
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(elementEnabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.addEnabledElement);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(elementDisabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.removeEnabledElement);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_6__.annotationInterpolationEventDispatcher.enable();
}
function _removeCornerstoneEventListeners() {
    const elementEnabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED;
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(elementEnabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.addEnabledElement);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(elementDisabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.removeEnabledElement);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_6__.annotationInterpolationEventDispatcher.disable();
}
function _addCornerstoneToolsEventListeners() {
    _removeCornerstoneToolsEventListeners();
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_COMPLETED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationCompletedListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationModifiedListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationSelectionListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationSelectionListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_REMOVED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationRemovedListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.segmentationModifiedListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_DATA_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.segmentationDataModifiedEventListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_MODIFIED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__["default"]);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_ADDED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__["default"]);
}
function _removeCornerstoneToolsEventListeners() {
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_COMPLETED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationCompletedListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationModifiedListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationSelectionListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.annotationSelectionListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.segmentationModifiedListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_DATA_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__.segmentationDataModifiedEventListener);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_MODIFIED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__["default"]);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_ADDED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__["default"]);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (init);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   color: () => (/* reexport module object */ _segmentationColor__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   style: () => (/* reexport module object */ _styleHelpers__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   visibility: () => (/* reexport module object */ _segmentationVisibility__WEBPACK_IMPORTED_MODULE_1__)
/* harmony export */ });
/* harmony import */ var _segmentationColor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./segmentationColor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js");
/* harmony import */ var _segmentationVisibility__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segmentationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js");
/* harmony import */ var _styleHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styleHelpers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHiddenSegmentIndices: () => (/* binding */ getHiddenSegmentIndices),
/* harmony export */   getSegmentIndexVisibility: () => (/* binding */ getSegmentIndexVisibility),
/* harmony export */   getSegmentationRepresentationVisibility: () => (/* binding */ getSegmentationRepresentationVisibility),
/* harmony export */   setSegmentIndexVisibility: () => (/* binding */ setSegmentIndexVisibility),
/* harmony export */   setSegmentationRepresentationVisibility: () => (/* binding */ setSegmentationRepresentationVisibility)
/* harmony export */ });
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _setSegmentationRepresentationVisibility__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../setSegmentationRepresentationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js");
/* harmony import */ var _getSegmentationRepresentationVisibility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getSegmentationRepresentationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js");
/* harmony import */ var _SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../SegmentationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");





function setSegmentationRepresentationVisibility(viewportId, specifier, visibility) {
    const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentationRepresentations)(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        (0,_setSegmentationRepresentationVisibility__WEBPACK_IMPORTED_MODULE_1__.setSegmentationRepresentationVisibility)(viewportId, {
            segmentationId: representation.segmentationId,
            type: representation.type,
        }, visibility);
    });
}
function getSegmentationRepresentationVisibility(viewportId, specifier) {
    return (0,_getSegmentationRepresentationVisibility__WEBPACK_IMPORTED_MODULE_2__.getSegmentationRepresentationVisibility)(viewportId, specifier);
}
function setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {
    const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentationRepresentations)(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        representation.segments[segmentIndex].visible = visibility;
    });
    (0,_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRenderBySegmentationId)(specifier.segmentationId);
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, specifier.segmentationId);
}
function getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {
    const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);
    return !hiddenSegments.has(segmentIndex);
}
function getHiddenSegmentIndices(viewportId, specifier) {
    const representation = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentationRepresentation)(viewportId, specifier);
    if (!representation) {
        return new Set();
    }
    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {
        if (!segment.visible) {
            acc.add(Number(segmentIndex));
        }
        return acc;
    }, new Set());
    return segmentsHidden;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRenderInactiveSegmentations: () => (/* binding */ getRenderInactiveSegmentations),
/* harmony export */   getStyle: () => (/* binding */ getStyle),
/* harmony export */   hasCustomStyle: () => (/* binding */ hasCustomStyle),
/* harmony export */   resetToGlobalStyle: () => (/* binding */ resetToGlobalStyle),
/* harmony export */   setRenderInactiveSegmentations: () => (/* binding */ setRenderInactiveSegmentations),
/* harmony export */   setStyle: () => (/* binding */ setStyle)
/* harmony export */ });
/* harmony import */ var _getSegmentations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../getSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js");
/* harmony import */ var _getViewportSegmentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getViewportSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js");
/* harmony import */ var _SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../SegmentationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js");
/* harmony import */ var _SegmentationStyle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../SegmentationStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");





function getStyle(specifier) {
    return _SegmentationStyle__WEBPACK_IMPORTED_MODULE_3__.segmentationStyle.getStyle(specifier);
}
function setStyle(specifier, style) {
    _SegmentationStyle__WEBPACK_IMPORTED_MODULE_3__.segmentationStyle.setStyle(specifier, style);
    if (!specifier.viewportId && !specifier.segmentationId) {
        const segmentations = (0,_getSegmentations__WEBPACK_IMPORTED_MODULE_0__.getSegmentations)();
        segmentations.forEach((segmentation) => {
            (0,_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationRender)(segmentation.segmentationId);
        });
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(specifier.viewportId, specifier.segmentationId, specifier.type);
}
function setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
    _SegmentationStyle__WEBPACK_IMPORTED_MODULE_3__.segmentationStyle.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);
    (0,_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationRender)(viewportId);
    const segmentations = (0,_getViewportSegmentations__WEBPACK_IMPORTED_MODULE_1__.getViewportSegmentations)(viewportId);
    segmentations.forEach((segmentation) => {
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentation.segmentationId);
    });
}
function getRenderInactiveSegmentations(viewportId) {
    return _SegmentationStyle__WEBPACK_IMPORTED_MODULE_3__.segmentationStyle.getRenderInactiveSegmentations(viewportId);
}
function resetToGlobalStyle() {
    _SegmentationStyle__WEBPACK_IMPORTED_MODULE_3__.segmentationStyle.resetToGlobalStyle();
    (0,_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationRender)();
}
function hasCustomStyle(specifier) {
    return _SegmentationStyle__WEBPACK_IMPORTED_MODULE_3__.segmentationStyle.hasCustomStyle(specifier);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLabelmapImageIds: () => (/* binding */ getLabelmapImageIds)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");


function getLabelmapImageIds(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__.defaultSegmentationStateManager;
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearSegmentValue: () => (/* binding */ clearSegmentValue)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");



function clearSegmentValue(segmentationId, segmentIndex) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    if (segmentation.representationData.Labelmap) {
        const { representationData } = segmentation;
        const labelmapData = representationData.Labelmap;
        if ('imageIds' in labelmapData || 'volumeId' in labelmapData) {
            const items = 'imageIds' in labelmapData
                ? labelmapData.imageIds.map((imageId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId))
                : [_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(labelmapData.volumeId)];
            items.forEach((item) => {
                if (!item) {
                    return;
                }
                const { voxelManager } = item;
                voxelManager.forEach(({ value, index }) => {
                    if (value === segmentIndex) {
                        voxelManager.setAtIndex(index, 0);
                    }
                });
            });
        }
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationDataModified)(segmentationId);
    }
    else {
        throw new Error('Invalid segmentation type, only labelmap is supported right now');
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js":
/*!********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertStackToVolumeLabelmap: () => (/* binding */ convertStackToVolumeLabelmap)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");


async function convertStackToVolumeLabelmap(args) {
    const result = (0,_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.internalConvertStackToVolumeLabelmap)(args);
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationModified)(args.segmentationId);
    return result;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   activeSegmentation: () => (/* reexport module object */ _activeSegmentation__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   addContourRepresentationToViewport: () => (/* reexport safe */ _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__.addContourRepresentationToViewport),
/* harmony export */   addContourRepresentationToViewportMap: () => (/* reexport safe */ _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__.addContourRepresentationToViewportMap),
/* harmony export */   addLabelmapRepresentationToViewport: () => (/* reexport safe */ _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__.addLabelmapRepresentationToViewport),
/* harmony export */   addLabelmapRepresentationToViewportMap: () => (/* reexport safe */ _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__.addLabelmapRepresentationToViewportMap),
/* harmony export */   addRepresentationData: () => (/* reexport safe */ _internalAddRepresentationData__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   addSegmentationRepresentations: () => (/* reexport safe */ _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__.addSegmentationRepresentations),
/* harmony export */   addSegmentations: () => (/* reexport safe */ _addSegmentations__WEBPACK_IMPORTED_MODULE_2__.addSegmentations),
/* harmony export */   addSurfaceRepresentationToViewport: () => (/* reexport safe */ _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__.addSurfaceRepresentationToViewport),
/* harmony export */   addSurfaceRepresentationToViewportMap: () => (/* reexport safe */ _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__.addSurfaceRepresentationToViewportMap),
/* harmony export */   config: () => (/* reexport module object */ _config__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   defaultSegmentationStateManager: () => (/* reexport safe */ _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_20__.defaultSegmentationStateManager),
/* harmony export */   getActiveSegmentation: () => (/* reexport safe */ _getActiveSegmentation__WEBPACK_IMPORTED_MODULE_22__.getActiveSegmentation),
/* harmony export */   getCurrentLabelmapImageIdsForViewport: () => (/* reexport safe */ _getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_21__.getCurrentLabelmapImageIdsForViewport),
/* harmony export */   getLabelmapImageIds: () => (/* reexport safe */ _getLabelmapImageIds__WEBPACK_IMPORTED_MODULE_16__.getLabelmapImageIds),
/* harmony export */   getLabelmapImageIdsForImageId: () => (/* reexport safe */ _getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_21__.getLabelmapImageIdsForImageId),
/* harmony export */   helpers: () => (/* binding */ helpers),
/* harmony export */   removeAllSegmentationRepresentations: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__.removeAllSegmentationRepresentations),
/* harmony export */   removeAllSegmentations: () => (/* reexport safe */ _removeSegmentation__WEBPACK_IMPORTED_MODULE_18__.removeAllSegmentations),
/* harmony export */   removeContourRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__.removeContourRepresentation),
/* harmony export */   removeLabelmapRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__.removeLabelmapRepresentation),
/* harmony export */   removeSegment: () => (/* reexport safe */ _removeSegment__WEBPACK_IMPORTED_MODULE_15__.removeSegment),
/* harmony export */   removeSegmentation: () => (/* reexport safe */ _removeSegmentation__WEBPACK_IMPORTED_MODULE_18__.removeSegmentation),
/* harmony export */   removeSegmentationRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__.removeSegmentationRepresentation),
/* harmony export */   removeSegmentationRepresentations: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__.removeSegmentationRepresentations),
/* harmony export */   removeSurfaceRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__.removeSurfaceRepresentation),
/* harmony export */   segmentIndex: () => (/* reexport module object */ _segmentIndex__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   segmentLocking: () => (/* reexport module object */ _segmentLocking__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   segmentationStyle: () => (/* reexport safe */ _SegmentationStyle__WEBPACK_IMPORTED_MODULE_19__.segmentationStyle),
/* harmony export */   state: () => (/* reexport module object */ _segmentationState__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   strategies: () => (/* reexport module object */ _tools_segmentation_strategies__WEBPACK_IMPORTED_MODULE_17__),
/* harmony export */   triggerSegmentationEvents: () => (/* reexport module object */ _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_10__),
/* harmony export */   updateSegmentations: () => (/* reexport safe */ _updateSegmentations__WEBPACK_IMPORTED_MODULE_4__.updateSegmentations)
/* harmony export */ });
/* harmony import */ var _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removeSegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js");
/* harmony import */ var _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addSegmentationRepresentationsToViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js");
/* harmony import */ var _addSegmentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js");
/* harmony import */ var _internalAddRepresentationData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internalAddRepresentationData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js");
/* harmony import */ var _updateSegmentations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./updateSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js");
/* harmony import */ var _activeSegmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./activeSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js");
/* harmony import */ var _segmentLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./segmentLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js");
/* harmony import */ var _segmentationState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js");
/* harmony import */ var _segmentIndex__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./segmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _helpers_convertStackToVolumeLabelmap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers/convertStackToVolumeLabelmap */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js");
/* harmony import */ var _helpers_computeVolumeLabelmapFromStack__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./helpers/computeVolumeLabelmapFromStack */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js");
/* harmony import */ var _helpers_clearSegmentValue__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./helpers/clearSegmentValue */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js");
/* harmony import */ var _helpers_computeStackLabelmapFromVolume__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/computeStackLabelmapFromVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js");
/* harmony import */ var _removeSegment__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./removeSegment */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js");
/* harmony import */ var _getLabelmapImageIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./getLabelmapImageIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js");
/* harmony import */ var _tools_segmentation_strategies__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./../../tools/segmentation/strategies */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js");
/* harmony import */ var _removeSegmentation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./removeSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js");
/* harmony import */ var _SegmentationStyle__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./SegmentationStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js");
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");
/* harmony import */ var _getActiveSegmentation__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./getActiveSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js");























const helpers = {
    clearSegmentValue: _helpers_clearSegmentValue__WEBPACK_IMPORTED_MODULE_13__.clearSegmentValue,
    convertStackToVolumeLabelmap: _helpers_convertStackToVolumeLabelmap__WEBPACK_IMPORTED_MODULE_11__.convertStackToVolumeLabelmap,
    computeVolumeLabelmapFromStack: _helpers_computeVolumeLabelmapFromStack__WEBPACK_IMPORTED_MODULE_12__.computeVolumeLabelmapFromStack,
    convertVolumeToStackLabelmap: _helpers_computeStackLabelmapFromVolume__WEBPACK_IMPORTED_MODULE_14__.convertVolumeToStackLabelmap,
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeSegment: () => (/* binding */ removeSegment)
/* harmony export */ });
/* harmony import */ var _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportIdsWithSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js");
/* harmony import */ var _helpers_clearSegmentValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/clearSegmentValue */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js");
/* harmony import */ var _segmentIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./segmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js");
/* harmony import */ var _updateSegmentations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./updateSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js");







function removeSegment(segmentationId, segmentIndex, options = {
    setNextSegmentAsActive: true,
}) {
    (0,_helpers_clearSegmentValue__WEBPACK_IMPORTED_MODULE_4__.clearSegmentValue)(segmentationId, segmentIndex);
    const isThisSegmentActive = (0,_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_0__.getActiveSegmentIndex)(segmentationId) === segmentIndex;
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    const { segments } = segmentation;
    delete segments[segmentIndex];
    const updatedSegments = {
        ...segments,
    };
    (0,_updateSegmentations__WEBPACK_IMPORTED_MODULE_6__.updateSegmentations)([
        {
            segmentationId,
            payload: {
                segments: updatedSegments,
            },
        },
    ]);
    if (isThisSegmentActive && options.setNextSegmentAsActive) {
        const segmentIndices = Object.keys(segments)
            .map(Number)
            .sort((a, b) => a - b);
        const currentIndex = segmentIndices.indexOf(segmentIndex);
        const nextSegmentIndex = segmentIndices[currentIndex + 1];
        const previousSegmentIndex = segmentIndices[currentIndex - 1];
        if (nextSegmentIndex !== undefined) {
            (0,_segmentIndex__WEBPACK_IMPORTED_MODULE_5__.setActiveSegmentIndex)(segmentationId, nextSegmentIndex);
        }
        else if (previousSegmentIndex !== undefined) {
            (0,_segmentIndex__WEBPACK_IMPORTED_MODULE_5__.setActiveSegmentIndex)(segmentationId, previousSegmentIndex);
        }
    }
    const viewportIds = (0,_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__.getViewportIdsWithSegmentation)(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentationRepresentations)(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            delete representation.segments[segmentIndex];
        });
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActiveSegmentIndex: () => (/* reexport safe */ _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__.getActiveSegmentIndex),
/* harmony export */   setActiveSegmentIndex: () => (/* binding */ setActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/segmentation/invalidateBrushCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js");
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportIdsWithSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");







function setActiveSegmentIndex(segmentationId, segmentIndex) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
    if (typeof segmentIndex === 'string') {
        console.warn('segmentIndex is a string, converting to number');
        segmentIndex = Number(segmentIndex);
    }
    Object.values(segmentation.segments).forEach((segment) => {
        segment.active = false;
    });
    if (!segmentation.segments[segmentIndex]) {
        segmentation.segments[segmentIndex] = {
            segmentIndex,
            label: '',
            locked: false,
            cachedStats: {},
            active: false,
        };
    }
    if (segmentation.segments[segmentIndex].active !== true) {
        segmentation.segments[segmentIndex].active = true;
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    const viewportIds = (0,_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__.getViewportIdsWithSegmentation)(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__.getSegmentationRepresentations)(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            if (!representation.segments[segmentIndex]) {
                representation.segments[segmentIndex] = {
                    visible: true,
                };
            }
        });
    });
    viewportIds.forEach((viewportId) => {
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroupForViewport)(viewportId);
        (0,_utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__.invalidateBrushCursor)(toolGroup.id);
    });
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setSegmentationRepresentationVisibility: () => (/* binding */ setSegmentationRepresentationVisibility)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateSegmentations: () => (/* binding */ updateSegmentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");


function updateSegmentations(segmentationUpdateArray, suppressEvents) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    segmentationUpdateArray.forEach((segmentationUpdate) => {
        segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);
        if (!suppressEvents) {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationModified)(segmentationUpdate.segmentationId);
        }
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

class Synchronizer {
    constructor(synchronizerId, eventName, eventHandler, options) {
        this._viewportOptions = {};
        this._onEvent = (evt) => {
            if (this._ignoreFiredEvents === true) {
                return;
            }
            if (!this._targetViewports.length) {
                return;
            }
            const enabledElement = this._eventSource === 'element'
                ? (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(evt.currentTarget)
                : (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(evt.detail?.viewportId);
            if (!enabledElement) {
                return;
            }
            const { renderingEngineId, viewportId } = enabledElement;
            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {
                return;
            }
            this.fireEvent({
                renderingEngineId,
                viewportId,
            }, evt);
        };
        this._enabled = true;
        this._eventName = eventName;
        this._eventHandler = eventHandler;
        this._ignoreFiredEvents = false;
        this._sourceViewports = [];
        this._targetViewports = [];
        this._options = options || {};
        this._eventSource = this._options.eventSource || 'element';
        this._auxiliaryEvents = this._options.auxiliaryEvents || [];
        this.id = synchronizerId;
    }
    isDisabled() {
        return !this._enabled || !this._hasSourceElements();
    }
    setOptions(viewportId, options = {}) {
        this._viewportOptions[viewportId] = options;
    }
    setEnabled(enabled) {
        this._enabled = enabled;
    }
    getOptions(viewportId) {
        return this._viewportOptions[viewportId];
    }
    add(viewportInfo) {
        this.addTarget(viewportInfo);
        this.addSource(viewportInfo);
    }
    addSource(viewportInfo) {
        if (_containsViewport(this._sourceViewports, viewportInfo)) {
            return;
        }
        const { renderingEngineId, viewportId } = viewportInfo;
        const viewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId).getViewport(viewportId);
        if (!viewport) {
            console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);
            return;
        }
        const eventSource = this._eventSource === 'element' ? viewport.element : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
        eventSource.addEventListener(this._eventName, this._onEvent.bind(this));
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element' ? viewport.element : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
            target.addEventListener(name, this._onEvent.bind(this));
        });
        this._updateDisableHandlers();
        this._sourceViewports.push(viewportInfo);
    }
    addTarget(viewportInfo) {
        if (_containsViewport(this._targetViewports, viewportInfo)) {
            return;
        }
        this._targetViewports.push(viewportInfo);
        this._updateDisableHandlers();
    }
    getSourceViewports() {
        return this._sourceViewports;
    }
    getTargetViewports() {
        return this._targetViewports;
    }
    destroy() {
        this._sourceViewports.forEach((s) => this.removeSource(s));
        this._targetViewports.forEach((t) => this.removeTarget(t));
    }
    remove(viewportInfo) {
        this.removeTarget(viewportInfo);
        this.removeSource(viewportInfo);
    }
    removeSource(viewportInfo) {
        const index = _getViewportIndex(this._sourceViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        const eventSource = this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
        this._sourceViewports.splice(index, 1);
        eventSource.removeEventListener(this._eventName, this._eventHandler);
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element'
                ? this.getViewportElement(viewportInfo)
                : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
            target.removeEventListener(name, this._eventHandler);
        });
        this._updateDisableHandlers();
    }
    removeTarget(viewportInfo) {
        const index = _getViewportIndex(this._targetViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        this._targetViewports.splice(index, 1);
        this._updateDisableHandlers();
    }
    hasSourceViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._sourceViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    hasTargetViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._targetViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    fireEvent(sourceViewport, sourceEvent) {
        if (this.isDisabled() || this._ignoreFiredEvents) {
            return;
        }
        this._ignoreFiredEvents = true;
        const promises = [];
        try {
            for (let i = 0; i < this._targetViewports.length; i++) {
                const targetViewport = this._targetViewports[i];
                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;
                if (targetIsSource) {
                    continue;
                }
                const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);
                if (result instanceof Promise) {
                    promises.push(result);
                }
            }
        }
        catch (ex) {
            console.warn(`Synchronizer, for: ${this._eventName}`, ex);
        }
        finally {
            if (promises.length) {
                Promise.allSettled(promises).then(() => {
                    this._ignoreFiredEvents = false;
                });
            }
            else {
                this._ignoreFiredEvents = false;
            }
        }
    }
    _hasSourceElements() {
        return this._sourceViewports.length !== 0;
    }
    _updateDisableHandlers() {
        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);
        const _remove = this.remove.bind(this);
        const disableHandler = (elementDisabledEvent) => {
            _remove(elementDisabledEvent.detail.element);
        };
        viewports.forEach((vp) => {
            const eventSource = this.getEventSource(vp);
            if (!eventSource) {
                return;
            }
            eventSource.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED, disableHandler);
            eventSource.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED, disableHandler);
        });
    }
    getEventSource(viewportInfo) {
        return this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
    }
    getViewportElement(viewportInfo) {
        const { renderingEngineId, viewportId } = viewportInfo;
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId);
        if (!renderingEngine) {
            return null;
        }
        const viewport = renderingEngine.getViewport(viewportId);
        if (!viewport) {
            return null;
        }
        return viewport.element;
    }
}
function _getUniqueViewports(vp1, vp2) {
    const unique = [];
    const vps = vp1.concat(vp2);
    for (let i = 0; i < vps.length; i++) {
        const vp = vps[i];
        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&
            vp.viewportId === u.viewportId)) {
            unique.push(vp);
        }
    }
    return unique;
}
function _getViewportIndex(arr, vp) {
    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&
        vp.viewportId === ar.viewportId);
}
function _containsViewport(arr, vp) {
    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&
        ar.viewportId === vp.viewportId);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Synchronizer);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _Synchronizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Synchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js");


function createSynchronizer(synchronizerId, eventName, eventHandler, options) {
    const synchronizerWithSameIdExists = _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.some((sync) => sync.id === synchronizerId);
    if (synchronizerWithSameIdExists) {
        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);
    }
    const synchronizer = new _Synchronizer__WEBPACK_IMPORTED_MODULE_1__["default"](synchronizerId, eventName, eventHandler, options);
    _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.push(synchronizer);
    return synchronizer;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSynchronizer);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function destroy() {
    while (_state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.length > 0) {
        const synchronizer = _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.pop();
        synchronizer.destroy();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (destroy);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function destroySynchronizer(synchronizerId) {
    const synchronizerIndex = _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.findIndex((sync) => sync.id === synchronizerId);
    if (synchronizerIndex > -1) {
        const synchronizer = _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers[synchronizerIndex];
        synchronizer.destroy();
        _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.splice(synchronizerIndex, 1);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (destroySynchronizer);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function getAllSynchronizers() {
    return _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getAllSynchronizers);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function getSynchronizer(synchronizerId) {
    return _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.find((s) => s.id === synchronizerId);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSynchronizer);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function getSynchronizersForViewport(viewportId, renderingEngineId) {
    const synchronizersFilteredByIds = [];
    if (!renderingEngineId && !viewportId) {
        throw new Error('At least one of renderingEngineId or viewportId should be given');
    }
    for (let i = 0; i < _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers.length; i++) {
        const synchronizer = _state__WEBPACK_IMPORTED_MODULE_0__.state.synchronizers[i];
        const notDisabled = !synchronizer.isDisabled();
        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);
        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);
        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {
            synchronizersFilteredByIds.push(synchronizer);
        }
    }
    return synchronizersFilteredByIds;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSynchronizersForViewport);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSynchronizer: () => (/* reexport safe */ _createSynchronizer__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   destroy: () => (/* reexport safe */ _destroy__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   destroySynchronizer: () => (/* reexport safe */ _destroySynchronizer__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   getAllSynchronizers: () => (/* reexport safe */ _getAllSynchronizers__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   getSynchronizer: () => (/* reexport safe */ _getSynchronizer__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   getSynchronizersForViewport: () => (/* reexport safe */ _getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _createSynchronizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createSynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js");
/* harmony import */ var _destroy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./destroy */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js");
/* harmony import */ var _getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getSynchronizersForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js");
/* harmony import */ var _getSynchronizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getSynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js");
/* harmony import */ var _getAllSynchronizers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getAllSynchronizers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js");
/* harmony import */ var _destroySynchronizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./destroySynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js");









/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addEnabledElement)
/* harmony export */ });
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../eventListeners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js");
/* harmony import */ var _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../eventDispatchers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stateManagement/annotation/AnnotationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js");




function addEnabledElement(evt) {
    const { element, viewportId } = evt.detail;
    const svgLayer = _createSvgAnnotationLayer(viewportId);
    _setSvgNodeCache(element);
    _appendChild(svgLayer, element);
    _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__.annotationRenderingEngine.addViewportElement(viewportId, element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__.mouseEventListeners.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__.wheelEventListener.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__.touchEventListeners.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__.keyEventListener.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__.imageChangeEventListener.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__.imageRenderedEventDispatcher.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__.cameraModifiedEventDispatcher.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__.imageSpacingCalibratedEventDispatcher.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__.cameraResetEventDispatcher.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__.mouseToolEventDispatcher.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__.keyboardToolEventDispatcher.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__.touchToolEventDispatcher.enable(element);
    _state__WEBPACK_IMPORTED_MODULE_2__.state.enabledElements.push(element);
}
function _createSvgAnnotationLayer(viewportId) {
    const svgns = 'http://www.w3.org/2000/svg';
    const svgLayer = document.createElementNS(svgns, 'svg');
    const svgLayerId = `svg-layer-${viewportId}`;
    svgLayer.classList.add('svg-layer');
    svgLayer.setAttribute('id', svgLayerId);
    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svgLayer.style.width = '100%';
    svgLayer.style.height = '100%';
    svgLayer.style.pointerEvents = 'none';
    svgLayer.style.position = 'absolute';
    const defs = document.createElementNS(svgns, 'defs');
    const filter = document.createElementNS(svgns, 'filter');
    const feOffset = document.createElementNS(svgns, 'feOffset');
    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');
    const feBlend = document.createElementNS(svgns, 'feBlend');
    filter.setAttribute('id', `shadow-${svgLayerId}`);
    filter.setAttribute('filterUnits', 'userSpaceOnUse');
    feOffset.setAttribute('result', 'offOut');
    feOffset.setAttribute('in', 'SourceGraphic');
    feOffset.setAttribute('dx', '0.5');
    feOffset.setAttribute('dy', '0.5');
    feColorMatrix.setAttribute('result', 'matrixOut');
    feColorMatrix.setAttribute('in', 'offOut');
    feColorMatrix.setAttribute('in2', 'matrix');
    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');
    feBlend.setAttribute('in', 'SourceGraphic');
    feBlend.setAttribute('in2', 'matrixOut');
    feBlend.setAttribute('mode', 'normal');
    filter.appendChild(feOffset);
    filter.appendChild(feColorMatrix);
    filter.appendChild(feBlend);
    defs.appendChild(filter);
    svgLayer.appendChild(defs);
    return svgLayer;
}
function _setSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    _state__WEBPACK_IMPORTED_MODULE_2__.state.svgNodeCache[elementHash] = {};
}
function _appendChild(newNode, referenceNode) {
    referenceNode.querySelector('div.viewport-element').appendChild(newNode);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cancelActiveManipulations)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/getToolsWithModesForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js");
/* harmony import */ var _filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filterToolsWithAnnotationsForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js");



function cancelActiveManipulations(element) {
    const tools = (0,_utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_1__["default"])(element, [
        _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Active,
        _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Passive,
    ]);
    const toolsWithData = (0,_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_2__["default"])(element, tools);
    for (const { tool } of toolsWithData) {
        const annotationUID = tool.cancel(element);
        if (annotationUID) {
            return annotationUID;
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filterMoveableAnnotationTools)
/* harmony export */ });
function filterMoveableAnnotationTools(element, ToolAndAnnotations, canvasCoords, interactionType = 'mouse') {
    const proximity = interactionType === 'touch' ? 36 : 6;
    const moveableAnnotationTools = [];
    ToolAndAnnotations.forEach(({ tool, annotations }) => {
        for (const annotation of annotations) {
            if (annotation.isLocked || !annotation.isVisible) {
                continue;
            }
            const near = tool.isPointNearTool(element, annotation, canvasCoords, proximity, interactionType);
            if (near) {
                moveableAnnotationTools.push({
                    tool,
                    annotation,
                });
                break;
            }
        }
    });
    return moveableAnnotationTools;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filterToolsWithAnnotationsForElement)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");

function filterToolsWithAnnotationsForElement(element, tools) {
    const result = [];
    for (let i = 0; i < tools.length; i++) {
        const tool = tools[i];
        if (!tool) {
            console.warn('undefined tool in filterToolsWithAnnotationsForElement');
            continue;
        }
        let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__.getAnnotations)(tool.constructor.toolName, element);
        if (!annotations?.length) {
            continue;
        }
        if (typeof tool.filterInteractableAnnotationsForElement === 'function') {
            annotations = tool.filterInteractableAnnotationsForElement(element, annotations);
        }
        if (annotations?.length > 0) {
            result.push({ tool, annotations });
        }
    }
    return result;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithMoveableHandles.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithMoveableHandles.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filterToolsWithMoveableHandles)
/* harmony export */ });
function filterToolsWithMoveableHandles(element, ToolAndAnnotations, canvasCoords, interactionType = 'mouse') {
    const proximity = interactionType === 'touch' ? 36 : 6;
    const toolsWithMoveableHandles = [];
    ToolAndAnnotations.forEach(({ tool, annotations }) => {
        for (const annotation of annotations) {
            if (annotation.isLocked || !annotation.isVisible) {
                continue;
            }
            const handle = tool.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);
            if (handle) {
                toolsWithMoveableHandles.push({
                    tool,
                    annotation,
                    handle,
                });
                break;
            }
        }
    });
    return toolsWithMoveableHandles;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/index.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Synchronizer: () => (/* reexport safe */ _SynchronizerManager_Synchronizer__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   SynchronizerManager: () => (/* reexport module object */ _SynchronizerManager__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   ToolGroupManager: () => (/* reexport module object */ _ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   addEnabledElement: () => (/* reexport safe */ _addEnabledElement__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   addTool: () => (/* reexport safe */ _addTool__WEBPACK_IMPORTED_MODULE_0__.addTool),
/* harmony export */   cancelActiveManipulations: () => (/* reexport safe */ _cancelActiveManipulations__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   hasTool: () => (/* reexport safe */ _addTool__WEBPACK_IMPORTED_MODULE_0__.hasTool),
/* harmony export */   removeEnabledElement: () => (/* reexport safe */ _removeEnabledElement__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   removeTool: () => (/* reexport safe */ _addTool__WEBPACK_IMPORTED_MODULE_0__.removeTool),
/* harmony export */   state: () => (/* reexport safe */ _state__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   svgNodeCache: () => (/* reexport safe */ _svgNodeCache__WEBPACK_IMPORTED_MODULE_6__["default"])
/* harmony export */ });
/* harmony import */ var _addTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js");
/* harmony import */ var _addEnabledElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addEnabledElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js");
/* harmony import */ var _removeEnabledElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./removeEnabledElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js");
/* harmony import */ var _cancelActiveManipulations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cancelActiveManipulations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _SynchronizerManager_Synchronizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SynchronizerManager/Synchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js");
/* harmony import */ var _svgNodeCache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./svgNodeCache */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js");
/* harmony import */ var _ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _SynchronizerManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SynchronizerManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js");












/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../eventListeners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js");
/* harmony import */ var _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../eventDispatchers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js");
/* harmony import */ var _filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filterToolsWithAnnotationsForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/getToolsWithModesForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _SynchronizerManager_getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SynchronizerManager/getSynchronizersForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js");
/* harmony import */ var _ToolGroupManager_getToolGroupForViewport__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ToolGroupManager/getToolGroupForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js");
/* harmony import */ var _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../stateManagement/annotation/AnnotationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js");











const VIEWPORT_ELEMENT = 'viewport-element';
function removeEnabledElement(elementDisabledEvt) {
    const { element, viewportId } = elementDisabledEvt.detail;
    _resetSvgNodeCache(element);
    _removeSvgNode(element);
    _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_10__.annotationRenderingEngine.removeViewportElement(viewportId, element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__.mouseEventListeners.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__.wheelEventListener.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__.touchEventListeners.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__.keyEventListener.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__.imageChangeEventListener.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__.imageRenderedEventDispatcher.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__.cameraModifiedEventDispatcher.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__.imageSpacingCalibratedEventDispatcher.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__.cameraResetEventDispatcher.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__.mouseToolEventDispatcher.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__.keyboardToolEventDispatcher.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__.touchToolEventDispatcher.disable(element);
    _removeViewportFromSynchronizers(element);
    _removeViewportFromToolGroup(element);
    _removeEnabledElement(element);
}
const _removeViewportFromSynchronizers = (element) => {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const synchronizers = (0,_SynchronizerManager_getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_8__["default"])(enabledElement.viewportId, enabledElement.renderingEngineId);
    synchronizers.forEach((sync) => {
        sync.remove(enabledElement);
    });
};
const _removeViewportFromToolGroup = (element) => {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const { renderingEngineId, viewportId } = enabledElement;
    const toolGroup = (0,_ToolGroupManager_getToolGroupForViewport__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportId, renderingEngineId);
    if (toolGroup) {
        toolGroup.removeViewports(renderingEngineId, viewportId);
    }
};
const _removeAllToolsForElement = function (element) {
    const tools = (0,_utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_5__["default"])(element, [
        _enums__WEBPACK_IMPORTED_MODULE_6__.ToolModes.Active,
        _enums__WEBPACK_IMPORTED_MODULE_6__.ToolModes.Passive,
    ]);
    const toolsWithData = (0,_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_3__["default"])(element, tools);
    toolsWithData.forEach(({ annotations }) => {
        annotations.forEach((annotation) => {
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_7__.removeAnnotation)(annotation.annotationUID);
        });
    });
};
function _resetSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    delete _state__WEBPACK_IMPORTED_MODULE_4__.state.svgNodeCache[elementHash];
}
function _removeSvgNode(element) {
    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);
    const svgLayer = internalViewportNode.querySelector('svg');
    if (svgLayer) {
        internalViewportNode.removeChild(svgLayer);
    }
}
const _removeEnabledElement = function (element) {
    const foundElementIndex = _state__WEBPACK_IMPORTED_MODULE_4__.state.enabledElements.findIndex((el) => el === element);
    if (foundElementIndex > -1) {
        _state__WEBPACK_IMPORTED_MODULE_4__.state.enabledElements.splice(foundElementIndex, 1);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (removeEnabledElement);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ areViewportsCoplanar)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function areViewportsCoplanar(viewport1, viewport2) {
    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();
    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();
    const dotProducts = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(viewPlaneNormal1, viewPlaneNormal2);
    return Math.abs(dotProducts) > 0.9;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cameraSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {
    const { camera } = cameraModifiedEvent.detail;
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    tViewport.setCamera(camera);
    tViewport.render();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ imageSliceSyncCallback)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _areViewportsCoplanar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./areViewportsCoplanar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js");



const getSpatialRegistration = (targetId, sourceId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', targetId, sourceId);
async function imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    if (options?.disabled) {
        return;
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const imageId1 = sViewport.getCurrentImageId();
    const imagePlaneModule1 = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId1);
    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;
    const targetImageIds = tViewport.getImageIds();
    if (!(0,_areViewportsCoplanar__WEBPACK_IMPORTED_MODULE_2__["default"])(sViewport, tViewport)) {
        return;
    }
    let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
    if (!registrationMatrixMat4) {
        const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();
        const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();
        if (frameOfReferenceUID1 === frameOfReferenceUID2 &&
            options?.useInitialPosition !== false) {
            registrationMatrixMat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.identity(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create());
        }
        else {
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);
            registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
        }
        if (!registrationMatrixMat4) {
            return;
        }
    }
    const targetImagePositionPatientWithRegistrationMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), sourceImagePositionPatient, registrationMatrixMat4);
    const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);
    let imageIndexToSet = closestImageIdIndex2.index;
    if (tViewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
        imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;
    }
    if (closestImageIdIndex2.index !== -1 &&
        tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {
        await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.jumpToSlice(tViewport.element, {
            imageIndex: imageIndexToSet,
        });
    }
}
function _getClosestImageIdIndex(targetPoint, imageIds) {
    return imageIds.reduce((closestImageIdIndex, imageId, index) => {
        const { imagePositionPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId);
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.distance(imagePositionPatient, targetPoint);
        if (distance < closestImageIdIndex.distance) {
            return {
                distance,
                index,
            };
        }
        return closestImageIdIndex;
    }, {
        distance: Infinity,
        index: -1,
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ presentationViewSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const presentationView = sViewport.getViewPresentation(options);
    tViewport.setViewPresentation(presentationView);
    tViewport.render();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ slabThicknessSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const slabThickness = sViewport.getSlabThickness?.();
    if (!slabThickness) {
        return;
    }
    tViewport.setSlabThickness?.(slabThickness);
    tViewport.render();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ voiSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {
    const eventDetail = modifiedEvent.detail;
    const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const tProperties = {
        voiRange: range,
    };
    if (options?.syncInvertState && invertStateChanged) {
        tProperties.invert = invert;
    }
    if (options?.syncColormap && colormap) {
        tProperties.colormap = colormap;
    }
    if (tViewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const isFusion = tViewport._actors && tViewport._actors.size > 1;
        if (isFusion) {
            tViewport.setProperties(tProperties, volumeId);
        }
        else {
            tViewport.setProperties(tProperties);
        }
    }
    else if (tViewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        tViewport.setProperties(tProperties);
    }
    else {
        throw new Error('Viewport type not supported.');
    }
    tViewport.render();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ zoomPanSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    if (options?.syncZoom !== false) {
        const srcZoom = sViewport.getZoom();
        tViewport.setZoom(srcZoom);
    }
    if (options?.syncPan !== false) {
        const srcPan = sViewport.getPan();
        tViewport.setPan(srcPan);
    }
    tViewport.render();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCameraPositionSynchronizer: () => (/* reexport safe */ _synchronizers_createCameraPositionSynchronizer__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   createImageSliceSynchronizer: () => (/* reexport safe */ _synchronizers_createImageSliceSynchronizer__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   createPresentationViewSynchronizer: () => (/* reexport safe */ _synchronizers_createPresentationViewSynchronizer__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   createSlabThicknessSynchronizer: () => (/* reexport safe */ _synchronizers_createSlabThicknessSynchronizer__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   createStackImageSynchronizer: () => (/* binding */ createStackImageSynchronizer),
/* harmony export */   createVOISynchronizer: () => (/* reexport safe */ _synchronizers_createVOISynchronizer__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   createZoomPanSynchronizer: () => (/* reexport safe */ _synchronizers_createZoomPanSynchronizer__WEBPACK_IMPORTED_MODULE_3__["default"])
/* harmony export */ });
/* harmony import */ var _synchronizers_createCameraPositionSynchronizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./synchronizers/createCameraPositionSynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js");
/* harmony import */ var _synchronizers_createPresentationViewSynchronizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./synchronizers/createPresentationViewSynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js");
/* harmony import */ var _synchronizers_createVOISynchronizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./synchronizers/createVOISynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js");
/* harmony import */ var _synchronizers_createZoomPanSynchronizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./synchronizers/createZoomPanSynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js");
/* harmony import */ var _synchronizers_createImageSliceSynchronizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./synchronizers/createImageSliceSynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js");
/* harmony import */ var _synchronizers_createSlabThicknessSynchronizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./synchronizers/createSlabThicknessSynchronizer */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js");






const createStackImageSynchronizer = _synchronizers_createImageSliceSynchronizer__WEBPACK_IMPORTED_MODULE_4__["default"];



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createCameraPositionSynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/SynchronizerManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _callbacks_cameraSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/cameraSyncCallback */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js");



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events;
function createCameraPositionSynchronizer(synchronizerName) {
    const cameraPositionSynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_cameraSyncCallback__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return cameraPositionSynchronizer;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createImageSliceSynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/SynchronizerManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _callbacks_imageSliceSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/imageSliceSyncCallback */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js");



const { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events;
function createImageSliceSynchronizer(synchronizerName) {
    const stackImageSynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, STACK_NEW_IMAGE, _callbacks_imageSliceSyncCallback__WEBPACK_IMPORTED_MODULE_2__["default"], {
        auxiliaryEvents: [
            {
                name: 'VOLUME_NEW_IMAGE',
            },
        ],
    });
    return stackImageSynchronizer;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createPresentationViewSynchronizer)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/SynchronizerManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js");
/* harmony import */ var _callbacks_presentationViewSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/presentationViewSyncCallback */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js");



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events;
function createPresentationViewSynchronizer(synchronizerName, options) {
    const presentationView = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_presentationViewSyncCallback__WEBPACK_IMPORTED_MODULE_2__["default"], { viewPresentation: options });
    return presentationView;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js":
/*!**************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createPresentationViewSynchronizer)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/SynchronizerManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js");
/* harmony import */ var _callbacks_slabThicknessSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/slabThicknessSyncCallback */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js");



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events;
function createPresentationViewSynchronizer(synchronizerName) {
    const presentationView = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_slabThicknessSyncCallback__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return presentationView;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createVOISynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/SynchronizerManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _callbacks_voiSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/voiSyncCallback */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js");



function createVOISynchronizer(synchronizerName, options) {
    options = Object.assign({ syncInvertState: true, syncColormap: true }, options);
    const VOISynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events.VOI_MODIFIED, _callbacks_voiSyncCallback__WEBPACK_IMPORTED_MODULE_2__["default"], {
        auxiliaryEvents: [
            {
                name: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events.COLORMAP_MODIFIED,
            },
        ],
        ...options,
    });
    return VOISynchronizer;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createZoomPanSynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/SynchronizerManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _callbacks_zoomPanSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../callbacks/zoomPanSyncCallback */ "../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js");



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events;
function createZoomPanSynchronizer(synchronizerName) {
    const zoomPanSynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_zoomPanSyncCallback__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return zoomPanSynchronizer;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AdvancedMagnifyTool)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utilities/math/circle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _utilities_debounce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utilities/debounce */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js");
/* harmony import */ var _utilities_math_point__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utilities/math/point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../stateManagement/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js");


















const MAGNIFY_CLASSNAME = 'advancedMagnifyTool';
const MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;
const { Events: csEvents } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums;
const isSegmentation = (actor) => actor.uid !== actor.referencedId;
var AdvancedMagnifyToolActions;
(function (AdvancedMagnifyToolActions) {
    AdvancedMagnifyToolActions["ShowZoomFactorsList"] = "showZoomFactorsList";
})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));
const ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';
const PARALLEL_THRESHOLD = 1 - _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.EPSILON;
class AdvancedMagnifyTool extends _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool {
    static { this.Actions = AdvancedMagnifyToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            magnifyingGlass: {
                radius: 125,
                zoomFactor: 3,
                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],
                autoPan: {
                    enabled: true,
                    padding: 10,
                },
            },
            actions: {
                showZoomFactorsList: {
                    method: 'showZoomFactorsList',
                    bindings: [
                        {
                            mouseButton: _enums__WEBPACK_IMPORTED_MODULE_8__.MouseBindings.Secondary,
                            modifierKey: _enums__WEBPACK_IMPORTED_MODULE_8__.KeyboardBindings.Shift,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const { magnifyingGlass: config } = this.configuration;
            const { radius, zoomFactor, autoPan } = config;
            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotationUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4();
            const magnifyViewportId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4();
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                annotationUID,
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    sourceViewportId: viewport.id,
                    magnifyViewportId,
                    zoomFactor,
                    isCanvasAnnotation: true,
                    handles: {
                        points: canvasHandlePoints,
                        activeHandleIndex: null,
                    },
                },
            };
            this.magnifyViewportManager.createViewport(annotation, {
                magnifyViewportId,
                sourceEnabledElement: enabledElement,
                position: canvasPos,
                radius,
                zoomFactor,
                autoPan: {
                    enabled: autoPan.enabled,
                    padding: autoPan.padding,
                    callback: (data) => {
                        const annotationPoints = annotation.data.handles.points;
                        const { canvas: canvasDelta } = data.delta;
                        for (let i = 0, len = annotationPoints.length; i < len; i++) {
                            const point = annotationPoints[i];
                            point[0] += canvasDelta[0];
                            point[1] += canvasDelta[1];
                            annotation.invalidated = true;
                        }
                    },
                },
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.onSetToolDisabled = () => {
            this.magnifyViewportManager.dispose();
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAllAnnotations)();
            annotations.forEach((annotation) => {
                if (annotation.metadata.toolName === this.getToolName()) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
                }
            });
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const center = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const radiusPoint = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_12__.getCanvasCircleRadius)([center, canvasCoords]);
            if (Math.abs(radiusPoint - radius) < proximity * 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            this._activateModify(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            const { points } = data.handles;
            const handleIndex = points.findIndex((p) => p === handle);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { deltaPoints } = eventDetail;
            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];
            const { annotation, viewportIdsToRender } = this.editData;
            const { points } = annotation.data.handles;
            points.forEach((point) => {
                point[0] += canvasDelta[0];
                point[1] += canvasDelta[1];
            });
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const canvasDelta = deltaPoints.canvas;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += canvasDelta[0];
                    point[1] += canvasDelta[1];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const canvasCenter = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const newRadius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_12__.getCanvasCircleRadius)([
                canvasCenter,
                currentCanvasPoints,
            ]);
            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);
            points[0] = newCanvasHandlePoints[0];
            points[1] = newCanvasHandlePoints[1];
            points[2] = newCanvasHandlePoints[2];
            points[3] = newCanvasHandlePoints[3];
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===
                viewport.id);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!filteredAnnotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < filteredAnnotations.length; i++) {
                const annotation = filteredAnnotations[i];
                const { annotationUID, data } = annotation;
                const { magnifyViewportId, zoomFactor, handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points;
                const canvasTop = canvasCoordinates[0];
                const canvasBottom = canvasCoordinates[2];
                const canvasLeft = canvasCoordinates[3];
                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
                const center = [
                    canvasLeft[0] + radius,
                    canvasTop[1] + radius,
                ];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-advancedMagnify`;
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineWidth: 5,
                }, dataId);
                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);
                magnifyViewport.position = center;
                magnifyViewport.radius = radius;
                magnifyViewport.zoomFactor = zoomFactor;
                magnifyViewport.update();
                renderStatus = true;
            }
            return renderStatus;
        };
        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {
            return [
                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],
                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],
                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],
                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],
            ];
        };
        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();
    }
    showZoomFactorsList(evt, annotation) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvas: canvasPoint } = currentPoints;
        const viewportElement = element.querySelector(':scope .viewport-element');
        const currentZoomFactor = annotation.data.zoomFactor;
        const remove = () => dropdown.parentElement.removeChild(dropdown);
        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {
            if (newZoomFactor !== undefined) {
                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);
                annotation.invalidated = true;
            }
            remove();
            viewport.render();
        });
        Object.assign(dropdown.style, {
            left: `${canvasPoint[0]}px`,
            top: `${canvasPoint[1]}px`,
        });
        viewportElement.appendChild(dropdown);
        dropdown.focus();
    }
    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {
        const { zoomFactorList } = this.configuration.magnifyingGlass;
        const dropdown = document.createElement('select');
        dropdown.size = 5;
        Object.assign(dropdown.style, {
            width: '50px',
            position: 'absolute',
        });
        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {
            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());
        });
        dropdown.addEventListener('change', (evt) => {
            evt.stopPropagation();
            onChangeCallback(dropdown.value);
        });
        dropdown.addEventListener('keydown', (evt) => {
            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||
                evt.key?.toLowerCase() === 'escape';
            if (shouldCancel) {
                evt.stopPropagation();
                onChangeCallback();
            }
        });
        zoomFactorList.forEach((zoomFactor) => {
            const option = document.createElement('option');
            option.label = zoomFactor;
            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;
            option.value = zoomFactor;
            option.defaultSelected = zoomFactor === currentZoomFactor;
            dropdown.add(option);
        });
        return dropdown;
    }
}
class AdvancedMagnifyViewportManager {
    constructor() {
        this.createViewport = (annotation, viewportInfo) => {
            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;
            const { viewport: sourceViewport } = sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            const magnifyViewport = new AdvancedMagnifyViewport({
                magnifyViewportId,
                sourceEnabledElement,
                radius,
                position,
                zoomFactor,
                autoPan,
            });
            this._addSourceElementEventListener(sourceElement);
            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {
                annotation,
                magnifyViewport,
                magnifyViewportInfo: viewportInfo,
            });
            return magnifyViewport;
        };
        this._annotationRemovedCallback = (evt) => {
            const { annotation } = evt.detail;
            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {
                return;
            }
            this.destroyViewport(annotation.data.magnifyViewportId);
        };
        this._newStackImageCallback = (evt) => {
            const { viewportId: sourceViewportId, imageId } = evt.detail;
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(sourceViewportId);
            if (viewport.stackActorReInitialized) {
                this._reset(sourceViewportId);
            }
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                annotation.metadata.referencedImageId = imageId;
                annotation.invalidated = true;
            });
        };
        this._newVolumeImageCallback = (evt) => {
            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(renderingEngineId);
            const sourceViewport = renderingEngine.getViewport(sourceViewportId);
            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                const { viewPlaneNormal } = annotation.metadata;
                const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >
                    PARALLEL_THRESHOLD;
                if (!isParallel) {
                    return;
                }
                const { handles } = annotation.data;
                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);
                const vecHandleToImagePlane = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.create(), worldImagePlanePoint, handles.points[0]);
                const worldDist = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);
                const worldDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.create(), currentViewPlaneNormal, worldDist);
                for (let i = 0, len = handles.points.length; i < len; i++) {
                    const point = handles.points[i];
                    point[0] += worldDelta[0];
                    point[1] += worldDelta[1];
                    point[2] += worldDelta[2];
                }
                annotation.invalidated = true;
            });
        };
        this._magnifyViewportsMap = new Map();
        this._initialize();
    }
    static getInstance() {
        AdvancedMagnifyViewportManager._singleton =
            AdvancedMagnifyViewportManager._singleton ??
                new AdvancedMagnifyViewportManager();
        return AdvancedMagnifyViewportManager._singleton;
    }
    getViewport(magnifyViewportId) {
        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;
    }
    dispose() {
        this._removeEventListeners();
        this._destroyViewports();
    }
    destroyViewport(magnifyViewportId) {
        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);
        if (magnifyViewportMapEntry) {
            const { magnifyViewport } = magnifyViewportMapEntry;
            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            this._removeSourceElementEventListener(sourceElement);
            magnifyViewport.dispose();
            this._magnifyViewportsMap.delete(magnifyViewportId);
        }
    }
    _destroyViewports() {
        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());
        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));
    }
    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {
        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());
        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {
            const { viewport } = magnifyViewport.sourceEnabledElement;
            return viewport.id === sourceViewportId;
        });
    }
    _reset(sourceViewportId) {
        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {
            this.destroyViewport(magnifyViewport.viewportId);
            const newEnabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(sourceViewportId);
            this.createViewport(annotation, {
                ...magnifyViewportInfo,
                sourceEnabledElement: {
                    ...newEnabledElement,
                },
            });
        });
    }
    _addEventListeners() {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _removeEventListeners() {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _addSourceElementEventListener(element) {
        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        const newStackHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);
        const newVolumeHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);
        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.newStackHandler = newStackHandler;
        element.newVolumeHandler = newVolumeHandler;
    }
    _removeSourceElementEventListener(element) {
        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);
        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);
        delete element.newStackHandler;
        delete element.newVolumeHandler;
    }
    _initialize() {
        this._addEventListeners();
    }
}
class AdvancedMagnifyViewport {
    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {
        this._enabledElement = null;
        this._sourceToolGroup = null;
        this._magnifyToolGroup = null;
        this._isViewportReady = false;
        this._radius = 0;
        this._resized = false;
        this._canAutoPan = false;
        this._viewportId = magnifyViewportId ?? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4();
        this._sourceEnabledElement = sourceEnabledElement;
        this._autoPan = autoPan;
        this.radius = radius;
        this.position = position;
        this.zoomFactor = zoomFactor;
        this.visible = true;
        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);
        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);
        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);
        this._mouseDragCallback = this._mouseDragCallback.bind(this);
        this._resizeViewportAsync = ((0,_utilities_debounce__WEBPACK_IMPORTED_MODULE_15__["default"])(this._resizeViewport.bind(this), 1));
        this._initialize();
    }
    get sourceEnabledElement() {
        return this._sourceEnabledElement;
    }
    get viewportId() {
        return this._viewportId;
    }
    get radius() {
        return this._radius;
    }
    set radius(radius) {
        if (Math.abs(this._radius - radius) > 0.00001) {
            this._radius = radius;
            this._resized = true;
        }
    }
    update() {
        const { radius, position, visible } = this;
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const size = 2 * radius;
        const [x, y] = position;
        if (this._resized) {
            this._resizeViewportAsync();
            this._resized = false;
        }
        Object.assign(element.style, {
            display: visible ? 'block' : 'hidden',
            width: `${size}px`,
            height: `${size}px`,
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(${x}px, ${y}px)`,
        });
        if (this._isViewportReady) {
            this._syncViewports();
            viewport.render();
        }
    }
    dispose() {
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const renderingEngine = viewport.getRenderingEngine();
        this._removeEventListeners(element);
        renderingEngine.disableElement(viewport.id);
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }
    _handleToolModeChanged(evt) {
        const { _magnifyToolGroup: magnifyToolGroup } = this;
        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;
        if (this._sourceToolGroup?.id !== toolGroupId) {
            return;
        }
        switch (mode) {
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Active:
                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Passive:
                magnifyToolGroup.setToolPassive(toolName);
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Enabled:
                magnifyToolGroup.setToolEnabled(toolName);
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Disabled:
                magnifyToolGroup.setToolDisabled(toolName);
                break;
            default:
                throw new Error(`Unknow tool mode (${mode})`);
        }
    }
    _inheritBorderRadius(magnifyElement) {
        const viewport = magnifyElement.querySelector('.viewport-element');
        const canvas = magnifyElement.querySelector('.cornerstone-canvas');
        viewport.style.borderRadius = 'inherit';
        canvas.style.borderRadius = 'inherit';
    }
    _createViewportNode() {
        const magnifyElement = document.createElement('div');
        const { radius } = this;
        const size = radius * 2;
        magnifyElement.classList.add(MAGNIFY_CLASSNAME);
        Object.assign(magnifyElement.style, {
            display: 'block',
            width: `${size}px`,
            height: `${size}px`,
            position: 'absolute',
            overflow: 'hidden',
            borderRadius: '50%',
            boxSizing: 'border-box',
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(-1000px, -1000px)`,
        });
        return magnifyElement;
    }
    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {
        const { parallelScale } = viewport.getCamera();
        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;
        return parallelScale * (1 / zoomFactor) * canvasRatio;
    }
    _isStackViewport(viewport) {
        return 'setStack' in viewport;
    }
    _isVolumeViewport(viewport) {
        return 'addVolumes' in viewport;
    }
    _cloneToolGroups(sourceViewport, magnifyViewport) {
        const sourceActors = sourceViewport.getActors();
        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;
        const sourceToolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_14__.getToolGroupForViewport)(sourceViewport.id, sourceViewport.renderingEngineId);
        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {
            const toolInstance = sourceToolGroup.getToolInstance(toolName);
            const isAnnotationTool = toolInstance instanceof _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool &&
                !(toolInstance instanceof AdvancedMagnifyTool);
            return isAnnotationTool;
        });
        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);
        sourceActors.filter(isSegmentation).forEach((actor) => {
            (0,_stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_17__.addSegmentationRepresentations)(this.viewportId, [
                {
                    segmentationId: actor.referencedId,
                    type: _enums__WEBPACK_IMPORTED_MODULE_8__.SegmentationRepresentations.Labelmap,
                },
            ]);
        });
        return { sourceToolGroup, magnifyToolGroup };
    }
    _cloneStack(sourceViewport, magnifyViewport) {
        const imageIds = sourceViewport.getImageIds();
        magnifyViewport.setStack(imageIds).then(() => {
            this._isViewportReady = true;
            this.update();
        });
    }
    _cloneVolumes(sourceViewport, magnifyViewport) {
        const actors = sourceViewport.getActors();
        const volumeInputArray = actors
            .filter((actor) => !isSegmentation(actor))
            .map((actor) => ({ volumeId: actor.uid }));
        magnifyViewport.setVolumes(volumeInputArray).then(() => {
            this._isViewportReady = true;
            this.update();
        });
        return magnifyViewport;
    }
    _cloneViewport(sourceViewport, magnifyElement) {
        const { viewportId: magnifyViewportId } = this;
        const renderingEngine = sourceViewport.getRenderingEngine();
        const { options: sourceViewportOptions } = sourceViewport;
        const viewportInput = {
            element: magnifyElement,
            viewportId: magnifyViewportId,
            type: sourceViewport.type,
            defaultOptions: { ...sourceViewportOptions },
        };
        renderingEngine.enableElement(viewportInput);
        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));
        if (this._isStackViewport(sourceViewport)) {
            this._cloneStack(sourceViewport, magnifyViewport);
        }
        else if (this._isVolumeViewport(sourceViewport)) {
            this._cloneVolumes(sourceViewport, magnifyViewport);
        }
        this._inheritBorderRadius(magnifyElement);
        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);
        this._sourceToolGroup = toolGroups.sourceToolGroup;
        this._magnifyToolGroup = toolGroups.magnifyToolGroup;
    }
    _cancelMouseEventCallback(evt) {
        evt.stopPropagation();
        evt.preventDefault();
    }
    _browserMouseUpCallback(evt) {
        const { element } = this._enabledElement.viewport;
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _browserMouseDownCallback(evt) {
        const { element } = this._enabledElement.viewport;
        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');
        document.addEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _mouseDragCallback(evt) {
        if (!_store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool) {
            return;
        }
        const { _autoPan: autoPan } = this;
        if (!autoPan.enabled || !this._canAutoPan) {
            return;
        }
        const { currentPoints } = evt.detail;
        const { viewport } = this._enabledElement;
        const { canvasToWorld } = viewport;
        const { canvas: canvasCurrent } = currentPoints;
        const { radius: magnifyRadius } = this;
        const canvasCenter = [magnifyRadius, magnifyRadius];
        const dist = (0,_utilities_math_point__WEBPACK_IMPORTED_MODULE_16__.distanceToPoint)(canvasCenter, canvasCurrent);
        const maxDist = magnifyRadius - autoPan.padding;
        if (dist <= maxDist) {
            return;
        }
        const panDist = dist - maxDist;
        const canvasDeltaPos = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec2.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec2.create(), canvasCurrent, canvasCenter);
        gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec2.normalize(canvasDeltaPos, canvasDeltaPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);
        const newCanvasPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec2.add(gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec2.create(), this.position, canvasDeltaPos);
        const currentWorldPos = canvasToWorld(this.position);
        const newWorldPos = canvasToWorld(newCanvasPosition);
        const worldDeltaPos = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_13__.vec3.create(), newWorldPos, currentWorldPos);
        const autoPanCallbackData = {
            points: {
                currentPosition: {
                    canvas: this.position,
                    world: currentWorldPos,
                },
                newPosition: {
                    canvas: newCanvasPosition,
                    world: newWorldPos,
                },
            },
            delta: {
                canvas: canvasDeltaPos,
                world: worldDeltaPos,
            },
        };
        autoPan.callback(autoPanCallbackData);
    }
    _addBrowserEventListeners(element) {
        document.addEventListener('mousedown', this._browserMouseDownCallback, true);
        element.addEventListener('mousedown', this._cancelMouseEventCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
        element.addEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _removeBrowserEventListeners(element) {
        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mousedown', this._cancelMouseEventCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
        element.removeEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _addEventListeners(element) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._addBrowserEventListeners(element);
    }
    _removeEventListeners(element) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._removeBrowserEventListeners(element);
    }
    _initialize() {
        const { _sourceEnabledElement: sourceEnabledElement } = this;
        const { viewport: sourceViewport } = sourceEnabledElement;
        const { canvas: sourceCanvas } = sourceViewport;
        const magnifyElement = this._createViewportNode();
        sourceCanvas.parentNode.appendChild(magnifyElement);
        this._addEventListeners(magnifyElement);
        this._cloneViewport(sourceViewport, magnifyElement);
        this._enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(magnifyElement);
    }
    _syncViewportsCameras(sourceViewport, magnifyViewport) {
        const worldPos = sourceViewport.canvasToWorld(this.position);
        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);
        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
            Math.pow(focalPoint[1] - position[1], 2) +
            Math.pow(focalPoint[2] - position[2], 2));
        const updatedFocalPoint = [
            worldPos[0],
            worldPos[1],
            worldPos[2],
        ];
        const updatedPosition = [
            updatedFocalPoint[0] + distance * viewPlaneNormal[0],
            updatedFocalPoint[1] + distance * viewPlaneNormal[1],
            updatedFocalPoint[2] + distance * viewPlaneNormal[2],
        ];
        magnifyViewport.setCamera({
            parallelScale,
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
    }
    _syncStackViewports(sourceViewport, magnifyViewport) {
        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());
    }
    _syncViewports() {
        const { viewport: sourceViewport } = this._sourceEnabledElement;
        const { viewport: magnifyViewport } = this._enabledElement;
        const sourceProperties = sourceViewport.getProperties();
        const imageData = magnifyViewport.getImageData();
        if (!imageData) {
            return;
        }
        magnifyViewport.setProperties(sourceProperties);
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        if (this._isStackViewport(sourceViewport)) {
            this._syncStackViewports(sourceViewport, magnifyViewport);
        }
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        magnifyViewport.render();
    }
    _resizeViewport() {
        const { viewport } = this._enabledElement;
        const renderingEngine = viewport.getRenderingEngine();
        renderingEngine.resize();
    }
}
AdvancedMagnifyTool.toolName = 'AdvancedMagnify';



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stateManagement/annotation/annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");




class AnnotationEraserTool extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'mouse');
        };
        this.preTouchStartCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'touch');
        };
    }
    _deleteNearbyAnnotations(evt, interactionType) {
        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroupForViewport)(viewportId, renderingEngineId);
        if (!toolGroup) {
            return false;
        }
        const tools = toolGroup._toolInstances;
        const annotationsToRemove = [];
        for (const toolName in tools) {
            const toolInstance = tools[toolName];
            if (typeof toolInstance.isPointNearTool !== 'function' ||
                typeof toolInstance.filterInteractableAnnotationsForElement !==
                    'function') {
                continue;
            }
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(toolName, element);
            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);
            if (!interactableAnnotations) {
                continue;
            }
            for (const annotation of interactableAnnotations) {
                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {
                    annotationsToRemove.push(annotation.annotationUID);
                }
            }
        }
        for (const annotationUID of annotationsToRemove) {
            (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID);
            const annotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotation)(annotationUID);
            _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool.createAnnotationMemo(element, annotation, {
                deleting: true,
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.removeAnnotation)(annotationUID);
        }
        evt.preventDefault();
        return true;
    }
}
AnnotationEraserTool.toolName = 'Eraser';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationEraserTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/Math */ "../../../node_modules/@kitware/vtk.js/Common/Core/Math.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/MatrixBuilder */ "../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utilities/math/vec2/liangBarksyClip */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js");
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utilities/math/line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
















const { RENDERING_DEFAULTS } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS;
function defaultReferenceLineColor() {
    return 'rgb(0, 200, 0)';
}
function defaultReferenceLineControllable() {
    return true;
}
function defaultReferenceLineDraggableRotatable() {
    return true;
}
function defaultReferenceLineSlabThicknessControlsOn() {
    return true;
}
const OPERATION = {
    DRAG: 1,
    ROTATE: 2,
    SLAB: 3,
};
const EPSILON = 1e-3;
class CrosshairsTool extends _base__WEBPACK_IMPORTED_MODULE_3__.AnnotationTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse'],
        configuration: {
            shadow: true,
            viewportIndicators: false,
            viewportIndicatorsConfig: {
                radius: 5,
                x: null,
                y: null,
            },
            autoPan: {
                enabled: false,
                panSize: 10,
            },
            handleRadius: 3,
            enableHDPIHandles: false,
            referenceLinesCenterGapRadius: 20,
            filterActorUIDsToSetSlabThickness: [],
            slabThicknessBlendMode: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,
            mobile: {
                enabled: false,
                opacity: 0.8,
                handleRadius: 9,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.toolCenter = [0, 0, 0];
        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { FrameOfReferenceUID, viewport } = enabledElement;
            const { element } = viewport;
            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();
            let annotations = this._getAnnotations(enabledElement);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (annotations?.length) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.removeAnnotation)(annotations[0].annotationUID);
            }
            const annotation = {
                highlighted: false,
                metadata: {
                    cameraPosition: [...position],
                    cameraFocalPoint: [...focalPoint],
                    FrameOfReferenceUID,
                    toolName: this.getToolName(),
                },
                data: {
                    handles: {
                        rotationPoints: [],
                        slabThicknessPoints: [],
                        toolCenter: this.toolCenter,
                    },
                    activeOperation: null,
                    activeViewportIds: [],
                    viewportId,
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.addAnnotation)(annotation, element);
            return {
                normal: viewPlaneNormal,
                point: viewport.canvasToWorld([
                    viewport.canvas.clientWidth / 2,
                    viewport.canvas.clientHeight / 2,
                ]),
            };
        };
        this._getViewportsInfo = () => {
            const viewports = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resetCrosshairs = () => {
            const viewportsInfo = this._getViewportsInfo();
            for (const viewportInfo of viewportsInfo) {
                const { viewportId, renderingEngineId } = viewportInfo;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
                const viewport = enabledElement.viewport;
                const resetPan = true;
                const resetZoom = true;
                const resetToCenter = true;
                const resetRotation = true;
                const suppressEvents = true;
                viewport.resetCamera({
                    resetPan,
                    resetZoom,
                    resetToCenter,
                    resetRotation,
                    suppressEvents,
                });
                viewport.resetSlabThickness();
                const { element } = viewport;
                let annotations = this._getAnnotations(enabledElement);
                annotations = this.filterInteractableAnnotationsForElement(element, annotations);
                if (annotations.length) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.removeAnnotation)(annotations[0].annotationUID);
                }
                viewport.render();
            }
            this._computeToolCenter(viewportsInfo);
        };
        this.computeToolCenter = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._computeToolCenter = (viewportsInfo) => {
            if (!viewportsInfo.length || viewportsInfo.length === 1) {
                console.warn('For crosshairs to operate, at least two viewports must be given.');
                return;
            }
            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;
            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);
            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);
            let normal3 = [0, 0, 0];
            let point3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
            if (thirdViewport) {
                ({ normal: normal3, point: point3 } =
                    this.initializeViewport(thirdViewport));
            }
            else {
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(point3, point1, point2);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scale(point3, point3, 0.5);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(normal3, normal1, normal2);
            }
            const firstPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.planeEquation(normal1, point1);
            const secondPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.planeEquation(normal2, point2);
            const thirdPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.planeEquation(normal3, point3);
            const toolCenter = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);
            this.setToolCenter(toolCenter);
        };
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const jumpWorld = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this._jump(enabledElement, jumpWorld);
            const annotations = this._getAnnotations(enabledElement);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);
            const { data } = filteredAnnotations[0];
            const { rotationPoints } = data.handles;
            const viewportIdArray = [];
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                if (!viewportControllable || !viewportDraggableRotatable) {
                    continue;
                }
                viewportIdArray.push(otherViewport.id);
                i++;
            }
            data.activeViewportIds = [...viewportIdArray];
            data.handles.activeOperation = OPERATION.DRAG;
            evt.preventDefault();
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            this._activateModify(element);
            return filteredAnnotations[0];
        };
        this.cancel = () => {
            console.log('Not implemented yet');
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const viewport = enabledElement.viewport;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const currentCamera = viewport.getCamera();
            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;
            const deltaCameraPosition = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);
            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);
            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];
            viewportAnnotation.metadata.cameraFocalPoint = [
                ...currentCamera.focalPoint,
            ];
            const viewportControllable = this._getReferenceLineControllable(viewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);
            if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&
                viewportControllable &&
                viewportDraggableRotatable) {
                let isRotation = false;
                const cameraModifiedSameForPosAndFocalPoint = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);
                if (!cameraModifiedSameForPosAndFocalPoint) {
                    isRotation = true;
                }
                const cameraModifiedInPlane = Math.abs(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;
                if (!isRotation && !cameraModifiedInPlane) {
                    this.toolCenter[0] += deltaCameraPosition[0];
                    this.toolCenter[1] += deltaCameraPosition[1];
                    this.toolCenter[2] += deltaCameraPosition[2];
                    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_9__.Events.CROSSHAIR_TOOL_CENTER_CHANGED, {
                        toolGroupId: this.toolGroupId,
                        toolCenter: this.toolCenter,
                    });
                }
            }
            if (this.configuration.autoPan?.enabled) {
                const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroupForViewport)(viewport.id, renderingEngine.id);
                const otherViewportIds = toolGroup
                    .getViewportIds()
                    .filter((id) => id !== viewport.id);
                otherViewportIds.forEach((viewportId) => {
                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);
                });
            }
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
        };
        this.onResetCamera = (evt) => {
            this.resetCrosshairs();
        };
        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {
            const { element, currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            let imageNeedsUpdate = false;
            for (let i = 0; i < filteredToolAnnotations.length; i++) {
                const annotation = filteredToolAnnotations[i];
                if ((0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_14__.isAnnotationLocked)(annotation.annotationUID)) {
                    continue;
                }
                const { data, highlighted } = annotation;
                if (!data.handles) {
                    continue;
                }
                const previousActiveOperation = data.handles.activeOperation;
                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0
                    ? [...data.activeViewportIds]
                    : [];
                data.activeViewportIds = [];
                data.handles.activeOperation = null;
                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);
                let near = false;
                if (handleNearImagePoint) {
                    near = true;
                }
                else {
                    near = this._pointNearTool(element, annotation, canvasCoords, 6);
                }
                const nearToolAndNotMarkedActive = near && !highlighted;
                const notNearToolAndMarkedActive = !near && highlighted;
                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
                    annotation.highlighted = !highlighted;
                    imageNeedsUpdate = true;
                }
                else if (data.handles.activeOperation !== previousActiveOperation ||
                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {
                    imageNeedsUpdate = true;
                }
            }
            return imageNeedsUpdate;
        };
        this.filterInteractableAnnotationsForElement = (element, annotations) => {
            if (!annotations || !annotations.length) {
                return [];
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { viewportId } = enabledElement;
            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);
            return viewportUIDSpecificCrosshairs;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, renderingEngine } = enabledElement;
            const { element } = viewport;
            const annotations = this._getAnnotations(enabledElement);
            const camera = viewport.getCamera();
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!annotations?.length || !viewportAnnotation?.data) {
                return renderStatus;
            }
            const annotationUID = viewportAnnotation.annotationUID;
            const { clientWidth, clientHeight } = viewport.canvas;
            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);
            const data = viewportAnnotation.data;
            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);
            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);
            const referenceLines = [];
            const canvasBox = [0, 0, clientWidth, clientHeight];
            otherViewportAnnotations.forEach((annotation) => {
                const { data } = annotation;
                data.handles.toolCenter = this.toolCenter;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                const { clientWidth, clientHeight } = otherViewport.canvas;
                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
                const otherCanvasCenter = [
                    clientWidth * 0.5,
                    clientHeight * 0.5,
                ];
                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);
                const direction = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(direction);
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].multiplyScalar(direction, otherCanvasDiagonalLength);
                const pointWorld0 = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].add(otherViewportCenterWorld, direction, pointWorld0);
                const pointWorld1 = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].subtract(otherViewportCenterWorld, direction, pointWorld1);
                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);
                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);
                const canvasUnitVectorFromCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
                const canvasVectorFromCenterLong = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);
                const canvasVectorFromCenterMid = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);
                const canvasVectorFromCenterShort = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);
                const canvasVectorFromCenterStart = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const centerGap = this.configuration.referenceLinesCenterGapRadius;
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);
                const refLinePointOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const refLinePointTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const refLinePointThree = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const refLinePointFour = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                let refLinesCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable || !otherViewportControllable) {
                    refLinesCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.clone(otherViewportCenterCanvas);
                }
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__["default"])(refLinePointOne, refLinePointTwo, canvasBox);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__["default"])(refLinePointThree, refLinePointFour, canvasBox);
                const rotHandleOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);
                const rotHandleTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);
                let stHandlesCenterCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.clone(otherViewportCenterCanvas);
                }
                let stHandlesCenterWorld = [...this.toolCenter];
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterWorld = [...otherViewportCenterWorld];
                }
                const worldUnitVectorFromCenter = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(worldUnitVectorFromCenter);
                const { viewPlaneNormal } = camera;
                const { matrix } = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__["default"]
                    .buildFromDegree()
                    .rotate(90, viewPlaneNormal);
                const worldUnitOrthoVectorFromCenter = [0, 0, 0];
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);
                const slabThicknessValue = otherViewport.getSlabThickness();
                const worldOrthoVectorFromCenter = [
                    ...worldUnitOrthoVectorFromCenter,
                ];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);
                const worldVerticalRefPoint = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);
                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);
                const canvasOrthoVectorFromCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);
                const stLinePointOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);
                const stLinePointTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__["default"])(stLinePointOne, stLinePointTwo, canvasBox);
                const stLinePointThree = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);
                const stLinePointFour = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__["default"])(stLinePointThree, stLinePointFour, canvasBox);
                const stHandleOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const stHandleTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const stHandleThree = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const stHandleFour = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);
                referenceLines.push([
                    otherViewport,
                    refLinePointOne,
                    refLinePointTwo,
                    refLinePointThree,
                    refLinePointFour,
                    stLinePointOne,
                    stLinePointTwo,
                    stLinePointThree,
                    stLinePointFour,
                    rotHandleOne,
                    rotHandleTwo,
                    stHandleOne,
                    stHandleTwo,
                    stHandleThree,
                    stHandleFour,
                ]);
            });
            const newRtpoints = [];
            const newStpoints = [];
            const viewportColor = this._getReferenceLineColor(viewport.id);
            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
            referenceLines.forEach((line, lineIndex) => {
                const otherViewport = line[0];
                const viewportColor = this._getReferenceLineColor(otherViewport.id);
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);
                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                let lineWidth = 1;
                const lineActive = data.handles.activeOperation !== null &&
                    data.handles.activeOperation === OPERATION.DRAG &&
                    selectedViewportId;
                if (lineActive) {
                    lineWidth = 2.5;
                }
                let lineUID = `${lineIndex}`;
                if (viewportControllable && viewportDraggableRotatable) {
                    lineUID = `${lineIndex}One`;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {
                        color,
                        lineWidth,
                    });
                    lineUID = `${lineIndex}Two`;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {
                        color,
                        lineWidth,
                    });
                }
                else {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {
                        color,
                        lineWidth,
                    });
                }
                if (viewportControllable) {
                    color =
                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;
                    const rotationHandles = [line[9], line[10]];
                    const rotHandleWorldOne = [
                        viewport.canvasToWorld(line[9]),
                        otherViewport,
                        line[1],
                        line[2],
                    ];
                    const rotHandleWorldTwo = [
                        viewport.canvasToWorld(line[10]),
                        otherViewport,
                        line[3],
                        line[4],
                    ];
                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);
                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;
                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];
                    const slabThicknessHandleWorldOne = [
                        viewport.canvasToWorld(line[11]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldTwo = [
                        viewport.canvasToWorld(line[12]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldThree = [
                        viewport.canvasToWorld(line[13]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    const slabThicknessHandleWorldFour = [
                        viewport.canvasToWorld(line[14]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);
                    let handleRadius = this.configuration.handleRadius *
                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);
                    let opacity = 1;
                    if (this.configuration.mobile?.enabled) {
                        handleRadius = this.configuration.mobile.handleRadius;
                        opacity = this.configuration.mobile.opacity;
                    }
                    if ((lineActive || this.configuration.mobile?.enabled) &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable &&
                        viewportSlabThicknessControlsOn) {
                        let handleUID = `${lineIndex}One`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'circle',
                        });
                        handleUID = `${lineIndex}Two`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'rect',
                        });
                    }
                    else if (lineActive &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'circle',
                        });
                    }
                    else if (selectedViewportId &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportSlabThicknessControlsOn) {
                        const handleUID = `${lineIndex}`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'rect',
                        });
                    }
                    else if (rotHandlesActive && viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        const handleRadius = this.configuration.handleRadius *
                            (this.configuration.enableHDPIHandles
                                ? window.devicePixelRatio
                                : 1);
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            fill: color,
                            type: 'circle',
                        });
                    }
                    else if (slabThicknessHandlesActive &&
                        selectedViewportId &&
                        viewportSlabThicknessControlsOn) {
                        const handleRadius = this.configuration.handleRadius *
                            (this.configuration.enableHDPIHandles
                                ? window.devicePixelRatio
                                : 1);
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            fill: color,
                            type: 'rect',
                        });
                    }
                    const slabThicknessValue = otherViewport.getSlabThickness();
                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {
                        lineUID = `${lineIndex}STOne`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {
                            color,
                            width: 1,
                            lineDash: [2, 3],
                        });
                        lineUID = `${lineIndex}STTwo`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {
                            color,
                            width: line,
                            lineDash: [2, 3],
                        });
                    }
                }
            });
            renderStatus = true;
            data.handles.rotationPoints = newRtpoints;
            data.handles.slabThicknessPoints = newStpoints;
            if (this.configuration.viewportIndicators) {
                const { viewportIndicatorsConfig } = this.configuration;
                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;
                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;
                const referenceColorCoordinates = [
                    clientWidth * xOffset,
                    clientHeight * yOffset,
                ];
                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });
            }
            return renderStatus;
        };
        this._getAnnotations = (enabledElement) => {
            const { viewport } = enabledElement;
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.getAnnotations)(this.getToolName(), viewport.element) || [];
            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);
            const toolGroupAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                return viewportIds.includes(data.viewportId);
            });
            return toolGroupAnnotations;
        };
        this._onNewVolume = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {
            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {
                return false;
            }
            viewportIdArrayOne.forEach((id) => {
                let itemFound = false;
                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {
                    if (id === viewportIdArrayTwo[i]) {
                        itemFound = true;
                        break;
                    }
                }
                if (itemFound === false) {
                    return false;
                }
            });
            return true;
        };
        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {
            const { viewportId, renderingEngine, viewport } = enabledElement;
            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);
            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const { viewPlaneNormal, position } = camera;
            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const targetViewport = renderingEngine.getViewport(viewportId);
                const cameraOfTarget = targetViewport.getCamera();
                return !(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfTarget.position, position, 1));
            });
            return viewportsWithDifferentCameras;
        };
        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {
            const { renderingEngine } = enabledElement;
            const { data } = referenceAnnotation;
            const viewport = renderingEngine.getViewport(data.viewportId);
            const linkedViewportAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return otherViewportControllable === true;
            });
            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(viewPlaneNormal);
            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(otherViewPlaneNormal);
                return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));
            });
            return otherViewportsAnnotationsWithSameCameraDirection;
        };
        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {
            const { renderingEngine, viewport } = enabledElement;
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(viewPlaneNormal);
            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable === true);
            });
            const otherViewportsAnnotationsWithUniqueCameras = [];
            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(otherViewPlaneNormal);
                if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable !== true);
            });
            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(otherViewPlaneNormal);
                if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            for (let i = 0; i < otherViewportAnnotations.length; ++i) {
                const annotation = otherViewportAnnotations[i];
                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {
                    continue;
                }
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].normalize(otherViewPlaneNormal);
                if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            return otherViewportsAnnotationsWithUniqueCameras;
        };
        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {
            const volumeIds = viewport.getAllVolumeIds();
            const otherVolumeIds = otherViewport.getAllVolumeIds();
            return (volumeIds.length === otherVolumeIds.length &&
                volumeIds.every((id) => otherVolumeIds.includes(id)));
        };
        this._jump = (enabledElement, jumpWorld) => {
            _store_state__WEBPACK_IMPORTED_MODULE_8__.state.isInteractingWithTool = true;
            const { viewport, renderingEngine } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const delta = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].subtract(jumpWorld, this.toolCenter, delta);
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);
                return (this._getReferenceLineControllable(otherViewport.id) &&
                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&
                    sameScene);
            });
            if (viewportsAnnotationsToUpdate.length === 0) {
                _store_state__WEBPACK_IMPORTED_MODULE_8__.state.isInteractingWithTool = false;
                return false;
            }
            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            _store_state__WEBPACK_IMPORTED_MODULE_8__.state.isInteractingWithTool = false;
            return true;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_8__.state.isInteractingWithTool = !this.configuration.mobile?.enabled;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_8__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_TAP, this._endCallback);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            this.editData.annotation.data.handles.activeOperation = null;
            this.editData.annotation.data.activeViewportIds = [];
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            this.editData = null;
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const delta = eventDetail.deltaPoints.world;
            if (Math.abs(delta[0]) < 1e-3 &&
                Math.abs(delta[1]) < 1e-3 &&
                Math.abs(delta[2]) < 1e-3) {
                return;
            }
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const { handles } = viewportAnnotation.data;
            const { currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            if (handles.activeOperation === OPERATION.DRAG) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            }
            else if (handles.activeOperation === OPERATION.ROTATE) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true);
                });
                const dir1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const dir2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                const center = [
                    this.toolCenter[0],
                    this.toolCenter[1],
                    this.toolCenter[2],
                ];
                const centerCanvas = viewport.worldToCanvas(center);
                const finalPointCanvas = eventDetail.currentPoints.canvas;
                const originalPointCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.sub(dir1, originalPointCanvas, centerCanvas);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.sub(dir2, finalPointCanvas, centerCanvas);
                let angle = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.angle(dir1, dir2);
                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {
                    angle *= -1;
                }
                angle = Math.round(angle * 100) / 100;
                const rotationAxis = viewport.getCamera().viewPlaneNormal;
                const { matrix } = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__["default"]
                    .buildFromRadian()
                    .translate(center[0], center[1], center[2])
                    .rotate(angle, rotationAxis)
                    .translate(-center[0], -center[1], -center[2]);
                const otherViewportsIds = [];
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    data.handles.toolCenter = center;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const { viewUp, position, focalPoint } = camera;
                    viewUp[0] += position[0];
                    viewUp[1] += position[1];
                    viewUp[2] += position[2];
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4(focalPoint, focalPoint, matrix);
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4(position, position, matrix);
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4(viewUp, viewUp, matrix);
                    viewUp[0] -= position[0];
                    viewUp[1] -= position[1];
                    viewUp[2] -= position[2];
                    otherViewport.setCamera({
                        position,
                        viewUp,
                        focalPoint,
                    });
                    otherViewportsIds.push(otherViewport.id);
                });
                renderingEngine.renderViewports(otherViewportsIds);
            }
            else if (handles.activeOperation === OPERATION.SLAB) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportSlabThicknessControlsOn === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                if (referenceAnnotations.length === 0) {
                    return;
                }
                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);
                const viewportsIds = [];
                viewportsIds.push(viewport.id);
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const normal = camera.viewPlaneNormal;
                    const dotProd = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].dot(delta, normal);
                    const projectedDelta = [...normal];
                    _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].multiplyScalar(projectedDelta, dotProd);
                    if (Math.abs(projectedDelta[0]) > 1e-3 ||
                        Math.abs(projectedDelta[1]) > 1e-3 ||
                        Math.abs(projectedDelta[2]) > 1e-3) {
                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +
                            projectedDelta[1] * projectedDelta[1] +
                            projectedDelta[2] * projectedDelta[2]);
                        const currentPoint = eventDetail.lastPoints.world;
                        const direction = [0, 0, 0];
                        const currentCenter = [
                            this.toolCenter[0],
                            this.toolCenter[1],
                            this.toolCenter[2],
                        ];
                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                        if (!viewportDraggableRotatable) {
                            const { rotationPoints } = this.editData.annotation.data.handles;
                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);
                            if (otherViewportRotationPoints.length === 2) {
                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);
                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);
                                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].add(point1, point2, currentCenter);
                                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].multiplyScalar(currentCenter, 0.5);
                            }
                        }
                        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].subtract(currentPoint, currentCenter, direction);
                        const dotProdDirection = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].dot(direction, normal);
                        const projectedDirection = [...normal];
                        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].multiplyScalar(projectedDirection, dotProdDirection);
                        const normalizedProjectedDirection = [
                            projectedDirection[0],
                            projectedDirection[1],
                            projectedDirection[2],
                        ];
                        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);
                        const normalizedProjectedDelta = [
                            projectedDelta[0],
                            projectedDelta[1],
                            projectedDelta[2],
                        ];
                        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);
                        let slabThicknessValue = otherViewport.getSlabThickness();
                        if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {
                            slabThicknessValue -= mod;
                        }
                        else {
                            slabThicknessValue += mod;
                        }
                        slabThicknessValue = Math.abs(slabThicknessValue);
                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);
                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);
                        if (near) {
                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
                        }
                        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroupForViewport)(otherViewport.id, renderingEngine.id);
                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());
                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);
                        viewportsIds.push(otherViewport.id);
                    }
                });
                renderingEngine.renderViewports(viewportsIds);
            }
        };
        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {
            const { data } = annotation;
            const { rotationPoints } = data.handles;
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                if (otherViewport.id !== lineViewport.id) {
                    continue;
                }
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                if (!viewportControllable) {
                    continue;
                }
                const lineSegment1 = {
                    start: {
                        x: rotationPoints[i][2][0],
                        y: rotationPoints[i][2][1],
                    },
                    end: {
                        x: rotationPoints[i][3][0],
                        y: rotationPoints[i][3][1],
                    },
                };
                const distanceToPoint1 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
                const lineSegment2 = {
                    start: {
                        x: rotationPoints[i + 1][2][0],
                        y: rotationPoints[i + 1][2][1],
                    },
                    end: {
                        x: rotationPoints[i + 1][3][0],
                        y: rotationPoints[i + 1][3][1],
                    },
                };
                const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                    return true;
                }
                i++;
            }
            return false;
        };
        this._getReferenceLineColor =
            toolProps.configuration?.getReferenceLineColor ||
                defaultReferenceLineColor;
        this._getReferenceLineControllable =
            toolProps.configuration?.getReferenceLineControllable ||
                defaultReferenceLineControllable;
        this._getReferenceLineDraggableRotatable =
            toolProps.configuration?.getReferenceLineDraggableRotatable ||
                defaultReferenceLineDraggableRotatable;
        this._getReferenceLineSlabThicknessControlsOn =
            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||
                defaultReferenceLineSlabThicknessControlsOn;
    }
    onSetToolActive() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        this._subscribeToViewportNewVolumeSet(viewportsInfo);
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolPassive() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolEnabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolDisabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const annotations = this._getAnnotations(enabledElement);
            if (annotations?.length) {
                annotations.forEach((annotation) => {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.removeAnnotation)(annotation.annotationUID);
                });
            }
        });
    }
    setToolCenter(toolCenter, suppressEvents = false) {
        this.toolCenter = toolCenter;
        const viewportsInfo = this._getViewportsInfo();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportsInfo.map(({ viewportId }) => viewportId));
        if (!suppressEvents) {
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_9__.Events.CROSSHAIR_TOOL_CENTER_CHANGED, {
                toolGroupId: this.toolGroupId,
                toolCenter: this.toolCenter,
            });
        }
    }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
    }
    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _subscribeToViewportNewVolumeSet(viewports) {
        viewports.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _autoPanViewportIfNecessary(viewportId, renderingEngine) {
        const viewport = renderingEngine.getViewport(viewportId);
        const { clientWidth, clientHeight } = viewport.canvas;
        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);
        const pan = this.configuration.autoPan.panSize;
        const visiblePointCanvas = [
            toolCenterCanvas[0],
            toolCenterCanvas[1],
        ];
        if (toolCenterCanvas[0] < 0) {
            visiblePointCanvas[0] = pan;
        }
        else if (toolCenterCanvas[0] > clientWidth) {
            visiblePointCanvas[0] = clientWidth - pan;
        }
        if (toolCenterCanvas[1] < 0) {
            visiblePointCanvas[1] = pan;
        }
        else if (toolCenterCanvas[1] > clientHeight) {
            visiblePointCanvas[1] = clientHeight - pan;
        }
        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&
            visiblePointCanvas[1] === toolCenterCanvas[1]) {
            return;
        }
        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);
        const deltaPointsWorld = [
            visiblePointWorld[0] - this.toolCenter[0],
            visiblePointWorld[1] - this.toolCenter[1],
            visiblePointWorld[2] - this.toolCenter[2],
        ];
        const camera = viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        viewport.render();
    }
    setSlabThickness(viewport, slabThickness) {
        let actorUIDs;
        const { filterActorUIDsToSetSlabThickness } = this.configuration;
        if (filterActorUIDsToSetSlabThickness &&
            filterActorUIDsToSetSlabThickness.length > 0) {
            actorUIDs = filterActorUIDsToSetSlabThickness;
        }
        let blendModeToUse = this.configuration.slabThicknessBlendMode;
        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {
            blendModeToUse = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.BlendModes.COMPOSITE;
        }
        const immediate = false;
        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);
        viewport.setSlabThickness(slabThickness, actorUIDs);
    }
    _isClockWise(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
    }
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {
        viewportsAnnotationsToUpdate.forEach((annotation) => {
            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);
        });
    }
    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {
        const { data } = annotation;
        const viewport = renderingEngine.getViewport(data.viewportId);
        const camera = viewport.getCamera();
        const normal = camera.viewPlaneNormal;
        const dotProd = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].dot(delta, normal);
        const projectedDelta = [...normal];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].multiplyScalar(projectedDelta, dotProd);
        if (Math.abs(projectedDelta[0]) > 1e-3 ||
            Math.abs(projectedDelta[1]) > 1e-3 ||
            Math.abs(projectedDelta[2]) > 1e-3) {
            const newFocalPoint = [0, 0, 0];
            const newPosition = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].add(camera.focalPoint, projectedDelta, newFocalPoint);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].add(camera.position, projectedDelta, newPosition);
            viewport.setCamera({
                focalPoint: newFocalPoint,
                position: newPosition,
            });
            viewport.render();
        }
    }
    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        for (let i = 0; i < rotationPoints.length; i++) {
            const point = rotationPoints[i][0];
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportDraggableRotatable) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = OPERATION.ROTATE;
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { slabThicknessPoints } = data.handles;
        for (let i = 0; i < slabThicknessPoints.length; i++) {
            const point = slabThicknessPoints[i][0];
            const otherViewport = slabThicknessPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportSlabThicknessControlsOn) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = OPERATION.SLAB;
                data.activeViewportIds = [otherViewport.id];
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _pointNearTool(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { clientWidth, clientHeight } = viewport.canvas;
        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        const { slabThicknessPoints } = data.handles;
        const viewportIdArray = [];
        for (let i = 0; i < rotationPoints.length - 1; ++i) {
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportControllable || !viewportDraggableRotatable) {
                continue;
            }
            const lineSegment1 = {
                start: {
                    x: rotationPoints[i][2][0],
                    y: rotationPoints[i][2][1],
                },
                end: {
                    x: rotationPoints[i][3][0],
                    y: rotationPoints[i][3][1],
                },
            };
            const distanceToPoint1 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: rotationPoints[i + 1][2][0],
                    y: rotationPoints[i + 1][2][1],
                },
                end: {
                    x: rotationPoints[i + 1][3][0],
                    y: rotationPoints[i + 1][3][1],
                },
            };
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = OPERATION.DRAG;
            }
            i++;
        }
        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {
            const otherViewport = slabThicknessPoints[i][1];
            if (viewportIdArray.find((id) => id === otherViewport.id)) {
                continue;
            }
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportControllable || !viewportSlabThicknessControlsOn) {
                continue;
            }
            const stPointLineCanvas1 = slabThicknessPoints[i][2];
            const stPointLineCanvas2 = slabThicknessPoints[i][3];
            const centerCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.scale(centerCanvas, centerCanvas, 0.5);
            const canvasUnitVectorFromCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
            const canvasVectorFromCenterStart = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);
            const stPointLineCanvas1Start = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
            const stPointLineCanvas2Start = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);
            const lineSegment1 = {
                start: {
                    x: stPointLineCanvas1Start[0],
                    y: stPointLineCanvas1Start[1],
                },
                end: {
                    x: stPointLineCanvas1[0],
                    y: stPointLineCanvas1[1],
                },
            };
            const distanceToPoint1 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: stPointLineCanvas2Start[0],
                    y: stPointLineCanvas2Start[1],
                },
                end: {
                    x: stPointLineCanvas2[0],
                    y: stPointLineCanvas2[1],
                },
            };
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = null;
            }
            i++;
        }
        data.activeViewportIds = [...viewportIdArray];
        this.editData = {
            annotation,
        };
        return data.handles.activeOperation === OPERATION.DRAG ? true : false;
    }
}
CrosshairsTool.toolName = 'Crosshairs';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrosshairsTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/planar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");





class MIPJumpToClickTool extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            targetViewportIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseClickCallback(evt) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const volumeId = viewport.getVolumeId();
        if (!volumeId) {
            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);
        }
        let maxIntensity = -Infinity;
        const maxFn = (intensity, point) => {
            if (intensity > maxIntensity) {
                maxIntensity = intensity;
                return point;
            }
        };
        const brightestPoint = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_2__.getPointInLineOfSightWithCriteria)(viewport, currentPoints.world, volumeId, maxFn);
        if (!brightestPoint || !brightestPoint.length) {
            return;
        }
        const { targetViewportIds, toolGroupId } = this.configuration;
        const viewports = renderingEngine.getViewports().filter((vp) => {
            if (targetViewportIds?.indexOf(vp.id) >= 0) {
                return true;
            }
            const foundToolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroupForViewport)(vp.id, renderingEngine.id);
            if (toolGroupId && toolGroupId === foundToolGroup?.id) {
                return true;
            }
            return false;
        });
        viewports.forEach((viewport) => {
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                viewport.jumpToWorld(brightestPoint);
            }
            else {
                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');
            }
        });
    }
}
MIPJumpToClickTool.toolName = 'MIPJumpToClickTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MIPJumpToClickTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");







const MAGNIFY_VIEWPORT_ID = 'magnify-viewport';
class MagnifyTool extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            magnifySize: 10,
            magnifyWidth: 250,
            magnifyHeight: 250,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._hasBeenRemoved = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.StackViewport)) {
                throw new Error('MagnifyTool only works on StackViewports');
            }
            const referencedImageId = this._getReferencedImageId(viewport);
            if (!referencedImageId) {
                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_3__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                referencedImageId,
                viewportIdsToRender,
                enabledElement,
                renderingEngine,
                currentPoints,
            };
            this._createMagnificationViewport();
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__["default"])(viewportIdsToRender);
            return true;
        };
        this.preTouchStartCallback = (evt) => {
            this.preMouseDownCallback(evt);
        };
        this._createMagnificationViewport = () => {
            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const viewportProperties = viewport.getProperties();
            const { rotation: originalViewportRotation } = viewport.getViewPresentation();
            const { canvas: canvasPos, world: worldPos } = currentPoints;
            let magnifyToolElement;
            magnifyToolElement = element.querySelector('.magnifyTool');
            if (magnifyToolElement === null) {
                const magnifyElement = document.createElement('div');
                magnifyElement.classList.add('magnifyTool');
                magnifyElement.style.display = 'block';
                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;
                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;
                magnifyElement.style.position = 'absolute';
                magnifyToolElement = magnifyElement;
                const viewportElement = element.querySelector('.viewport-element');
                viewportElement.appendChild(magnifyElement);
                const viewportInput = {
                    viewportId: MAGNIFY_VIEWPORT_ID,
                    type: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.ViewportType.STACK,
                    element: magnifyToolElement,
                };
                renderingEngine.enableElement(viewportInput);
            }
            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            magnifyViewport.setStack([referencedImageId]).then(() => {
                if (this._hasBeenRemoved) {
                    return;
                }
                magnifyViewport.setProperties(viewportProperties);
                magnifyViewport.setViewPresentation({
                    rotation: originalViewportRotation,
                });
                const { parallelScale } = viewport.getCamera();
                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
                    Math.pow(focalPoint[1] - position[1], 2) +
                    Math.pow(focalPoint[2] - position[2], 2));
                const updatedFocalPoint = [
                    worldPos[0],
                    worldPos[1],
                    worldPos[2],
                ];
                const updatedPosition = [
                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],
                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],
                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],
                ];
                magnifyViewport.setCamera({
                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),
                    focalPoint: updatedFocalPoint,
                    position: updatedPosition,
                });
                magnifyViewport.render();
            });
            magnifyToolElement.style.display = 'block';
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__["default"])(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const { deltaPoints, element, currentPoints } = eventDetail;
            const deltaPointsWorld = deltaPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            const magnifyElement = element.querySelector('.magnifyTool');
            if (!magnifyElement) {
                return;
            }
            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const { focalPoint, position } = magnifyViewport.getCamera();
            const updatedPosition = [
                position[0] + deltaPointsWorld[0],
                position[1] + deltaPointsWorld[1],
                position[2] + deltaPointsWorld[2],
            ];
            const updatedFocalPoint = [
                focalPoint[0] + deltaPointsWorld[0],
                focalPoint[1] + deltaPointsWorld[1],
                focalPoint[2] + deltaPointsWorld[2],
            ];
            magnifyViewport.setCamera({
                focalPoint: updatedFocalPoint,
                position: updatedPosition,
            });
            magnifyViewport.render();
        };
        this._dragEndCallback = (evt) => {
            const { element } = evt.detail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);
            const viewportElement = element.querySelector('.viewport-element');
            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');
            viewportElement.removeChild(magnifyToolElement);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            this._hasBeenRemoved = true;
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__.state.isInteractingWithTool = true;
            this._hasBeenRemoved = false;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._dragEndCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._dragEndCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._dragEndCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._dragEndCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._dragEndCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._dragEndCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
    }
    _getReferencedImageId(viewport) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.StackViewport) {
            referencedImageId = targetId.split('imageId:')[1];
        }
        return referencedImageId;
    }
}
MagnifyTool.toolName = 'Magnify';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MagnifyTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Interaction_Widgets_OrientationMarkerWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget */ "../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js");
/* harmony import */ var _kitware_vtk_js_Rendering_Core_AnnotatedCubeActor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kitware/vtk.js/Rendering/Core/AnnotatedCubeActor */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js");
/* harmony import */ var _kitware_vtk_js_Rendering_Core_AxesActor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @kitware/vtk.js/Rendering/Core/AxesActor */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js");
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @kitware/vtk.js/Rendering/Core/Actor */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js");
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @kitware/vtk.js/Rendering/Core/Mapper */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js");
/* harmony import */ var _kitware_vtk_js_IO_XML_XMLPolyDataReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @kitware/vtk.js/IO/XML/XMLPolyDataReader */ "../../../node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataReader.js");
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @kitware/vtk.js/Common/DataModel/PolyData */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");












var OverlayMarkerType;
(function (OverlayMarkerType) {
    OverlayMarkerType[OverlayMarkerType["ANNOTATED_CUBE"] = 1] = "ANNOTATED_CUBE";
    OverlayMarkerType[OverlayMarkerType["AXES"] = 2] = "AXES";
    OverlayMarkerType[OverlayMarkerType["CUSTOM"] = 3] = "CUSTOM";
})(OverlayMarkerType || (OverlayMarkerType = {}));
class OrientationMarkerTool extends _base__WEBPACK_IMPORTED_MODULE_7__.BaseTool {
    static { this.CUBE = 1; }
    static { this.AXIS = 2; }
    static { this.VTPFILE = 3; }
    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            orientationWidget: {
                enabled: true,
                viewportCorner: _kitware_vtk_js_Interaction_Widgets_OrientationMarkerWidget__WEBPACK_IMPORTED_MODULE_0__["default"].Corners.BOTTOM_RIGHT,
                viewportSize: 0.15,
                minPixelSize: 100,
                maxPixelSize: 300,
            },
            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,
            overlayConfiguration: {
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {
                    faceProperties: {
                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },
                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },
                        yPlus: {
                            text: 'P',
                            faceColor: '#00ffff',
                            fontColor: 'white',
                            faceRotation: 180,
                        },
                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },
                        zPlus: { text: 'S' },
                        zMinus: { text: 'I' },
                    },
                    defaultStyle: {
                        fontStyle: 'bold',
                        fontFamily: 'Arial',
                        fontColor: 'black',
                        fontSizeScale: (res) => res / 2,
                        faceColor: '#0000ff',
                        edgeThickness: 0.1,
                        edgeColor: 'black',
                        resolution: 400,
                    },
                },
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {
                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this.onSetToolEnabled = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolActive = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolDisabled = () => {
            this.cleanUpData();
            this._unsubscribeToViewportNewVolumeSet();
        };
        this._getViewportsInfo = () => {
            const viewports = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resize = (viewportId) => {
            const orientationMarker = this.orientationMarkers[viewportId];
            if (!orientationMarker) {
                return;
            }
            const { orientationWidget } = orientationMarker;
            orientationWidget.updateViewport();
        };
        this.orientationMarkers = {};
        this.updatingOrientationMarker = {};
    }
    _unsubscribeToViewportNewVolumeSet() {
        const unsubscribe = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = this._resizeObservers.get(viewportId);
                resizeObserver.unobserve(element);
            });
        };
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            unsubscribe();
            this.initViewports();
        });
    }
    _subscribeToViewportEvents() {
        const subscribeToElementResize = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                this.initViewports();
                element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = new ResizeObserver(() => {
                    setTimeout(() => {
                        const element = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getEnabledElementByIds)(viewportId, renderingEngineId);
                        if (!element) {
                            return;
                        }
                        const { viewport } = element;
                        this.resize(viewportId);
                        viewport.render();
                    }, 100);
                });
                resizeObserver.observe(element);
                this._resizeObservers.set(viewportId, resizeObserver);
            });
        };
        subscribeToElementResize();
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            subscribeToElementResize();
            this.initViewports();
        });
    }
    cleanUpData() {
        const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        const viewports = renderingEngine.getViewports();
        viewports.forEach((viewport) => {
            const orientationMarker = this.orientationMarkers[viewport.id];
            if (!orientationMarker) {
                return;
            }
            const { actor, orientationWidget } = orientationMarker;
            orientationWidget?.setEnabled(false);
            orientationWidget?.delete();
            actor?.delete();
            const renderWindow = viewport
                .getRenderingEngine()
                .offscreenMultiRenderWindow.getRenderWindow();
            renderWindow.render();
            viewport.getRenderingEngine().render();
            delete this.orientationMarkers[viewport.id];
        });
    }
    initViewports() {
        const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        if (!renderingEngine) {
            return;
        }
        let viewports = renderingEngine.getViewports();
        viewports = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.filterViewportsWithToolEnabled)(viewports, this.getToolName());
        viewports.forEach((viewport) => {
            const widget = viewport.getWidget(this.getToolName());
            if (!widget || widget.isDeleted()) {
                this.addAxisActorInViewport(viewport);
            }
        });
    }
    async addAxisActorInViewport(viewport) {
        const viewportId = viewport.id;
        if (!this.updatingOrientationMarker[viewportId]) {
            this.updatingOrientationMarker[viewportId] = true;
            const type = this.configuration.overlayMarkerType;
            const overlayConfiguration = this.configuration.overlayConfiguration[type];
            if (this.orientationMarkers[viewportId]) {
                const { actor, orientationWidget } = this.orientationMarkers[viewportId];
                viewport.getRenderer().removeActor(actor);
                orientationWidget.setEnabled(false);
            }
            let actor;
            if (type === 1) {
                actor = this.createAnnotationCube(overlayConfiguration);
            }
            else if (type === 2) {
                actor = _kitware_vtk_js_Rendering_Core_AxesActor__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
            }
            else if (type === 3) {
                actor = await this.createCustomActor();
            }
            const renderer = viewport.getRenderer();
            const renderWindow = viewport
                .getRenderingEngine()
                .offscreenMultiRenderWindow.getRenderWindow();
            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;
            const orientationWidget = _kitware_vtk_js_Interaction_Widgets_OrientationMarkerWidget__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance({
                actor,
                interactor: renderWindow.getInteractor(),
                parentRenderer: renderer,
            });
            orientationWidget.setEnabled(enabled);
            orientationWidget.setViewportCorner(viewportCorner);
            orientationWidget.setViewportSize(viewportSize);
            orientationWidget.setMinPixelSize(minPixelSize);
            orientationWidget.setMaxPixelSize(maxPixelSize);
            orientationWidget.updateMarkerOrientation();
            this.orientationMarkers[viewportId] = {
                orientationWidget,
                actor,
            };
            viewport.addWidget(this.getToolName(), orientationWidget);
            renderWindow.render();
            viewport.getRenderingEngine().render();
            this.updatingOrientationMarker[viewportId] = false;
        }
    }
    async createCustomActor() {
        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]
            .polyDataURL;
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const vtpReader = _kitware_vtk_js_IO_XML_XMLPolyDataReader__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance();
        vtpReader.parseAsArrayBuffer(arrayBuffer);
        vtpReader.update();
        const polyData = _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance();
        polyData.shallowCopy(vtpReader.getOutputData());
        polyData.getPointData().setActiveScalars('Color');
        const mapper = _kitware_vtk_js_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance();
        mapper.setInputData(polyData);
        mapper.setColorModeToDirectScalars();
        const actor = _kitware_vtk_js_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
        actor.setMapper(mapper);
        actor.rotateZ(180);
        return actor;
    }
    createAnnotationCube(overlayConfiguration) {
        const actor = _kitware_vtk_js_Rendering_Core_AnnotatedCubeActor__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });
        actor.setXPlusFaceProperty({
            ...overlayConfiguration.faceProperties.xPlus,
        });
        actor.setXMinusFaceProperty({
            ...overlayConfiguration.faceProperties.xMinus,
        });
        actor.setYPlusFaceProperty({
            ...overlayConfiguration.faceProperties.yPlus,
        });
        actor.setYMinusFaceProperty({
            ...overlayConfiguration.faceProperties.yMinus,
        });
        actor.setZPlusFaceProperty({
            ...overlayConfiguration.faceProperties.zPlus,
        });
        actor.setZMinusFaceProperty({
            ...overlayConfiguration.faceProperties.zMinus,
        });
        return actor;
    }
    async createAnnotatedCubeActor() {
        const axes = _kitware_vtk_js_Rendering_Core_AnnotatedCubeActor__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;
        axes.setDefaultStyle(defaultStyle);
        Object.keys(faceProperties).forEach((key) => {
            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;
            axes[methodName](faceProperties[key]);
        });
        return axes;
    }
}
OrientationMarkerTool.toolName = 'OrientationMarker';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrientationMarkerTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base/AnnotationDisplayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js");







const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS;
class OverlayGridTool extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceImageIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolActive = () => {
            this._init();
        };
        this._init = () => {
            const sourceImageIds = this.configuration.sourceImageIds;
            if (!sourceImageIds?.length) {
                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');
                return;
            }
            const imagePlaneModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', sourceImageIds[0]);
            if (!imagePlaneModule) {
                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');
                return;
            }
            const { frameOfReferenceUID } = imagePlaneModule;
            const viewportsInfo = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn('OverlayGridTool: No viewports found');
                return;
            }
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const pointSets = sourceImageIds.map((id) => {
                    return this.calculateImageIdPointSets(id);
                });
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        viewportData: new Map(),
                        pointSets,
                    },
                };
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.calculateImageIdPointSets = (imageId) => {
            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId);
            const topLeft = [...imagePositionPatient];
            const topRight = [...imagePositionPatient];
            const bottomLeft = [...imagePositionPatient];
            const bottomRight = [...imagePositionPatient];
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            return { pointSet1, pointSet2 };
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const sourceImageIds = this.configuration.sourceImageIds;
            let renderStatus = false;
            if (!sourceImageIds?.length) {
                return renderStatus;
            }
            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;
            const targetImageIds = targetViewport.getImageIds();
            if (targetImageIds.length < 2) {
                return renderStatus;
            }
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));
            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSets = annotation.data.pointSets;
            const viewportData = annotation.data.viewportData;
            for (let i = 0; i < sourceImageIds.length; i++) {
                const { pointSet1, pointSet2 } = pointSets[i];
                const targetData = viewportData.get(targetViewport.id) ||
                    this.initializeViewportData(viewportData, targetViewport.id);
                if (!targetData.pointSetsToUse[i]) {
                    let pointSetToUse = pointSet1;
                    let topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), pointSet1[0], pointSet1[1]);
                    topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), topBottomVec);
                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                        pointSetToUse = pointSet2;
                    }
                    targetData.pointSetsToUse[i] = pointSetToUse;
                    targetData.lineStartsWorld[i] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
                    targetData.lineEndsWorld[i] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
                }
                const lineStartWorld = targetData.lineStartsWorld[i];
                const lineEndWorld = targetData.lineEndsWorld[i];
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const shadow = this.getStyle('shadow', styleSpecifier, annotation);
                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
                const dataId = `${annotationUID}-line`;
                const lineUID = `${i}`;
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
            }
            renderStatus = true;
            return renderStatus;
        };
        this.initializeViewportData = (viewportData, id) => {
            viewportData.set(id, {
                pointSetsToUse: [],
                lineStartsWorld: [],
                lineEndsWorld: [],
            });
            return viewportData.get(id);
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(vec1, vec2);
            return Math.abs(dot) < EPSILON;
        };
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(vec1, vec2)) > 1 - EPSILON;
    }
    getImageIdNormal(imageId) {
        const { imageOrientationPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId);
        const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
        const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), rowCosineVec, colCosineVec);
    }
}
OverlayGridTool.toolName = 'OverlayGrid';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OverlayGridTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


class PanTool extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    _dragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        if (deltaPointsWorld[0] === 0 &&
            deltaPointsWorld[1] === 0 &&
            deltaPointsWorld[2] === 0) {
            return;
        }
        const camera = enabledElement.viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        enabledElement.viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        enabledElement.viewport.render();
    }
}
PanTool.toolName = 'Pan';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PanTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/math/angle/angleBetweenLines */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js");




class PlanarRotateTool extends _base__WEBPACK_IMPORTED_MODULE_2__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.mouseWheelCallback = (evt) => {
            const { element, wheel } = evt.detail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { invert } = this.configuration;
            const angle = wheel.direction * 10 * (invert ? -1 : 1);
            this.setAngle(viewport, angle);
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, startPoints } = evt.detail;
        const currentPointWorld = currentPoints.world;
        const startPointWorld = startPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const centerCanvas = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(centerCanvas);
        let angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_3__["default"])([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);
        const { viewPlaneNormal } = camera;
        const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), centerWorld, startPointWorld);
        const v2 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), centerWorld, currentPointWorld);
        const cross = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), v1, v2);
        if (gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewPlaneNormal, cross) > 0) {
            angle = -angle;
        }
        if (Number.isNaN(angle)) {
            return;
        }
        this.setAngle(viewport, angle);
    }
    setAngle(viewport, angle) {
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;
            const rotMat = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.identity(new Float32Array(16));
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);
            const rotatedViewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), viewUp, rotMat);
            viewport.setCamera({ viewUp: rotatedViewUp });
        }
        else {
            const { rotation } = viewport.getViewPresentation();
            viewport.setViewPresentation({
                rotation: (rotation + angle + 360) % 360,
            });
        }
        viewport.render();
    }
}
PlanarRotateTool.toolName = 'PlanarRotate';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarRotateTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base/AnnotationDisplayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/Math */ "../../../node_modules/@kitware/vtk.js/Common/Core/Math.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");











class ReferenceCursors extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            displayThreshold: 5,
            positionSync: true,
            disableCursor: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isHandleOutsideImage = false;
        this._elementWithCursor = null;
        this._currentCursorWorldPosition = null;
        this._currentCanvasPosition = null;
        this._disableCursorEnabled = false;
        this.mouseMoveCallback = (evt) => {
            const { detail } = evt;
            const { element, currentPoints } = detail;
            this._currentCursorWorldPosition = currentPoints.world;
            this._currentCanvasPosition = currentPoints.canvas;
            this._elementWithCursor = element;
            const annotation = this.getActiveAnnotation(element);
            if (annotation === null) {
                this.createInitialAnnotation(currentPoints.world, element);
                return false;
            }
            this.updateAnnotationPosition(element, annotation);
            return false;
        };
        this.createInitialAnnotation = (worldPos, element) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('No enabled element found');
            }
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            if (!viewPlaneNormal || !viewUp) {
                throw new Error('Camera not found');
            }
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                },
            };
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
            if (annotations.length > 0) {
                return null;
            }
            const annotationId = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, element);
            if (annotationId === null) {
                return;
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])(viewportIdsToRender);
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element, previousCamera, camera } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const viewport = enabledElement.viewport;
            if (element !== this._elementWithCursor) {
                return;
            }
            const oldFocalPoint = previousCamera.focalPoint;
            const cameraNormal = camera.viewPlaneNormal;
            const newFocalPoint = camera.focalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_8__["default"].subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);
            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {
                return;
            }
            const dotProduct = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_8__["default"].dot(deltaCameraFocalPoint, cameraNormal);
            if (Math.abs(dotProduct) < 1e-2) {
                return;
            }
            if (!this._currentCanvasPosition) {
                return;
            }
            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);
            this._currentCursorWorldPosition = newWorldPos;
            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, FrameOfReferenceUID } = enabledElement;
            const isElementWithCursor = this._elementWithCursor === viewport.element;
            if (this.configuration.positionSync && !isElementWithCursor) {
                this.updateViewportImage(viewport);
            }
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                if (!annotationUID) {
                    return renderStatus;
                }
                styleSpecifier.annotationUID = annotationUID;
                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));
                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor
                    ? lineWidthBase
                    : lineWidthBase;
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (points[0].some((e) => isNaN(e))) {
                    return renderStatus;
                }
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_2__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const crosshairUIDs = {
                    upper: 'upper',
                    right: 'right',
                    lower: 'lower',
                    left: 'left',
                };
                const [x, y] = canvasCoordinates[0];
                const centerSpace = isElementWithCursor ? 20 : 7;
                const lineLength = isElementWithCursor ? 5 : 7;
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });
                renderStatus = true;
            }
            return renderStatus;
        };
        this._disableCursorEnabled = this.configuration.disableCursor;
    }
    onSetToolActive() {
        this._disableCursorEnabled = this.configuration.disableCursor;
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element.viewport.element);
            }
        });
    }
    onSetToolDisabled() {
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element.viewport.element);
            }
        });
    }
    getActiveAnnotation(element) {
        const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
        if (!annotations.length) {
            return null;
        }
        const targetAnnotation = annotations[0];
        return targetAnnotation;
    }
    updateAnnotationPosition(element, annotation) {
        const worldPos = this._currentCursorWorldPosition;
        if (!worldPos) {
            return;
        }
        if (!annotation.data?.handles?.points) {
            return;
        }
        annotation.data.handles.points = [[...worldPos]];
        annotation.invalidated = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])(viewportIdsToRender);
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!(annotations instanceof Array) || annotations.length === 0) {
            return [];
        }
        const annotation = annotations[0];
        const viewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element)?.viewport;
        if (!viewport) {
            return [];
        }
        const camera = viewport.getCamera();
        const { viewPlaneNormal, focalPoint } = camera;
        if (!viewPlaneNormal || !focalPoint) {
            return [];
        }
        const points = annotation.data?.handles?.points;
        if (!(points instanceof Array) || points.length !== 1) {
            return [];
        }
        const worldPos = points[0];
        const plane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
        const distance = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeDistanceToPoint(plane, worldPos);
        return distance < this.configuration.displayThreshold ? [annotation] : [];
    }
    updateViewportImage(viewport) {
        const currentMousePosition = this._currentCursorWorldPosition;
        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {
            return;
        }
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
            const closestIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);
            if (closestIndex === null) {
                return;
            }
            if (closestIndex !== viewport.getCurrentImageIdIndex()) {
                viewport.setImageIdIndex(closestIndex);
            }
        }
        else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            const { focalPoint, viewPlaneNormal } = viewport.getCamera();
            if (!focalPoint || !viewPlaneNormal) {
                return;
            }
            const plane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const currentDistance = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);
            if (Math.abs(currentDistance) < 0.5) {
                return;
            }
            const normalizedViewPlane = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.fromValues(...viewPlaneNormal));
            const scaledPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.create(), normalizedViewPlane, currentDistance);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.add(gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.fromValues(...focalPoint), scaledPlaneNormal);
            const isInBounds = true;
            if (isInBounds) {
                viewport.setCamera({ focalPoint: newFocalPoint });
                const renderingEngine = viewport.getRenderingEngine();
                if (renderingEngine) {
                    renderingEngine.renderViewport(viewport.id);
                }
            }
        }
    }
}
ReferenceCursors.toolName = 'ReferenceCursors';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReferenceCursors);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base/AnnotationDisplayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js");








const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS;
class ReferenceLines extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceViewportId: '',
            enforceSameFrameOfReference: true,
            showFullDimension: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            let viewports = renderingEngine.getViewports();
            viewports = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.filterViewportsWithToolEnabled)(viewports, this.getToolName());
            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);
            if (!sourceViewport?.getImageData()) {
                return;
            }
            const { element } = sourceViewport;
            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();
            const sourceViewportCanvasCornersInWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getViewportImageCornersInWorld(sourceViewport);
            let annotation = this.editData?.annotation;
            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();
            if (!annotation) {
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [...viewPlaneNormal],
                        viewUp: [...viewUp],
                        FrameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        handles: {
                            points: sourceViewportCanvasCornersInWorld,
                        },
                    },
                };
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(newAnnotation, element);
                annotation = newAnnotation;
            }
            else {
                this.editData.annotation.data.handles.points =
                    sourceViewportCanvasCornersInWorld;
            }
            this.editData = {
                sourceViewportId: sourceViewport.id,
                renderingEngine,
                annotation,
            };
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])(viewports
                .filter((viewport) => viewport.id !== sourceViewport.id)
                .map((viewport) => viewport.id));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolConfiguration = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport: targetViewport } = enabledElement;
            if (!this.editData) {
                return false;
            }
            const { annotation, sourceViewportId } = this.editData;
            let renderStatus = false;
            const { viewport: sourceViewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(sourceViewportId) || {};
            if (!sourceViewport) {
                return renderStatus;
            }
            if (sourceViewport.id === targetViewport.id) {
                return renderStatus;
            }
            if (!annotation || !annotation?.data?.handles?.points) {
                return renderStatus;
            }
            if (this.configuration.enforceSameFrameOfReference &&
                sourceViewport.getFrameOfReferenceUID() !==
                    targetViewport.getFrameOfReferenceUID()) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const topLeft = annotation.data.handles.points[0];
            const topRight = annotation.data.handles.points[1];
            const bottomLeft = annotation.data.handles.points[2];
            const bottomRight = annotation.data.handles.points[3];
            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();
            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();
            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            let pointSetToUse = pointSet1;
            let topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), pointSet1[0], pointSet1[1]);
            topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), topBottomVec);
            let topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), pointSet1[2], pointSet1[0]);
            topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), topRightVec);
            const newNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), topBottomVec, topRightVec);
            if (this.isParallel(newNormal, viewPlaneNormal)) {
                return renderStatus;
            }
            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                pointSetToUse = pointSet2;
            }
            const lineStartWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
            const lineEndWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
            const { annotationUID } = annotation;
            styleSpecifier.annotationUID = annotationUID;
            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
            const color = this.getStyle('color', styleSpecifier, annotation);
            const shadow = this.getStyle('shadow', styleSpecifier, annotation);
            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
            if (this.configuration.showFullDimension) {
                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);
            }
            if (canvasCoordinates.length < 2) {
                return renderStatus;
            }
            const dataId = `${annotationUID}-line`;
            const lineUID = '1';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, dataId);
            renderStatus = true;
            return renderStatus;
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(vec1, vec2);
            return Math.abs(dot) < EPSILON;
        };
    }
    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {
        const renderingEngine = targetViewport.getRenderingEngine();
        const targetId = this.getTargetId(targetViewport);
        const targetImage = this.getTargetImageData(targetId);
        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);
        if (referencedImageId && targetImage) {
            try {
                const { imageData, dimensions } = targetImage;
                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [
                    imageData.indexToWorld([0, 0, 0]),
                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),
                    imageData.indexToWorld([
                        dimensions[0] - 1,
                        dimensions[1] - 1,
                        0,
                    ]),
                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),
                ].map((world) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.worldToImageCoords(referencedImageId, world));
                const [lineStartImageCoord, lineEndImageCoord] = [
                    lineStartWorld,
                    lineEndWorld,
                ].map((world) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.worldToImageCoords(referencedImageId, world));
                canvasCoordinates = [
                    [topLeftImageCoord, topRightImageCoord],
                    [topRightImageCoord, bottomRightImageCoord],
                    [bottomLeftImageCoord, bottomRightImageCoord],
                    [topLeftImageCoord, bottomLeftImageCoord],
                ]
                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))
                    .filter((point) => point && this.isInBound(point, dimensions))
                    .map((point) => {
                    const world = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageToWorldCoords(referencedImageId, point);
                    return targetViewport.worldToCanvas(world);
                });
            }
            catch (err) {
                console.log(err);
            }
        }
        return canvasCoordinates;
    }
    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {
        const [x1, y1] = line1Start;
        const [x2, y2] = line1End;
        const [x3, y3] = line2Start;
        const [x4, y4] = line2End;
        const a1 = y2 - y1;
        const b1 = x1 - x2;
        const c1 = x2 * y1 - x1 * y2;
        const a2 = y4 - y3;
        const b2 = x3 - x4;
        const c2 = x4 * y3 - x3 * y4;
        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {
            return;
        }
        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);
        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);
        return [x, y];
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(vec1, vec2)) > 1 - EPSILON;
    }
    isInBound(point, dimensions) {
        return (point[0] >= 0 &&
            point[0] <= dimensions[0] &&
            point[1] >= 0 &&
            point[1] <= dimensions[1]);
    }
}
ReferenceLines.toolName = 'ReferenceLines';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReferenceLines);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/AnnotationDisplayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");






const viewportsWithAnnotations = [];
class ScaleOverlayTool extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            viewportId: '',
            scaleLocation: 'bottom',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            const viewportIds = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportIds) {
                return;
            }
            const enabledElements = viewportIds.map((e) => (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
            let { viewport } = enabledElements[0];
            const { FrameOfReferenceUID } = enabledElements[0];
            if (this.configuration.viewportId) {
                enabledElements.forEach((element) => {
                    if (element.viewport.id == this.configuration.viewportId) {
                        viewport = element.viewport;
                    }
                });
            }
            if (!viewport) {
                return;
            }
            const { viewUp, viewPlaneNormal } = viewport.getCamera();
            const viewportCanvasCornersInWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.getViewportImageCornersInWorld(viewport);
            let annotation = this.editData?.annotation;
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), viewport.element);
            if (annotations.length) {
                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
            }
            enabledElements.forEach((element) => {
                const { viewport } = element;
                if (!viewportsWithAnnotations.includes(viewport.id)) {
                    const newAnnotation = {
                        metadata: {
                            toolName: this.getToolName(),
                            viewPlaneNormal: [...viewPlaneNormal],
                            viewUp: [...viewUp],
                            FrameOfReferenceUID,
                            referencedImageId: null,
                        },
                        data: {
                            handles: {
                                points: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.getViewportImageCornersInWorld(viewport),
                            },
                            viewportId: viewport.id,
                        },
                    };
                    viewportsWithAnnotations.push(viewport.id);
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(newAnnotation, viewport.element);
                    annotation = newAnnotation;
                }
            });
            if (this.editData?.annotation &&
                this.editData.annotation.data.viewportId == viewport.id) {
                this.editData.annotation.data.handles.points =
                    viewportCanvasCornersInWorld;
                this.editData.annotation.data.viewportId = viewport.id;
            }
            this.editData = {
                viewport,
                renderingEngine,
                annotation,
            };
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this.configuration.viewportId = evt.detail.viewportId;
            this._init();
        };
        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {
            const scaleSizes = [
                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,
            ];
            let currentScaleSize;
            if (location == 'top' || location == 'bottom') {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&
                    scaleSize > worldWidthViewport * 0.2);
            }
            else {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&
                    scaleSize > worldHeightViewport * 0.2);
            }
            return currentScaleSize[0];
        };
        this.computeEndScaleTicks = (canvasCoordinates, location) => {
            const locationTickOffset = {
                bottom: [
                    [0, -10],
                    [0, -10],
                ],
                top: [
                    [0, 10],
                    [0, 10],
                ],
                left: [
                    [0, 0],
                    [10, 0],
                ],
                right: [
                    [0, 0],
                    [-10, 0],
                ],
            };
            const endTick1 = [
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],
                ],
            ];
            const endTick2 = [
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],
                ],
            ];
            return {
                endTick1: endTick1,
                endTick2: endTick2,
            };
        };
        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {
            let canvasScaleSize;
            if (location == 'bottom' || location == 'top') {
                canvasScaleSize = rightTick[0][0] - leftTick[0][0];
            }
            else if (location == 'left' || location == 'right') {
                canvasScaleSize = rightTick[0][1] - leftTick[0][1];
            }
            const tickIds = [];
            const tickUIDs = [];
            const tickCoordinates = [];
            let numberSmallTicks = scaleSize;
            if (scaleSize >= 50) {
                numberSmallTicks = scaleSize / 10;
            }
            const tickSpacing = canvasScaleSize / numberSmallTicks;
            for (let i = 0; i < numberSmallTicks - 1; i++) {
                const locationOffset = {
                    bottom: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), 5],
                    ],
                    top: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), -5],
                    ],
                    left: [
                        [0, tickSpacing * (i + 1)],
                        [-5, tickSpacing * (i + 1)],
                    ],
                    right: [
                        [0, tickSpacing * (i + 1)],
                        [5, tickSpacing * (i + 1)],
                    ],
                };
                tickIds.push(`${annotationUID}-tick${i}`);
                tickUIDs.push(`tick${i}`);
                if ((i + 1) % 5 == 0) {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][0][0],
                            leftTick[1][1] + locationOffset[location][0][1],
                        ],
                    ]);
                }
                else {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][1][0],
                            leftTick[1][1] + locationOffset[location][1][1],
                        ],
                    ]);
                }
            }
            return { tickIds, tickUIDs, tickCoordinates };
        };
        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {
            let worldCoordinates;
            let topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), pointSet[0], pointSet[1]);
            topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), topBottomVec);
            let topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), pointSet[2], pointSet[0]);
            topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), topRightVec);
            const midpointLocation = {
                bottom: [pointSet[1], pointSet[2]],
                top: [pointSet[0], pointSet[3]],
                right: [pointSet[2], pointSet[3]],
                left: [pointSet[0], pointSet[1]],
            };
            const midpoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), midpointLocation[location][0], midpointLocation[location][0])
                .map((i) => i / 2);
            const offset = scaleSize /
                2 /
                Math.sqrt(Math.pow(topBottomVec[0], 2) +
                    Math.pow(topBottomVec[1], 2) +
                    Math.pow(topBottomVec[2], 2));
            if (location == 'top' || location == 'bottom') {
                worldCoordinates = [
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), midpoint, topRightVec.map((i) => i * offset)),
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), midpoint, topRightVec.map((i) => i * offset)),
                ];
            }
            else if (location == 'left' || location == 'right') {
                worldCoordinates = [
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),
                ];
            }
            return worldCoordinates;
        };
        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {
            let scaleCanvasCoordinates;
            if (location == 'top' || location == 'bottom') {
                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];
                scaleCanvasCoordinates = [
                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],
                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],
                ];
            }
            else if (location == 'left' || location == 'right') {
                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];
                scaleCanvasCoordinates = [
                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],
                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],
                ];
            }
            return scaleCanvasCoordinates;
        };
        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {
            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);
            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);
            const locationBounds = {
                bottom: [-vReduction, -hReduction],
                top: [vReduction, hReduction],
                left: [vReduction, hReduction],
                right: [-vReduction, -hReduction],
            };
            const canvasBounds = {
                bottom: [canvasSize.height, canvasSize.width],
                top: [0, canvasSize.width],
                left: [canvasSize.height, 0],
                right: [canvasSize.height, canvasSize.width],
            };
            return {
                height: canvasBounds[location][0] + locationBounds[location][0],
                width: canvasBounds[location][1] + locationBounds[location][1],
            };
        };
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.editData || !this.editData.viewport) {
            return;
        }
        const location = this.configuration.scaleLocation;
        const { viewport } = enabledElement;
        const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), viewport.element);
        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
        const canvas = enabledElement.viewport.canvas;
        const renderStatus = false;
        if (!viewport) {
            return renderStatus;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        const canvasSize = {
            width: canvas.width / window.devicePixelRatio || 1,
            height: canvas.height / window.devicePixelRatio || 1,
        };
        const topLeft = annotation.data.handles.points[0];
        const topRight = annotation.data.handles.points[1];
        const bottomLeft = annotation.data.handles.points[2];
        const bottomRight = annotation.data.handles.points[3];
        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
        const worldWidthViewport = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(bottomLeft, bottomRight);
        const worldHeightViewport = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(topLeft, bottomLeft);
        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);
        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));
        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);
        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);
        const { annotationUID } = annotation;
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
        const color = this.getStyle('color', styleSpecifier, annotation);
        const shadow = this.getStyle('shadow', styleSpecifier, annotation);
        const scaleId = `${annotationUID}-scaleline`;
        const scaleLineUID = '1';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, scaleId);
        const leftTickId = `${annotationUID}-left`;
        const leftTickUID = '2';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, leftTickId);
        const rightTickId = `${annotationUID}-right`;
        const rightTickUID = '3';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, rightTickId);
        const locationTextOffest = {
            bottom: [-10, -42],
            top: [-12, -35],
            left: [-40, -20],
            right: [-50, -20],
        };
        const textCanvasCoordinates = [
            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],
            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],
        ];
        const textBoxLines = this._getTextLines(scaleSize);
        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);
        for (let i = 0; i < tickUIDs.length; i++) {
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, tickIds[i]);
        }
        const textUID = 'text0';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {
            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            fontSize: '14px',
            lineDash: '2,3',
            lineWidth: '1',
            shadow: true,
            color: color,
        });
        return renderStatus;
    }
    _getTextLines(scaleSize) {
        let scaleSizeDisplayValue;
        let scaleSizeUnits;
        if (scaleSize >= 50) {
            scaleSizeDisplayValue = scaleSize / 10;
            scaleSizeUnits = ' cm';
        }
        else {
            scaleSizeDisplayValue = scaleSize;
            scaleSizeUnits = ' mm';
        }
        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];
        return textLines;
    }
}
ScaleOverlayTool.toolName = 'ScaleOverlay';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScaleOverlayTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contourIndex: () => (/* binding */ contourIndex),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../stateManagement/annotation/config/helpers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SculptorTool/CircleSculptCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool/CircleSculptCursor.js");
/* harmony import */ var _distancePointToContour__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./distancePointToContour */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");












class SculptorTool extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minSpacing: 1,
            referencedToolNames: [
                'PlanarFreehandROI',
                'PlanarFreehandContourSegmentationTool',
            ],
            toolShape: 'circle',
            referencedToolName: 'PlanarFreehandROI',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.registeredShapes = new Map();
        this.isActive = false;
        this.commonData = {
            activeAnnotationUID: null,
            viewportIdsToRender: [],
            isEditingOpenContour: false,
            canvasLocation: undefined,
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.configureToolSize(evt);
            this.selectFreehandTool(eventData);
            if (this.commonData.activeAnnotationUID === null) {
                return;
            }
            this.isActive = true;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.hideElementCursor)(element);
            this.activateModify(element);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === _enums__WEBPACK_IMPORTED_MODULE_4__.ToolModes.Active) {
                this.configureToolSize(evt);
                this.updateCursor(evt);
            }
            else {
                this.commonData.canvasLocation = undefined;
            }
        };
        this.endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const config = this.configuration;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.isActive = false;
            this.deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const { renderingEngineId, viewportId } = enabledElement;
            const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_11__.getToolGroupForViewport)(viewportId, renderingEngineId);
            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (toolInstance.configuration.calculateStats) {
                activeAnnotation.invalidated = true;
            }
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(activeAnnotation, element, _enums__WEBPACK_IMPORTED_MODULE_4__.ChangeTypes.HandlesUpdated);
        };
        this.dragCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.updateCursor(evt);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (!annotations?.length || !this.isActive) {
                return;
            }
            const points = activeAnnotation.data.contour.polyline;
            this.sculpt(eventData, points);
        };
        this.registerShapes(_SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__["default"].shapeName, _SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.setToolShape(this.configuration.toolShape);
    }
    registerShapes(shapeName, shapeClass) {
        const shape = new shapeClass();
        this.registeredShapes.set(shapeName, shape);
    }
    sculpt(eventData, points) {
        const config = this.configuration;
        const element = eventData.element;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        this.sculptData = {
            mousePoint: eventData.currentPoints.world,
            mouseCanvasPoint: eventData.currentPoints.canvas,
            points,
            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),
            element: element,
        };
        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);
        if (pushedHandles.first !== undefined) {
            this.insertNewHandles(pushedHandles);
        }
    }
    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {
        const { element } = this.sculptData;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const nextHandleIndex = contourIndex(i + 1, points.length);
        const currentCanvasPoint = viewport.worldToCanvas(points[i]);
        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);
        const distanceToNextHandle = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);
        if (distanceToNextHandle > maxSpacing) {
            indicesToInsertAfter.push(i);
        }
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const element = eventData.element;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngine, viewport } = enabledElement;
        this.commonData.viewportIdsToRender = [viewport.id];
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
        this.commonData.canvasLocation = eventData.currentPoints.canvas;
        if (this.isActive) {
            activeAnnotation.highlighted = true;
        }
        else {
            const cursorShape = this.registeredShapes.get(this.selectedShape);
            const canvasCoords = eventData.currentPoints.canvas;
            cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationRenderForViewportIds)(this.commonData.viewportIdsToRender);
    }
    filterSculptableAnnotationsForElement(element) {
        const config = this.configuration;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngineId, viewportId } = enabledElement;
        const sculptableAnnotations = [];
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_11__.getToolGroupForViewport)(viewportId, renderingEngineId);
        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
        config.referencedToolNames.forEach((referencedToolName) => {
            const annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(referencedToolName, element);
            if (annotations) {
                sculptableAnnotations.push(...annotations);
            }
        });
        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);
    }
    configureToolSize(evt) {
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.configureToolSize(evt);
    }
    insertNewHandles(pushedHandles) {
        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);
        let newIndexModifier = 0;
        for (let i = 0; i < indicesToInsertAfter?.length; i++) {
            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;
            this.insertHandleRadially(insertIndex);
            newIndexModifier++;
        }
    }
    findNewHandleIndices(pushedHandles) {
        const { points, maxSpacing } = this.sculptData;
        const indicesToInsertAfter = [];
        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {
            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);
        }
        return indicesToInsertAfter;
    }
    insertHandleRadially(insertIndex) {
        const { points } = this.sculptData;
        if (insertIndex > points.length - 1 &&
            this.commonData.isEditingOpenContour) {
            return;
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        const previousIndex = insertIndex - 1;
        const nextIndex = contourIndex(insertIndex, points.length);
        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);
        const handleData = insertPosition;
        points.splice(insertIndex, 0, handleData);
    }
    selectFreehandTool(eventData) {
        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);
        if (closestAnnotationUID === undefined) {
            return;
        }
        this.commonData.activeAnnotationUID = closestAnnotationUID;
    }
    getClosestFreehandToolOnElement(eventData) {
        const { element } = eventData;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const config = this.configuration;
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const canvasPoints = eventData.currentPoints.canvas;
        const closest = {
            distance: Infinity,
            toolIndex: undefined,
            annotationUID: undefined,
        };
        for (let i = 0; i < annotations?.length; i++) {
            if (annotations[i].isLocked || !annotations[i].isVisible) {
                continue;
            }
            const distanceFromTool = (0,_distancePointToContour__WEBPACK_IMPORTED_MODULE_10__.distancePointToContour)(viewport, annotations[i], canvasPoints);
            if (distanceFromTool === -1) {
                continue;
            }
            if (distanceFromTool < closest.distance) {
                closest.distance = distanceFromTool;
                closest.toolIndex = i;
                closest.annotationUID = annotations[i].annotationUID;
            }
        }
        this.commonData.isEditingOpenContour =
            !annotations[closest.toolIndex].data.contour.closed;
        config.referencedToolName =
            annotations[closest.toolIndex].metadata.toolName;
        return closest.annotationUID;
    }
    activateModify(element) {
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this.dragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this.dragCallback);
    }
    deactivateModify(element) {
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this.dragCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this.dragCallback);
    }
    setToolShape(toolShape) {
        this.selectedShape =
            this.registeredShapes.get(toolShape) ?? _SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__["default"].shapeName;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        const { viewport } = enabledElement;
        const { element } = viewport;
        const viewportIdsToRender = this.commonData.viewportIdsToRender;
        if (!this.commonData.canvasLocation ||
            this.mode !== _enums__WEBPACK_IMPORTED_MODULE_4__.ToolModes.Active ||
            !viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        let color = (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_7__.getStyleProperty)('color', styleSpecifier, _enums__WEBPACK_IMPORTED_MODULE_4__.AnnotationStyleStates.Default, this.mode);
        if (this.isActive) {
            color = (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_7__.getStyleProperty)('color', styleSpecifier, _enums__WEBPACK_IMPORTED_MODULE_4__.AnnotationStyleStates.Highlighted, this.mode);
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {
            color,
        });
    }
}
const contourIndex = (i, length) => {
    return (i + length) % length;
};
SculptorTool.toolName = 'SculptorTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SculptorTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool/CircleSculptCursor.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool/CircleSculptCursor.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _distancePointToContour__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../distancePointToContour */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");




class CircleSculptCursor {
    constructor() {
        this.toolInfo = {
            toolSize: null,
            maxToolSize: null,
        };
    }
    static { this.shapeName = 'Circle'; }
    renderShape(svgDrawingHelper, canvasLocation, options) {
        const circleUID = '0';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawCircle)(svgDrawingHelper, 'SculptorTool', circleUID, canvasLocation, this.toolInfo.toolSize, options);
    }
    pushHandles(viewport, sculptData) {
        const { points, mouseCanvasPoint } = sculptData;
        const pushedHandles = { first: undefined, last: undefined };
        for (let i = 0; i < points.length; i++) {
            const handleCanvasPoint = viewport.worldToCanvas(points[i]);
            const distanceToHandle = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.point.distanceToPoint(handleCanvasPoint, mouseCanvasPoint);
            if (distanceToHandle > this.toolInfo.toolSize) {
                continue;
            }
            this.pushOneHandle(i, distanceToHandle, sculptData);
            if (pushedHandles.first === undefined) {
                pushedHandles.first = i;
                pushedHandles.last = i;
            }
            else {
                pushedHandles.last = i;
            }
        }
        return pushedHandles;
    }
    configureToolSize(evt) {
        const toolInfo = this.toolInfo;
        if (toolInfo.toolSize && toolInfo.maxToolSize) {
            return;
        }
        const eventData = evt.detail;
        const element = eventData.element;
        const minDim = Math.min(element.clientWidth, element.clientHeight);
        const maxRadius = minDim / 12;
        toolInfo.toolSize = maxRadius;
        toolInfo.maxToolSize = maxRadius;
    }
    updateToolSize(canvasCoords, viewport, activeAnnotation) {
        const toolInfo = this.toolInfo;
        const radius = (0,_distancePointToContour__WEBPACK_IMPORTED_MODULE_1__.distancePointToContour)(viewport, activeAnnotation, canvasCoords);
        if (radius > 0) {
            toolInfo.toolSize = Math.min(toolInfo.maxToolSize, radius);
        }
    }
    getMaxSpacing(minSpacing) {
        return Math.max(this.toolInfo.toolSize / 4, minSpacing);
    }
    getInsertPosition(previousIndex, nextIndex, sculptData) {
        let insertPosition;
        const { points, element, mouseCanvasPoint } = sculptData;
        const toolSize = this.toolInfo.toolSize;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const previousCanvasPoint = viewport.worldToCanvas(points[previousIndex]);
        const nextCanvasPoint = viewport.worldToCanvas(points[nextIndex]);
        const midPoint = [
            (previousCanvasPoint[0] + nextCanvasPoint[0]) / 2.0,
            (previousCanvasPoint[1] + nextCanvasPoint[1]) / 2.0,
        ];
        const distanceToMidPoint = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.point.distanceToPoint(mouseCanvasPoint, midPoint);
        if (distanceToMidPoint < toolSize) {
            const directionUnitVector = {
                x: (midPoint[0] - mouseCanvasPoint[0]) / distanceToMidPoint,
                y: (midPoint[1] - mouseCanvasPoint[1]) / distanceToMidPoint,
            };
            insertPosition = [
                mouseCanvasPoint[0] + toolSize * directionUnitVector.x,
                mouseCanvasPoint[1] + toolSize * directionUnitVector.y,
            ];
        }
        else {
            insertPosition = midPoint;
        }
        const worldPosition = viewport.canvasToWorld(insertPosition);
        return worldPosition;
    }
    pushOneHandle(i, distanceToHandle, sculptData) {
        const { points, mousePoint } = sculptData;
        const toolSize = this.toolInfo.toolSize;
        const handle = points[i];
        const directionUnitVector = {
            x: (handle[0] - mousePoint[0]) / distanceToHandle,
            y: (handle[1] - mousePoint[1]) / distanceToHandle,
            z: (handle[2] - mousePoint[2]) / distanceToHandle,
        };
        const position = {
            x: mousePoint[0] + toolSize * directionUnitVector.x,
            y: mousePoint[1] + toolSize * directionUnitVector.y,
            z: mousePoint[2] + toolSize * directionUnitVector.z,
        };
        handle[0] = position.x;
        handle[1] = position.y;
        handle[2] = position.z;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleSculptCursor);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/AnnotationDisplayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js");
/* harmony import */ var _utilities_math_point__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utilities/math/point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");
/* harmony import */ var _utilities_pointToString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/pointToString */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js");









class SegmentationIntersectionTool extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            opacity: 0.5,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._init = () => {
            const viewportsInfo = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn(this.getToolName() + 'Tool: No viewports found');
                return;
            }
            const firstViewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);
            if (!firstViewport) {
                return;
            }
            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const actorsWorldPointsMap = new Map();
                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        actorsWorldPointsMap,
                    },
                };
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__["default"])(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport, FrameOfReferenceUID } = enabledElement;
            let renderStatus = false;
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;
            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
            const actorEntries = viewport.getActors();
            const cacheId = getCacheId(viewport);
            actorEntries.forEach((actorEntry) => {
                if (!actorEntry?.clippingFilter) {
                    return;
                }
                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);
                if (!actorWorldPointMap) {
                    return;
                }
                if (!actorWorldPointMap.get(cacheId)) {
                    return;
                }
                let polyLineIdx = 1;
                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);
                for (let i = 0; i < worldPointsSet.length; i++) {
                    const worldPoints = worldPointsSet[i];
                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));
                    const options = {
                        color: color,
                        fillColor: color,
                        fillOpacity: this.configuration.opacity,
                        closePath: true,
                        lineWidth: 2,
                    };
                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawPath)(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);
                    polyLineIdx++;
                }
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
function calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {
    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
        const viewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId)?.getViewport(viewportId);
        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
    });
}
function calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {
    const actorEntries = viewport.getActors();
    const cacheId = getCacheId(viewport);
    actorEntries.forEach((actorEntry) => {
        if (!actorEntry?.clippingFilter) {
            return;
        }
        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);
        if (!actorWorldPointsMap) {
            actorWorldPointsMap = new Map();
            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);
        }
        if (!actorWorldPointsMap.get(cacheId)) {
            const polyData = actorEntry.clippingFilter.getOutputData();
            const worldPointsSet = _utilities__WEBPACK_IMPORTED_MODULE_8__.polyDataUtils.getPolyDataPoints(polyData);
            if (!worldPointsSet) {
                return;
            }
            const colorArray = actorEntry.actor.getProperty().getColor();
            const color = colorToString(colorArray);
            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });
        }
    });
}
function getCacheId(viewport) {
    const { viewPlaneNormal } = viewport.getCamera();
    const imageIndex = viewport.getCurrentImageIdIndex();
    return `${viewport.id}-${(0,_utilities_pointToString__WEBPACK_IMPORTED_MODULE_7__.pointToString)(viewPlaneNormal)}-${imageIndex}`;
}
function colorToString(colorArray) {
    function colorComponentToString(component) {
        let componentString = Math.floor(component * 255).toString(16);
        if (componentString.length === 1) {
            componentString = '0' + componentString;
        }
        return componentString;
    }
    return ('#' +
        colorComponentToString(colorArray[0]) +
        colorComponentToString(colorArray[1]) +
        colorComponentToString(colorArray[2]));
}
function removeExtraPoints(viewport, worldPointsSet) {
    return worldPointsSet.map((worldPoints) => {
        const canvasPoints = worldPoints.map((point) => {
            const canvasPoint = viewport.worldToCanvas(point);
            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];
        });
        let lastPoint;
        const newWorldPoints = [];
        let newCanvasPoints = [];
        for (let i = 0; i < worldPoints.length; i++) {
            if (lastPoint) {
                if ((0,_utilities_math_point__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint)(lastPoint, canvasPoints[i]) > 0) {
                    newWorldPoints.push(worldPoints[i]);
                    newCanvasPoints.push(canvasPoints[i]);
                }
            }
            lastPoint = canvasPoints[i];
        }
        const firstPoint = newCanvasPoints[0];
        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {
            if ((0,_utilities_math_point__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint)(firstPoint, newCanvasPoints[j]) < 0.5) {
                newCanvasPoints = newCanvasPoints.slice(0, j);
                return newWorldPoints.slice(0, j);
            }
        }
        return newWorldPoints;
    });
}
SegmentationIntersectionTool.toolName = 'SegmentationIntersection';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentationIntersectionTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");


class StackScrollTool extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            invert: false,
            debounceIfNotLoaded: true,
            loop: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.deltaY = 1;
    }
    mouseWheelCallback(evt) {
        this._scroll(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    _dragCallback(evt) {
        this._scrollDrag(evt);
    }
    _scrollDrag(evt) {
        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
        const { debounceIfNotLoaded, invert, loop } = this.configuration;
        const deltaPointY = deltaPoints.canvas[1];
        let volumeId;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            volumeId = viewport.getVolumeId();
        }
        const pixelsPerImage = this._getPixelPerImage(viewport);
        const deltaY = deltaPointY + this.deltaY;
        if (!pixelsPerImage) {
            return;
        }
        if (Math.abs(deltaY) >= pixelsPerImage) {
            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.scroll(viewport, {
                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,
                volumeId,
                debounceLoading: debounceIfNotLoaded,
                loop: loop,
            });
            this.deltaY = deltaY % pixelsPerImage;
        }
        else {
            this.deltaY = deltaY;
        }
    }
    _scroll(evt) {
        const { wheel, element } = evt.detail;
        const { direction } = wheel;
        const { invert } = this.configuration;
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const delta = direction * (invert ? -1 : 1);
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.scroll(viewport, {
            delta,
            debounceLoading: this.configuration.debounceIfNotLoaded,
            loop: this.configuration.loop,
            volumeId: viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport
                ? viewport.getVolumeId()
                : undefined,
            scrollSlabs: this.configuration.scrollSlabs,
        });
    }
    _getPixelPerImage(viewport) {
        const { element } = viewport;
        const numberOfSlices = viewport.getNumberOfSlices();
        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));
    }
}
StackScrollTool.toolName = 'StackScroll';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackScrollTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/Math */ "../../../node_modules/@kitware/vtk.js/Common/Core/Math.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");






class TrackballRotateTool extends _base__WEBPACK_IMPORTED_MODULE_4__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            rotateIncrementDegrees: 2,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this._hasResolutionChanged = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const actorEntry = viewport.getDefaultActor();
            const actor = actorEntry.actor;
            const mapper = actor.getMapper();
            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;
            if (!hasSampleDistance) {
                return true;
            }
            const originalSampleDistance = mapper.getSampleDistance();
            if (!this._hasResolutionChanged) {
                mapper.setSampleDistance(originalSampleDistance * 2);
                this._hasResolutionChanged = true;
                if (this.cleanUp !== null) {
                    document.removeEventListener('mouseup', this.cleanUp);
                }
                this.cleanUp = () => {
                    mapper.setSampleDistance(originalSampleDistance);
                    viewport.render();
                    this._hasResolutionChanged = false;
                };
                document.addEventListener('mouseup', this.cleanUp, { once: true });
            }
            return true;
        };
        this._getViewportsInfo = () => {
            const viewports = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.onSetToolActive = () => {
            const subscribeToElementResize = () => {
                const viewportsInfo = this._getViewportsInfo();
                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                    if (!this._resizeObservers.has(viewportId)) {
                        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(viewportId, renderingEngineId) || { viewport: null };
                        if (!viewport) {
                            return;
                        }
                        const { element } = viewport;
                        const resizeObserver = new ResizeObserver(() => {
                            const element = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(viewportId, renderingEngineId);
                            if (!element) {
                                return;
                            }
                            const { viewport } = element;
                            const viewPresentation = viewport.getViewPresentation();
                            viewport.resetCamera();
                            viewport.setViewPresentation(viewPresentation);
                            viewport.render();
                        });
                        resizeObserver.observe(element);
                        this._resizeObservers.set(viewportId, resizeObserver);
                    }
                });
            };
            subscribeToElementResize();
            this._viewportAddedListener = (evt) => {
                if (evt.detail.toolGroupId === this.toolGroupId) {
                    subscribeToElementResize();
                }
            };
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
        };
        this.onSetToolDisabled = () => {
            this._resizeObservers.forEach((resizeObserver, viewportId) => {
                resizeObserver.disconnect();
                this._resizeObservers.delete(viewportId);
            });
            if (this._viewportAddedListener) {
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
                this._viewportAddedListener = null;
            }
        };
        this.rotateCamera = (viewport, centerWorld, axis, angle) => {
            const vtkCamera = viewport.getVtkActiveCamera();
            const viewUp = vtkCamera.getViewUp();
            const focalPoint = vtkCamera.getFocalPoint();
            const position = vtkCamera.getPosition();
            const newPosition = [0, 0, 0];
            const newFocalPoint = [0, 0, 0];
            const newViewUp = [0, 0, 0];
            const transform = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.identity(new Float32Array(16));
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.translate(transform, transform, centerWorld);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.rotate(transform, transform, angle, axis);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.translate(transform, transform, [
                -centerWorld[0],
                -centerWorld[1],
                -centerWorld[2],
            ]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.transformMat4(newPosition, position, transform);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.transformMat4(newFocalPoint, focalPoint, transform);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.identity(transform);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.rotate(transform, transform, angle, axis);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.transformMat4(newViewUp, viewUp, transform);
            viewport.setCamera({
                position: newPosition,
                viewUp: newViewUp,
                focalPoint: newFocalPoint,
            });
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, lastPoints } = evt.detail;
        const currentPointsCanvas = currentPoints.canvas;
        const lastPointsCanvas = lastPoints.canvas;
        const { rotateIncrementDegrees } = this.configuration;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const normalizedPosition = [
            currentPointsCanvas[0] / width,
            currentPointsCanvas[1] / height,
        ];
        const normalizedPreviousPosition = [
            lastPointsCanvas[0] / width,
            lastPointsCanvas[1] / height,
        ];
        const center = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(center);
        const normalizedCenter = [0.5, 0.5];
        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;
        const op = [normalizedPreviousPosition[0], 0, 0];
        const oe = [normalizedPosition[0], 0, 0];
        const opsq = op[0] ** 2;
        const oesq = oe[0] ** 2;
        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);
        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);
        const nop = [op[0], 0, lop];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(nop);
        const noe = [oe[0], 0, loe];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(noe);
        const dot = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].dot(nop, noe);
        if (Math.abs(dot) > 0.0001) {
            const angleX = -2 *
                Math.acos(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].clampValue(dot, -1.0, 1.0)) *
                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *
                rotateIncrementDegrees;
            const upVec = camera.viewUp;
            const atV = camera.viewPlaneNormal;
            const rightV = [0, 0, 0];
            const forwardV = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].cross(upVec, atV, rightV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(rightV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].cross(atV, rightV, forwardV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(forwardV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(upVec);
            this.rotateCamera(viewport, centerWorld, forwardV, angleX);
            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *
                rotateIncrementDegrees;
            this.rotateCamera(viewport, centerWorld, rightV, angleY);
            viewport.render();
        }
    }
}
TrackballRotateTool.toolName = 'TrackballRotate';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TrackballRotateTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");



const DIRECTIONS = {
    X: [1, 0, 0],
    Y: [0, 1, 0],
    Z: [0, 0, 1],
    CUSTOM: [],
};
class VolumeRotateTool extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            direction: DIRECTIONS.Z,
            rotateIncrementDegrees: 30,
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseWheelCallback(evt) {
        const { element, wheel } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { direction, rotateIncrementDegrees } = this.configuration;
        const camera = viewport.getCamera();
        const { viewUp, position, focalPoint } = camera;
        const { direction: deltaY } = wheel;
        const [cx, cy, cz] = focalPoint;
        const [ax, ay, az] = direction;
        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;
        const newPosition = [0, 0, 0];
        const newFocalPoint = [0, 0, 0];
        const newViewUp = [0, 0, 0];
        const transform = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.identity(new Float32Array(16));
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.translate(transform, transform, [cx, cy, cz]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.translate(transform, transform, [-cx, -cy, -cz]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.transformMat4(newPosition, position, transform);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.transformMat4(newFocalPoint, focalPoint, transform);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.identity(transform);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.transformMat4(newViewUp, viewUp, transform);
        viewport.setCamera({
            position: newPosition,
            viewUp: newViewUp,
            focalPoint: newFocalPoint,
        });
        viewport.render();
    }
}
VolumeRotateTool.toolName = 'VolumeRotateMouseWheel';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VolumeRotateTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_voi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utilities/voi */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js");











class WindowLevelRegionTool extends _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minWindowWidth: 10,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                    },
                    cachedStats: {},
                },
            };
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__.triggerAnnotationCompleted)(annotation);
            this.applyWindowLevelRegion(annotation, element);
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            const DEFAULT_HANDLE_INDEX = 3;
            points[DEFAULT_HANDLE_INDEX] = [...worldPos];
            const bottomLeftCanvas = worldToCanvas(points[0]);
            const topRightCanvas = worldToCanvas(points[3]);
            const bottomRightCanvas = [
                topRightCanvas[0],
                bottomLeftCanvas[1],
            ];
            const topLeftCanvas = [
                bottomLeftCanvas[0],
                topRightCanvas[1],
            ];
            const bottomRightWorld = canvasToWorld(bottomRightCanvas);
            const topLeftWorld = canvasToWorld(topLeftCanvas);
            points[1] = bottomRightWorld;
            points[2] = topLeftWorld;
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const dataId = `${annotationUID}-rect`;
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                renderStatus = true;
            }
            return renderStatus;
        };
        this.applyWindowLevelRegion = (annotation, element) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const imageData = _utilities_voi__WEBPACK_IMPORTED_MODULE_10__.windowLevel.extractWindowLevelRegionToolData(viewport);
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const startCanvas = canvasCoordinates[0];
            const endCanvas = canvasCoordinates[3];
            let left = Math.min(startCanvas[0], endCanvas[0]);
            let top = Math.min(startCanvas[1], endCanvas[1]);
            let width = Math.abs(startCanvas[0] - endCanvas[0]);
            let height = Math.abs(startCanvas[1] - endCanvas[1]);
            left = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.clip(left, 0, imageData.width);
            top = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.clip(top, 0, imageData.height);
            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));
            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));
            const pixelLuminanceData = _utilities_voi__WEBPACK_IMPORTED_MODULE_10__.windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);
            const minMaxMean = _utilities_voi__WEBPACK_IMPORTED_MODULE_10__.windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);
            if (this.configuration.minWindowWidth === undefined) {
                this.configuration.minWindowWidth = 10;
            }
            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);
            const windowCenter = minMaxMean.mean;
            const voiLutFunction = viewport.getProperties().VOILUTFunction;
            const voiRange = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
            viewport.setProperties({ voiRange });
            viewport.render();
        };
        this.cancel = () => {
            return null;
        };
        this.isPointNearTool = () => {
            return null;
        };
        this.toolSelectedCallback = () => {
            return null;
        };
        this.handleSelectedCallback = () => {
            return null;
        };
        this._activateModify = () => {
            return null;
        };
        this._deactivateModify = () => {
            return null;
        };
    }
}
WindowLevelRegionTool.toolName = 'WindowLevelRegion';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WindowLevelRegionTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


const DEFAULT_MULTIPLIER = 4;
const DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;
const PT = 'PT';
class WindowLevelTool extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            const frameLength = dimensions[0] * dimensions[1];
            let bytesPerVoxel;
            let TypedArrayConstructor;
            if (scalarData instanceof Float32Array) {
                bytesPerVoxel = 4;
                TypedArrayConstructor = Float32Array;
            }
            else if (scalarData instanceof Uint8Array) {
                bytesPerVoxel = 1;
                TypedArrayConstructor = Uint8Array;
            }
            else if (scalarData instanceof Uint16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Uint16Array;
            }
            else if (scalarData instanceof Int16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Int16Array;
            }
            const buffer = scalarData.buffer;
            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;
            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);
            const { max, min } = this._getMinMax(frame, frameLength);
            return max - min;
        };
    }
    touchDragCallback(evt) {
        this.mouseDragCallback(evt);
    }
    mouseDragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;
        let isPreScaled = false;
        const properties = viewport.getProperties();
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
            volumeId = viewport.getVolumeId();
            viewportsContainingVolumeUID =
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getViewportsWithVolumeId(volumeId);
            ({ lower, upper } = properties.voiRange);
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
            if (!volume) {
                throw new Error('Volume not found ' + volumeId);
            }
            modality = volume.metadata.Modality;
            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;
        }
        else if (properties.voiRange) {
            modality = viewport.modality;
            ({ lower, upper } = properties.voiRange);
            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};
            isPreScaled =
                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;
        }
        else {
            throw new Error('Viewport is not a valid type');
        }
        if (modality === PT && isPreScaled) {
            newRange = this.getPTScaledNewRange({
                deltaPointsCanvas: deltaPoints.canvas,
                lower,
                upper,
                clientHeight: element.clientHeight,
                isPreScaled,
                viewport,
                volumeId,
            });
        }
        else {
            newRange = this.getNewRange({
                viewport,
                deltaPointsCanvas: deltaPoints.canvas,
                volumeId,
                lower,
                upper,
            });
        }
        if (newRange.lower >= newRange.upper) {
            return;
        }
        viewport.setProperties({
            voiRange: newRange,
        });
        viewport.render();
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
            viewportsContainingVolumeUID.forEach((vp) => {
                if (viewport !== vp) {
                    vp.render();
                }
            });
            return;
        }
    }
    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {
        let multiplier = DEFAULT_MULTIPLIER;
        if (isPreScaled) {
            multiplier = 5 / clientHeight;
        }
        else {
            multiplier =
                this._getMultiplierFromDynamicRange(viewport, volumeId) ||
                    DEFAULT_MULTIPLIER;
        }
        const deltaY = deltaPointsCanvas[1];
        const wcDelta = deltaY * multiplier;
        upper -= wcDelta;
        upper = isPreScaled ? Math.max(upper, 0.1) : upper;
        return { lower, upper };
    }
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {
        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||
            DEFAULT_MULTIPLIER;
        const wwDelta = deltaPointsCanvas[0] * multiplier;
        const wcDelta = deltaPointsCanvas[1] * multiplier;
        let { windowWidth, windowCenter } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toWindowLevel(lower, upper);
        windowWidth += wwDelta;
        windowCenter += wcDelta;
        windowWidth = Math.max(windowWidth, 1);
        const voiLutFunction = viewport.getProperties().VOILUTFunction;
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
    }
    _getMultiplierFromDynamicRange(viewport, volumeId) {
        let imageDynamicRange;
        if (volumeId) {
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
            const { voxelManager } = viewport.getImageData();
            const middleSlicePixelData = voxelManager.getMiddleSliceData();
            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {
                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];
            }, [Infinity, -Infinity]);
            const BitsStored = imageVolume?.metadata?.BitsStored;
            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;
            imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);
        }
        else {
            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);
        }
        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;
        return ratio > 1 ? Math.round(ratio) : ratio;
    }
    _getImageDynamicRangeFromViewport(viewport) {
        const { imageData, voxelManager } = viewport.getImageData();
        if (voxelManager?.getRange) {
            const range = voxelManager.getRange();
            return range[1] - range[0];
        }
        const dimensions = imageData.getDimensions();
        if (imageData.getRange) {
            const imageDataRange = imageData.getRange();
            return imageDataRange[1] - imageDataRange[0];
        }
        let scalarData;
        if (imageData.getScalarData) {
            scalarData = imageData.getScalarData();
        }
        else {
            scalarData = imageData.getPointData().getScalars().getData();
        }
        if (dimensions[2] !== 1) {
            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);
        }
        let range;
        if (scalarData.getRange) {
            range = scalarData.getRange();
        }
        else {
            const { min, max } = this._getMinMax(scalarData, scalarData.length);
            range = [min, max];
        }
        return range[1] - range[0];
    }
    _getMinMax(frame, frameLength) {
        let min = Infinity;
        let max = -Infinity;
        for (let i = 0; i < frameLength; i++) {
            const voxel = frame[i];
            if (voxel < min) {
                min = voxel;
            }
            if (voxel > max) {
                max = voxel;
            }
        }
        return { max, min };
    }
}
WindowLevelTool.toolName = 'WindowLevel';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WindowLevelTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/Math */ "../../../node_modules/@kitware/vtk.js/Common/Core/Math.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");





class ZoomTool extends _base__WEBPACK_IMPORTED_MODULE_3__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            zoomToCenter: false,
            minZoomScale: 0.001,
            maxZoomScale: 3000,
            pinchToZoom: true,
            pan: true,
            invert: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const camera = enabledElement.viewport.getCamera();
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), dirVec);
            this.dirVec = dirVec;
            return false;
        };
        this.preTouchStartCallback = (evt) => {
            if (!this.configuration.pinchToZoom) {
                return this.preMouseDownCallback(evt);
            }
        };
        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { parallelScale, focalPoint, position } = camera;
            const zoomScale = 5 / size[1];
            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);
            const parallelScaleToSet = (1.0 - k) * parallelScale;
            let focalPointToSet = focalPoint;
            let positionToSet = position;
            if (!this.configuration.zoomToCenter) {
                const distanceToCanvasCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.distance(focalPoint, this.initialMousePosWorld);
                positionToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);
                focalPointToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);
            }
            const imageData = viewport.getImageData();
            let spacing = [1, 1, 1];
            if (imageData) {
                spacing = imageData.spacing;
            }
            const { minZoomScale, maxZoomScale } = this.configuration;
            const t = element.clientHeight * spacing[1] * 0.5;
            const scale = t / parallelScaleToSet;
            let cappedParallelScale = parallelScaleToSet;
            let thresholdExceeded = false;
            if (imageData) {
                if (scale < minZoomScale) {
                    cappedParallelScale = t / minZoomScale;
                    thresholdExceeded = true;
                }
                else if (scale >= maxZoomScale) {
                    cappedParallelScale = t / maxZoomScale;
                    thresholdExceeded = true;
                }
            }
            viewport.setCamera({
                parallelScale: cappedParallelScale,
                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,
                position: thresholdExceeded ? position : positionToSet,
            });
        };
        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { position, focalPoint, viewPlaneNormal } = camera;
            const distance = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["default"].distance2BetweenPoints(position, focalPoint);
            const zoomScale = Math.sqrt(distance) / size[1];
            const directionOfProjection = [
                -viewPlaneNormal[0],
                -viewPlaneNormal[1],
                -viewPlaneNormal[2],
            ];
            const k = this.configuration.invert
                ? deltaY / zoomScale
                : deltaY * zoomScale;
            let tmp = k * directionOfProjection[0];
            position[0] += tmp;
            focalPoint[0] += tmp;
            tmp = k * directionOfProjection[1];
            position[1] += tmp;
            focalPoint[1] += tmp;
            tmp = k * directionOfProjection[2];
            position[2] += tmp;
            focalPoint[2] += tmp;
            viewport.setCamera({ position, focalPoint });
        };
        this.initialMousePosWorld = [0, 0, 0];
        this.dirVec = [0, 0, 0];
        if (this.configuration.pinchToZoom) {
            this.touchDragCallback = this._pinchCallback.bind(this);
        }
        else {
            this.touchDragCallback = this._dragCallback.bind(this);
        }
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    mouseWheelCallback(evt) {
        this._zoom(evt);
    }
    _pinchCallback(evt) {
        const pointsList = evt.detail
            .currentPointsList;
        if (pointsList.length > 1) {
            const { element, currentPoints } = evt.detail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const worldPos = currentPoints.world;
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), dirVec);
            this.dirVec = dirVec;
            if (camera.parallelProjection) {
                this._dragParallelProjection(evt, viewport, camera, true);
            }
            else {
                this._dragPerspectiveProjection(evt, viewport, camera, true);
            }
            viewport.render();
        }
        if (this.configuration.pan) {
            this._panCallback(evt);
        }
    }
    _dragCallback(evt) {
        const { element } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        if (camera.parallelProjection) {
            this._dragParallelProjection(evt, viewport, camera);
        }
        else {
            this._dragPerspectiveProjection(evt, viewport, camera);
        }
        viewport.render();
    }
    _zoom(evt) {
        const { element, points } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const wheelData = evt.detail.wheel;
        const direction = wheelData.direction;
        const eventDetails = {
            detail: {
                element,
                eventName: _enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_WHEEL,
                renderingEngineId: enabledElement.renderingEngineId,
                viewportId: viewport.id,
                camera: {},
                deltaPoints: {
                    page: points.page,
                    client: points.client,
                    world: points.world,
                    canvas: [0, -direction * 5],
                },
                startPoints: points,
                lastPoints: points,
                currentPoints: points,
            },
        };
        if (viewport.type === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.ViewportType.STACK) {
            this.preMouseDownCallback(eventDetails);
        }
        this._dragCallback(eventDetails);
    }
    _panCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        const camera = enabledElement.viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        enabledElement.viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        enabledElement.viewport.render();
    }
}
ZoomTool.toolName = 'Zoom';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ZoomTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/math/line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/math/angle/angleBetweenLines */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");















class AngleTool extends _base__WEBPACK_IMPORTED_MODULE_2__.AnnotationTool {
    static { this.toolName = 'Angle'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            showAngleArc: false,
            arcOffset: 5,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2, point3] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            if (!point3) {
                return false;
            }
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const line2 = {
                start: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
                end: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
            };
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {
                this.editData.handleIndex = 2;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            this.doneEditMemo();
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                this.angleStartedNotYetCompleted = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, angleArcLineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotation.annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_14__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                let lineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length !== 3) {
                    return renderStatus;
                }
                lineUID = '2';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                if (this.configuration.showAngleArc) {
                    const center = canvasCoordinates[1];
                    const offset = this.configuration.arcOffset;
                    const radius = Math.min(_utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([center[0], center[1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]]), _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([center[0], center[1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]])) / offset;
                    const anglePoints = [];
                    let startAngle = Math.atan2(canvasCoordinates[0][1] - center[1], canvasCoordinates[0][0] - center[0]);
                    let endAngle = Math.atan2(canvasCoordinates[2][1] - center[1], canvasCoordinates[2][0] - center[0]);
                    if (endAngle < startAngle) {
                        endAngle += 2 * Math.PI;
                    }
                    const angleDifference = endAngle - startAngle;
                    if (angleDifference > Math.PI) {
                        const temp = startAngle;
                        startAngle = endAngle;
                        endAngle = temp + 2 * Math.PI;
                    }
                    const segments = 32;
                    for (let i = 0; i <= segments; i++) {
                        const angle = startAngle + (i / segments) * (endAngle - startAngle);
                        anglePoints.push([
                            center[0] + radius * Math.cos(angle),
                            center[1] + radius * Math.sin(angle),
                        ]);
                    }
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawPath)(svgDrawingHelper, annotationUID, '3', anglePoints, {
                        color: color,
                        width: lineWidth,
                        lineDash: angleArcLineDash,
                    });
                }
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 3) {
            return;
        }
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const worldPos3 = data.handles.points[2];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_7__["default"])([worldPos1, worldPos2], [worldPos2, worldPos3]);
            const { dimensions, imageData } = this.getTargetImageData(targetId);
            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]
                .map((worldPos) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, worldPos))
                .some((index) => !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index, dimensions));
            cachedStats[targetId] = {
                angle: isNaN(angle) ? 'Incomplete Angle' : angle,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    if (isNaN(angle)) {
        return [`${angle}`];
    }
    const textLines = [
        `${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(angle)} ${String.fromCharCode(176)}`,
    ];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AngleTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/math/line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js");














class ArrowAnnotateTool extends _base__WEBPACK_IMPORTED_MODULE_2__.AnnotationTool {
    static { this.toolName = 'ArrowAnnotate'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            getTextCallback,
            changeTextCallback,
            preventHandleOutsideImage: false,
            arrowFirst: true,
            arrowHeadStyle: 'legacy',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const { arrowFirst } = this.configuration;
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    text: '',
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        arrowFirst,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_5__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
            }
            if (newAnnotation) {
                this.configuration.getTextCallback((text) => {
                    if (!text) {
                        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
                        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
                        this.editData = null;
                        this.isDrawing = false;
                        return;
                    }
                    annotation.data.text = text;
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationCompleted)(annotation);
                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });
                    (0,_utilities__WEBPACK_IMPORTED_MODULE_13__.setAnnotationLabel)(annotation, element, text);
                    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
                });
            }
            else if (!movingTextBox) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
        };
        this.touchTapCallback = (evt) => {
            if (evt.detail.taps == 2) {
                this.doubleClickCallback(evt);
            }
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.editData = null;
            this.isDrawing = false;
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles, text } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_12__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineWidth,
                    });
                }
                const arrowUID = '1';
                if (this.configuration.arrowFirst) {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',
                        markerSize,
                    });
                }
                else {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',
                        markerSize,
                    });
                }
                renderStatus = true;
                if (!text) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
    }
    static { this.hydrate = (viewportId, points, text, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                text: text || '',
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArrowAnnotateTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/planar/getWorldWidthAndHeightFromTwoPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/viewport/isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/math/circle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js");
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities/math/ellipse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js");
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../utilities/math/basic */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js");





















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class CircleROITool extends _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool {
    static { this.toolName = 'CircleROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_20__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleRadius)(canvasCoordinates);
            const radiusPoint = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleRadius)([
                canvasCoordinates[0],
                canvasCoords,
            ]);
            if (Math.abs(radiusPoint - radius) < proximity / 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            data.handles.points = [
                data.handles.points[0],
                canvasToWorld(currentCanvasPoints),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation, handleIndex } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => worldToCanvas(p));
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            if (handleIndex === 0) {
                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
                const canvasCenter = currentCanvasPoints;
                const canvasEnd = [
                    canvasCoordinates[1][0] + dXCanvas,
                    canvasCoordinates[1][1] + dYCanvas,
                ];
                points[0] = canvasToWorld(canvasCenter);
                points[1] = canvasToWorld(canvasEnd);
            }
            else {
                points[1] = canvasToWorld(currentCanvasPoints);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleRadius)(canvasCoordinates);
                const canvasCorners = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleCorners)(canvasCoordinates);
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                        radius: null,
                        radiusUnit: null,
                        perimeter: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-circle`;
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_12__.getTextBoxCoordsCanvas)(canvasCorners);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            const { element } = viewport;
            const wasInvalidated = annotation.invalidated;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const center = [
                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,
                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,
                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,
                    ];
                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
                    const ellipseObj = {
                        center,
                        xRadius: xRadius < _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.EPSILON / 2 ? 0 : xRadius,
                        yRadius: yRadius < _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.EPSILON / 2 ? 0 : yRadius,
                        zRadius: zRadius < _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.EPSILON / 2 ? 0 : zRadius,
                    };
                    const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__["default"])(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                    const handles = [pos1Index, pos2Index];
                    const { scale, unit, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, handles);
                    const aspect = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedAspect)(image);
                    const area = Math.abs(Math.PI *
                        (worldWidth / scale / 2) *
                        (worldHeight / aspect / scale / 2));
                    const pixelUnitsOptions = {
                        isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_17__.isViewportPreScaled)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_16__.getPixelValueUnits)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                        isInObject: (pointLPS) => (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_19__.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                        boundsIJK,
                        imageData,
                        returnPoints: this.configuration.storePointData,
                    });
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        max: stats.max?.value,
                        pointsInShape,
                        stdDev: stats.stdDev?.value,
                        statsArray: stats.array,
                        isEmptyArea,
                        areaUnit,
                        radius: worldWidth / 2 / scale,
                        radiusUnit: unit,
                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            annotation.invalidated = false;
            if (wasInvalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])([viewport.id]);
    }; }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { radius, radiusUnit, area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;
    const textLines = [];
    if (radius) {
        const radiusLine = isEmptyArea
            ? `Radius: Oblique not supported`
            : `Radius: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(radius)} ${radiusUnit}`;
        textLines.push(radiusLine);
    }
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (max) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleROITool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/math/line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/math/angle/angleBetweenLines */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js");
/* harmony import */ var _utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/math/midPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");


















class CobbAngleTool extends _base__WEBPACK_IMPORTED_MODULE_3__.AnnotationTool {
    static { this.toolName = 'CobbAngle'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            showArcLines: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({
                viewport,
                points: data.handles.points,
                canvasCoords,
                proximity,
            });
            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__.getViewportIdsWithToolToRender)(element, this.getToolName());
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({
                viewport,
                points: annotation.data.handles.points,
                canvasCoords,
                proximity,
            });
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
                isNearFirstLine,
                isNearSecondLine,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.resetElementCursor)(element);
                this.editData.handleIndex = data.handles.points.length;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._mouseDownCallback = (evt) => {
            const { annotation, handleIndex } = this.editData;
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const worldPos = currentPoints.world;
            const { data } = annotation;
            if (handleIndex === 1) {
                data.handles.points[1] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[1][0] !== data.handles.points[0][0] ||
                        data.handles.points[1][1] !== data.handles.points[0][0];
                return;
            }
            if (handleIndex === 3) {
                data.handles.points[3] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[3][0] !== data.handles.points[2][0] ||
                        data.handles.points[3][1] !== data.handles.points[2][0];
                this.angleStartedNotYetCompleted = false;
                return;
            }
            this.editData.hasMoved = false;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
            data.handles.points[2] = data.handles.points[3] = worldPos;
            this.editData.handleIndex = data.handles.points.length - 1;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined &&
                (isNearFirstLine || isNearSecondLine)) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                if (isNearFirstLine) {
                    const firstLinePoints = [points[0], points[1]];
                    firstLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                else if (isNearSecondLine) {
                    const secondLinePoints = [points[2], points[3]];
                    secondLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length < 4) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.angleStartedNotYetCompleted = false;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                        arc1Angle: null,
                        arc2Angle: null,
                        points: {
                            world: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                            canvas: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                        },
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_17__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];
                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];
                let lineUID = 'line1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length < 4) {
                    return renderStatus;
                }
                lineUID = 'line2';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                lineUID = 'linkLine';
                const mid1 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(firstLine[0], firstLine[1]);
                const mid2 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(secondLine[0], secondLine[1]);
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {
                    color,
                    lineWidth: '1',
                    lineDash: '1,4',
                });
                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;
                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];
                if (this.configuration.showArcLines) {
                    lineUID = 'arc1';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {
                        color,
                        lineWidth: '1',
                    });
                    lineUID = 'arc2';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {
                        color,
                        lineWidth: '1',
                    });
                }
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_14__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = 'cobbAngleText';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
                if (this.configuration.showArcLines) {
                    const arc1TextBoxUID = 'arcAngle1';
                    const arc1TextLine = [
                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch1TextPosCanvas = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(arc1Start, arc1End);
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawTextBox)(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                    const arc2TextBoxUID = 'arcAngle2';
                    const arc2TextLine = [
                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch2TextPosCanvas = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(arc2Start, arc2End);
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawTextBox)(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                }
            }
            return renderStatus;
        };
        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {
            const [point1, point2, point3, point4] = points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const canvasPoint4 = viewport.worldToCanvas(point4);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const line2 = {
                start: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
                end: {
                    x: canvasPoint4[0],
                    y: canvasPoint4[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_8__.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_8__.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            let isNearFirstLine = false;
            let isNearSecondLine = false;
            if (distanceToPoint <= proximity) {
                isNearFirstLine = true;
            }
            else if (distanceToPoint2 <= proximity) {
                isNearSecondLine = true;
            }
            return {
                distanceToPoint,
                distanceToPoint2,
                isNearFirstLine,
                isNearSecondLine,
            };
        };
        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {
            const linkLine = [mid1, mid2];
            const arc1Angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__["default"])(firstLine, linkLine);
            const arc2Angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__["default"])(secondLine, linkLine);
            const arc1Side = arc1Angle > 90 ? 1 : 0;
            const arc2Side = arc2Angle > 90 ? 0 : 1;
            const midLinkLine = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(linkLine[0], linkLine[1]);
            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +
                (linkLine[1][1] - linkLine[0][1]) ** 2);
            const ratio = 0.1;
            const midFirstLine = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(firstLine[0], firstLine[1]);
            const midSecondLine = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(secondLine[0], secondLine[1]);
            const directionVectorStartArc1 = [
                firstLine[arc1Side][0] - midFirstLine[0],
                firstLine[arc1Side][1] - midFirstLine[1],
            ];
            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);
            const normalizedDirectionStartArc1 = [
                directionVectorStartArc1[0] / magnitudeStartArc1,
                directionVectorStartArc1[1] / magnitudeStartArc1,
            ];
            const arc1Start = [
                midFirstLine[0] +
                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,
                midFirstLine[1] +
                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc1 = [
                midLinkLine[0] - mid1[0],
                midLinkLine[1] - mid1[1],
            ];
            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);
            const normalizedDirectionEndArc1 = [
                directionVectorEndArc1[0] / magnitudeEndArc1,
                directionVectorEndArc1[1] / magnitudeEndArc1,
            ];
            const arc1End = [
                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,
                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorStartArc2 = [
                secondLine[arc2Side][0] - midSecondLine[0],
                secondLine[arc2Side][1] - midSecondLine[1],
            ];
            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);
            const normalizedDirectionStartArc2 = [
                directionVectorStartArc2[0] / magnitudeStartArc2,
                directionVectorStartArc2[1] / magnitudeStartArc2,
            ];
            const arc2Start = [
                midSecondLine[0] +
                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,
                midSecondLine[1] +
                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc2 = [
                midLinkLine[0] - mid2[0],
                midLinkLine[1] - mid2[1],
            ];
            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);
            const normalizedDirectionEndArc2 = [
                directionVectorEndArc2[0] / magnitudeEndArc2,
                directionVectorEndArc2[1] / magnitudeEndArc2,
            ];
            const arc2End = [
                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,
                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,
            ];
            return {
                arc1Start,
                arc1End,
                arc2Start,
                arc2End,
                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,
                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,
            };
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__["default"])(this._calculateCachedStats, 25, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        if (data.handles.points.length !== 4) {
            return;
        }
        const seg1 = [null, null];
        const seg2 = [null, null];
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < 2; i += 1) {
            for (let j = 2; j < 4; j += 1) {
                const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.distance(data.handles.points[i], data.handles.points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    seg1[1] = data.handles.points[i];
                    seg1[0] = data.handles.points[(i + 1) % 2];
                    seg2[0] = data.handles.points[j];
                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];
                }
            }
        }
        const { viewport } = enabledElement;
        const { element } = viewport;
        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const firstLine = [canvasPoints[0], canvasPoints[1]];
        const secondLine = [canvasPoints[2], canvasPoints[3]];
        const mid1 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(firstLine[0], firstLine[1]);
        const mid2 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__.midPoint2)(secondLine[0], secondLine[1]);
        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({
            firstLine,
            secondLine,
            mid1,
            mid2,
        });
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            cachedStats[targetId] = {
                angle: (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__["default"])(seg1, seg2),
                arc1Angle,
                arc2Angle,
                points: {
                    canvas: {
                        arc1Start,
                        arc1End,
                        arc2End,
                        arc2Start,
                    },
                    world: {
                        arc1Start: viewport.canvasToWorld(arc1Start),
                        arc1End: viewport.canvasToWorld(arc1End),
                        arc2End: viewport.canvasToWorld(arc2End),
                        arc2Start: viewport.canvasToWorld(arc2Start),
                    },
                },
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CobbAngleTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _ProbeTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ProbeTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js");






class DragProbeTool extends _ProbeTool__WEBPACK_IMPORTED_MODULE_5__["default"] {
    static { this.toolName = 'DragProbe'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.postMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                invalidated: true,
                highlighted: true,
                isVisible: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: { points: [[...worldPos]] },
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_2__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.postTouchStartCallback = (evt) => {
            return this.postMouseDownCallback(evt);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            if (!this.editData) {
                return renderStatus;
            }
            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const annotation = this.editData.annotation;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const point = data.handles.points[0];
            const canvasCoordinates = viewport.worldToCanvas(point);
            styleSpecifier.annotationUID = annotationUID;
            const { color } = this.getAnnotationStyle({
                annotation,
                styleSpecifier,
            });
            if (!data.cachedStats[targetId] ||
                data.cachedStats[targetId].value === null) {
                data.cachedStats[targetId] = {
                    Modality: null,
                    index: null,
                    value: null,
                };
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            else if (annotation.invalidated) {
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const handleGroupUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_1__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });
            renderStatus = true;
            const textLines = this.configuration.getTextLines(data, targetId);
            if (textLines) {
                const textCanvasCoordinates = [
                    canvasCoordinates[0] + 6,
                    canvasCoordinates[1] - 6,
                ];
                const textUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_1__.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));
            }
            return renderStatus;
        };
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragProbeTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/math/circle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");













const CROSSHAIR_SIZE = 5;
class ETDRSGridTool extends _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool {
    static { this.toolName = 'ETDRSGrid'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            degrees: [45, 135, 225, 315],
            diameters: [10, 30, 60],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                    },
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const center = viewport.worldToCanvas(points[0]);
            const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_11__.getCanvasCircleRadius)([center, canvasCoords]);
            if (Math.abs(radius) < proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            data.handles.points = [
                canvasToWorld(currentCanvasPoints),
                canvasToWorld(currentCanvasPoints),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { deltaPoints } = eventDetail;
            const worldPosDelta = deltaPoints.world;
            const points = data.handles.points;
            points.forEach((point) => {
                point[0] += worldPosDelta[0];
                point[1] += worldPosDelta[1];
                point[2] += worldPosDelta[2];
            });
            annotation.invalidated = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => worldToCanvas(p));
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
            const canvasCenter = currentCanvasPoints;
            const canvasEnd = [
                canvasCoordinates[1][0] + dXCanvas,
                canvasCoordinates[1][1] + dYCanvas,
            ];
            points[0] = canvasToWorld(canvasCenter);
            points[1] = canvasToWorld(canvasEnd);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                let lineUID = `${annotationUID}-crosshair-vertical`;
                let start = [center[0], center[1] + CROSSHAIR_SIZE];
                let end = [center[0], center[1] - CROSSHAIR_SIZE];
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                lineUID = `${annotationUID}-crosshair-horizontal`;
                start = [center[0] + CROSSHAIR_SIZE, center[1]];
                end = [center[0] - CROSSHAIR_SIZE, center[1]];
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));
                for (let i = 0; i < diametersCanvas.length; i++) {
                    const dataId = `${annotationUID}-circle-${i}`;
                    const circleUID = `${annotationUID}-circle-${i}`;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {
                        color,
                        lineDash,
                        lineWidth,
                    }, dataId);
                }
                const degreesRad = (x) => (x * Math.PI) / 180;
                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));
                for (let i = 0; i < angleRadians.length; i++) {
                    const lineUID = `${annotationUID}-line-${i}`;
                    const start = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],
                    ];
                    const end = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],
                    ];
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                renderStatus = true;
            }
            return renderStatus;
        };
    }
    worldMeasureToCanvas(measurement, viewport) {
        const p1 = viewport.canvasToWorld([
            viewport.canvas.width / 2,
            viewport.canvas.height / 2,
        ]);
        const { viewUp } = viewport.getCamera();
        const p2 = gl_matrix__WEBPACK_IMPORTED_MODULE_12__.vec3.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_12__.vec3.create(), p1, viewUp, measurement);
        const p1Canvas = viewport.worldToCanvas(p1);
        const p2Canvas = viewport.worldToCanvas(p2);
        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +
            Math.pow(p2Canvas[1] - p1Canvas[1], 2));
        return distance;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ETDRSGridTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/planar/getWorldWidthAndHeightFromTwoPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js");
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/math/ellipse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/viewport/isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities/math/basic */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js");




















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class EllipticalROITool extends _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool {
    static { this.toolName = 'EllipticalROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    initialRotation: viewport.getRotation(),
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                centerWorld: worldPos,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const canvasCorners = (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.getCanvasEllipseCorners)(canvasCoordinates);
            const [canvasPoint1, canvasPoint2] = canvasCorners;
            const minorEllipse = {
                left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,
                top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,
                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,
                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,
            };
            const majorEllipse = {
                left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,
                top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,
                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,
                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,
            };
            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);
            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);
            if (pointInMajorEllipse && !pointInMinorEllipse) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            let centerCanvas;
            let centerWorld;
            let canvasWidth;
            let canvasHeight;
            let originalHandleCanvas;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = viewport;
                handleIndex = points.findIndex((p) => p === handle);
                const pointsCanvas = points.map(worldToCanvas);
                originalHandleCanvas = pointsCanvas[handleIndex];
                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);
                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);
                centerCanvas = [
                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,
                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,
                ];
                centerWorld = canvasToWorld(centerCanvas);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                canvasWidth,
                canvasHeight,
                centerWorld,
                originalHandleCanvas,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];
            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];
            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];
            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = viewport;
            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const { points } = data.handles;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            if (handleIndex === 0 || handleIndex === 1) {
                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - dYCanvas,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + dYCanvas,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];
                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;
                const canvasLeft = [
                    centerCanvas[0] - newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
            }
            else {
                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
                const canvasLeft = [
                    centerCanvas[0] - dXCanvas,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + dXCanvas,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];
                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - newHalfCanvasHeight,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + newHalfCanvasHeight,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasCorners = ((0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.getCanvasEllipseCorners)(canvasCoordinates));
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-ellipse`;
                const ellipseUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawEllipseByCoordinates)(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);
                    if (minRadius > 3 * centerPointRadius) {
                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_12__.getTextBoxCoordsCanvas)(canvasCorners);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            const { element } = viewport;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.getCanvasEllipseCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const post2Index = transformWorldToIndex(imageData, worldPos2);
                post2Index[0] = Math.floor(post2Index[0]);
                post2Index[1] = Math.floor(post2Index[1]);
                post2Index[2] = Math.floor(post2Index[2]);
                this.isHandleOutsideImage = !this._isInsideVolume(pos1Index, post2Index, dimensions);
                const iMin = Math.min(pos1Index[0], post2Index[0]);
                const iMax = Math.max(pos1Index[0], post2Index[0]);
                const jMin = Math.min(pos1Index[1], post2Index[1]);
                const jMax = Math.max(pos1Index[1], post2Index[1]);
                const kMin = Math.min(pos1Index[2], post2Index[2]);
                const kMax = Math.max(pos1Index[2], post2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const center = [
                    (topLeftWorld[0] + bottomRightWorld[0]) / 2,
                    (topLeftWorld[1] + bottomRightWorld[1]) / 2,
                    (topLeftWorld[2] + bottomRightWorld[2]) / 2,
                ];
                const ellipseObj = {
                    center,
                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                };
                const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__["default"])(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                const handles = [pos1Index, post2Index];
                const { scale, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, handles);
                const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /
                    scale /
                    scale;
                const pixelUnitsOptions = {
                    isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__.isViewportPreScaled)(viewport, targetId),
                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                };
                const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__.getPixelValueUnits)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    boundsIJK,
                    imageData,
                    isInObject: (pointLPS) => (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                    returnPoints: this.configuration.storePointData,
                });
                const stats = this.configuration.statsCalculator.getStatistics();
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    mean: stats.mean?.value,
                    max: stats.max?.value,
                    stdDev: stats.stdDev?.value,
                    statsArray: stats.array,
                    pointsInShape,
                    isEmptyArea,
                    areaUnit,
                    modalityUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])([viewport.id]);
    }; }
    _pointInEllipseCanvas(ellipse, location) {
        const xRadius = ellipse.width / 2;
        const yRadius = ellipse.height / 2;
        if (xRadius <= 0.0 || yRadius <= 0.0) {
            return false;
        }
        const center = [ellipse.left + xRadius, ellipse.top + yRadius];
        const normalized = [location[0] - center[0], location[1] - center[1]];
        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +
            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=
            1.0;
        return inEllipse;
    }
    _getCanvasEllipseCenter(ellipseCanvasPoints) {
        const [bottom, top, left, right] = ellipseCanvasPoints;
        const topLeft = [left[0], top[1]];
        const bottomRight = [right[0], bottom[1]];
        return [
            (topLeft[0] + bottomRight[0]) / 2,
            (topLeft[1] + bottomRight[1]) / 2,
        ];
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (max) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipticalROITool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/math/line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class HeightTool extends _base__WEBPACK_IMPORTED_MODULE_3__.AnnotationTool {
    static { this.toolName = 'Height'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.isDrawing = true;
            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    ...viewport.getViewReference({ points: [worldPos] }),
                    toolName: this.getToolName(),
                    referencedImageId,
                    viewUp,
                    cameraPosition,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const heightUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawHeight)(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash: lineDash,
                });
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_13__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateHeight(pos1, pos2) {
        const dx = pos2[0] - pos1[0];
        const dy = pos2[1] - pos1[1];
        const dz = pos2[2] - pos1[2];
        if (dx == 0) {
            if (dy != 0) {
                return Math.abs(dz);
            }
            else {
                return 0;
            }
        }
        else if (dy == 0) {
            return Math.abs(dz);
        }
        else if (dz == 0) {
            return Math.abs(dy);
        }
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = transformWorldToIndex(imageData, worldPos1);
            const index2 = transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, handles);
            const height = this._calculateHeight(worldPos1, worldPos2) / scale;
            const outside = this._isInsideVolume(index1, index2, dimensions);
            this.isHandleOutsideImage = outside;
            cachedStats[targetId] = {
                height,
                unit,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { height, unit } = cachedVolumeStats;
    if (height === undefined || height === null || isNaN(height)) {
        return;
    }
    const textLines = [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(height)} ${unit}`];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeightTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");










class KeyImageTool extends _base__WEBPACK_IMPORTED_MODULE_2__.AnnotationTool {
    static { this.toolName = 'KeyImage'; }
    static { this.dataSeries = {
        data: {
            seriesLevel: true,
        },
    }; }
    static { this.dataPoint = {
        data: {
            isPoint: true,
        },
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextCallback,
            changeTextCallback,
            canvasPosition: [10, 10],
            canvasSize: 10,
            handleRadius: '6',
            seriesLevel: false,
            isPoint: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const worldPos = currentPoints.world;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: { points: [[...worldPos]] },
                    seriesLevel: this.configuration.seriesLevel,
                    isPoint: this.configuration.isPoint,
                },
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            this.configuration.getTextCallback((text) => {
                if (!text) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
                    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
                    this.isDrawing = false;
                    return;
                }
                annotation.data.text = text;
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            });
            this.createMemo(element, annotation, { newAnnotation: true });
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            if (!data?.isPoint) {
                return false;
            }
            const { canvasPosition, canvasSize } = this.configuration;
            if (!canvasPosition?.length) {
                return false;
            }
            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=
                canvasSize / 2 &&
                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=
                    canvasSize / 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            annotation.highlighted = true;
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { viewportId, renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.eventDispatchDetail = {
                viewportId,
                renderingEngineId: renderingEngine.id,
            };
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.createMemo(element, annotation);
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.isDrawing = false;
            this.doneEditMemo();
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            data.handles.points[0] = [...worldPos];
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const { canvasPosition, canvasSize } = this.configuration;
                const arrowUID = '1';
                if (data?.isPoint) {
                    const point = data.handles.points[0];
                    const canvasCoordinates = viewport.worldToCanvas(point);
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {
                        color,
                        lineWidth,
                        handleRadius: this.configuration.handleRadius,
                    });
                }
                else if (canvasPosition?.length) {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {
                        color,
                        width: 1,
                    });
                }
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
            }
            return renderStatus;
        };
    }
    handleSelectedCallback(evt, annotation) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {
        annotation.data.isPoint = isPoint;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationModified)(annotation, element);
    }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationModified)(annotation, element);
    }
    cancel(element) {
        if (this.isDrawing) {
            this.isDrawing = false;
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            return annotation.annotationUID;
        }
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyImageTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");












class LabelTool extends _base__WEBPACK_IMPORTED_MODULE_3__.AnnotationTool {
    static { this.toolName = 'Label'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            getTextCallback,
            changeTextCallback,
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { annotationUID } = annotation;
            const point = annotation.data.handles.points[0];
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(canvasCoords, annotationCanvasCoordinate);
            if (dist < proximity) {
                return true;
            }
            const svgLayer = element.querySelector('svg');
            if (!svgLayer) {
                return false;
            }
            const textGroup = svgLayer.querySelector(`g[data-annotation-uid="${annotationUID}"]`);
            if (!textGroup) {
                return false;
            }
            const textGroupElement = textGroup;
            const bbox = textGroupElement.getBBox();
            const transform = textGroupElement.getAttribute('transform');
            let translateX = 0;
            let translateY = 0;
            if (transform) {
                const matches = transform.match(/translate\(([-\d.]+)\s+([-\d.]+)\)/);
                if (matches) {
                    translateX = parseFloat(matches[1]);
                    translateY = parseFloat(matches[2]);
                }
            }
            const x = bbox.x + translateX;
            const y = bbox.y + translateY;
            const isNear = canvasCoords[0] >= x &&
                canvasCoords[0] <= x + bbox.width &&
                canvasCoords[1] >= y &&
                canvasCoords[1] <= y + bbox.height;
            return isNear;
        };
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                annotationUID: null,
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    text: '',
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                    },
                    label: '',
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
                offset: [0, 0, 0],
            };
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            this.configuration.getTextCallback((text) => {
                if (!text) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
                    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
                    this.isDrawing = false;
                    return;
                }
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
                annotation.data.text = text;
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationCompleted)(annotation);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            });
            this.createMemo(element, annotation, { newAnnotation: true });
            return annotation;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            let offset = [0, 0, 0];
            if (currentPoints && currentPoints.world) {
                const initialWorldPos = currentPoints.world;
                const anchorWorldPos = annotation.data.handles.points[0];
                offset = [
                    anchorWorldPos[0] - initialWorldPos[0],
                    anchorWorldPos[1] - initialWorldPos[1],
                    anchorWorldPos[2] - initialWorldPos[2],
                ];
            }
            this.editData = {
                annotation,
                viewportIdsToRender,
                offset,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, offset } = this.editData;
            if (offset) {
                annotation.data.handles.points[0] = [
                    worldPos[0] + offset[0],
                    worldPos[1] + offset[1],
                    worldPos[2] + offset[2],
                ];
            }
            else {
                annotation.data.handles.points[0] = [...worldPos];
            }
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.LabelChange);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const point = data.handles.points[0];
                styleSpecifier.annotationUID = annotationUID;
                const canvasCoordinates = viewport.worldToCanvas(point);
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!data.text) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                const textBoxUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawTextBox)(svgDrawingHelper, annotationUID, textBoxUID, [data.text], canvasCoordinates, {
                    ...options,
                    padding: 0,
                });
            }
            return renderStatus;
        };
    }
    static { this.hydrate = (viewportId, position, text, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        const instance = new this();
        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.uuidv4(),
            data: {
                text,
                handles: {
                    points: [position],
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...options,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle, interactionType) { }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationModified)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
LabelTool.toolName = 'Label';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LabelTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/math/line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class LengthTool extends _base__WEBPACK_IMPORTED_MODULE_3__.AnnotationTool {
    static { this.toolName = 'Length'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            actions: {
                undo: {
                    method: 'undo',
                    bindings: [{ key: 'z' }],
                },
                redo: {
                    method: 'redo',
                    bindings: [{ key: 'y' }],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.isDrawing = true;
            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    ...viewport.getViewReference({ points: [worldPos] }),
                    toolName: this.getToolName(),
                    referencedImageId,
                    viewUp,
                    cameraPosition,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
            this.doneEditMemo();
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const dataId = `${annotationUID}-line`;
                const lineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_13__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = transformWorldToIndex(imageData, worldPos1);
            const index2 = transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, handles);
            const length = this._calculateLength(worldPos1, worldPos2) / scale;
            if (this._isInsideVolume(index1, index2, dimensions)) {
                this.isHandleOutsideImage = false;
            }
            else {
                this.isHandleOutsideImage = true;
            }
            cachedStats[targetId] = {
                length,
                unit,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { length, unit } = cachedVolumeStats;
    if (length === undefined || length === null || isNaN(length)) {
        return;
    }
    const textLines = [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(length)} ${unit}`];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LengthTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _LivewireContourTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LivewireContourTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js");
/* harmony import */ var _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/livewire/LiveWirePath */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");






class LivewireContourSegmentationTool extends _LivewireContourTool__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static { this.toolName = 'LivewireContourSegmentationTool'; }
    updateInterpolatedAnnotation(annotation, enabledElement) {
        if (this.editData ||
            !annotation.invalidated ||
            !annotation.data.handles.interpolationSources) {
            return;
        }
        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;
        queueMicrotask(() => {
            if (!annotation.data.handles.interpolationSources) {
                return;
            }
            const { points } = annotation.data.handles;
            const { element } = enabledElement.viewport;
            this.setupBaseEditData(points[0], element, annotation);
            const { length: count } = points;
            const { scissors } = this;
            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;
            annotation.data.handles.originalPoints = points;
            const { worldToSlice, sliceToWorld } = this.editData;
            const handleSmoothing = [];
            if (nearestEdge) {
                let lastPoint = worldToSlice(points[points.length - 1]);
                points.forEach((point, hIndex) => {
                    const testPoint = worldToSlice(point);
                    lastPoint = testPoint;
                    handleSmoothing.push(testPoint);
                    scissors.startSearch(lastPoint);
                    scissors.findPathToPoint(testPoint);
                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));
                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);
                    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(testPoint, minPoint)) {
                        handleSmoothing[hIndex] = minPoint;
                        lastPoint = minPoint;
                        points[hIndex] = sliceToWorld(minPoint);
                    }
                });
            }
            const acceptedPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_2__.LivewirePath();
            for (let i = 0; i < count; i++) {
                scissors.startSearch(worldToSlice(points[i]));
                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));
                acceptedPath.addPoints(path);
            }
            this.updateAnnotation(acceptedPath);
            this.scissors = null;
            this.scissorsNext = null;
            this.editData = null;
            annotation.data.handles.interpolationSources = null;
            if (repeatInterpolation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__.triggerAnnotationModified)(annotation, enabledElement.viewport.element, _enums__WEBPACK_IMPORTED_MODULE_4__.ChangeTypes.InterpolationUpdated);
            }
        });
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        const { annotationUID } = annotation;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { showInterpolationPolyline } = this.configuration.interpolation || {};
        this.updateInterpolatedAnnotation?.(annotation, enabledElement);
        const { originalPolyline } = annotation.data.contour;
        const rendered = super.renderAnnotationInstance(renderContext);
        if (showInterpolationPolyline &&
            originalPolyline &&
            annotation.autoGenerated) {
            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);
            polylineCanvasPoints.push(polylineCanvasPoints[0]);
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawPolyline)(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {
                color: '#70ffff',
                lineWidth: 1,
                fillOpacity: 0,
            });
        }
        return rendered;
    }
    isContourSegmentationTool() {
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivewireContourSegmentationTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../eventDispatchers/shared/getMouseModifier */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_contours_findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/contours/findHandlePolylineIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js");
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../types/ContourAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _utilities_livewire_LivewireScissors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/livewire/LivewireScissors */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LivewireScissors.js");
/* harmony import */ var _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/livewire/LiveWirePath */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../base/ContourSegmentationBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js");



















const CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;
class LivewireContourTool extends _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_16__["default"] {
    static { this.toolName = 'LivewireContour'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextLines: defaultGetTextLines,
            calculateStats: true,
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Shift,
            snapHandleNearby: 2,
            interpolation: {
                enabled: false,
                nearestEdge: 2,
                showInterpolationPolyline: false,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            actions: {
                cancelInProgress: {
                    method: 'cancelInProgress',
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const proximitySquared = proximity * proximity;
            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            let startPoint = canvasPoints[canvasPoints.length - 1];
            for (let i = 0; i < canvasPoints.length; i++) {
                const endPoint = canvasPoints[i];
                const distanceToPointSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);
                if (distanceToPointSquared <= proximitySquared) {
                    return true;
                }
                startPoint = endPoint;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this._activateModify(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt, clearAnnotation = false) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            this.doneEditMemo();
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            if ((this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) ||
                clearAnnotation) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
                this.clearEditData();
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
                return;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            const changeType = newAnnotation
                ? _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed
                : _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.HandlesUpdated;
            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);
            this.clearEditData();
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {
            if (changeType === _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerContourAnnotationCompleted)(annotation, contourHoleProcessingEnabled);
            }
            else {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationModified)(annotation, enabledElement.viewport.element, changeType);
            }
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === _enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;
            if (this.editData.closed) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;
            let worldPos = worldPosOriginal;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const controlPoints = this.editData.currentPath.getControlPoints();
            let closePath = controlPoints.length >= 2 && doubleClick;
            this.doneEditMemo();
            this.createMemo(element, annotation, {
                newAnnotation: newAnnotation && controlPoints.length === 1,
            });
            if (controlPoints.length >= 2) {
                const closestHandlePoint = {
                    index: -1,
                    distSquared: Infinity,
                };
                for (let i = 0, len = controlPoints.length; i < len; i++) {
                    const controlPoint = controlPoints[i];
                    const worldControlPoint = sliceToWorld(controlPoint);
                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);
                    const distSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.point.distanceToPointSquared(canvasPos, canvasControlPoint);
                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&
                        distSquared < closestHandlePoint.distSquared) {
                        closestHandlePoint.distSquared = distSquared;
                        closestHandlePoint.index = i;
                    }
                }
                if (closestHandlePoint.index === 0) {
                    closePath = true;
                }
            }
            const { snapHandleNearby } = this.configuration;
            if (snapHandleNearby && !this.editData.closed) {
                const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);
                const pathPoints = this.scissors.findPathToPoint(snapPoint);
                currentPath.addPoints(pathPoints);
                currentPath.prependPath(this.editData.confirmedPath);
                worldPos = sliceToWorld(snapPoint);
                this.editData.currentPath = currentPath;
            }
            this.editData.closed = this.editData.closed || closePath;
            this.editData.confirmedPath = this.editData.currentPath;
            const lastPoint = this.editData.currentPath.getLastPoint();
            this.editData.confirmedPath.addControlPoint(lastPoint);
            annotation.data.handles.points.push(sliceToWorld(lastPoint));
            this.scissors.startSearch(worldToSlice(worldPos));
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            if (this.editData.closed) {
                this.updateAnnotation(this.editData.confirmedPath);
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { element, currentPoints } = evt.detail;
            const { world: worldPos, canvas: canvasPos } = currentPoints;
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = canvasPos;
            const { width: imgWidth, height: imgHeight } = this.scissors;
            const { worldToSlice } = this.editData;
            const slicePoint = worldToSlice(worldPos);
            if (slicePoint[0] < 0 ||
                slicePoint[1] < 0 ||
                slicePoint[0] >= imgWidth ||
                slicePoint[1] >= imgHeight) {
                return;
            }
            const pathPoints = this.scissors.findPathToPoint(slicePoint);
            const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
            currentPath.addPoints(pathPoints);
            currentPath.prependPath(this.editData.confirmedPath);
            this.editData.currentPath = currentPath;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                console.warn('Drag annotation not implemented');
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                this.editHandle(worldPos, element, annotation, handleIndex);
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            if (newAnnotation) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            this.doneEditMemo();
            this.scissors = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,_utilities__WEBPACK_IMPORTED_MODULE_18__.getCalibratedLengthUnitsAndScale)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit: areaUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                this.triggerAnnotationModified(annotation, enabledElement, _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.contour.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_17__.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = _enums__WEBPACK_IMPORTED_MODULE_5__.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget, eventType, eventDetail);
        };
        this._throttledCalculateCachedStats = (0,_utilities__WEBPACK_IMPORTED_MODULE_18__.throttle)(this._calculateCachedStats, 100, { trailing: true });
    }
    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const viewportImageData = viewport.getImageData();
        const { imageData: vtkImageData } = viewportImageData;
        let worldToSlice;
        let sliceToWorld;
        let width;
        let height;
        let scalarData;
        if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport)) {
            width = viewportImageData.dimensions[0];
            height = viewportImageData.dimensions[1];
            worldToSlice = (point) => {
                const ijkPoint = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(vtkImageData, point);
                return [ijkPoint[0], ijkPoint[1]];
            };
            sliceToWorld = (point) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);
            scalarData = viewportImageData.scalarData;
        }
        else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
            const sliceImageData = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getCurrentVolumeViewportSlice(viewport);
            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;
            worldToSlice = (point) => {
                const ijkPoint = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(vtkImageData, point);
                const slicePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);
                return [slicePoint[0], slicePoint[1]];
            };
            sliceToWorld = (point) => {
                const ijkPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);
                return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformIndexToWorld(vtkImageData, ijkPoint);
            };
            scalarData = sliceImageData.scalarData;
            width = sliceImageData.width;
            height = sliceImageData.height;
        }
        else {
            throw new Error('Viewport not supported');
        }
        scalarData = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.convertToGrayscale(scalarData, width, height);
        const { voiRange } = viewport.getProperties();
        const startPos = worldToSlice(worldPos);
        this.scissors = _utilities_livewire_LivewireScissors__WEBPACK_IMPORTED_MODULE_13__.LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
        if (nextPos) {
            this.scissorsNext = _utilities_livewire_LivewireScissors__WEBPACK_IMPORTED_MODULE_13__.LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
            this.scissorsNext.startSearch(worldToSlice(nextPos));
        }
        this.scissors.startSearch(startPos);
        const newAnnotation = !nextPos;
        const confirmedPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
        const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
        const currentPathNext = newAnnotation ? undefined : new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
        confirmedPath.addPoint(startPos);
        confirmedPath.addControlPoint(startPos);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
        const lastCanvasPoint = viewport.worldToCanvas(worldPos);
        this.editData = {
            annotation,
            viewportIdsToRender,
            newAnnotation,
            hasMoved: false,
            lastCanvasPoint,
            confirmedPath,
            currentPath,
            confirmedPathNext: currentPathNext,
            closed: false,
            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,
            worldToSlice,
            sliceToWorld,
            contourHoleProcessingEnabled,
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const annotation = this.createAnnotation(evt);
        const contourHoleProcessingEnabled = (0,_eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_7__["default"])(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);
        this.addAnnotation(annotation, element);
        this._activateDraw(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(this.editData.viewportIdsToRender);
        return annotation;
    }
    clearEditData() {
        this.editData = null;
        this.scissors = null;
        this.scissorsNext = null;
        this.isDrawing = false;
    }
    editHandle(worldPos, element, annotation, handleIndex) {
        const { data } = annotation;
        const { points: handlePoints } = data.handles;
        const { length: numHandles } = handlePoints;
        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];
        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];
        if (!this.editData?.confirmedPathNext) {
            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);
            const { polyline } = data.contour;
            const confirmedPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
            const confirmedPathNext = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
            const { worldToSlice } = this.editData;
            const previousIndex = (0,_utilities_contours_findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__["default"])(annotation, handleIndex - 1);
            const nextIndex = (0,_utilities_contours_findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__["default"])(annotation, handleIndex + 1);
            if (nextIndex === -1 || previousIndex === -1) {
                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);
            }
            if (handleIndex === 0) {
                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));
            }
            else {
                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));
                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));
            }
            this.editData.confirmedPath = confirmedPath;
            this.editData.confirmedPathNext = confirmedPathNext;
        }
        const { editData, scissors } = this;
        const { worldToSlice, sliceToWorld } = editData;
        const { activeHandleIndex } = data.handles;
        if (activeHandleIndex === null || activeHandleIndex === undefined) {
            data.handles.activeHandleIndex = handleIndex;
        }
        else if (activeHandleIndex !== handleIndex) {
            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);
        }
        const slicePos = worldToSlice(worldPos);
        if (slicePos[0] < 0 ||
            slicePos[0] >= scissors.width ||
            slicePos[1] < 0 ||
            slicePos[1] >= scissors.height) {
            return;
        }
        handlePoints[handleIndex] = sliceToWorld(slicePos);
        const pathPointsLeft = scissors.findPathToPoint(slicePos);
        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);
        const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__.LivewirePath();
        currentPath.prependPath(editData.confirmedPath);
        if (handleIndex !== 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        currentPath.addPoints(pathPointsRight.reverse());
        currentPath.appendPath(editData.confirmedPathNext);
        if (handleIndex === 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        editData.currentPath = currentPath;
        annotation.invalidated = true;
        editData.hasMoved = true;
        editData.closed = true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        this.updateAnnotation(this.editData?.currentPath);
        return super.renderAnnotation(enabledElement, svgDrawingHelper);
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const contourSegmentationAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const annotation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.deepMerge(contourSegmentationAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
            },
        });
        return annotation;
    }
    cancelInProgress(element, config, evt) {
        if (!this.editData) {
            this.undo();
            return;
        }
        this._endCallback(evt, true);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;
        const { viewport } = enabledElement;
        const { element } = viewport;
        const { worldToCanvas } = viewport;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color } = annotationStyle;
        if (highlighted ||
            (newAnnotation &&
                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {
            const handleGroupUID = '0';
            const canvasHandles = handles.points.map(worldToCanvas);
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {
                color,
                lineDash,
                lineWidth,
            });
        }
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId]?.areaUnit === null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        return true;
    }
    updateAnnotation(livewirePath) {
        if (!this.editData || !livewirePath) {
            return;
        }
        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;
        let { pointArray: imagePoints } = livewirePath;
        if (imagePoints.length > 1) {
            imagePoints = [...imagePoints, imagePoints[0]];
        }
        const targetWindingDirection = newAnnotation && closed ? _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_11__.ContourWindingDirection.Clockwise : undefined;
        this.updateContourPolyline(annotation, {
            points: imagePoints,
            closed,
            targetWindingDirection,
        }, {
            canvasToWorld: sliceToWorld,
            worldToCanvas: worldToSlice,
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivewireContourTool);
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/viewport/isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class ProbeTool extends _base__WEBPACK_IMPORTED_MODULE_2__.AnnotationTool {
    static { this.toolName = 'Probe'; }
    static { this.probeDefaults = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            handleRadius: '6',
            textCanvasOffset: {
                x: 6,
                y: -6,
            },
        },
    }; }
    constructor(toolProps = {}, defaultToolProps) {
        super(toolProps, _base__WEBPACK_IMPORTED_MODULE_2__.AnnotationTool.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: { points: [[...worldPos]] },
                },
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { viewportId, renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.eventDispatchDetail = {
                viewportId,
                renderingEngineId: renderingEngine.id,
            };
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            data.handles.points[0] = [...worldPos];
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const annotationUID = annotation.annotationUID;
                const data = annotation.data;
                const point = data.handles.points[0];
                const canvasCoordinates = viewport.worldToCanvas(point);
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!data.cachedStats) {
                    data.cachedStats = {};
                }
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].value === null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        index: null,
                        value: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, _enums__WEBPACK_IMPORTED_MODULE_8__.ChangeTypes.StatsUpdated);
                }
                else if (annotation.invalidated) {
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const handleGroupUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (textLines) {
                    const textCanvasCoordinates = [
                        canvasCoordinates[0] + this.configuration.textCanvasOffset.x,
                        canvasCoordinates[1] + this.configuration.textCanvasOffset.y,
                    ];
                    const textUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);
                }
            }
            return renderStatus;
        };
    }
    isPointNearTool(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const point = data.handles.points[0];
        const annotationCanvasCoordinate = viewport.worldToCanvas(point);
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
    }
    toolSelectedCallback() { }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])([viewport.id]);
    }; }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const point = data.handles.points[0];
        const annotationCanvasCoordinate = viewport.worldToCanvas(point);
        const near = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
        if (near === true) {
            return point;
        }
    }
    handleSelectedCallback(evt, annotation) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_8__.ChangeTypes.StatsUpdated) {
        const data = annotation.data;
        const { renderingEngineId, viewport } = enabledElement;
        const { element } = viewport;
        const worldPos = data.handles.points[0];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const pixelUnitsOptions = {
                isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_14__.isViewportPreScaled)(viewport, targetId),
                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
            };
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { dimensions, imageData, metadata, voxelManager } = image;
            const modality = metadata.Modality;
            let ijk = transformWorldToIndex(imageData, worldPos);
            ijk = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.round(ijk, ijk);
            if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(ijk, dimensions)) {
                this.isHandleOutsideImage = false;
                let value = voxelManager.getAtIJKPoint(ijk);
                if (targetId.startsWith('imageId:')) {
                    const imageId = targetId.split('imageId:')[1];
                    const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(imageId);
                    const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getViewportsWithImageURI(imageURI);
                    const viewport = viewports[0];
                    ijk[2] = viewport.getCurrentImageIdIndex();
                }
                let modalityUnit;
                if (modality === 'US') {
                    const calibratedResults = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_5__.getCalibratedProbeUnitsAndValue)(image, [
                        ijk,
                    ]);
                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);
                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);
                    modalityUnit = hasEnhancedRegionValues
                        ? calibratedResults.units
                        : 'raw';
                }
                else {
                    modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_13__.getPixelValueUnits)(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                }
                cachedStats[targetId] = {
                    index: ijk,
                    value,
                    Modality: modality,
                    modalityUnit,
                };
            }
            else {
                this.isHandleOutsideImage = true;
                cachedStats[targetId] = {
                    index: ijk,
                    Modality: modality,
                };
            }
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationModified)(annotation, element, changeType);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined || !index) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    if (value instanceof Array && modalityUnit instanceof Array) {
        for (let i = 0; i < value.length; i++) {
            textLines.push(`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(value[i])} ${modalityUnit[i]}`);
        }
    }
    else {
        textLines.push(`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(value)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProbeTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GrowCutBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js");
/* harmony import */ var _utilities_segmentation_growCut_runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/segmentation/growCut/runOneClickGrowCut */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");





class RegionSegmentPlusTool extends _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static { this.toolName = 'RegionSegmentPlus'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: false,
            positiveSeedVariance: 0.4,
            negativeSeedVariance: 0.9,
            subVolumePaddingPercentage: 0.1,
            islandRemoval: {
                enabled: false,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseTimer = null;
        this.allowedToProceed = false;
    }
    mouseMoveCallback(evt) {
        if (this.mode !== _enums__WEBPACK_IMPORTED_MODULE_4__.ToolModes.Active) {
            return;
        }
        const eventData = evt.detail;
        const { currentPoints, element } = eventData;
        const { world: worldPoint } = currentPoints;
        element.style.cursor = 'default';
        if (this.mouseTimer !== null) {
            window.clearTimeout(this.mouseTimer);
            this.mouseTimer = null;
        }
        this.mouseTimer = window.setTimeout(() => {
            this.onMouseStable(evt, worldPoint, element);
        }, this.configuration.mouseStabilityDelay || 500);
    }
    async onMouseStable(evt, worldPoint, element) {
        await super.preMouseDownCallback(evt);
        const refVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(this.growCutData.segmentation.referencedVolumeId);
        const seeds = (0,_utilities_segmentation_growCut_runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__.calculateGrowCutSeeds)(refVolume, worldPoint, {}) || {
            positiveSeedIndices: new Set(),
            negativeSeedIndices: new Set(),
        };
        const { positiveSeedIndices, negativeSeedIndices } = seeds;
        let cursor;
        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||
            negativeSeedIndices.size < 30) {
            cursor = 'not-allowed';
            this.allowedToProceed = false;
        }
        else {
            cursor = 'copy';
            this.allowedToProceed = true;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (element) {
            element.style.cursor = cursor;
            requestAnimationFrame(() => {
                if (element.style.cursor !== cursor) {
                    element.style.cursor = cursor;
                }
            });
        }
        if (this.allowedToProceed) {
            this.seeds = seeds;
        }
        if (enabledElement && enabledElement.viewport) {
            enabledElement.viewport.render();
        }
    }
    async preMouseDownCallback(evt) {
        if (!this.allowedToProceed) {
            return false;
        }
        const eventData = evt.detail;
        const { currentPoints, element } = eventData;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (enabledElement) {
            element.style.cursor = 'wait';
            requestAnimationFrame(() => {
                if (element.style.cursor !== 'wait') {
                    element.style.cursor = 'wait';
                }
            });
        }
        const { world: worldPoint } = currentPoints;
        await super.preMouseDownCallback(evt);
        this.growCutData = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(this.growCutData, {
            worldPoint,
            islandRemoval: {
                worldIslandPoints: [worldPoint],
            },
        });
        this.growCutData.worldPoint = worldPoint;
        this.growCutData.islandRemoval = {
            worldIslandPoints: [worldPoint],
        };
        await this.runGrowCut();
        if (element) {
            element.style.cursor = 'default';
        }
        return true;
    }
    getRemoveIslandData(growCutData) {
        const { worldPoint } = growCutData;
        return {
            worldIslandPoints: [worldPoint],
        };
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;
        const { subVolumePaddingPercentage } = this.configuration;
        const mergedOptions = {
            ...options,
            subVolumePaddingPercentage,
            seeds: this.seeds,
        };
        return _utilities_segmentation__WEBPACK_IMPORTED_MODULE_1__.growCut.runOneClickGrowCut({
            referencedVolumeId,
            worldPosition: worldPoint,
            options: mergedOptions,
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegionSegmentPlusTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/GrowCutBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js");








class RegionSegmentTool extends _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__["default"] {
    static { this.toolName = 'RegionSegment'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: true,
            positiveSeedVariance: 0.5,
            negativeSeedVariance: 0.9,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const { world: currentWorldPoint } = currentPoints;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.growCutData.circleBorderPoint = currentWorldPoint;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])([viewport.id]);
        };
        this._endCallback = async (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.runGrowCut();
            this._deactivateDraw(element);
            this.growCutData = null;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.resetElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])([viewport.id]);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        await super.preMouseDownCallback(evt);
        Object.assign(this.growCutData, {
            circleCenterPoint: worldPoint,
            circleBorderPoint: worldPoint,
        });
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])([viewport.id]);
        return true;
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const worldCircleRadius = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.len(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), circleCenterPoint, circleBorderPoint));
        const sphereInfo = {
            center: circleCenterPoint,
            radius: worldCircleRadius,
        };
        return _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);
    }
    _activateDraw(element) {
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.growCutData) {
            return;
        }
        const { viewport } = enabledElement;
        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;
        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);
        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);
        const vecCenterToBorder = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), canvasBorderPoint, canvasCenterPoint);
        const circleRadius = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.len(vecCenterToBorder);
        if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(circleRadius, 0)) {
            return;
        }
        const annotationUID = 'growcut';
        const circleUID = '0';
        const { color } = this.getSegmentStyle({
            segmentationId: segmentationData.segmentationId,
            segmentIndex: segmentationData.segmentIndex,
            viewportId: viewport.id,
        });
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {
            color,
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegionSegmentTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _SplineROITool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SplineROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js");


class SplineContourSegmentationTool extends _SplineROITool__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static { this.toolName = 'SplineContourSegmentationTool'; }
    constructor(toolProps) {
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge({
            configuration: {
                calculateStats: false,
            },
        }, toolProps);
        super(initialProps);
    }
    isContourSegmentationTool() {
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SplineContourSegmentationTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../eventDispatchers/shared/getMouseModifier */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js");
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../types/ContourAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js");
/* harmony import */ var _splines_CardinalSpline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./splines/CardinalSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js");
/* harmony import */ var _splines_LinearSpline__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./splines/LinearSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js");
/* harmony import */ var _splines_CatmullRomSpline__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./splines/CatmullRomSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js");
/* harmony import */ var _splines_BSpline__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./splines/BSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js");
/* harmony import */ var _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../base/ContourSegmentationBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js");




















const SPLINE_MIN_POINTS = 3;
const SPLINE_CLICK_CLOSE_CURVE_DIST = 10;
const DEFAULT_SPLINE_CONFIG = {
    resolution: 20,
    controlPointAdditionDistance: 6,
    controlPointDeletionDistance: 6,
    showControlPointsConnectors: false,
    controlPointAdditionEnabled: true,
    controlPointDeletionEnabled: true,
};
var SplineTypesEnum;
(function (SplineTypesEnum) {
    SplineTypesEnum["Cardinal"] = "CARDINAL";
    SplineTypesEnum["Linear"] = "LINEAR";
    SplineTypesEnum["CatmullRom"] = "CATMULLROM";
    SplineTypesEnum["BSpline"] = "BSPLINE";
})(SplineTypesEnum || (SplineTypesEnum = {}));
var SplineToolActions;
(function (SplineToolActions) {
    SplineToolActions["AddControlPoint"] = "addControlPoint";
    SplineToolActions["DeleteControlPoint"] = "deleteControlPoint";
})(SplineToolActions || (SplineToolActions = {}));
class SplineROITool extends _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_18__["default"] {
    static { this.toolName = 'SplineROI'; }
    static { this.SplineTypes = SplineTypesEnum; }
    static { this.Actions = SplineToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            contourHoleAdditionModifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Shift,
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            spline: {
                configuration: {
                    [SplineTypesEnum.Cardinal]: {
                        Class: _splines_CardinalSpline__WEBPACK_IMPORTED_MODULE_14__.CardinalSpline,
                        scale: 0.5,
                    },
                    [SplineTypesEnum.CatmullRom]: {
                        Class: _splines_CatmullRomSpline__WEBPACK_IMPORTED_MODULE_16__.CatmullRomSpline,
                    },
                    [SplineTypesEnum.Linear]: {
                        Class: _splines_LinearSpline__WEBPACK_IMPORTED_MODULE_15__.LinearSpline,
                    },
                    [SplineTypesEnum.BSpline]: {
                        Class: _splines_BSpline__WEBPACK_IMPORTED_MODULE_17__.BSpline,
                        controlPointAdditionEnabled: false,
                        controlPointDeletionEnabled: false,
                        showControlPointsConnectors: true,
                    },
                },
                type: SplineTypesEnum.CatmullRom,
                drawPreviewEnabled: true,
                lastControlPointDeletionKeys: ['Backspace', 'Delete'],
            },
            actions: {
                [SplineToolActions.AddControlPoint]: {
                    method: 'addControlPointCallback',
                    bindings: [
                        {
                            mouseButton: _enums__WEBPACK_IMPORTED_MODULE_5__.MouseBindings.Primary,
                            modifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Shift,
                        },
                    ],
                },
                [SplineToolActions.DeleteControlPoint]: {
                    method: 'deleteControlPointCallback',
                    bindings: [
                        {
                            mouseButton: _enums__WEBPACK_IMPORTED_MODULE_5__.MouseBindings.Primary,
                            modifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Ctrl,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.fireChangeOnUpdate = null;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { instance: spline } = annotation.data.spline;
            return spline.isPointNearCurve(canvasCoords, proximity);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            annotation.autoGenerated = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));
            const { imageData, dimensions } = image;
            this.isHandleOutsideImage = data.handles.points
                .map((p) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, p))
                .some((index) => !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.indexWithinDimensions(index, dimensions));
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            const changeType = newAnnotation
                ? _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed
                : _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.HandlesUpdated;
            if (!this.fireChangeOnUpdate) {
                this.fireChangeOnUpdate = {
                    annotationUID: annotation.annotationUID,
                    changeType,
                    contourHoleProcessingEnabled,
                };
            }
            else {
                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;
                this.fireChangeOnUpdate.changeType = changeType;
            }
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
        };
        this._keyDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const key = eventDetail.key ?? '';
            const { lastControlPointDeletionKeys } = this.configuration.spline;
            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);
            if (!deleteLastPoint) {
                return;
            }
            const { annotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length === SPLINE_MIN_POINTS) {
                this.cancel(element);
                return;
            }
            else {
                const controlPointIndex = data.handles.points.length - 1;
                this._deleteControlPointByIndex(element, annotation, controlPointIndex);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { drawPreviewEnabled } = this.configuration.spline;
            if (!drawPreviewEnabled) {
                return;
            }
            const { element } = evt.detail;
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === _enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            if (data.contour.closed) {
                return;
            }
            this.doneEditMemo();
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const { canvas: canvasPoint, world: worldPoint } = currentPoints;
            let closeContour = data.handles.points.length >= 2 && doubleClick;
            let addNewPoint = true;
            if (data.handles.points.length) {
                this.createMemo(element, annotation, {
                    newAnnotation: data.handles.points.length === 1,
                });
            }
            if (data.handles.points.length >= 3) {
                this.createMemo(element, annotation);
                const { instance: spline } = data.spline;
                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
                if (closestControlPoint?.index === 0) {
                    addNewPoint = false;
                    closeContour = true;
                }
            }
            if (addNewPoint) {
                data.handles.points.push(worldPoint);
            }
            data.contour.closed = data.contour.closed || closeContour;
            annotation.invalidated = true;
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            if (data.contour.closed) {
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                this.moveAnnotation(annotation, worldPosDelta);
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        };
        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {
            const eventType = _enums__WEBPACK_IMPORTED_MODULE_5__.Events.ANNOTATION_COMPLETED;
            const eventDetail = {
                annotation,
                changeType: _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed,
                contourHoleProcessingEnabled,
            };
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = _enums__WEBPACK_IMPORTED_MODULE_5__.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {
            if (changeType === _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed) {
                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);
            }
            else {
                this.triggerAnnotationModified(annotation, enabledElement, changeType);
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_DOWN, this._keyDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_DOWN, this._keyDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.spline.instance.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_10__.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.addControlPointCallback = (evt, annotation) => {
            const { data } = annotation;
            const splineType = data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointAdditionDistance;
            if (splineConfig.controlPointAdditionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { instance: spline } = data.spline;
            const canvasPos = evt.detail.currentPoints.canvas;
            const closestPointInfo = spline.getClosestPoint(canvasPos);
            if (closestPointInfo.distance > maxDist) {
                return;
            }
            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);
            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));
            annotation.invalidated = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        };
        this.deleteControlPointCallback = (evt, annotation) => {
            const splineType = annotation.data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointDeletionDistance;
            if (splineConfig.controlPointDeletionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const { canvas: canvasPos } = currentPoints;
            const { instance: spline } = annotation.data.spline;
            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);
            if (!closestControlPoint) {
                return;
            }
            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_11__.getCalibratedLengthUnitsAndScale)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = _utilities_math__WEBPACK_IMPORTED_MODULE_7__.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = _utilities_math__WEBPACK_IMPORTED_MODULE_7__.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                this.triggerAnnotationModified(annotation, enabledElement, _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_8__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { canvas: canvasPos } = currentPoints;
        const contourHoleProcessingEnabled = (0,_eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_12__["default"])(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        const annotation = this.createAnnotation(evt);
        this.isDrawing = true;
        this.addAnnotation(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
            lastCanvasPoint: canvasPos,
            contourHoleProcessingEnabled,
        };
        this._activateDraw(element);
        evt.preventDefault();
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        return annotation;
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        if (newAnnotation) {
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
        }
        super.cancelAnnotation(annotation);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        this.editData = null;
        return annotation.annotationUID;
    }
    isContourSegmentationTool() {
        return false;
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { element } = viewport;
        const annotation = renderContext.annotation;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const { points: controlPoints, activeHandleIndex } = handles;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;
        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));
        const { drawPreviewEnabled } = this.configuration.spline;
        const splineType = annotation.data.spline.type;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = annotation.data.spline.instance;
        const childAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getChildAnnotations)(annotation);
        const missingAnnotation = childAnnotations.findIndex((it) => !it);
        if (missingAnnotation !== -1) {
            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);
        }
        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));
        splineAnnotationsGroup.forEach((annotation) => {
            const spline = this._updateSplineInstance(element, annotation);
            const splinePolylineCanvas = spline.getPolylinePoints();
            this.updateContourPolyline(annotation, {
                points: splinePolylineCanvas,
                closed: data.contour.closed,
                targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_13__.ContourWindingDirection.Clockwise,
            }, viewport, { updateWindingDirection: data.contour.closed });
        });
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId].areaUnit == null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        let activeHandleCanvasCoords;
        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {
            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords || newAnnotation || highlighted) {
            const handleGroupUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                color,
                lineWidth,
                handleRadius: '3',
            });
        }
        if (drawPreviewEnabled &&
            spline.numControlPoints > 1 &&
            this.editData?.lastCanvasPoint &&
            !spline.closed) {
            const { lastCanvasPoint } = this.editData;
            const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawPolyline)(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {
                color: '#9EA0CA',
                lineDash: lineDash,
                lineWidth: 1,
            });
        }
        if (splineConfig.showControlPointsConnectors) {
            const controlPointsConnectors = [...canvasCoordinates];
            if (spline.closed) {
                controlPointsConnectors.push(canvasCoordinates[0]);
            }
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawPolyline)(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {
                color: 'rgba(255, 255, 255, 0.5)',
                lineWidth: 1,
            });
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {
            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);
            this.fireChangeOnUpdate = null;
        }
        annotation.invalidated = false;
        return true;
    }
    createInterpolatedSplineControl(annotation) {
        if (annotation.data.handles.points?.length) {
            return;
        }
        const { polyline } = annotation.data.contour;
        if (!polyline || !polyline.length) {
            return;
        }
        annotation.data.handles.points = [];
        const { points } = annotation.data.handles;
        const increment = Math.max(10, Math.floor(polyline.length / 20));
        for (let i = 0; i < polyline.length - increment; i += increment) {
            points.push(polyline[i]);
        }
        points.push(polyline[polyline.length - 1]);
    }
    createAnnotation(evt) {
        const contourAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const { type: splineType } = this.configuration.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = new splineConfig.Class();
        const createSpline = () => ({
            type: splineConfig.type,
            instance: spline,
            resolution: splineConfig.resolution,
        });
        let onInterpolationComplete;
        if (this.configuration.interpolation?.enabled) {
            onInterpolationComplete = (annotation) => {
                annotation.data.spline ||= createSpline();
                this.createInterpolatedSplineControl(annotation);
            };
        }
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(contourAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
                spline: createSpline(),
                cachedStats: {},
            },
            onInterpolationComplete,
        });
    }
    _deleteControlPointByIndex(element, annotation, controlPointIndex) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { points: controlPoints } = annotation.data.handles;
        if (controlPoints.length === 3) {
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
        }
        else {
            controlPoints.splice(controlPointIndex, 1);
        }
        const { renderingEngine } = enabledElement;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
        annotation.invalidated = true;
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
    }
    _isSplineROIAnnotation(annotation) {
        return !!annotation.data?.spline;
    }
    _getSplineConfig(type) {
        const { configuration: config } = this;
        const splineConfigs = config.spline.configuration;
        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);
    }
    _updateSplineInstance(element, annotation) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { data } = annotation;
        const { type: splineType, instance: spline } = annotation.data.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const worldPoints = data.handles.points;
        const canvasPoints = worldPoints.map(worldToCanvas);
        const resolution = splineConfig.resolution !== undefined
            ? parseInt(splineConfig.resolution)
            : undefined;
        const scale = splineConfig.scale !== undefined
            ? parseFloat(splineConfig.scale)
            : undefined;
        spline.setControlPoints(canvasPoints);
        spline.closed = !!data.contour.closed;
        if (!spline.fixedResolution &&
            resolution !== undefined &&
            spline.resolution !== resolution) {
            spline.resolution = resolution;
            annotation.invalidated = true;
        }
        if (spline instanceof _splines_CardinalSpline__WEBPACK_IMPORTED_MODULE_14__.CardinalSpline &&
            !spline.fixedScale &&
            scale !== undefined &&
            spline.scale !== scale) {
            spline.scale = scale;
            annotation.invalidated = true;
        }
        return spline;
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        if (points.length < SPLINE_MIN_POINTS) {
            console.warn('Spline requires at least 3 control points');
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);
        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;
        const splineConfig = instance._getSplineConfig(splineType);
        const SplineClass = splineConfig.Class;
        const splineInstance = new SplineClass();
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
                label: '',
                cachedStats: {},
                spline: {
                    type: splineType,
                    instance: splineInstance,
                },
                contour: {
                    closed: true,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: true,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, viewport.element);
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)([viewport.id]);
    }; }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SplineROITool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_math_point__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/math/point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");














const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class UltrasoundDirectionalTool extends _base__WEBPACK_IMPORTED_MODULE_2__.AnnotationTool {
    static { this.toolName = 'UltrasoundDirectionalTool'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            displayBothAxesDistances: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.startedDrawing) {
                return;
            }
            this.startedDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.StackViewport)) {
                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');
            }
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math__WEBPACK_IMPORTED_MODULE_13__.lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.startedDrawing && data.handles.points.length === 1) {
                this.editData.handleIndex = 1;
                return;
            }
            this.startedDrawing = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                this.startedDrawing = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].xValues == null) {
                    data.cachedStats[targetId] = {
                        xValues: [0, 0],
                        yValues: [0, 0],
                        isHorizontal: false,
                        units: [''],
                        isUnitless: false,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let handleGroupUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {
                    color,
                }, 0);
                renderStatus = true;
                if (canvasCoordinates.length !== 2) {
                    return renderStatus;
                }
                handleGroupUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {
                    color,
                }, 1);
                const isUnitless = data.cachedStats[targetId].isUnitless;
                if (!isUnitless) {
                    const canvasPoint1 = canvasCoordinates[0];
                    const canvasPoint2 = canvasCoordinates[1];
                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                    const isHorizontal = data.cachedStats[targetId].isHorizontal;
                    let projectedPointCanvas = [0, 0];
                    if (isHorizontal) {
                        projectedPointCanvas = [
                            canvasPoint1[0] + canvasDeltaX,
                            canvasPoint1[1],
                        ];
                    }
                    else {
                        projectedPointCanvas = [
                            canvasPoint1[0],
                            canvasPoint1[1] + canvasDeltaY,
                        ];
                    }
                    let dataId = `${annotationUID}-line-1`;
                    let lineUID = '1';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                    dataId = `${annotationUID}-line-2`;
                    lineUID = '2';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {
                        color,
                        width: 1,
                        lineDash: [1, 1],
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                else {
                    const dataId = `${annotationUID}-line-1`;
                    const lineUID = '1';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {
        return;
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        this.editData = {
            handleIndex,
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__["default"])(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 2) {
            return;
        }
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData } = image;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);
            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);
            const { values: values1, units: units1 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_12__.getCalibratedProbeUnitsAndValue)(image, [imageIndex1]);
            const { values: values2, units: units2 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_12__.getCalibratedProbeUnitsAndValue)(image, [imageIndex2]);
            let xValues, yValues, units, isHorizontal;
            let isUnitless = false;
            if (units1[0] !== units2[0] ||
                units1[1] !== units2[1] ||
                (units1[0] === 'raw' && units2[0] === 'raw')) {
                const value = (0,_utilities_math_point__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint)(worldPos1, worldPos2);
                xValues = [value, 0];
                yValues = [value, 0];
                units = ['px'];
                isUnitless = true;
            }
            else {
                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);
                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);
                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);
                xValues = [values1[0], values2[0]];
                yValues = [values1[1], values2[1]];
                units = [units1[0], units1[1]];
            }
            cachedStats[targetId] = {
                xValues,
                yValues,
                isHorizontal,
                units,
                isUnitless,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId, configuration) {
    const cachedStats = data.cachedStats[targetId];
    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;
    if (isUnitless) {
        return [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(xValues[0])} px`];
    }
    if (configuration.displayBothAxesDistances) {
        const dist1 = Math.abs(xValues[1] - xValues[0]);
        const dist2 = Math.abs(yValues[1] - yValues[0]);
        return [
            `${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist1)} ${units[0]}`,
            `${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist2)} ${units[1]}`,
        ];
    }
    if (isHorizontal) {
        const dist = Math.abs(xValues[1] - xValues[0]);
        return [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist)} ${units[0]}`];
    }
    else {
        const dist = Math.abs(yValues[1] - yValues[0]);
        return [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist)} ${units[1]}`];
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UltrasoundDirectionalTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/math/rectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/planar/getWorldWidthAndHeightFromTwoPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js");













class VideoRedactionTool extends _base__WEBPACK_IMPORTED_MODULE_2__.AnnotationTool {
    static { this.toolName = 'VideoRedaction'; }
    constructor(toolConfiguration = {}) {
        super(toolConfiguration, {
            supportedInteractionTypes: ['Mouse', 'Touch'],
            configuration: { shadow: true, preventHandleOutsideImage: false },
        });
        this.addNewAnnotation = (evt) => {
            const eventData = evt.detail;
            const { currentPoints, element } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                    },
                },
            });
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportUIDsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportUIDsToRender);
            return annotation;
        };
        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);
                const near = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;
                if (near === true) {
                    data.handles.activeHandleIndex = i;
                    return point;
                }
            }
            data.handles.activeHandleIndex = null;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasPoint1 = viewport.worldToCanvas(points[0]);
            const canvasPoint2 = viewport.worldToCanvas(points[3]);
            const rect = this._getRectangleImageCoordinates([
                canvasPoint1,
                canvasPoint2,
            ]);
            const point = [canvasCoords[0], canvasCoords[1]];
            const { left, top, width, height } = rect;
            const distanceToPoint = _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint([left, top, width, height], point);
            if (distanceToPoint <= proximity) {
                return true;
            }
        };
        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            const viewportUIDsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportUIDsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportUIDsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportUIDsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            data.active = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportUIDsToRender);
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventData;
                const worldPosDelta = deltaPoints.world;
                const { points } = data.handles;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                data.invalidated = true;
            }
            else {
                const { currentPoints } = eventData;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
                const worldPos = currentPoints.world;
                const { points } = data.handles;
                points[handleIndex] = [...worldPos];
                let bottomLeftCanvas;
                let bottomRightCanvas;
                let topLeftCanvas;
                let topRightCanvas;
                let bottomLeftWorld;
                let bottomRightWorld;
                let topLeftWorld;
                let topRightWorld;
                switch (handleIndex) {
                    case 0:
                    case 3:
                        bottomLeftCanvas = worldToCanvas(points[0]);
                        topRightCanvas = worldToCanvas(points[3]);
                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                        bottomRightWorld = canvasToWorld(bottomRightCanvas);
                        topLeftWorld = canvasToWorld(topLeftCanvas);
                        points[1] = bottomRightWorld;
                        points[2] = topLeftWorld;
                        break;
                    case 1:
                    case 2:
                        bottomRightCanvas = worldToCanvas(points[1]);
                        topLeftCanvas = worldToCanvas(points[2]);
                        bottomLeftCanvas = [
                            topLeftCanvas[0],
                            bottomRightCanvas[1],
                        ];
                        topRightCanvas = [
                            bottomRightCanvas[0],
                            topLeftCanvas[1],
                        ];
                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                        topRightWorld = canvasToWorld(topRightCanvas);
                        points[0] = bottomLeftWorld;
                        points[3] = topRightWorld;
                        break;
                }
                data.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportUIDsToRender);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID } = annotation;
                const data = annotation.data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return;
                }
                let activeHandleCanvasCoords;
                if (!this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawRedactionRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color: 'black',
                    lineDash,
                    lineWidth,
                });
            }
        };
        this._getRectangleImageCoordinates = (points) => {
            const [point0, point1] = points;
            return {
                left: Math.min(point0[0], point1[0]),
                top: Math.min(point0[1], point1[1]),
                width: Math.abs(point0[0] - point1[0]),
                height: Math.abs(point0[1] - point1[1]),
            };
        };
        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[3];
            const { cachedStats } = data;
            const targetUIDs = Object.keys(cachedStats);
            for (let i = 0; i < targetUIDs.length; i++) {
                const targetUID = targetUIDs[i];
                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);
                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;
                const worldPos1Index = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(0, 0, 0);
                const worldPos2Index = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(0, 0, 0);
                imageData.worldToIndexVec3(worldPos1, worldPos1Index);
                worldPos1Index[0] = Math.floor(worldPos1Index[0]);
                worldPos1Index[1] = Math.floor(worldPos1Index[1]);
                worldPos1Index[2] = Math.floor(worldPos1Index[2]);
                imageData.worldToIndexVec3(worldPos2, worldPos2Index);
                worldPos2Index[0] = Math.floor(worldPos2Index[0]);
                worldPos2Index[1] = Math.floor(worldPos2Index[1]);
                worldPos2Index[2] = Math.floor(worldPos2Index[2]);
                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                    this.isHandleOutsideImage = false;
                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                    const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_12__["default"])(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const area = worldWidth * worldHeight;
                    let count = 0;
                    let mean = 0;
                    let stdDev = 0;
                    const yMultiple = dimensions[0];
                    const zMultiple = dimensions[0] * dimensions[1];
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                count++;
                                mean += value;
                            }
                        }
                    }
                    mean /= count;
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                const valueMinusMean = value - mean;
                                stdDev += valueMinusMean * valueMinusMean;
                            }
                        }
                    }
                    stdDev /= count;
                    stdDev = Math.sqrt(stdDev);
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                        area,
                        mean,
                        stdDev,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                const eventType = _enums__WEBPACK_IMPORTED_MODULE_7__.Events.ANNOTATION_MODIFIED;
                const eventDetail = {
                    annotation,
                    viewportUID,
                    renderingEngineUID,
                    sceneUID: sceneUID,
                    changeType: _enums__WEBPACK_IMPORTED_MODULE_7__.ChangeTypes.StatsUpdated,
                };
                (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget, eventType, eventDetail);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._getTargetVolumeUID = (scene) => {
            if (this.configuration.volumeUID) {
                return this.configuration.volumeUID;
            }
            const volumeActors = scene.getVolumeActors();
            if (!volumeActors && !volumeActors.length) {
                return;
            }
            return volumeActors[0].uid;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
        const { annotation, viewportUIDsToRender } = this.editData;
        const { data } = annotation;
        data.active = false;
        data.handles.activeHandleIndex = null;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__["default"])(viewportUIDsToRender);
        this.editData = null;
        return annotation.metadata.annotationUID;
    }
    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {
        let imageVolume, viewport;
        if (targetUID.startsWith('stackTarget')) {
            const coloneIndex = targetUID.indexOf(':');
            const viewportUID = targetUID.substring(coloneIndex + 1);
            const viewport = renderingEngine.getViewport(viewportUID);
            imageVolume = viewport.getImageData();
        }
        else {
            imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(targetUID);
        }
        return { imageVolume, viewport };
    }
    _getTargetStackUID(viewport) {
        return `stackTarget:${viewport.uid}`;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VideoRedactionTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/GrowCutBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js");








const NEGATIVE_PIXEL_RANGE = [-Infinity, -995];
const POSITIVE_PIXEL_RANGE = [0, 1900];
const ISLAND_PIXEL_RANGE = [1000, 1900];
const { transformWorldToIndex, transformIndexToWorld } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class WholeBodySegmentTool extends _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: true,
            positivePixelRange: POSITIVE_PIXEL_RANGE,
            negativePixelRange: NEGATIVE_PIXEL_RANGE,
            islandRemoval: {
                enabled: true,
                islandPixelRange: ISLAND_PIXEL_RANGE,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const { world: currentWorldPoint } = currentPoints;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);
            this.growCutData.horizontalLines[1] = linePoints;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])([viewport.id]);
        };
        this._endCallback = async (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            await this.runGrowCut();
            this._deactivateDraw(element);
            this.growCutData = null;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.resetElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])([viewport.id]);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);
        await super.preMouseDownCallback(evt);
        this.growCutData.horizontalLines = [linePoints, linePoints];
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__["default"])([viewport.id]);
        return true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.growCutData) {
            return;
        }
        const { segmentation: segmentationData, horizontalLines } = this.growCutData;
        if (horizontalLines.length !== 2) {
            return;
        }
        const { viewport } = enabledElement;
        const { segmentationId, segmentIndex } = segmentationData;
        const [line1, line2] = horizontalLines;
        const [worldLine1P1, worldLine1P2] = line1;
        const [worldLine2P1, worldLine2P2] = line2;
        const canvasPoints = [
            worldLine1P1,
            worldLine1P2,
            worldLine2P2,
            worldLine2P1,
        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));
        const annotationUID = 'growCutRect';
        const squareGroupUID = '0';
        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({
            segmentationId,
            segmentIndex,
            viewportId: viewport.id,
        });
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawPolyline)(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {
            color,
            fillColor,
            fillOpacity,
            lineWidth,
            lineDash,
            closePath: true,
        });
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const [line1, line2] = horizontalLines;
        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];
        const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(referencedVolumeId);
        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);
        const ijkTopLeft = transformWorldToIndex(referencedVolume.imageData, worldTopLeft);
        const ijkBottomRight = transformWorldToIndex(referencedVolume.imageData, worldBottomRight);
        const boundingBoxInfo = {
            boundingBox: {
                ijkTopLeft,
                ijkBottomRight,
            },
        };
        const config = this.configuration;
        const options = {
            positiveSeedValue: segmentIndex,
            negativeSeedValue: 255,
            negativePixelRange: config.negativePixelRange,
            positivePixelRange: config.positivePixelRange,
        };
        return _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);
    }
    getRemoveIslandData() {
        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;
        const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(referencedVolumeId);
        const labelmapVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(labelmapVolumeId);
        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();
        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();
        const { islandPixelRange } = this.configuration.islandRemoval;
        const islandPointIndexes = [];
        for (let i = 0, len = labelmapData.length; i < len; i++) {
            if (labelmapData[i] !== segmentIndex) {
                continue;
            }
            const pixelValue = referencedVolumeData[i];
            if (pixelValue >= islandPixelRange[0] &&
                pixelValue <= islandPixelRange[1]) {
                islandPointIndexes.push(i);
            }
        }
        return {
            islandPointIndexes,
        };
    }
    _activateDraw(element) {
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
    }
    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {
        const volume = this._getViewportVolume(viewport);
        const { dimensions } = volume;
        const ijkPoint = transformWorldToIndex(volume.imageData, worldEdgePoint);
        const axis = vecDirection.findIndex((n) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(n), 1));
        if (axis === -1) {
            throw new Error('Non-orthogonal direction vector');
        }
        const ijkLineP1 = [...ijkPoint];
        const ijkLineP2 = [...ijkPoint];
        ijkLineP1[axis] = 0;
        ijkLineP2[axis] = dimensions[axis] - 1;
        return [ijkLineP1, ijkLineP2];
    }
    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {
        const { viewPlaneNormal } = viewport.getCamera();
        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);
    }
    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {
        const cuboidPoints = [];
        const volume = this._getViewportVolume(viewport);
        worldSquarePoints.forEach((worldSquarePoint) => {
            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);
            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld(volume.imageData, ijkPoint));
            cuboidPoints.push(...worldEdgePoints);
        });
        return cuboidPoints;
    }
    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {
        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);
        const topLeft = [...worldCuboidPoints[0]];
        const bottomRight = [...worldCuboidPoints[0]];
        worldCuboidPoints.forEach((worldPoint) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.min(topLeft, topLeft, worldPoint);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.max(bottomRight, bottomRight, worldPoint);
        });
        return { topLeft, bottomRight };
    }
    _getViewportVolume(viewport) {
        if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.BaseVolumeViewport)) {
            throw new Error('Viewport is not a BaseVolumeViewport');
        }
        const volumeId = viewport.getAllVolumeIds()[0];
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
    }
    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {
        const { viewport } = enabledElement;
        const volume = this._getViewportVolume(viewport);
        const { dimensions } = volume;
        const ijkPoint = transformWorldToIndex(volume.imageData, worldPoint);
        const { viewUp, viewPlaneNormal } = viewport.getCamera();
        const vecRow = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), viewUp, viewPlaneNormal);
        const axis = vecRow.findIndex((n) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(n), 1));
        const ijkLineP1 = [...ijkPoint];
        const ijkLineP2 = [...ijkPoint];
        ijkLineP1[axis] = 0;
        ijkLineP2[axis] = dimensions[axis] - 1;
        return [ijkLineP1, ijkLineP2];
    }
    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {
        const { viewport } = enabledElement;
        const volume = this._getViewportVolume(viewport);
        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);
        const worldPoint1 = transformIndexToWorld(volume.imageData, ijkPoint1);
        const worldPoint2 = transformIndexToWorld(volume.imageData, ijkPoint2);
        return [worldPoint1, worldPoint2];
    }
}
WholeBodySegmentTool.toolName = 'WholeBodySegment';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WholeBodySegmentTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BSpline: () => (/* binding */ BSpline),
/* harmony export */   "default": () => (/* binding */ BSpline)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _CubicSpline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CubicSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js");


const TRANSFORM_MATRIX = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.multiplyScalar(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);
class BSpline extends _CubicSpline__WEBPACK_IMPORTED_MODULE_1__.CubicSpline {
    getTransformMatrix() {
        return TRANSFORM_MATRIX;
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalSpline: () => (/* binding */ CardinalSpline),
/* harmony export */   "default": () => (/* binding */ CardinalSpline)
/* harmony export */ });
/* harmony import */ var _CubicSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CubicSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js");

class CardinalSpline extends _CubicSpline__WEBPACK_IMPORTED_MODULE_0__.CubicSpline {
    constructor(props) {
        super(props);
        this._scale = props?.scale ?? 0.5;
        this._fixedScale = props?.fixedScale ?? false;
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        if (this._fixedScale || this._scale === scale) {
            return;
        }
        this._scale = scale;
        this.invalidated = true;
    }
    get fixedScale() {
        return this._fixedScale;
    }
    getTransformMatrix() {
        const { scale: s } = this;
        const s2 = 2 * s;
        return [
            0, 1, 0, 0,
            -s, 0, s, 0,
            s2, s - 3, 3 - s2, -s,
            -s, 2 - s, s - 2, s
        ];
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CatmullRomSpline: () => (/* binding */ CatmullRomSpline),
/* harmony export */   "default": () => (/* binding */ CatmullRomSpline)
/* harmony export */ });
/* harmony import */ var _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CardinalSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js");

class CatmullRomSpline extends _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__.CardinalSpline {
    constructor() {
        super({ scale: 0.5, fixedScale: true });
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CubicSpline: () => (/* binding */ CubicSpline),
/* harmony export */   "default": () => (/* binding */ CubicSpline)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _Spline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Spline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");



const MAX_U_ERROR = 1e-8;
class CubicSpline extends _Spline__WEBPACK_IMPORTED_MODULE_1__.Spline {
    getPreviewCurveSegments(controlPointPreview, closeSpline) {
        const previewNumCurveSegments = this._getNumCurveSegments() + 1;
        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);
        const endCurveSegIndex = closeSpline
            ? previewNumCurveSegments
            : previewNumCurveSegments - 1;
        const transformMatrix = this.getTransformMatrix();
        const controlPoints = [...this.controlPoints];
        const curveSegments = [];
        if (!closeSpline) {
            controlPoints.push(controlPointPreview);
        }
        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {
            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);
            curveSegments.push(curveSegment);
        }
        return curveSegments;
    }
    getSplineCurves() {
        const numCurveSegments = this._getNumCurveSegments();
        const curveSegments = new Array(numCurveSegments);
        if (numCurveSegments <= 0) {
            return [];
        }
        const transformMatrix = this.getTransformMatrix();
        let previousCurveSegmentsLength = 0;
        for (let i = 0; i < numCurveSegments; i++) {
            const curveSegment = this._getCurveSegment(i, transformMatrix);
            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;
            curveSegments[i] = curveSegment;
            previousCurveSegmentsLength += curveSegment.length;
        }
        return curveSegments;
    }
    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {
        return closed
            ? controlPoints.length
            : Math.max(0, controlPoints.length - 1);
    }
    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const uInt = Math.floor(u);
        let curveSegmentIndex = uInt % numCurveSegments;
        const t = u - uInt;
        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;
        if (curveSegmentIndexOutOfBounds) {
            if (this.closed) {
                curveSegmentIndex =
                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;
            }
            else {
                return;
            }
        }
        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);
        const tt = t * t;
        const ttt = tt * t;
        const tValues = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.fromValues(1, t, tt, ttt);
        const qValues = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.create(), tValues, transformMatrix);
        return [
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.dot(qValues, gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.dot(qValues, gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),
        ];
    }
    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const p1Index = curveSegmentIndex;
        const p0Index = p1Index - 1;
        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;
        const p3Index = p2Index + 1;
        const p1 = controlPoints[p1Index];
        const p2 = controlPoints[p2Index];
        let p0;
        let p3;
        if (p0Index >= 0) {
            p0 = controlPoints[p0Index];
        }
        else {
            p0 = closed
                ? controlPoints[controlPoints.length - 1]
                : _utilities_math__WEBPACK_IMPORTED_MODULE_2__.point.mirror(p2, p1);
        }
        if (p3Index < controlPoints.length) {
            p3 = controlPoints[p3Index];
        }
        else {
            p3 = closed ? controlPoints[0] : _utilities_math__WEBPACK_IMPORTED_MODULE_2__.point.mirror(p1, p2);
        }
        return { p0, p1, p2, p3 };
    }
    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const numLineSegments = this.resolution + 1;
        const inc = 1 / numLineSegments;
        const minU = curveSegmentIndex;
        let maxU = minU + 1;
        if (!closed && curveSegmentIndex === numCurveSegments - 1) {
            maxU -= MAX_U_ERROR;
        }
        const lineSegments = [];
        let startPoint;
        let endPoint;
        let previousLineSegmentsLength = 0;
        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {
            u = u > maxU ? maxU : u;
            const point = this._getPoint(u, transformMatrix, controlPoints, closed);
            if (!i) {
                startPoint = point;
                continue;
            }
            endPoint = point;
            const dx = endPoint[0] - startPoint[0];
            const dy = endPoint[1] - startPoint[1];
            const length = Math.sqrt(dx ** 2 + dy ** 2);
            const aabb = {
                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],
                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],
                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],
                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],
            };
            lineSegments.push({
                points: {
                    start: startPoint,
                    end: endPoint,
                },
                aabb,
                length,
                previousLineSegmentsLength,
            });
            startPoint = endPoint;
            previousLineSegmentsLength += length;
        }
        return lineSegments;
    }
    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {
        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);
        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);
        let curveSegmentLength = 0;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {
            minX = Math.min(minX, lineSegAABB.minX);
            minY = Math.min(minY, lineSegAABB.minY);
            maxX = Math.max(maxX, lineSegAABB.maxX);
            maxY = Math.max(maxY, lineSegAABB.maxY);
            curveSegmentLength += lineSegLength;
        });
        return {
            controlPoints: { p0, p1, p2, p3 },
            aabb: { minX, minY, maxX, maxY },
            length: curveSegmentLength,
            previousCurveSegmentsLength: 0,
            lineSegments,
        };
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinearSpline: () => (/* binding */ LinearSpline),
/* harmony export */   "default": () => (/* binding */ LinearSpline)
/* harmony export */ });
/* harmony import */ var _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CardinalSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js");

class LinearSpline extends _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__.CardinalSpline {
    constructor() {
        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QuadraticBezier: () => (/* binding */ QuadraticBezier),
/* harmony export */   "default": () => (/* binding */ QuadraticBezier)
/* harmony export */ });
/* harmony import */ var _QuadraticSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./QuadraticSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js");

const TRANSFORM_MATRIX = [
    1, 0, 0,
    -2, 2, 0,
    1, -2, 1,
];
class QuadraticBezier extends _QuadraticSpline__WEBPACK_IMPORTED_MODULE_0__.QuadraticSpline {
    hasTangentPoints() {
        return true;
    }
    getTransformMatrix() {
        return TRANSFORM_MATRIX;
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QuadraticSpline: () => (/* binding */ QuadraticSpline),
/* harmony export */   "default": () => (/* binding */ QuadraticSpline)
/* harmony export */ });
/* harmony import */ var _Spline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js");

class QuadraticSpline extends _Spline__WEBPACK_IMPORTED_MODULE_0__.Spline {
    getSplineCurves() {
        return [];
    }
    getLineSegments() {
        return [];
    }
    getPreviewCurveSegments(controlPointPreview, closeSpline) {
        return [];
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Spline: () => (/* binding */ Spline),
/* harmony export */   "default": () => (/* binding */ Spline)
/* harmony export */ });
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");

class Spline {
    constructor(props) {
        this._controlPoints = [];
        this._invalidated = false;
        this._length = 0;
        this._controlPoints = [];
        this._resolution = props?.resolution ?? 20;
        this._fixedResolution = props?.fixedResolution ?? false;
        this._closed = props?.closed ?? false;
        this._invalidated = true;
    }
    get controlPoints() {
        return this._controlPoints;
    }
    get numControlPoints() {
        return this._controlPoints.length;
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        if (this._fixedResolution || this._resolution === resolution) {
            return;
        }
        this._resolution = resolution;
        this.invalidated = true;
    }
    get fixedResolution() {
        return this._fixedResolution;
    }
    get closed() {
        return this._closed;
    }
    set closed(closed) {
        if (this._closed === closed) {
            return;
        }
        this._closed = closed;
        this.invalidated = true;
    }
    get aabb() {
        this._update();
        return this._aabb;
    }
    get length() {
        this._update();
        return this._length;
    }
    get invalidated() {
        return this._invalidated;
    }
    set invalidated(invalidated) {
        this._invalidated = invalidated;
    }
    hasTangentPoints() {
        return false;
    }
    addControlPoint(point) {
        this._controlPoints.push([point[0], point[1]]);
        this.invalidated = true;
    }
    addControlPoints(points) {
        points.forEach((point) => this.addControlPoint(point));
    }
    addControlPointAtU(u) {
        const lineSegment = this._getLineSegmentAt(u);
        const { start: startPoint, end: endPoint } = lineSegment.points;
        const curveSegmentIndex = Math.floor(u);
        const curveSegment = this._curveSegments[curveSegmentIndex];
        const t = u - Math.floor(curveSegmentIndex);
        const controlPointPos = [
            startPoint[0] + t * (endPoint[0] - startPoint[0]),
            startPoint[1] + t * (endPoint[1] - startPoint[1]),
        ];
        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;
        this._controlPoints.splice(insertIndex, 0, controlPointPos);
        this.invalidated = true;
        return {
            index: insertIndex,
            point: controlPointPos,
        };
    }
    deleteControlPointByIndex(index) {
        const minControlPoints = this._closed ? 3 : 1;
        const canDelete = index >= 0 &&
            index < this._controlPoints.length &&
            this._controlPoints.length > minControlPoints;
        if (!canDelete) {
            return false;
        }
        this._controlPoints.splice(index, 1);
        this.invalidated = true;
        return true;
    }
    clearControlPoints() {
        this._controlPoints = [];
        this.invalidated = true;
    }
    setControlPoints(points) {
        this.clearControlPoints();
        this.addControlPoints(points);
    }
    updateControlPoint(index, newControlPoint) {
        if (index < 0 || index >= this._controlPoints.length) {
            throw new Error('Index out of bounds');
        }
        this._controlPoints[index] = [...newControlPoint];
        this.invalidated = true;
    }
    getControlPoints() {
        return this._controlPoints.map((controlPoint) => [
            controlPoint[0],
            controlPoint[1],
        ]);
    }
    getClosestControlPoint(point) {
        const controlPoints = this._controlPoints;
        let minSquaredDist = Infinity;
        let closestPointIndex = -1;
        for (let i = 0, len = controlPoints.length; i < len; i++) {
            const controlPoint = controlPoints[i];
            const dx = point[0] - controlPoint[0];
            const dy = point[1] - controlPoint[1];
            const squaredDist = dx * dx + dy * dy;
            if (squaredDist < minSquaredDist) {
                minSquaredDist = squaredDist;
                closestPointIndex = i;
            }
        }
        return {
            index: closestPointIndex,
            point: closestPointIndex === -1
                ? undefined
                : [...controlPoints[closestPointIndex]],
            distance: Math.sqrt(minSquaredDist),
        };
    }
    getClosestControlPointWithinDistance(point, maxDist) {
        const closestControlPoint = this.getClosestControlPoint(point);
        return closestControlPoint.distance <= maxDist
            ? closestControlPoint
            : undefined;
    }
    getClosestPoint(point) {
        this._update();
        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);
        if (!curveSegmentsDistInfo.length) {
            return;
        }
        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);
        let closestPoint;
        let closestPointCurveSegmentIndex = -1;
        let minDistSquared = Infinity;
        let minDistCurveSegment;
        let minDistLineSegment;
        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {
            const curveSegmentDistInfo = curveSegmentsDistInfo[i];
            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {
                continue;
            }
            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;
            const { lineSegments } = curveSegment;
            for (let j = 0; j < lineSegments.length; j++) {
                const lineSegment = lineSegments[j];
                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);
                if (lineSegDistSquared < minDistSquared) {
                    minDistLineSegment = lineSegment;
                    closestPointCurveSegmentIndex = curveSegmentIndex;
                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;
                    closestPoint = lineSegPoint;
                    minDistSquared = lineSegDistSquared;
                }
            }
        }
        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +
            _utilities_math__WEBPACK_IMPORTED_MODULE_0__.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);
        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;
        const u = closestPointCurveSegmentIndex + t;
        return {
            point: closestPoint,
            uValue: u,
            distance: Math.sqrt(minDistSquared),
        };
    }
    getClosestPointOnControlPointLines(point) {
        const linePoints = [...this._controlPoints];
        if (this._closed) {
            linePoints.push(this._controlPoints[0]);
        }
        if (!linePoints.length) {
            return;
        }
        let closestPoint;
        let minDistSquared = Infinity;
        let startPoint = linePoints[0];
        for (let i = 1, len = linePoints.length; i < len; i++) {
            const endPoint = linePoints[i];
            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);
            if (lineSegDistSquared < minDistSquared) {
                closestPoint = lineSegPoint;
                minDistSquared = lineSegDistSquared;
            }
            startPoint = endPoint;
        }
        return {
            point: closestPoint,
            distance: Math.sqrt(minDistSquared),
        };
    }
    getPolylinePoints() {
        this._update();
        return this._convertCurveSegmentsToPolyline(this._curveSegments);
    }
    getPreviewPolylinePoints(controlPointPreview, closeDistance) {
        if (this._closed) {
            return [];
        }
        this._update();
        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);
        const closeSpline = closestControlPoint?.index === 0;
        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);
        return previewCurveSegments?.length
            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)
            : [];
    }
    isPointNearCurve(point, maxDist) {
        this._update();
        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);
        const maxDistSquared = maxDist * maxDist;
        for (let i = 0; i < curveSegments.length; i++) {
            const { lineSegments } = curveSegments[i];
            for (let j = 0; j < lineSegments.length; j++) {
                const lineSegment = lineSegments[j];
                const lineDistSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);
                if (lineDistSquared <= maxDistSquared) {
                    return true;
                }
            }
        }
        return false;
    }
    containsPoint(point) {
        this._update();
        const controlPoints = this._controlPoints;
        if (controlPoints.length < 3) {
            return false;
        }
        const curveSegments = [...this._curveSegments];
        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();
        if (closingCurveSegment) {
            curveSegments.push(closingCurveSegment);
        }
        let numIntersections = 0;
        for (let i = 0; i < curveSegments.length; i++) {
            const curveSegment = curveSegments[i];
            const { aabb: curveSegAABB } = curveSegment;
            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&
                point[1] >= curveSegAABB.minY &&
                point[1] < curveSegAABB.maxY;
            if (!mayIntersectCurveSegment) {
                continue;
            }
            const { lineSegments } = curveSegment;
            for (let i = 0; i < lineSegments.length; i++) {
                const lineSegment = lineSegments[i];
                const { aabb: lineSegmentAABB } = lineSegment;
                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&
                    point[1] >= lineSegmentAABB.minY &&
                    point[1] < lineSegmentAABB.maxY;
                if (mayIntersectLineSegment) {
                    const { start: p1, end: p2 } = lineSegment.points;
                    const isVerticalLine = p1[0] === p2[0];
                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];
                    numIntersections +=
                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;
                }
            }
        }
        return numIntersections % 2 === 1;
    }
    _update() {
        if (!this._invalidated) {
            return;
        }
        const curveSegments = this.getSplineCurves();
        let length = 0;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0, len = curveSegments.length; i < len; i++) {
            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];
            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;
            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;
            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;
            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;
            length += curveSegLength;
        }
        this._curveSegments = curveSegments;
        this._aabb = { minX, minY, maxX, maxY };
        this._length = length;
        this._invalidated = false;
    }
    _convertCurveSegmentsToPolyline(curveSegments) {
        this._update();
        const polylinePoints = [];
        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {
            lineSegments.forEach((lineSegment, lineSegIndex) => {
                if (curveSegIndex === 0 && lineSegIndex === 0) {
                    polylinePoints.push([...lineSegment.points.start]);
                }
                polylinePoints.push([...lineSegment.points.end]);
            });
        });
        return polylinePoints;
    }
    _getCurveSegmmentsDistanceSquaredInfo(point) {
        this._update();
        const curveSegmentsDistanceSquared = [];
        const { _curveSegments: curveSegments } = this;
        for (let i = 0; i < curveSegments.length; i++) {
            const curveSegment = curveSegments[i];
            const distanceSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.aabb.distanceToPointSquared(curveSegment.aabb, point);
            curveSegmentsDistanceSquared.push({
                curveSegmentIndex: i,
                curveSegment,
                distanceSquared,
            });
        }
        return curveSegmentsDistanceSquared;
    }
    _getCurveSegmmentsWithinDistance(point, maxDist) {
        this._update();
        const maxDistSquared = maxDist * maxDist;
        if (_utilities_math__WEBPACK_IMPORTED_MODULE_0__.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {
            return [];
        }
        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);
        const curveSegmentsWithinRange = [];
        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {
            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];
            if (curveSegmentDistSquared <= maxDistSquared) {
                curveSegmentsWithinRange.push(curveSegment);
            }
        }
        return curveSegmentsWithinRange;
    }
    _getLineSegmentAt(u) {
        this._update();
        const curveSegmentIndex = Math.floor(u);
        const t = u - curveSegmentIndex;
        const curveSegment = this._curveSegments[curveSegmentIndex];
        const { lineSegments } = curveSegment;
        const pointLength = curveSegment.length * t;
        for (let i = 0; i < lineSegments.length; i++) {
            const lineSegment = lineSegments[i];
            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;
            if (pointLength >= lineSegment.previousLineSegmentsLength &&
                pointLength <= lengthEnd) {
                return lineSegment;
            }
        }
    }
    _getClosingCurveSegmentWithStraightLineSegment() {
        if (this.closed) {
            return;
        }
        const controlPoints = this._controlPoints;
        const startControlPoint = controlPoints[0];
        const endControlPoint = controlPoints[controlPoints.length - 1];
        const closingLineSegment = {
            points: {
                start: [...startControlPoint],
                end: [...endControlPoint],
            },
            aabb: {
                minX: Math.min(startControlPoint[0], endControlPoint[0]),
                minY: Math.min(startControlPoint[1], endControlPoint[1]),
                maxX: Math.max(startControlPoint[0], endControlPoint[0]),
                maxY: Math.max(startControlPoint[1], endControlPoint[1]),
            },
        };
        return {
            aabb: {
                minX: closingLineSegment.aabb.minX,
                minY: closingLineSegment.aabb.minY,
                maxX: closingLineSegment.aabb.maxX,
                maxY: closingLineSegment.aabb.maxY,
            },
            lineSegments: [closingLineSegment],
        };
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/index.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BSpline: () => (/* reexport safe */ _BSpline__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   CardinalSpline: () => (/* reexport safe */ _CardinalSpline__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   CatmullRomSpline: () => (/* reexport safe */ _CatmullRomSpline__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   CubicSpline: () => (/* reexport safe */ _CubicSpline__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   LinearSpline: () => (/* reexport safe */ _LinearSpline__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   QuadraticBezier: () => (/* reexport safe */ _QuadraticBezier__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   QuadraticSpline: () => (/* reexport safe */ _QuadraticSpline__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   Spline: () => (/* reexport safe */ _Spline__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _BSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js");
/* harmony import */ var _CardinalSpline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CardinalSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js");
/* harmony import */ var _CatmullRomSpline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CatmullRomSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js");
/* harmony import */ var _CubicSpline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CubicSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js");
/* harmony import */ var _LinearSpline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LinearSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js");
/* harmony import */ var _QuadraticBezier__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./QuadraticBezier */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js");
/* harmony import */ var _QuadraticSpline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./QuadraticSpline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js");
/* harmony import */ var _Spline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Spline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js");











/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _utilities_segmentation_growCut_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/segmentation/growCut/constants */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/constants.js");
/* harmony import */ var _utilities_segmentation_getSVGStyleForSegment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/segmentation/getSVGStyleForSegment */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js");
/* harmony import */ var _utilities_segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/segmentation/islandRemoval */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js");
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");










const { transformWorldToIndex, transformIndexToWorld } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class GrowCutBaseTool extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseTool {
    static { this.lastGrowCutCommand = null; }
    constructor(toolProps, defaultToolProps) {
        const baseToolProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge({
            configuration: {
                positiveStdDevMultiplier: _utilities_segmentation_growCut_constants__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_POSITIVE_STD_DEV_MULTIPLIER,
                shrinkExpandIncrement: 0.1,
                islandRemoval: {
                    enabled: false,
                },
            },
        }, defaultToolProps);
        super(toolProps, baseToolProps);
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const { viewUp } = viewport.getCamera();
        const { segmentationId, segmentIndex, labelmapVolumeId, referencedVolumeId, } = await this.getLabelmapSegmentationData(viewport);
        if (!this._isOrthogonalView(viewport, referencedVolumeId)) {
            throw new Error('Oblique view is not supported yet');
        }
        this.growCutData = {
            metadata: {
                ...viewport.getViewReference({ points: [worldPoint] }),
                viewUp,
            },
            segmentation: {
                segmentationId,
                segmentIndex,
                labelmapVolumeId,
                referencedVolumeId,
            },
            viewportId: viewport.id,
            renderingEngineId: renderingEngine.id,
        };
        evt.preventDefault();
        return true;
    }
    shrink() {
        this._runLastCommand({
            shrinkExpandAmount: -this.configuration.shrinkExpandIncrement,
        });
    }
    expand() {
        this._runLastCommand({
            shrinkExpandAmount: this.configuration.shrinkExpandIncrement,
        });
    }
    refresh() {
        this._runLastCommand();
    }
    async getGrowCutLabelmap(_growCutData) {
        throw new Error('Not implemented');
    }
    async runGrowCut() {
        const { growCutData, configuration: config } = this;
        const { segmentation: { segmentationId, segmentIndex, labelmapVolumeId }, } = growCutData;
        const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(labelmapVolumeId);
        let shrinkExpandAccumulator = 0;
        const growCutCommand = async ({ shrinkExpandAmount = 0 } = {}) => {
            if (shrinkExpandAmount !== 0) {
                this.seeds = null;
            }
            shrinkExpandAccumulator += shrinkExpandAmount;
            const newPositiveStdDevMultiplier = Math.max(0.1, config.positiveStdDevMultiplier + shrinkExpandAccumulator);
            const negativeSeedMargin = shrinkExpandAmount < 0
                ? Math.max(1, _utilities_segmentation_growCut_constants__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_NEGATIVE_SEED_MARGIN -
                    Math.abs(shrinkExpandAccumulator) * 3)
                : _utilities_segmentation_growCut_constants__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_NEGATIVE_SEED_MARGIN + shrinkExpandAccumulator * 3;
            const updatedGrowCutData = {
                ...growCutData,
                options: {
                    ...(growCutData.options || {}),
                    positiveSeedValue: segmentIndex,
                    negativeSeedValue: 255,
                    positiveStdDevMultiplier: newPositiveStdDevMultiplier,
                    negativeSeedMargin,
                },
            };
            const growcutLabelmap = await this.getGrowCutLabelmap(updatedGrowCutData);
            const { isPartialVolume } = config;
            const fn = isPartialVolume
                ? this.applyPartialGrowCutLabelmap
                : this.applyGrowCutLabelmap;
            fn(segmentationId, segmentIndex, labelmap, growcutLabelmap);
            this._removeIslands(updatedGrowCutData);
        };
        await growCutCommand();
        GrowCutBaseTool.lastGrowCutCommand = growCutCommand;
        this.growCutData = null;
    }
    applyPartialGrowCutLabelmap(segmentationId, segmentIndex, targetLabelmap, sourceLabelmap) {
        const srcLabelmapData = sourceLabelmap.voxelManager.getCompleteScalarDataArray();
        const tgtVoxelManager = targetLabelmap.voxelManager;
        const [srcColumns, srcRows, srcNumSlices] = sourceLabelmap.dimensions;
        const [tgtColumns, tgtRows] = targetLabelmap.dimensions;
        const srcPixelsPerSlice = srcColumns * srcRows;
        const tgtPixelsPerSlice = tgtColumns * tgtRows;
        for (let srcSlice = 0; srcSlice < srcNumSlices; srcSlice++) {
            for (let srcRow = 0; srcRow < srcRows; srcRow++) {
                const srcRowIJK = [0, srcRow, srcSlice];
                const rowVoxelWorld = transformIndexToWorld(sourceLabelmap.imageData, srcRowIJK);
                const tgtRowIJK = transformWorldToIndex(targetLabelmap.imageData, rowVoxelWorld);
                const [tgtColumn, tgtRow, tgtSlice] = tgtRowIJK;
                const srcOffset = srcRow * srcColumns + srcSlice * srcPixelsPerSlice;
                const tgtOffset = tgtColumn + tgtRow * tgtColumns + tgtSlice * tgtPixelsPerSlice;
                for (let column = 0; column < srcColumns; column++) {
                    const labelmapValue = srcLabelmapData[srcOffset + column] === segmentIndex
                        ? segmentIndex
                        : 0;
                    tgtVoxelManager.setAtIndex(tgtOffset + column, labelmapValue);
                }
            }
        }
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationDataModified)(segmentationId);
    }
    applyGrowCutLabelmap(segmentationId, segmentIndex, targetLabelmap, sourceLabelmap) {
        const tgtVoxelManager = targetLabelmap.voxelManager;
        const srcVoxelManager = sourceLabelmap.voxelManager;
        srcVoxelManager.forEach(({ value, index }) => {
            if (value === segmentIndex) {
                tgtVoxelManager.setAtIndex(index, value);
            }
        });
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationDataModified)(segmentationId);
    }
    _runLastCommand({ shrinkExpandAmount = 0 } = {}) {
        const cmd = GrowCutBaseTool.lastGrowCutCommand;
        if (cmd) {
            cmd({ shrinkExpandAmount });
        }
    }
    async getLabelmapSegmentationData(viewport) {
        const activeSeg = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_3__.activeSegmentation.getActiveSegmentation(viewport.id);
        if (!activeSeg) {
            throw new Error('No active segmentation found');
        }
        const { segmentationId } = activeSeg;
        const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_3__.segmentIndex.getActiveSegmentIndex(segmentationId);
        const { representationData } = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_3__.state.getSegmentation(segmentationId);
        const labelmapData = representationData[_enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap];
        let { volumeId: labelmapVolumeId, referencedVolumeId } = labelmapData;
        if (!labelmapVolumeId) {
            const referencedImageIds = viewport.getImageIds();
            if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds)) {
                const currentImageId = viewport.getCurrentImageId();
                const currentImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(currentImageId);
                const fakeImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoader.createAndCacheDerivedImage(currentImageId);
                const fakeVolume = this._createFakeVolume([
                    currentImage.imageId,
                    fakeImage.imageId,
                ]);
                referencedVolumeId = fakeVolume.volumeId;
                const currentLabelmapImageId = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_9__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                const fakeDerivedImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoader.createAndCacheDerivedImage(currentLabelmapImageId);
                const fakeLabelmapVolume = this._createFakeVolume([
                    currentLabelmapImageId,
                    fakeDerivedImage.imageId,
                ]);
                labelmapVolumeId = fakeLabelmapVolume.volumeId;
            }
            else {
                const segVolume = (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_8__.getOrCreateSegmentationVolume)(segmentationId);
                labelmapVolumeId = segVolume.volumeId;
            }
        }
        if (!referencedVolumeId) {
            const { imageIds: segImageIds } = labelmapData;
            const referencedImageIds = segImageIds.map((imageId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId).referencedImageId);
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(referencedImageIds);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            referencedVolumeId = imageVolume
                ? imageVolume.volumeId
                : (await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds)).volumeId;
        }
        return {
            segmentationId,
            segmentIndex,
            labelmapVolumeId,
            referencedVolumeId,
        };
    }
    _createFakeVolume(imageIds) {
        const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(imageIds);
        const cachedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (cachedVolume) {
            return cachedVolume;
        }
        const volumeProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.generateVolumePropsFromImageIds(imageIds, volumeId);
        const spacing = volumeProps.spacing;
        if (spacing[2] === 0) {
            spacing[2] = 1;
        }
        const derivedVolume = new _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.ImageVolume({
            volumeId,
            dataType: volumeProps.dataType,
            metadata: structuredClone(volumeProps.metadata),
            dimensions: volumeProps.dimensions,
            spacing: volumeProps.spacing,
            origin: volumeProps.origin,
            direction: volumeProps.direction,
            referencedVolumeId: volumeProps.referencedVolumeId,
            imageIds: volumeProps.imageIds,
            referencedImageIds: volumeProps.referencedImageIds,
        });
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.putVolumeSync(volumeId, derivedVolume);
        return derivedVolume;
    }
    _isOrthogonalView(viewport, referencedVolumeId) {
        const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
        const volumeImageData = volume.imageData;
        const camera = viewport.getCamera();
        const { ijkVecColDir, ijkVecSliceDir } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeDirectionVectors(volumeImageData, camera);
        return [ijkVecColDir, ijkVecSliceDir].every((vec) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(Math.abs(vec[0]), 1) ||
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(Math.abs(vec[1]), 1) ||
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(Math.abs(vec[2]), 1));
    }
    getRemoveIslandData(_growCutData) {
        return;
    }
    _removeIslands(growCutData) {
        const { islandRemoval: config } = this.configuration;
        if (!config.enabled) {
            return;
        }
        const { segmentation: { segmentIndex, labelmapVolumeId }, renderingEngineId, viewportId, } = growCutData;
        const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(labelmapVolumeId);
        const removeIslandData = this.getRemoveIslandData(growCutData);
        if (!removeIslandData) {
            return;
        }
        const [width, height] = labelmap.dimensions;
        const numPixelsPerSlice = width * height;
        const { worldIslandPoints = [], islandPointIndexes = [] } = removeIslandData;
        let ijkIslandPoints = [...(removeIslandData?.ijkIslandPoints ?? [])];
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const { voxelManager } = labelmap;
        const islandRemoval = new _utilities_segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_7__["default"]();
        ijkIslandPoints = ijkIslandPoints.concat(worldIslandPoints.map((worldPoint) => transformWorldToIndex(labelmap.imageData, worldPoint)));
        ijkIslandPoints = ijkIslandPoints.concat(islandPointIndexes.map((pointIndex) => {
            const x = pointIndex % width;
            const y = Math.floor(pointIndex / width) % height;
            const z = Math.floor(pointIndex / numPixelsPerSlice);
            return [x, y, z];
        }));
        islandRemoval.initialize(viewport, voxelManager, {
            points: ijkIslandPoints,
            previewSegmentIndex: segmentIndex,
            segmentIndex,
        });
        islandRemoval.floodFillSegmentIsland();
        islandRemoval.removeExternalIslands();
        islandRemoval.removeInternalIslands();
    }
    getSegmentStyle({ segmentationId, viewportId, segmentIndex }) {
        return (0,_utilities_segmentation_getSVGStyleForSegment__WEBPACK_IMPORTED_MODULE_6__.getSVGStyleForSegment)({
            segmentationId,
            segmentIndex,
            viewportId,
        });
    }
}
GrowCutBaseTool.toolName = 'GrowCutBaseTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GrowCutBaseTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distancePointToContour: () => (/* binding */ distancePointToContour)
/* harmony export */ });
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");

const distancePointToContour = (viewport, annotation, coords) => {
    if (!annotation?.data?.contour?.polyline?.length) {
        return;
    }
    const { polyline } = annotation.data.contour;
    const { length } = polyline;
    let distance = Infinity;
    for (let i = 0; i < length; i++) {
        const canvasPoint = viewport.worldToCanvas(polyline[i]);
        const distanceToPoint = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.point.distanceToPoint(canvasPoint, coords);
        distance = Math.min(distance, distanceToPoint);
    }
    if (distance === Infinity || isNaN(distance)) {
        return;
    }
    return distance;
};


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/index.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdvancedMagnifyTool: () => (/* reexport safe */ _AdvancedMagnifyTool__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   AngleTool: () => (/* reexport safe */ _annotation_AngleTool__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   AnnotationDisplayTool: () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationDisplayTool),
/* harmony export */   AnnotationTool: () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool),
/* harmony export */   ArrowAnnotateTool: () => (/* reexport safe */ _annotation_ArrowAnnotateTool__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   BaseTool: () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.BaseTool),
/* harmony export */   BidirectionalTool: () => (/* reexport safe */ _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   BrushTool: () => (/* reexport safe */ _segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_51__["default"]),
/* harmony export */   CircleROIStartEndThresholdTool: () => (/* reexport safe */ _segmentation_CircleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_50__["default"]),
/* harmony export */   CircleROITool: () => (/* reexport safe */ _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   CircleScissorsTool: () => (/* reexport safe */ _segmentation_CircleScissorsTool__WEBPACK_IMPORTED_MODULE_46__["default"]),
/* harmony export */   CobbAngleTool: () => (/* reexport safe */ _annotation_CobbAngleTool__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   CrosshairsTool: () => (/* reexport safe */ _CrosshairsTool__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   DragProbeTool: () => (/* reexport safe */ _annotation_DragProbeTool__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   ETDRSGridTool: () => (/* reexport safe */ _annotation_ETDRSGridTool__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   EllipticalROITool: () => (/* reexport safe */ _annotation_EllipticalROITool__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   EraserTool: () => (/* reexport safe */ _AnnotationEraserTool__WEBPACK_IMPORTED_MODULE_40__["default"]),
/* harmony export */   HeightTool: () => (/* reexport safe */ _annotation_HeightTool__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   KeyImageTool: () => (/* reexport safe */ _annotation_KeyImageTool__WEBPACK_IMPORTED_MODULE_39__["default"]),
/* harmony export */   LabelTool: () => (/* reexport safe */ _annotation_LabelTool__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   LabelmapBaseTool: () => (/* reexport safe */ _segmentation_LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_44__["default"]),
/* harmony export */   LengthTool: () => (/* reexport safe */ _annotation_LengthTool__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   LivewireContourSegmentationTool: () => (/* reexport safe */ _annotation_LivewireContourSegmentationTool__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   LivewireContourTool: () => (/* reexport safe */ _annotation_LivewireContourTool__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   MIPJumpToClickTool: () => (/* reexport safe */ _MIPJumpToClickTool__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   MagnifyTool: () => (/* reexport safe */ _MagnifyTool__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   OrientationMarkerTool: () => (/* reexport safe */ _OrientationMarkerTool__WEBPACK_IMPORTED_MODULE_53__["default"]),
/* harmony export */   OverlayGridTool: () => (/* reexport safe */ _OverlayGridTool__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   PaintFillTool: () => (/* reexport safe */ _segmentation_PaintFillTool__WEBPACK_IMPORTED_MODULE_52__["default"]),
/* harmony export */   PanTool: () => (/* reexport safe */ _PanTool__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   PlanarFreehandContourSegmentationTool: () => (/* reexport safe */ _annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   PlanarFreehandROITool: () => (/* reexport safe */ _annotation_PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   PlanarRotateTool: () => (/* reexport safe */ _PlanarRotateTool__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   ProbeTool: () => (/* reexport safe */ _annotation_ProbeTool__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   RectangleROIStartEndThresholdTool: () => (/* reexport safe */ _segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_49__["default"]),
/* harmony export */   RectangleROIThresholdTool: () => (/* reexport safe */ _segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_48__["default"]),
/* harmony export */   RectangleROITool: () => (/* reexport safe */ _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   RectangleScissorsTool: () => (/* reexport safe */ _segmentation_RectangleScissorsTool__WEBPACK_IMPORTED_MODULE_45__["default"]),
/* harmony export */   ReferenceCursors: () => (/* reexport safe */ _ReferenceCursors__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   ReferenceLinesTool: () => (/* reexport safe */ _ReferenceLinesTool__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   RegionSegmentPlusTool: () => (/* reexport safe */ _annotation_RegionSegmentPlusTool__WEBPACK_IMPORTED_MODULE_42__["default"]),
/* harmony export */   RegionSegmentTool: () => (/* reexport safe */ _annotation_RegionSegmentTool__WEBPACK_IMPORTED_MODULE_41__["default"]),
/* harmony export */   ScaleOverlayTool: () => (/* reexport safe */ _ScaleOverlayTool__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   SculptorTool: () => (/* reexport safe */ _SculptorTool__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   SegmentBidirectionalTool: () => (/* reexport safe */ _segmentation_SegmentBidirectionalTool__WEBPACK_IMPORTED_MODULE_55__["default"]),
/* harmony export */   SegmentLabelTool: () => (/* reexport safe */ _segmentation_SegmentLabelTool__WEBPACK_IMPORTED_MODULE_57__["default"]),
/* harmony export */   SegmentSelectTool: () => (/* reexport safe */ _segmentation_SegmentSelectTool__WEBPACK_IMPORTED_MODULE_54__["default"]),
/* harmony export */   SegmentationIntersectionTool: () => (/* reexport safe */ _SegmentationIntersectionTool__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   SphereScissorsTool: () => (/* reexport safe */ _segmentation_SphereScissorsTool__WEBPACK_IMPORTED_MODULE_47__["default"]),
/* harmony export */   SplineContourSegmentationTool: () => (/* reexport safe */ _annotation_SplineContourSegmentationTool__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   SplineROITool: () => (/* reexport safe */ _annotation_SplineROITool__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   StackScrollTool: () => (/* reexport safe */ _StackScrollTool__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   TrackballRotateTool: () => (/* reexport safe */ _TrackballRotateTool__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   UltrasoundDirectionalTool: () => (/* reexport safe */ _annotation_UltrasoundDirectionalTool__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   VolumeRotateTool: () => (/* reexport safe */ _VolumeRotateTool__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   WholeBodySegmentTool: () => (/* reexport safe */ _annotation_WholeBodySegmentTool__WEBPACK_IMPORTED_MODULE_43__["default"]),
/* harmony export */   WindowLevelRegionTool: () => (/* reexport safe */ _WindowLevelRegionTool__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   WindowLevelTool: () => (/* reexport safe */ _WindowLevelTool__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   ZoomTool: () => (/* reexport safe */ _ZoomTool__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   strategies: () => (/* reexport module object */ _segmentation_strategies__WEBPACK_IMPORTED_MODULE_56__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _PanTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PanTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js");
/* harmony import */ var _TrackballRotateTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrackballRotateTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js");
/* harmony import */ var _WindowLevelTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WindowLevelTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js");
/* harmony import */ var _WindowLevelRegionTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WindowLevelRegionTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js");
/* harmony import */ var _StackScrollTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./StackScrollTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js");
/* harmony import */ var _PlanarRotateTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PlanarRotateTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js");
/* harmony import */ var _ZoomTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ZoomTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js");
/* harmony import */ var _MIPJumpToClickTool__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MIPJumpToClickTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js");
/* harmony import */ var _CrosshairsTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CrosshairsTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js");
/* harmony import */ var _MagnifyTool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MagnifyTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js");
/* harmony import */ var _AdvancedMagnifyTool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./AdvancedMagnifyTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js");
/* harmony import */ var _ReferenceLinesTool__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ReferenceLinesTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js");
/* harmony import */ var _OverlayGridTool__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./OverlayGridTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js");
/* harmony import */ var _SegmentationIntersectionTool__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./SegmentationIntersectionTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js");
/* harmony import */ var _ReferenceCursors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ReferenceCursors */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js");
/* harmony import */ var _ScaleOverlayTool__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ScaleOverlayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js");
/* harmony import */ var _SculptorTool__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./SculptorTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js");
/* harmony import */ var _VolumeRotateTool__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./VolumeRotateTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js");
/* harmony import */ var _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./annotation/BidirectionalTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js");
/* harmony import */ var _annotation_LabelTool__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./annotation/LabelTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js");
/* harmony import */ var _annotation_LengthTool__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./annotation/LengthTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js");
/* harmony import */ var _annotation_HeightTool__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./annotation/HeightTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js");
/* harmony import */ var _annotation_ProbeTool__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./annotation/ProbeTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js");
/* harmony import */ var _annotation_DragProbeTool__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./annotation/DragProbeTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js");
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./annotation/RectangleROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js");
/* harmony import */ var _annotation_EllipticalROITool__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./annotation/EllipticalROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js");
/* harmony import */ var _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./annotation/CircleROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js");
/* harmony import */ var _annotation_ETDRSGridTool__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./annotation/ETDRSGridTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js");
/* harmony import */ var _annotation_SplineROITool__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./annotation/SplineROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js");
/* harmony import */ var _annotation_SplineContourSegmentationTool__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./annotation/SplineContourSegmentationTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js");
/* harmony import */ var _annotation_PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./annotation/PlanarFreehandROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js");
/* harmony import */ var _annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./annotation/PlanarFreehandContourSegmentationTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js");
/* harmony import */ var _annotation_LivewireContourTool__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./annotation/LivewireContourTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js");
/* harmony import */ var _annotation_LivewireContourSegmentationTool__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./annotation/LivewireContourSegmentationTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js");
/* harmony import */ var _annotation_ArrowAnnotateTool__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./annotation/ArrowAnnotateTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js");
/* harmony import */ var _annotation_AngleTool__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./annotation/AngleTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js");
/* harmony import */ var _annotation_CobbAngleTool__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./annotation/CobbAngleTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js");
/* harmony import */ var _annotation_UltrasoundDirectionalTool__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./annotation/UltrasoundDirectionalTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js");
/* harmony import */ var _annotation_KeyImageTool__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./annotation/KeyImageTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js");
/* harmony import */ var _AnnotationEraserTool__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./AnnotationEraserTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js");
/* harmony import */ var _annotation_RegionSegmentTool__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./annotation/RegionSegmentTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js");
/* harmony import */ var _annotation_RegionSegmentPlusTool__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./annotation/RegionSegmentPlusTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js");
/* harmony import */ var _annotation_WholeBodySegmentTool__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./annotation/WholeBodySegmentTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js");
/* harmony import */ var _segmentation_LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./segmentation/LabelmapBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js");
/* harmony import */ var _segmentation_RectangleScissorsTool__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./segmentation/RectangleScissorsTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js");
/* harmony import */ var _segmentation_CircleScissorsTool__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./segmentation/CircleScissorsTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js");
/* harmony import */ var _segmentation_SphereScissorsTool__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./segmentation/SphereScissorsTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js");
/* harmony import */ var _segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./segmentation/RectangleROIThresholdTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js");
/* harmony import */ var _segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./segmentation/RectangleROIStartEndThresholdTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js");
/* harmony import */ var _segmentation_CircleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./segmentation/CircleROIStartEndThresholdTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js");
/* harmony import */ var _segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./segmentation/BrushTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js");
/* harmony import */ var _segmentation_PaintFillTool__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./segmentation/PaintFillTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js");
/* harmony import */ var _OrientationMarkerTool__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./OrientationMarkerTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js");
/* harmony import */ var _segmentation_SegmentSelectTool__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./segmentation/SegmentSelectTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js");
/* harmony import */ var _segmentation_SegmentBidirectionalTool__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./segmentation/SegmentBidirectionalTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js");
/* harmony import */ var _segmentation_strategies__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./segmentation/strategies */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js");
/* harmony import */ var _segmentation_SegmentLabelTool__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./segmentation/SegmentLabelTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js");





























































/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/planar/getWorldWidthAndHeightFromTwoPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _utilities_debounce__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/debounce */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../annotation/CircleROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js");
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/math/circle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/viewport/isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/math/ellipse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js");
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities/math/basic */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js");
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../utilities/planar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js");
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../utilities/getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");






















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class CircleROIStartEndThresholdTool extends _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_14__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            numSlicesToPropagate: 10,
            calculatePointsInsideVolume: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
            showTextBox: false,
            throttleTimeout: 100,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    volumeId,
                    spacingInNormal,
                    enabledElement,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                    },
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        statistics: [],
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__.triggerAnnotationCompleted)(annotation);
            }
            else {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__.triggerAnnotationModified)(annotation, element);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_20__.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data, metadata } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_15__.getCanvasCircleRadius)(canvasCoordinates);
                const { centerPointRadius } = this.configuration;
                const canvasCorners = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_15__.getCanvasCircleCorners)(canvasCoordinates);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let tempStartCoordinate = startCoordinate;
                let tempEndCoordinate = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);
                    data.startCoordinate = tempStartCoordinate;
                }
                if (Array.isArray(endCoordinate)) {
                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);
                    data.endCoordinate = tempEndCoordinate;
                }
                const roundedStartCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(data.startCoordinate);
                const roundedEndCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(data.endCoordinate);
                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCameraCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(cameraCoordinate);
                if (roundedCameraCoordinate <
                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||
                    roundedCameraCoordinate >
                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {
                    continue;
                }
                const middleCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);
                let isMiddleSlice = false;
                if (roundedCameraCoordinate === middleCoordinate) {
                    isMiddleSlice = true;
                }
                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;
                if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    isMiddleSlice) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineWidthToUse = lineWidth;
                let lineDashToUse = lineDash;
                if (isMiddleSlice) {
                    lineWidthToUse = lineWidth;
                    lineDashToUse = [];
                }
                else {
                    lineDashToUse = [5, 5];
                }
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth: lineWidthToUse,
                });
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                if (this.configuration.showTextBox) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data, { metadata });
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    let canvasTextBoxCoords;
                    if (!data.handles.textBox.hasMoved) {
                        canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_7__.getTextBoxCoordsCanvas)(canvasCorners);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        if (this.configuration.calculatePointsInsideVolume) {
            this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_8__["default"])(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });
        }
        else {
            this._throttledCalculateCachedStats = (0,_utilities_debounce__WEBPACK_IMPORTED_MODULE_9__["default"])(this._calculateCachedStatsTool, this.configuration.throttleTimeout);
        }
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { imageData } = imageVolume;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const startIJK = transformWorldToIndex(imageData, points[0]);
        const endIJK = transformWorldToIndex(imageData, points[0]);
        const handlesToStart = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(points);
        const startWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        imageData.indexToWorldVec3(startIJK, startWorld);
        const endWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        imageData.indexToWorldVec3(endIJK, endWorld);
        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
            startWorld[2] = startCoordinate;
            endWorld[2] = endCoordinate;
            handlesToStart[0][2] = startCoordinate;
            handlesToStart[1][2] = startCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
            startWorld[0] = startCoordinate;
            endWorld[0] = endCoordinate;
            handlesToStart[0][0] = startCoordinate;
            handlesToStart[1][0] = startCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
            startWorld[1] = startCoordinate;
            endWorld[1] = endCoordinate;
            handlesToStart[0][1] = startCoordinate;
            handlesToStart[1][1] = startCoordinate;
        }
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(startWorld, endWorld);
        const newProjectionPoints = [];
        for (let dist = 0; dist < distance; dist += spacingInNormal) {
            newProjectionPoints.push(handlesToStart.map((point) => {
                const newPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_15__.getCanvasCircleCorners)(canvasCoordinates));
        const pos1 = viewport.canvasToWorld(topLeftCanvas);
        const pos2 = viewport.canvasToWorld(bottomRightCanvas);
        const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_6__["default"])(viewPlaneNormal, viewUp, pos1, pos2);
        const measureInfo = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_16__.getCalibratedLengthUnitsAndScale)(image, data.handles);
        const aspect = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_16__.getCalibratedAspect)(image);
        const area = Math.abs(Math.PI *
            (worldWidth / measureInfo.scale / 2) *
            (worldHeight / aspect / measureInfo.scale / 2));
        const modalityUnitOptions = {
            isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_17__.isViewportPreScaled)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_21__.getPixelValueUnits)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const centerWorld = projectionPoints[i][0];
            const canvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));
            const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_15__.getCanvasCircleCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const center = centerWorld;
                const ellipseObj = {
                    center,
                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                };
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    isInObject: (pointLPS) => (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_18__.pointInEllipse)(ellipseObj, pointLPS),
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
        annotation.invalidated = false;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__.triggerAnnotationModified)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);
        const startPos = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);
        const endPos = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function defaultGetTextLines(data, _context = {}) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
CircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleROIStartEndThresholdTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strategies/fillCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js");
/* harmony import */ var _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategies/eraseCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LabelmapBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js");











class CircleScissorsTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_2__.fillInsideCircle,
                ERASE_INSIDE: _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_3__.eraseInsideCircle,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_9__.getSegmentation)(segmentationId);
            const labelmapData = representationData.Labelmap;
            if (!labelmapData) {
                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');
            }
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    isDrawing: true,
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_9__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                viewPlaneNormal,
                viewUp,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
CircleScissorsTool.toolName = 'CircleScissor';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleScissorsTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js");
/* harmony import */ var _utilities_segmentation_floodFill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/segmentation/floodFill */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");







const { transformWorldToIndex, isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class PaintFillTool extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const { viewPlaneNormal } = camera;
            const activeSegmentationRepresentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_6__.getSegmentation)(segmentationId);
            let dimensions;
            let direction;
            let index;
            let voxelManager;
            this.doneEditMemo();
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
                const { volumeId } = representationData[_enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap];
                const segmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                ({ dimensions, direction } = segmentation);
                voxelManager = segmentation.voxelManager;
                index = transformWorldToIndex(segmentation.imageData, worldPos);
            }
            else {
                const currentSegmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_6__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                if (!currentSegmentationImageId) {
                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');
                }
                const { imageData } = viewport.getImageData();
                dimensions = imageData.getDimensions();
                direction = imageData.getDirection();
                const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(currentSegmentationImageId);
                voxelManager = image.voxelManager;
                index = transformWorldToIndex(imageData, worldPos);
            }
            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);
            if (fixedDimension === undefined) {
                console.warn('Oblique paint fill not yet supported');
                return;
            }
            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);
            if (index[0] < 0 ||
                index[0] >= dimensions[0] ||
                index[1] < 0 ||
                index[1] >= dimensions[1] ||
                index[2] < 0 ||
                index[2] >= dimensions[2]) {
                return;
            }
            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);
            if (segmentsLocked.includes(clickedLabelValue)) {
                return;
            }
            const floodFillResult = (0,_utilities_segmentation_floodFill__WEBPACK_IMPORTED_MODULE_5__["default"])(floodFillGetter, inPlaneSeedPoint);
            const { flooded } = floodFillResult;
            flooded.forEach((index) => {
                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);
                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);
            });
            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);
            (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationDataModified)(segmentationId, framesModified);
            return true;
        };
        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {
            const { flooded: boundaries } = floodFillResult;
            if (fixedDimension === 2) {
                return [fixedDimensionValue];
            }
            let minJ = Infinity;
            let maxJ = -Infinity;
            for (let b = 0; b < boundaries.length; b++) {
                const j = boundaries[b][1];
                if (j < minJ) {
                    minJ = j;
                }
                if (j > maxJ) {
                    maxJ = j;
                }
            }
            const framesModified = [];
            for (let frame = minJ; frame <= maxJ; frame++) {
                framesModified.push(frame);
            }
            return framesModified;
        };
        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {
            let fixedDimensionValue;
            let inPlaneSeedPoint;
            switch (fixedDimension) {
                case 0:
                    fixedDimensionValue = seedIndex3D[0];
                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];
                    break;
                case 1:
                    fixedDimensionValue = seedIndex3D[1];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];
                    break;
                case 2:
                    fixedDimensionValue = seedIndex3D[2];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            const getScalarDataPosition = (x, y, z) => {
                return voxelManager.toIndex([x, y, z]);
            };
            const getLabelValue = (x, y, z) => {
                return voxelManager.getAtIJK(x, y, z);
            };
            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);
            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);
            return {
                getScalarDataPositionFromPlane,
                getLabelValue,
                floodFillGetter,
                inPlaneSeedPoint,
                fixedDimensionValue,
            };
        };
        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {
            let floodFillGetter;
            switch (fixedDimension) {
                case 0:
                    floodFillGetter = (y, z) => {
                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    floodFillGetter = (x, z) => {
                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    floodFillGetter = (x, y) => {
                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {
                            return;
                        }
                        return getLabelValue(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return floodFillGetter;
        };
        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {
            let getScalarDataPositionFromPlane;
            switch (fixedDimension) {
                case 0:
                    getScalarDataPositionFromPlane = (y, z) => {
                        return getScalarDataPosition(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    getScalarDataPositionFromPlane = (x, z) => {
                        return getScalarDataPosition(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    getScalarDataPositionFromPlane = (x, y) => {
                        return getScalarDataPosition(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return getScalarDataPositionFromPlane;
        };
    }
    getFixedDimension(viewPlaneNormal, direction) {
        const xDirection = direction.slice(0, 3);
        const yDirection = direction.slice(3, 6);
        const zDirection = direction.slice(6, 9);
        const absoluteOfViewPlaneNormal = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const absoluteOfXDirection = [
            Math.abs(xDirection[0]),
            Math.abs(xDirection[1]),
            Math.abs(xDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {
            return 0;
        }
        const absoluteOfYDirection = [
            Math.abs(yDirection[0]),
            Math.abs(yDirection[1]),
            Math.abs(yDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {
            return 1;
        }
        const absoluteOfZDirection = [
            Math.abs(zDirection[0]),
            Math.abs(zDirection[1]),
            Math.abs(zDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {
            return 2;
        }
    }
}
PaintFillTool.toolName = 'PaintFill';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PaintFillTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _strategies_fillRectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strategies/fillRectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js");
/* harmony import */ var _strategies_eraseRectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategies/eraseRectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../stateManagement/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LabelmapBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js");












class RectangleScissorsTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_11__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: _strategies_fillRectangle__WEBPACK_IMPORTED_MODULE_2__.fillInsideRectangle,
                ERASE_INSIDE: _strategies_eraseRectangle__WEBPACK_IMPORTED_MODULE_3__.eraseInsideRectangle,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_10__.getSegmentation)(segmentationId);
            const labelmapData = representationData[_enums__WEBPACK_IMPORTED_MODULE_5__.SegmentationRepresentations.Labelmap];
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                },
            };
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_10__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            points[handleIndex] = [...worldPos];
            let bottomLeftCanvas;
            let bottomRightCanvas;
            let topLeftCanvas;
            let topRightCanvas;
            let bottomLeftWorld;
            let bottomRightWorld;
            let topLeftWorld;
            let topRightWorld;
            switch (handleIndex) {
                case 0:
                case 3:
                    bottomLeftCanvas = worldToCanvas(points[0]);
                    topRightCanvas = worldToCanvas(points[3]);
                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                    bottomRightWorld = canvasToWorld(bottomRightCanvas);
                    topLeftWorld = canvasToWorld(topLeftCanvas);
                    points[1] = bottomRightWorld;
                    points[2] = topLeftWorld;
                    break;
                case 1:
                case 2:
                    bottomRightCanvas = worldToCanvas(points[1]);
                    topLeftCanvas = worldToCanvas(points[2]);
                    bottomLeftCanvas = [
                        topLeftCanvas[0],
                        bottomRightCanvas[1],
                    ];
                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];
                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                    topRightWorld = canvasToWorld(topRightCanvas);
                    points[0] = bottomLeftWorld;
                    points[3] = topRightWorld;
                    break;
            }
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const rectangleUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
RectangleScissorsTool.toolName = 'RectangleScissor';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleScissorsTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../annotation/BidirectionalTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js");
/* harmony import */ var _stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../stateManagement/segmentation/config/segmentationColor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js");











class SegmentBidirectionalTool extends _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_9__["default"] {
    static { this.toolName = 'SegmentBidirectional'; }
    constructor(toolProps = {}) {
        super(toolProps);
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = true;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const viewportId = viewport.id;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { segmentIndex, segmentationId } = annotation.metadata;
                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const colorArray = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_10__.getSegmentIndexColor)(viewportId, segmentationId, segmentIndex);
                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        width: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId1 = `${annotationUID}-line-1`;
                const dataId2 = `${annotationUID}-line-2`;
                const lineUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    lineWidth,
                    lineDash,
                    shadow,
                }, dataId1);
                const secondLineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
                    color,
                    lineWidth,
                    lineDash,
                    shadow,
                }, dataId2);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                options.color = color;
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_6__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const worldPos = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const annotation = {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID,
                referencedImageId,
                ...viewport.getViewReference({ points: [worldPos] }),
            },
            data: {
                handles: {
                    points: [
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                    ],
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex: 1,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
        };
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__.hideElementCursor)(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
        return annotation;
    }
    static { this.hydrate = (viewportId, axis, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const existingAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAllAnnotations)();
        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');
        const existingAnnotation = toolAnnotations.find((annotation) => {
            const { metadata } = annotation;
            if (metadata.segmentIndex === options?.segmentIndex &&
                metadata.segmentationId === options?.segmentationId) {
                return true;
            }
            return false;
        });
        if (existingAnnotation) {
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.removeAnnotation)(existingAnnotation.annotationUID);
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);
        const [majorAxis, minorAxis] = axis;
        const [major0, major1] = majorAxis;
        const [minor0, minor1] = minorAxis;
        const points = [major0, major1, minor0, minor1];
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                segmentIndex: options?.segmentIndex,
                segmentationId: options?.segmentationId,
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])([viewport.id]);
        return annotation;
    }; }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentBidirectionalTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation/activeSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js");
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");








class SegmentLabelTool extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseTool {
    constructor(toolProps = {
        data: {
            handles: {
                textBox: {
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
            },
        },
    }, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setHoveredSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.data = toolProps.data ?? {
            handles: {
                textBox: {
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
            },
        };
        this.hoverTimer = null;
    }
    _setHoveredSegment(evt = {}) {
        if (_store_state__WEBPACK_IMPORTED_MODULE_6__.state.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            return;
        }
        this._setHoveredSegmentForType(activeSegmentation, worldPoint, viewport);
    }
    _setHoveredSegmentForType(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId } = activeSegmentation;
        const hoveredSegmentIndex = (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_5__.getSegmentIndexAtWorldPoint)(segmentationId, worldPoint, {
            viewport,
        });
        const segment = activeSegmentation.segments[hoveredSegmentIndex];
        const label = segment?.label;
        const canvasCoordinates = viewport.worldToCanvas(worldPoint);
        this._editData = {
            hoveredSegmentIndex,
            hoveredSegmentLabel: label,
            canvasCoordinates,
            worldPoint,
        };
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationModified)(segmentationId);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportIds);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this._editData) {
            return;
        }
        const { viewport } = enabledElement;
        const { hoveredSegmentIndex, hoveredSegmentLabel, canvasCoordinates, worldPoint, } = this._editData;
        if (!hoveredSegmentIndex) {
            return;
        }
        const textBoxPosition = viewport.worldToCanvas(worldPoint);
        const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLinkedTextBox)(svgDrawingHelper, 'segmentSelectLabelAnnotation', 'segmentSelectLabelTextBox', [hoveredSegmentLabel ? hoveredSegmentLabel : '(unnamed segment)'], textBoxPosition, [canvasCoordinates], {}, {});
        const left = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const { width, height } = boundingBox;
        this.data.handles.textBox.worldBoundingBox = {
            topLeft: viewport.canvasToWorld([left, top]),
            topRight: viewport.canvasToWorld([left + width, top]),
            bottomLeft: viewport.canvasToWorld([left, top + height]),
            bottomRight: viewport.canvasToWorld([left + width, top + height]),
        };
    }
}
SegmentLabelTool.toolName = 'SegmentLabelTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentLabelTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation/activeSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_segmentIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js");
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");









class SegmentSelectTool extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseTool {
    static { this.SelectMode = {
        Inside: 'Inside',
        Border: 'Border',
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            mode: SegmentSelectTool.SelectMode.Border,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.mode !== _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Active) {
                return;
            }
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setActiveSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.hoverTimer = null;
    }
    _setActiveSegment(evt = {}) {
        if (_store_state__WEBPACK_IMPORTED_MODULE_7__.state.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            return;
        }
        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);
    }
    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId, representationData } = activeSegmentation;
        let hoveredSegmentIndex;
        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {
            hoveredSegmentIndex = (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.getSegmentIndexAtWorldPoint)(segmentationId, worldPoint, {
                viewport,
            });
        }
        else {
            if (representationData.Labelmap) {
                hoveredSegmentIndex = (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.getSegmentIndexAtLabelmapBorder)(segmentationId, worldPoint, {
                    viewport,
                    searchRadius: this.configuration.searchRadius,
                });
            }
            else if (representationData.Contour) {
                hoveredSegmentIndex =
                    (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.getHoveredContourSegmentationAnnotation)(segmentationId);
            }
            else if (representationData.Surface) {
            }
        }
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        (0,_stateManagement_segmentation_segmentIndex__WEBPACK_IMPORTED_MODULE_5__.setActiveSegmentIndex)(segmentationId, hoveredSegmentIndex);
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationModified)(segmentationId);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportIds);
    }
}
SegmentSelectTool.toolName = 'SegmentSelectTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentSelectTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strategies/fillSphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js");
/* harmony import */ var _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strategies/eraseSphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LabelmapBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js");










class SphereScissorsTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_9__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_1__.fillInsideSphere,
                ERASE_INSIDE: _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_2__.eraseInsideSphere,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            this.doneEditMemo();
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeSegmentationRepresentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            this.isDrawing = true;
            const annotation = {
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    invalidated: true,
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    highlighted: true,
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                toolGroupId: this.toolGroupId,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_8__.getSegmentation)(segmentationId);
            const editData = this.getEditData({
                viewport,
                representationData,
                segmentsLocked,
                segmentationId,
            });
            this.editData = {
                ...this.editData,
                ...editData,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__["default"])(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__["default"])(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                segmentIndex,
                segmentsLocked,
                viewPlaneNormal,
                viewUp,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
SphereScissorsTool.toolName = 'SphereScissor';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SphereScissorsTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eraseInsideRectangle: () => (/* binding */ eraseInsideRectangle),
/* harmony export */   eraseOutsideRectangle: () => (/* binding */ eraseOutsideRectangle)
/* harmony export */ });
/* harmony import */ var _fillRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fillRectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js");

function eraseRectangle(enabledElement, operationData, inside = true) {
    const eraseOperationData = Object.assign({}, operationData, {
        segmentIndex: 0,
    });
    (0,_fillRectangle__WEBPACK_IMPORTED_MODULE_0__.fillInsideRectangle)(enabledElement, eraseOperationData);
}
function eraseInsideRectangle(enabledElement, operationData) {
    eraseRectangle(enabledElement, operationData, true);
}
function eraseOutsideRectangle(enabledElement, operationData) {
    eraseRectangle(enabledElement, operationData, false);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/index.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/types/index.js ***!
  \**************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/AnnotationMultiSlice.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/AnnotationMultiSlice.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnnotationMultiSlice)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");



class AnnotationMultiSlice {
    static setStartRange(viewport, annotation, startRange = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, startRange);
    }
    static setEndRange(viewport, annotation, endRange = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, undefined, endRange);
    }
    static setRange(viewport, annotation, startRange, endRange) {
        const { metadata } = annotation;
        if (startRange === undefined) {
            startRange = metadata.sliceIndex < endRange ? metadata.sliceIndex : 0;
            if (endRange === undefined) {
                endRange = viewport.getNumberOfSlices() - 1;
            }
        }
        const rangeEndSliceIndex = viewport.getSliceIndexForImage(metadata.multiSliceReference);
        if (endRange === undefined) {
            endRange =
                rangeEndSliceIndex >= startRange
                    ? rangeEndSliceIndex
                    : viewport.getNumberOfSlices() - 1;
        }
        endRange = Math.max(startRange, endRange);
        metadata.sliceIndex = Math.min(startRange, endRange);
        metadata.referencedImageId = viewport.getCurrentImageId(metadata.sliceIndex);
        metadata.referencedImageURI = undefined;
        if (endRange === metadata.sliceIndex) {
            metadata.multiSliceReference = undefined;
        }
        else if (endRange !== metadata.multiSliceReference?.sliceIndex) {
            metadata.multiSliceReference = {
                referencedImageId: viewport.getCurrentImageId(endRange),
                sliceIndex: endRange,
            };
        }
        const eventDetail = {
            viewportId: viewport.id,
            renderingEngineId: viewport.renderingEngineId,
            changeType: _enums__WEBPACK_IMPORTED_MODULE_2__.ChangeTypes.MetadataReferenceModified,
            annotation,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_MODIFIED, eventDetail);
        this.setViewportFrameRange(viewport, metadata);
    }
    static setSingle(viewport, annotation, current = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, current, current);
    }
    static getFrameRange(annotation) {
        const { metadata } = annotation;
        const { sliceIndex, multiSliceReference } = metadata;
        const rangeEndSliceIndex = multiSliceReference?.sliceIndex;
        return rangeEndSliceIndex
            ? [sliceIndex + 1, rangeEndSliceIndex + 1]
            : sliceIndex + 1;
    }
    static getFrameRangeStr(annotation) {
        const range = this.getFrameRange(annotation);
        return Array.isArray(range) ? `${range[0]}-${range[1]}` : String(range);
    }
    static setViewportFrameRange(viewport, specifier) {
        if (viewport.setFrameRange && specifier.multiSliceReference?.sliceIndex) {
            viewport.setFrameRange(specifier.sliceIndex + 1, specifier.multiSliceReference.sliceIndex + 1);
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/BucketQueue.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/BucketQueue.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BucketQueue: () => (/* binding */ BucketQueue)
/* harmony export */ });
class BucketQueue {
    constructor({ numBits, getPriority, areEqual, }) {
        this._bucketCount = 1 << numBits;
        this._mask = this._bucketCount - 1;
        this._size = 0;
        this._currentBucketIndex = 0;
        this._buckets = this._buildArray(this._bucketCount);
        this._getPriority =
            typeof getPriority !== 'undefined'
                ? getPriority
                : (item) => item;
        this._areEqual =
            typeof areEqual === 'function'
                ? areEqual
                : (itemA, itemB) => itemA === itemB;
    }
    push(item) {
        const bucketIndex = this._getBucketIndex(item);
        const oldHead = this._buckets[bucketIndex];
        const newHead = {
            value: item,
            next: oldHead,
        };
        this._buckets[bucketIndex] = newHead;
        this._size++;
    }
    pop() {
        if (this._size === 0) {
            throw new Error('Cannot pop because the queue is empty.');
        }
        while (this._buckets[this._currentBucketIndex] === null) {
            this._currentBucketIndex =
                (this._currentBucketIndex + 1) % this._bucketCount;
        }
        const ret = this._buckets[this._currentBucketIndex];
        this._buckets[this._currentBucketIndex] = ret.next;
        this._size--;
        return ret.value;
    }
    remove(item) {
        if (!item) {
            return false;
        }
        const bucketIndex = this._getBucketIndex(item);
        const firstBucketNode = this._buckets[bucketIndex];
        let node = firstBucketNode;
        let prevNode;
        while (node !== null) {
            if (this._areEqual(item, node.value)) {
                break;
            }
            prevNode = node;
            node = node.next;
        }
        if (node === null) {
            return false;
        }
        if (node === firstBucketNode) {
            this._buckets[bucketIndex] = node.next;
        }
        else {
            prevNode.next = node.next;
        }
        this._size--;
        return true;
    }
    isEmpty() {
        return this._size === 0;
    }
    _getBucketIndex(item) {
        return this._getPriority(item) & this._mask;
    }
    _buildArray(size) {
        const buckets = new Array(size);
        buckets.fill(null);
        return buckets;
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ calibrateImageSpacing)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const { calibratedPixelSpacingMetadataProvider } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {
    if (typeof calibrationOrScale === 'number') {
        calibrationOrScale = {
            type: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.CalibrationTypes.USER,
            scale: calibrationOrScale,
        };
    }
    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);
    const viewports = renderingEngine.getStackViewports();
    viewports.forEach((viewport) => {
        const imageIds = viewport.getImageIds();
        if (imageIds.includes(imageId)) {
            viewport.calibrateSpacing(imageId);
        }
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["CLIP_STOPPED"] = "CORNERSTONE_CINE_TOOL_STOPPED";
    Events["CLIP_STARTED"] = "CORNERSTONE_CINE_TOOL_STARTED";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/index.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Events: () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   addToolState: () => (/* reexport safe */ _state__WEBPACK_IMPORTED_MODULE_2__.addToolState),
/* harmony export */   getToolState: () => (/* reexport safe */ _state__WEBPACK_IMPORTED_MODULE_2__.getToolState),
/* harmony export */   playClip: () => (/* reexport safe */ _playClip__WEBPACK_IMPORTED_MODULE_0__.playClip),
/* harmony export */   stopClip: () => (/* reexport safe */ _playClip__WEBPACK_IMPORTED_MODULE_0__.stopClip)
/* harmony export */ });
/* harmony import */ var _playClip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./playClip */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   playClip: () => (/* binding */ playClip),
/* harmony export */   stopClip: () => (/* binding */ stopClip)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js");




const { ViewportStatus } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums;
const { triggerEvent } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const debounced = true;
const dynamicVolumesPlayingMap = new Map();
function playClip(element, playClipOptions) {
    let playClipTimeouts;
    let playClipIsTimeVarying;
    if (element === undefined) {
        throw new Error('playClip: element must not be undefined');
    }
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    if (!enabledElement) {
        throw new Error('playClip: element must be a valid Cornerstone enabled element');
    }
    if (!playClipOptions) {
        playClipOptions = {};
    }
    playClipOptions.dynamicCineEnabled =
        playClipOptions.dynamicCineEnabled ?? true;
    const { viewport } = enabledElement;
    const playClipContext = _createCinePlayContext(viewport, playClipOptions);
    let playClipData = (0,_state__WEBPACK_IMPORTED_MODULE_3__.getToolState)(element);
    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;
    if (isDynamicCinePlaying) {
        _stopDynamicVolumeCine(element);
    }
    if (!playClipData) {
        playClipData = {
            intervalId: undefined,
            framesPerSecond: 30,
            lastFrameTimeStamp: undefined,
            ignoreFrameTimeVector: false,
            usingFrameTimeVector: false,
            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,
            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,
            reverse: playClipOptions.reverse ?? false,
            loop: playClipOptions.loop ?? true,
            bounce: playClipOptions.bounce ?? false,
        };
        (0,_state__WEBPACK_IMPORTED_MODULE_3__.addToolState)(element, playClipData);
    }
    else {
        _stopClip(element, {
            stopDynamicCine: !isDynamicCinePlaying,
            viewportId: viewport.id,
        });
    }
    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;
    if (playClipOptions.framesPerSecond < 0 ||
        playClipOptions.framesPerSecond > 0) {
        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);
        playClipData.reverse = playClipData.framesPerSecond < 0;
        playClipData.ignoreFrameTimeVector = true;
    }
    if (playClipData.ignoreFrameTimeVector !== true &&
        playClipData.frameTimeVector &&
        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&
        playClipContext.frameTimeVectorEnabled) {
        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);
        playClipTimeouts = timeouts;
        playClipIsTimeVarying = isTimeVarying;
    }
    if (playClipOptions.bounce !== undefined) {
        playClipData.bounce = playClipOptions.bounce;
    }
    const playClipAction = () => {
        const { numScrollSteps, currentStepIndex } = playClipContext;
        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);
        const outOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;
        if (outOfRange) {
            if (playClipData.bounce) {
                playClipData.reverse = !playClipData.reverse;
                newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);
                newStepIndex = Math.max(0, Math.min(numScrollSteps - 1, newStepIndex));
            }
            else if (!playClipData.loop) {
                _stopClip(element, {
                    stopDynamicCine: !isDynamicCinePlaying,
                    viewportId: viewport.id,
                });
                triggerEvent(element, _events__WEBPACK_IMPORTED_MODULE_2__["default"].CLIP_STOPPED, { element });
                return;
            }
            else {
                newStepIndex = playClipData.reverse ? numScrollSteps - 1 : 0;
            }
        }
        const delta = newStepIndex - currentStepIndex;
        if (delta) {
            try {
                playClipContext.scroll(delta);
            }
            catch (e) {
                console.warn('Play clip not scrolling', e);
                _stopClipWithData(playClipData);
                triggerEvent(element, _events__WEBPACK_IMPORTED_MODULE_2__["default"].CLIP_STOPPED, { element });
            }
        }
    };
    if (isDynamicCinePlaying) {
        const volume = _getVolumeFromViewport(viewport);
        if (volume) {
            dynamicVolumesPlayingMap.set(volume.volumeId, element);
        }
    }
    if (playClipContext.play) {
        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);
    }
    else if (playClipTimeouts &&
        playClipTimeouts.length > 0 &&
        playClipIsTimeVarying) {
        playClipData.usingFrameTimeVector = true;
        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {
            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);
            playClipAction();
        }, 0);
    }
    else {
        playClipData.usingFrameTimeVector = false;
        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));
    }
    const eventDetail = {
        element,
    };
    triggerEvent(element, _events__WEBPACK_IMPORTED_MODULE_2__["default"].CLIP_STARTED, eventDetail);
}
function stopClip(element, options = {}) {
    _stopClip(element, {
        stopDynamicCine: true,
        ...options,
    });
}
function _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {
    const { stopDynamicCine, viewportId } = options;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    let toolState;
    const viewport = enabledElement?.viewport;
    if (!enabledElement) {
        if (viewportId) {
            toolState = (0,_state__WEBPACK_IMPORTED_MODULE_3__.getToolStateByViewportId)(viewportId);
        }
        else {
            return;
        }
    }
    else {
        const { viewport } = enabledElement;
        toolState = (0,_state__WEBPACK_IMPORTED_MODULE_3__.getToolState)(viewport.element);
    }
    if (toolState) {
        _stopClipWithData(toolState);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VideoViewport) {
        viewport.pause();
    }
    else if (stopDynamicCine && viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.BaseVolumeViewport) {
        _stopDynamicVolumeCine(element);
    }
}
function _stopDynamicVolumeCine(element) {
    const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
        const volume = _getVolumeFromViewport(viewport);
        if (volume?.isDynamicVolume()) {
            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);
            dynamicVolumesPlayingMap.delete(volume.volumeId);
            if (dynamicCineElement && dynamicCineElement !== element) {
                stopClip(dynamicCineElement);
            }
        }
    }
}
function _getPlayClipTimeouts(vector, speed) {
    let i;
    let sample;
    let delay;
    let sum = 0;
    const limit = vector.length;
    const timeouts = [];
    let isTimeVarying = false;
    if (typeof speed !== 'number' || speed <= 0) {
        speed = 1;
    }
    for (i = 1; i < limit; i++) {
        delay = (Number(vector[i]) / speed) | 0;
        timeouts.push(delay);
        if (i === 1) {
            sample = delay;
        }
        else if (delay !== sample) {
            isTimeVarying = true;
        }
        sum += delay;
    }
    if (timeouts.length > 0) {
        if (isTimeVarying) {
            delay = (sum / timeouts.length) | 0;
        }
        else {
            delay = timeouts[0];
        }
        timeouts.push(delay);
    }
    return { timeouts, isTimeVarying };
}
function _stopClipWithData(playClipData) {
    const id = playClipData.intervalId;
    if (typeof id !== 'undefined') {
        playClipData.intervalId = undefined;
        if (playClipData.usingFrameTimeVector) {
            clearTimeout(id);
        }
        else {
            clearInterval(id);
        }
    }
}
function _getVolumeFromViewport(viewport) {
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport)) {
        return undefined;
    }
    const volumeIds = viewport.getAllVolumeIds();
    if (!volumeIds?.length) {
        return undefined;
    }
    const dynamicVolumeId = volumeIds.find((volumeId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId)?.isDynamicVolume());
    const volumeId = dynamicVolumeId ?? volumeIds[0];
    return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
}
function _createStackViewportCinePlayContext(viewport, waitForRendered) {
    const imageIds = viewport.getImageIds();
    return {
        get numScrollSteps() {
            return imageIds.length;
        },
        get currentStepIndex() {
            return viewport.getTargetImageIdIndex();
        },
        get frameTimeVectorEnabled() {
            return true;
        },
        waitForRenderedCount: 0,
        scroll(delta) {
            if (this.waitForRenderedCount <= waitForRendered &&
                viewport.viewportStatus !== ViewportStatus.RENDERED) {
                this.waitForRenderedCount++;
                return;
            }
            this.waitForRenderedCount = 0;
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.scroll(viewport, { delta, debounceLoading: debounced });
        },
    };
}
function _createVideoViewportCinePlayContext(viewport, waitForRendered) {
    return {
        get numScrollSteps() {
            return viewport.getNumberOfSlices();
        },
        get currentStepIndex() {
            return viewport.getSliceIndex();
        },
        get frameTimeVectorEnabled() {
            return true;
        },
        waitForRenderedCount: 0,
        scroll(delta) {
            if (this.waitForRenderedCount <= waitForRendered &&
                viewport.viewportStatus !== ViewportStatus.RENDERED) {
                this.waitForRenderedCount++;
                return;
            }
            this.waitForRenderedCount = 0;
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.scroll(viewport, { delta, debounceLoading: debounced });
        },
        play(fps) {
            if (fps) {
                viewport.setPlaybackRate(fps / 24);
            }
            viewport.play();
            return viewport.getFrameRate();
        },
    };
}
function _createVolumeViewportCinePlayContext(viewport, volume) {
    const { volumeId } = volume;
    const cachedScrollInfo = {
        viewPlaneNormal: gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(),
        scrollInfo: null,
    };
    const getScrollInfo = () => {
        const camera = viewport.getCamera();
        const updateCache = !cachedScrollInfo.scrollInfo ||
            !gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);
        if (updateCache) {
            const scrollInfo = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeViewportScrollInfo(viewport, volumeId);
            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;
            cachedScrollInfo.scrollInfo = scrollInfo;
        }
        return cachedScrollInfo.scrollInfo;
    };
    return {
        get numScrollSteps() {
            return getScrollInfo().numScrollSteps;
        },
        get currentStepIndex() {
            return getScrollInfo().currentStepIndex;
        },
        get frameTimeVectorEnabled() {
            const camera = viewport.getCamera();
            const volumeViewPlaneNormal = volume.direction
                .slice(6, 9)
                .map((x) => -x);
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);
            return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.glMatrix.equals(dot, 1);
        },
        scroll(delta) {
            getScrollInfo().currentStepIndex += delta;
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.scroll(viewport, { delta });
        },
    };
}
function _createDynamicVolumeViewportCinePlayContext(volume) {
    return {
        get numScrollSteps() {
            return volume.numDimensionGroups;
        },
        get currentStepIndex() {
            return volume.dimensionGroupNumber - 1;
        },
        get frameTimeVectorEnabled() {
            return false;
        },
        scroll(delta) {
            volume.scroll(delta);
        },
    };
}
function _createCinePlayContext(viewport, playClipOptions) {
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.StackViewport) {
        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
        const volume = _getVolumeFromViewport(viewport);
        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {
            return _createDynamicVolumeViewportCinePlayContext(volume);
        }
        return _createVolumeViewportCinePlayContext(viewport, volume);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VideoViewport) {
        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
    }
    throw new Error('Unknown viewport type');
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addToolState: () => (/* binding */ addToolState),
/* harmony export */   getToolState: () => (/* binding */ getToolState),
/* harmony export */   getToolStateByViewportId: () => (/* binding */ getToolStateByViewportId)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const state = {};
function addToolState(element, data) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId } = enabledElement;
    state[viewportId] = data;
}
function getToolState(element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId } = enabledElement;
    return state[viewportId];
}
function getToolStateByViewportId(viewportId) {
    return state[viewportId];
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateImageFromTimeData: () => (/* binding */ generateImageFromTimeData),
/* harmony export */   updateVolumeFromTimeData: () => (/* binding */ updateVolumeFromTimeData)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function sumOverDimensionGroups(voxelManager, dimensionGroups) {
    const arrayLength = voxelManager.getScalarDataLength();
    const resultArray = new Float32Array(arrayLength);
    for (const dimensionGroupNumber of dimensionGroups) {
        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);
        for (let i = 0; i < arrayLength; i++) {
            resultArray[i] += scalarData[i];
        }
    }
    return resultArray;
}
function averageOverDimensionGroups(voxelManager, dimensionGroups) {
    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);
    const numDimensionGroups = dimensionGroups.length;
    for (let i = 0; i < sumArray.length; i++) {
        sumArray[i] /= numDimensionGroups;
    }
    return sumArray;
}
const operationFunctions = {
    [_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {
        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);
        for (let i = 0; i < resultArray.length; i++) {
            callback(i, resultArray[i]);
        }
    },
    [_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {
        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);
        for (let i = 0; i < resultArray.length; i++) {
            callback(i, resultArray[i]);
        }
    },
    [_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {
        if (dimensionGroups.length !== 2) {
            throw new Error('Please provide only 2 dimension groups for subtraction.');
        }
        const arrayLength = voxelManager.getScalarDataLength();
        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);
        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);
        for (let i = 0; i < arrayLength; i++) {
            const difference = scalarData1[i] - scalarData2[i];
            callback(i, difference);
        }
    },
};
function generateImageFromTimeData(dynamicVolume, operation, options) {
    const { dimensionGroupNumbers, frameNumbers } = options;
    if (frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    const dimensionGroups = dimensionGroupNumbers ||
        frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (dimensionGroups.length <= 1) {
        throw new Error('Please provide two or more dimension groups');
    }
    const voxelManager = dynamicVolume.voxelManager;
    const arrayLength = voxelManager.getScalarDataLength();
    const operationFunction = operationFunctions[operation];
    if (!operationFunction) {
        throw new Error(`Unsupported operation: ${operation}`);
    }
    const resultArray = new Float32Array(arrayLength);
    operationFunction(voxelManager, dimensionGroups, (index, value) => {
        resultArray[index] = value;
    });
    return resultArray;
}
function updateVolumeFromTimeData(dynamicVolume, operation, options) {
    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;
    if (!targetVolume) {
        throw new Error('A target volume must be provided');
    }
    if (frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    const dimensionGroups = dimensionGroupNumbers ||
        frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (dimensionGroups.length <= 1) {
        throw new Error('Please provide two or more dimension groups');
    }
    const voxelManager = dynamicVolume.voxelManager;
    const targetVoxelManager = targetVolume.voxelManager;
    const operationFunction = operationFunctions[operation];
    if (!operationFunction) {
        throw new Error(`Unsupported operation: ${operation}`);
    }
    operationFunction(voxelManager, dimensionGroups, (index, value) => {
        targetVoxelManager.setAtIndex(index, value);
    });
    targetVoxelManager.resetModifiedSlices();
    for (let k = 0; k < targetVolume.dimensions[2]; k++) {
        targetVoxelManager.modifiedSlices.add(k);
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _segmentation_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../segmentation/utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js");


function getDataInTime(dynamicVolume, options) {
    let dataInTime;
    const dimensionGroups = options.dimensionGroupNumbers ||
        options.frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (options.frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    if (!options.maskVolumeId && !options.worldCoordinate) {
        throw new Error('You should provide either maskVolumeId or imageCoordinate');
    }
    if (options.maskVolumeId && options.worldCoordinate) {
        throw new Error('You can only use one of maskVolumeId or imageCoordinate');
    }
    if (options.maskVolumeId) {
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(options.maskVolumeId);
        if (!segmentationVolume) {
            throw new Error('Segmentation volume not found');
        }
        const [dataInTime, ijkCoords] = _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume);
        return [dataInTime, ijkCoords];
    }
    if (options.worldCoordinate) {
        const dataInTime = _getDimensionGroupDataCoordinate(dimensionGroups, options.worldCoordinate, dynamicVolume);
        return dataInTime;
    }
    return dataInTime;
}
function _getDimensionGroupDataCoordinate(dimensionGroups, coordinate, volume) {
    const { dimensions, imageData } = volume;
    const index = imageData.worldToIndex(coordinate);
    index[0] = Math.floor(index[0]);
    index[1] = Math.floor(index[1]);
    index[2] = Math.floor(index[2]);
    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.indexWithinDimensions(index, dimensions)) {
        throw new Error('outside bounds');
    }
    const yMultiple = dimensions[0];
    const zMultiple = dimensions[0] * dimensions[1];
    const value = [];
    dimensionGroups.forEach((dimensionGroupNumber) => {
        const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];
        value.push(volume.voxelManager.getAtIndexAndDimensionGroup(scalarIndex, dimensionGroupNumber));
    });
    return value;
}
function _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume) {
    const { imageData: maskImageData } = segmentationVolume;
    const segVoxelManager = segmentationVolume.voxelManager;
    const scalarDataLength = segVoxelManager.getScalarDataLength();
    const nonZeroVoxelIndices = [];
    nonZeroVoxelIndices.length = scalarDataLength;
    let actualLen = 0;
    for (let i = 0, len = scalarDataLength; i < len; i++) {
        if (segVoxelManager.getAtIndex(i) !== 0) {
            nonZeroVoxelIndices[actualLen++] = i;
        }
    }
    nonZeroVoxelIndices.length = actualLen;
    const nonZeroVoxelValuesInTime = [];
    const isSameVolume = dynamicVolume.voxelManager.getScalarDataLength() === scalarDataLength &&
        JSON.stringify(dynamicVolume.spacing) ===
            JSON.stringify(segmentationVolume.spacing);
    const ijkCoords = [];
    if (isSameVolume) {
        for (let i = 0; i < nonZeroVoxelIndices.length; i++) {
            const valuesInTime = [];
            const index = nonZeroVoxelIndices[i];
            for (let j = 0; j < dimensionGroups.length; j++) {
                valuesInTime.push(dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[j]));
            }
            nonZeroVoxelValuesInTime.push(valuesInTime);
            ijkCoords.push(segVoxelManager.toIJK(index));
        }
        return [nonZeroVoxelValuesInTime, ijkCoords];
    }
    const callback = ({ pointLPS: segPointLPS, value: segValue, pointIJK: segPointIJK, }) => {
        if (segValue === 0) {
            return;
        }
        const overlapIJKMinMax = (0,_segmentation_utilities__WEBPACK_IMPORTED_MODULE_1__.getVoxelOverlap)(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);
        let count = 0;
        const perDimensionGroupSum = new Map();
        dimensionGroups.forEach((dimensionGroupNumber) => perDimensionGroupSum.set(dimensionGroupNumber, 0));
        const averageCallback = ({ index }) => {
            for (let i = 0; i < dimensionGroups.length; i++) {
                const value = dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[i]);
                const dimensionGroupNumber = dimensionGroups[i];
                perDimensionGroupSum.set(dimensionGroupNumber, perDimensionGroupSum.get(dimensionGroupNumber) + value);
            }
            count++;
        };
        dynamicVolume.voxelManager.forEach(averageCallback, {
            imageData: dynamicVolume.imageData,
            boundsIJK: overlapIJKMinMax,
        });
        const averageValues = [];
        perDimensionGroupSum.forEach((sum) => {
            averageValues.push(sum / count);
        });
        ijkCoords.push(segPointIJK);
        nonZeroVoxelValuesInTime.push(averageValues);
    };
    segmentationVolume.voxelManager.forEach(callback, {
        imageData: maskImageData,
    });
    return [nonZeroVoxelValuesInTime, ijkCoords];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getDataInTime);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateImageFromTimeData: () => (/* reexport safe */ _generateImageFromTimeData__WEBPACK_IMPORTED_MODULE_1__.generateImageFromTimeData),
/* harmony export */   getDataInTime: () => (/* reexport safe */ _getDataInTime__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   updateVolumeFromTimeData: () => (/* reexport safe */ _generateImageFromTimeData__WEBPACK_IMPORTED_MODULE_1__.updateVolumeFromTimeData)
/* harmony export */ });
/* harmony import */ var _getDataInTime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDataInTime */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js");
/* harmony import */ var _generateImageFromTimeData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateImageFromTimeData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/geometricSurfaceUtils.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/geometricSurfaceUtils.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkStandardBasis: () => (/* binding */ checkStandardBasis),
/* harmony export */   inverse3x3Matrix: () => (/* binding */ inverse3x3Matrix),
/* harmony export */   rotatePoints: () => (/* binding */ rotatePoints)
/* harmony export */ });
function validate3x3Matrix(matrix) {
    if (!Array.isArray(matrix) || matrix.length !== 9) {
        throw new Error('Matrix must be an array of 9 numbers');
    }
    if (!matrix.every((n) => typeof n === 'number' && !isNaN(n))) {
        throw new Error('Matrix must contain only valid numbers');
    }
}
function inverse3x3Matrix(matrix) {
    validate3x3Matrix(matrix);
    const mat = [
        [matrix[0], matrix[1], matrix[2]],
        [matrix[3], matrix[4], matrix[5]],
        [matrix[6], matrix[7], matrix[8]],
    ];
    const determinant = mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) -
        mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) +
        mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]);
    if (Math.abs(determinant) < 1e-10) {
        throw new Error('Matrix is not invertible (determinant is zero)');
    }
    const adjugate = [
        [
            mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1],
            -(mat[0][1] * mat[2][2] - mat[0][2] * mat[2][1]),
            mat[0][1] * mat[1][2] - mat[0][2] * mat[1][1],
        ],
        [
            -(mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]),
            mat[0][0] * mat[2][2] - mat[0][2] * mat[2][0],
            -(mat[0][0] * mat[1][2] - mat[0][2] * mat[1][0]),
        ],
        [
            mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0],
            -(mat[0][0] * mat[2][1] - mat[0][1] * mat[2][0]),
            mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0],
        ],
    ];
    const inverse = [];
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            inverse.push(adjugate[i][j] / determinant);
        }
    }
    return inverse;
}
function normalizeVector(v) {
    const magnitude = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    return v.map((component) => component / magnitude);
}
function checkStandardBasis(directions) {
    validate3x3Matrix(directions);
    const xVector = directions.slice(0, 3);
    const yVector = directions.slice(3, 6);
    const zVector = directions.slice(6, 9);
    const normalizedX = normalizeVector(xVector);
    const normalizedY = normalizeVector(yVector);
    const normalizedZ = normalizeVector(zVector);
    const standardBasis = {
        x: [1, 0, 0],
        y: [0, 1, 0],
        z: [0, 0, 1],
    };
    const epsilon = 1e-10;
    const isStandard = normalizedX.every((val, i) => Math.abs(val - standardBasis.x[i]) < epsilon) &&
        normalizedY.every((val, i) => Math.abs(val - standardBasis.y[i]) < epsilon) &&
        normalizedZ.every((val, i) => Math.abs(val - standardBasis.z[i]) < epsilon);
    const rotationMatrix = isStandard
        ? [...standardBasis.x, ...standardBasis.y, ...standardBasis.z]
        : inverse3x3Matrix([...normalizedX, ...normalizedY, ...normalizedZ]);
    return {
        isStandard,
        rotationMatrix,
    };
}
function rotatePoint(point, origin, rotationMatrix) {
    const x = point[0] - origin[0];
    const y = point[1] - origin[1];
    const z = point[2] - origin[2];
    return [
        rotationMatrix[0] * x +
            rotationMatrix[1] * y +
            rotationMatrix[2] * z +
            origin[0],
        rotationMatrix[3] * x +
            rotationMatrix[4] * y +
            rotationMatrix[5] * z +
            origin[1],
        rotationMatrix[6] * x +
            rotationMatrix[7] * y +
            rotationMatrix[8] * z +
            origin[2],
    ];
}
function rotatePoints(rotationMatrix, origin, points) {
    const rotatedPoints = [];
    for (let i = 0; i < points.length; i += 3) {
        const point = points.slice(i, i + 3);
        const rotated = rotatePoint(point, origin, rotationMatrix);
        rotatedPoints.push(...rotated);
    }
    return rotatedPoints;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAnnotationNearPoint: () => (/* binding */ getAnnotationNearPoint),
/* harmony export */   getAnnotationNearPointOnEnabledElement: () => (/* binding */ getAnnotationNearPointOnEnabledElement)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");



function getAnnotationNearPoint(element, canvasPoint, proximity = 5) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        throw new Error('getAnnotationNearPoint: enabledElement not found');
    }
    return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);
}
function getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {
    const { renderingEngineId, viewportId } = enabledElement;
    const toolGroup = _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupForViewport(viewportId, renderingEngineId);
    if (!toolGroup) {
        return null;
    }
    const { _toolInstances: tools } = toolGroup;
    for (const name in tools) {
        const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);
        if (found) {
            return found;
        }
    }
    return null;
}
function findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {
    const { viewport } = enabledElement;
    const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(tool.constructor.toolName, viewport?.element);
    const currentId = viewport?.getCurrentImageId?.();
    if (annotations?.length) {
        const { element } = enabledElement.viewport;
        for (const annotation of annotations) {
            const referencedImageId = annotation.metadata?.referencedImageId;
            if ((currentId && referencedImageId && currentId !== referencedImageId) ||
                !tool.isPointNearTool) {
                continue;
            }
            if (tool.isPointNearTool(element, annotation, point, proximity, '') ||
                tool.getHandleNearImagePoint(element, annotation, point, proximity)) {
                return annotation;
            }
        }
    }
    return null;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getVOIMultipliers.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getVOIMultipliers.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVOIMultipliers),
/* harmony export */   getVOIMultipliers: () => (/* binding */ getVOIMultipliers)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js");


const DEFAULT_MULTIPLIER = 4;
function getVOIMultipliers(viewport, volumeId, options) {
    const modality = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportModality(viewport, volumeId);
    if (modality === 'PT') {
        const { clientWidth, clientHeight } = viewport.element;
        const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);
        const isPreScaled = (0,_viewport__WEBPACK_IMPORTED_MODULE_1__.isViewportPreScaled)(viewport, volumeId);
        const { fixedPTWindowWidth = true } = options ?? {};
        const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;
        return isPreScaled
            ? [xMultiplier, ptMultiplier]
            : [xMultiplier, DEFAULT_MULTIPLIER];
    }
    return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotationMultiSlice: () => (/* reexport safe */ _AnnotationMultiSlice__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   IslandRemoval: () => (/* reexport safe */ _segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   annotationHydration: () => (/* reexport safe */ _annotationHydration__WEBPACK_IMPORTED_MODULE_14__.annotationHydration),
/* harmony export */   boundingBox: () => (/* reexport module object */ _boundingBox__WEBPACK_IMPORTED_MODULE_23__),
/* harmony export */   calibrateImageSpacing: () => (/* reexport safe */ _calibrateImageSpacing__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   cine: () => (/* reexport module object */ _cine__WEBPACK_IMPORTED_MODULE_22__),
/* harmony export */   contourSegmentation: () => (/* reexport module object */ _contourSegmentation__WEBPACK_IMPORTED_MODULE_32__),
/* harmony export */   contours: () => (/* reexport module object */ _contours__WEBPACK_IMPORTED_MODULE_15__),
/* harmony export */   debounce: () => (/* reexport safe */ _debounce__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   drawing: () => (/* reexport module object */ _drawing__WEBPACK_IMPORTED_MODULE_17__),
/* harmony export */   dynamicVolume: () => (/* reexport module object */ _dynamicVolume__WEBPACK_IMPORTED_MODULE_29__),
/* harmony export */   geometricSurfaceUtils: () => (/* reexport module object */ _geometricSurfaceUtils__WEBPACK_IMPORTED_MODULE_37__),
/* harmony export */   getAnnotationNearPoint: () => (/* reexport safe */ _getAnnotationNearPoint__WEBPACK_IMPORTED_MODULE_1__.getAnnotationNearPoint),
/* harmony export */   getAnnotationNearPointOnEnabledElement: () => (/* reexport safe */ _getAnnotationNearPoint__WEBPACK_IMPORTED_MODULE_1__.getAnnotationNearPointOnEnabledElement),
/* harmony export */   getCalibratedAspect: () => (/* reexport safe */ _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__.getCalibratedAspect),
/* harmony export */   getCalibratedLengthUnitsAndScale: () => (/* reexport safe */ _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__.getCalibratedLengthUnitsAndScale),
/* harmony export */   getCalibratedProbeUnitsAndValue: () => (/* reexport safe */ _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__.getCalibratedProbeUnitsAndValue),
/* harmony export */   getClosestImageIdForStackViewport: () => (/* reexport safe */ _annotationHydration__WEBPACK_IMPORTED_MODULE_14__.getClosestImageIdForStackViewport),
/* harmony export */   getOrCreateImageVolume: () => (/* reexport safe */ _segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_40__["default"]),
/* harmony export */   getPixelValueUnits: () => (/* reexport safe */ _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_36__.getPixelValueUnits),
/* harmony export */   getPixelValueUnitsImageId: () => (/* reexport safe */ _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_36__.getPixelValueUnitsImageId),
/* harmony export */   getSphereBoundsInfo: () => (/* reexport safe */ _getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_10__.getSphereBoundsInfo),
/* harmony export */   getViewportForAnnotation: () => (/* reexport safe */ _getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   isObject: () => (/* reexport safe */ _isObject__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   math: () => (/* reexport module object */ _math__WEBPACK_IMPORTED_MODULE_18__),
/* harmony export */   moveAnnotationToViewPlane: () => (/* reexport safe */ _moveAnnotationToViewPlane__WEBPACK_IMPORTED_MODULE_39__.moveAnnotationToViewPlane),
/* harmony export */   normalizeViewportPlane: () => (/* reexport safe */ _normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   orientation: () => (/* reexport module object */ _orientation__WEBPACK_IMPORTED_MODULE_21__),
/* harmony export */   planar: () => (/* reexport module object */ _planar__WEBPACK_IMPORTED_MODULE_19__),
/* harmony export */   planarFreehandROITool: () => (/* reexport module object */ _planarFreehandROITool__WEBPACK_IMPORTED_MODULE_24__),
/* harmony export */   pointInSurroundingSphereCallback: () => (/* reexport safe */ _pointInSurroundingSphereCallback__WEBPACK_IMPORTED_MODULE_33__.pointInSurroundingSphereCallback),
/* harmony export */   pointToString: () => (/* reexport safe */ _pointToString__WEBPACK_IMPORTED_MODULE_11__.pointToString),
/* harmony export */   polyDataUtils: () => (/* reexport module object */ _polyData_utils__WEBPACK_IMPORTED_MODULE_30__),
/* harmony export */   rectangleROITool: () => (/* reexport module object */ _rectangleROITool__WEBPACK_IMPORTED_MODULE_25__),
/* harmony export */   roundNumber: () => (/* binding */ roundNumber),
/* harmony export */   segmentation: () => (/* reexport module object */ _segmentation__WEBPACK_IMPORTED_MODULE_16__),
/* harmony export */   setAnnotationLabel: () => (/* reexport safe */ _setAnnotationLabel__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   stackContextPrefetch: () => (/* reexport safe */ _stackPrefetch__WEBPACK_IMPORTED_MODULE_26__.stackContextPrefetch),
/* harmony export */   stackPrefetch: () => (/* reexport safe */ _stackPrefetch__WEBPACK_IMPORTED_MODULE_26__.stackPrefetch),
/* harmony export */   throttle: () => (/* reexport safe */ _throttle__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   touch: () => (/* reexport module object */ _touch__WEBPACK_IMPORTED_MODULE_28__),
/* harmony export */   triggerAnnotationRender: () => (/* reexport safe */ _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   triggerAnnotationRenderForToolGroupIds: () => (/* reexport safe */ _triggerAnnotationRenderForToolGroupIds__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   triggerAnnotationRenderForViewportIds: () => (/* reexport safe */ _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   triggerEvent: () => (/* reexport safe */ _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent),
/* harmony export */   viewport: () => (/* reexport module object */ _viewport__WEBPACK_IMPORTED_MODULE_27__),
/* harmony export */   viewportFilters: () => (/* reexport module object */ _viewportFilters__WEBPACK_IMPORTED_MODULE_20__),
/* harmony export */   voi: () => (/* reexport module object */ _voi__WEBPACK_IMPORTED_MODULE_31__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _getAnnotationNearPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getAnnotationNearPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js");
/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debounce */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js");
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isObject */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js");
/* harmony import */ var _calibrateImageSpacing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./calibrateImageSpacing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js");
/* harmony import */ var _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _triggerAnnotationRenderForToolGroupIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./triggerAnnotationRenderForToolGroupIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js");
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./triggerAnnotationRender */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js");
/* harmony import */ var _getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getSphereBoundsInfo */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js");
/* harmony import */ var _pointToString__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pointToString */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js");
/* harmony import */ var _AnnotationMultiSlice__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./AnnotationMultiSlice */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/AnnotationMultiSlice.js");
/* harmony import */ var _getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./getViewportForAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js");
/* harmony import */ var _annotationHydration__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./annotationHydration */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js");
/* harmony import */ var _contours__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./contours */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js");
/* harmony import */ var _segmentation__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./segmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js");
/* harmony import */ var _drawing__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _planar__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./planar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js");
/* harmony import */ var _viewportFilters__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _orientation__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./orientation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js");
/* harmony import */ var _cine__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./cine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/index.js");
/* harmony import */ var _boundingBox__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./boundingBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js");
/* harmony import */ var _planarFreehandROITool__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./planarFreehandROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js");
/* harmony import */ var _rectangleROITool__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./rectangleROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js");
/* harmony import */ var _stackPrefetch__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./stackPrefetch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/index.js");
/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./viewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js");
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./touch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js");
/* harmony import */ var _dynamicVolume__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./dynamicVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js");
/* harmony import */ var _polyData_utils__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./polyData/utils */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js");
/* harmony import */ var _voi__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./voi */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js");
/* harmony import */ var _contourSegmentation__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");
/* harmony import */ var _pointInSurroundingSphereCallback__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./pointInSurroundingSphereCallback */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js");
/* harmony import */ var _normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./normalizeViewportPlane */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js");
/* harmony import */ var _segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./segmentation/islandRemoval */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js");
/* harmony import */ var _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");
/* harmony import */ var _geometricSurfaceUtils__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./geometricSurfaceUtils */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/geometricSurfaceUtils.js");
/* harmony import */ var _setAnnotationLabel__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./setAnnotationLabel */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js");
/* harmony import */ var _moveAnnotationToViewPlane__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./moveAnnotationToViewPlane */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/moveAnnotationToViewPlane.js");
/* harmony import */ var _segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./segmentation/getOrCreateImageVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js");


































const roundNumber = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber;










/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LivewirePath: () => (/* binding */ LivewirePath)
/* harmony export */ });
class LivewirePath {
    constructor(inputPointArray, inputControlPointIndexArray) {
        this.pointArray = inputPointArray ? inputPointArray.slice() : [];
        this._controlPointIndexes = inputControlPointIndexArray
            ? inputControlPointIndexArray.slice()
            : [];
    }
    getPoint(index) {
        return this.pointArray[index];
    }
    getLastPoint() {
        return this.pointArray[this.pointArray.length - 1];
    }
    isControlPoint(point) {
        const index = this.pointArray.indexOf(point);
        if (index !== -1) {
            return this._controlPointIndexes.indexOf(index) !== -1;
        }
        else {
            throw new Error('Error: isControlPoint called with not in list point.');
        }
    }
    addPoint(point) {
        this.pointArray.push(point);
    }
    addControlPoint(point) {
        const index = this.pointArray.indexOf(point);
        if (index !== -1) {
            this._controlPointIndexes.push(index);
        }
        else {
            throw new Error('Cannot mark a non registered point as control point.');
        }
    }
    getControlPoints() {
        return this._controlPointIndexes.map((i) => this.pointArray[i]);
    }
    getNumControlPoints() {
        return this._controlPointIndexes.length;
    }
    removeLastControlPoint() {
        if (this._controlPointIndexes.length) {
            this._controlPointIndexes.pop();
        }
    }
    getLastControlPoint() {
        if (this._controlPointIndexes.length) {
            return this.pointArray[this._controlPointIndexes[this._controlPointIndexes.length - 1]];
        }
    }
    removeLastPoints(count) {
        this.pointArray.splice(this.pointArray.length - count, count);
    }
    addPoints(newPointArray) {
        this.pointArray = this.pointArray.concat(newPointArray);
    }
    prependPath(other) {
        const otherSize = other.pointArray.length;
        const shiftedIndexArray = [];
        this.pointArray = other.pointArray.concat(this.pointArray);
        for (let i = 0; i < this._controlPointIndexes.length; ++i) {
            shiftedIndexArray[i] = this._controlPointIndexes[i] + otherSize;
        }
        this._controlPointIndexes =
            other._controlPointIndexes.concat(shiftedIndexArray);
    }
    appendPath(other) {
        this.addPoints(other.pointArray);
        other._controlPointIndexes.forEach((point) => this._controlPointIndexes.push(point));
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LivewireScissors.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LivewireScissors.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LivewireScissors: () => (/* binding */ LivewireScissors)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _BucketQueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../BucketQueue */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/BucketQueue.js");


const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const MAX_UINT32 = 4294967295;
const TWO_THIRD_PI = 2 / (3 * Math.PI);
class LivewireScissors {
    constructor(grayscalePixelData, width, height) {
        this._getPointIndex = (row, col) => {
            const { width } = this;
            return row * width + col;
        };
        this._getPointCoordinate = (index) => {
            const x = index % this.width;
            const y = Math.floor(index / this.width);
            return [x, y];
        };
        this._getPointCost = (pointIndex) => {
            return Math.round(this.searchGranularity * this.costs[pointIndex]);
        };
        const numPixels = grayscalePixelData.length;
        this.searchGranularityBits = 8;
        this.searchGranularity = 1 << this.searchGranularityBits;
        this.width = width;
        this.height = height;
        this.grayscalePixelData = grayscalePixelData;
        this.laplace = null;
        this.gradXNew = null;
        this.gradYNew = null;
        this.laplace = this._computeLaplace();
        this.gradMagnitude = this._computeGradient();
        this.gradXNew = this._computeGradientX();
        this.gradYNew = this._computeGradientY();
        this.visited = new Array(numPixels);
        this.parents = new Uint32Array(numPixels);
        this.costs = new Float32Array(numPixels);
    }
    startSearch(startPoint) {
        const startPointIndex = this._getPointIndex(startPoint[1], startPoint[0]);
        this.startPoint = null;
        this.visited.fill(false);
        this.parents.fill(MAX_UINT32);
        this.costs.fill(Infinity);
        this.priorityQueueNew = new _BucketQueue__WEBPACK_IMPORTED_MODULE_1__.BucketQueue({
            numBits: this.searchGranularityBits,
            getPriority: this._getPointCost,
        });
        this.startPoint = startPoint;
        this.costs[startPointIndex] = 0;
        this.priorityQueueNew.push(startPointIndex);
    }
    findMinNearby(testPoint, delta = 2) {
        const [x, y] = testPoint;
        const { costs } = this;
        const xRange = [
            Math.max(0, x - delta),
            Math.min(x + delta + 1, this.width),
        ];
        const yRange = [
            Math.max(0, y - delta),
            Math.min(y + delta + 1, this.height),
        ];
        let minValue = costs[this._getPointIndex(y, x)] * 0.8;
        let minPoint = testPoint;
        for (let xTest = xRange[0]; xTest < xRange[1]; xTest++) {
            for (let yTest = yRange[0]; yTest < yRange[1]; yTest++) {
                const distanceCost = 1 -
                    (Math.abs(xTest - testPoint[0]) + Math.abs(yTest - testPoint[1])) /
                        delta /
                        2;
                const weightCost = costs[this._getPointIndex(yTest, xTest)];
                const weight = weightCost * 0.8 + distanceCost * 0.2;
                if (weight < minValue) {
                    minPoint = [xTest, yTest];
                    minValue = weight;
                }
            }
        }
        return minPoint;
    }
    findPathToPoint(targetPoint) {
        if (!this.startPoint) {
            throw new Error('There is no search in progress');
        }
        const { startPoint, _getPointIndex: index, _getPointCoordinate: coord, } = this;
        const startPointIndex = index(startPoint[1], startPoint[0]);
        const targetPointIndex = index(targetPoint[1], targetPoint[0]);
        const { visited: visited, parents: parents, costs: cost, priorityQueueNew: priorityQueue, } = this;
        if (targetPointIndex === startPointIndex) {
            return [];
        }
        while (!priorityQueue.isEmpty() &&
            parents[targetPointIndex] === MAX_UINT32) {
            const pointIndex = priorityQueue.pop();
            if (visited[pointIndex]) {
                continue;
            }
            const point = coord(pointIndex);
            const neighborsPoints = this._getNeighborPoints(point);
            visited[pointIndex] = true;
            for (let i = 0, len = neighborsPoints.length; i < len; i++) {
                const neighborPoint = neighborsPoints[i];
                const neighborPointIndex = index(neighborPoint[1], neighborPoint[0]);
                const dist = this._getWeightedDistance(point, neighborPoint);
                const neighborCost = cost[pointIndex] + dist;
                if (neighborCost < cost[neighborPointIndex]) {
                    if (cost[neighborPointIndex] !== Infinity) {
                        priorityQueue.remove(neighborPointIndex);
                    }
                    cost[neighborPointIndex] = neighborCost;
                    parents[neighborPointIndex] = pointIndex;
                    priorityQueue.push(neighborPointIndex);
                }
            }
        }
        const pathPoints = [];
        let pathPointIndex = targetPointIndex;
        while (pathPointIndex !== MAX_UINT32) {
            pathPoints.push(coord(pathPointIndex));
            pathPointIndex = parents[pathPointIndex];
        }
        return pathPoints.reverse();
    }
    _getDeltaX(x, y) {
        const { grayscalePixelData: data, width } = this;
        let index = this._getPointIndex(y, x);
        if (x + 1 === width) {
            index--;
        }
        return data[index + 1] - data[index];
    }
    _getDeltaY(x, y) {
        const { grayscalePixelData: data, width, height } = this;
        let index = this._getPointIndex(y, x);
        if (y + 1 === height) {
            index -= width;
        }
        return data[index] - data[index + width];
    }
    _getGradientMagnitude(x, y) {
        const dx = this._getDeltaX(x, y);
        const dy = this._getDeltaY(x, y);
        return Math.sqrt(dx * dx + dy * dy);
    }
    _getLaplace(x, y) {
        const { grayscalePixelData: data, _getPointIndex: index } = this;
        const p02 = data[index(y - 2, x)];
        const p11 = data[index(y - 1, x - 1)];
        const p12 = data[index(y - 1, x)];
        const p13 = data[index(y - 1, x + 1)];
        const p20 = data[index(y, x - 2)];
        const p21 = data[index(y, x - 1)];
        const p22 = data[index(y, x)];
        const p23 = data[index(y, x + 1)];
        const p24 = data[index(y, x + 2)];
        const p31 = data[index(y + 1, x - 1)];
        const p32 = data[index(y + 1, x)];
        const p33 = data[index(y + 1, x + 1)];
        const p42 = data[index(y + 2, x)];
        let lap = p02;
        lap += p11 + 2 * p12 + p13;
        lap += p20 + 2 * p21 - 16 * p22 + 2 * p23 + p24;
        lap += p31 + 2 * p32 + p33;
        lap += p42;
        return lap;
    }
    _computeGradient() {
        const { width, height } = this;
        const gradient = new Float32Array(width * height);
        let pixelIndex = 0;
        let max = 0;
        let x = 0;
        let y = 0;
        for (y = 0; y < height - 1; y++) {
            for (x = 0; x < width - 1; x++) {
                gradient[pixelIndex] = this._getGradientMagnitude(x, y);
                max = Math.max(gradient[pixelIndex], max);
                pixelIndex++;
            }
            gradient[pixelIndex] = gradient[pixelIndex - 1];
            pixelIndex++;
        }
        for (let len = gradient.length; pixelIndex < len; pixelIndex++) {
            gradient[pixelIndex] = gradient[pixelIndex - width];
        }
        for (let i = 0, len = gradient.length; i < len; i++) {
            gradient[i] = 1 - gradient[i] / max;
        }
        return gradient;
    }
    _computeLaplace() {
        const { width, height, _getPointIndex: index } = this;
        const laplace = new Float32Array(width * height);
        laplace.fill(1, 0, index(2, 0));
        for (let y = 2; y < height - 2; y++) {
            laplace[index(y, 0)] = 1;
            laplace[index(y, 1)] = 1;
            for (let x = 2; x < width - 2; x++) {
                laplace[index(y, x)] = this._getLaplace(x, y) > 0.33 ? 0 : 1;
            }
            laplace[index(y, width - 2)] = 1;
            laplace[index(y, width - 1)] = 1;
        }
        laplace.fill(1, index(height - 2, 0));
        return laplace;
    }
    _computeGradientX() {
        const { width, height } = this;
        const gradX = new Float32Array(width * height);
        let pixelIndex = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                gradX[pixelIndex++] = this._getDeltaX(x, y);
            }
        }
        return gradX;
    }
    _computeGradientY() {
        const { width, height } = this;
        const gradY = new Float32Array(width * height);
        let pixelIndex = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                gradY[pixelIndex++] = this._getDeltaY(x, y);
            }
        }
        return gradY;
    }
    _getGradientUnitVector(px, py) {
        const { gradXNew, gradYNew, _getPointIndex: index } = this;
        const pointGradX = gradXNew[index(py, px)];
        const pointGradY = gradYNew[index(py, px)];
        let gradVecLen = Math.sqrt(pointGradX * pointGradX + pointGradY * pointGradY);
        gradVecLen = Math.max(gradVecLen, 1e-100);
        return [pointGradX / gradVecLen, pointGradY / gradVecLen];
    }
    _getGradientDirection(px, py, qx, qy) {
        const dgpUnitVec = this._getGradientUnitVector(px, py);
        const gdqUnitVec = this._getGradientUnitVector(qx, qy);
        let dp = dgpUnitVec[1] * (qx - px) - dgpUnitVec[0] * (qy - py);
        let dq = gdqUnitVec[1] * (qx - px) - gdqUnitVec[0] * (qy - py);
        if (dp < 0) {
            dp = -dp;
            dq = -dq;
        }
        if (px !== qx && py !== qy) {
            dp *= Math.SQRT1_2;
            dq *= Math.SQRT1_2;
        }
        dq = Math.min(Math.max(dq, -1), 1);
        const direction = TWO_THIRD_PI * (Math.acos(Math.min(dp, 1)) + Math.acos(dq));
        if (isNaN(direction) || !isFinite(direction)) {
            console.warn('Found non-direction:', px, py, qx, qy, dp, dq, direction);
            return 1;
        }
        return direction;
    }
    getCost(pointA, pointB) {
        return this._getWeightedDistance(pointA, pointB);
    }
    _getWeightedDistance(pointA, pointB) {
        const { _getPointIndex: index, width, height } = this;
        const [aX, aY] = pointA;
        const [bX, bY] = pointB;
        if (bX < 0 || bX >= width || bY < 0 || bY >= height) {
            return 1;
        }
        if (aX < 0 || aY < 0 || aX >= width || aY >= height) {
            return 0;
        }
        const bIndex = index(bY, bX);
        let gradient = this.gradMagnitude[bIndex];
        if (aX === bX || aY === bY) {
            gradient *= Math.SQRT1_2;
        }
        const laplace = this.laplace[bIndex];
        const direction = this._getGradientDirection(aX, aY, bX, bY);
        return 0.43 * gradient + 0.43 * laplace + 0.11 * direction;
    }
    _getNeighborPoints(point) {
        const { width, height } = this;
        const list = [];
        const sx = Math.max(point[0] - 1, 0);
        const sy = Math.max(point[1] - 1, 0);
        const ex = Math.min(point[0] + 1, width - 1);
        const ey = Math.min(point[1] + 1, height - 1);
        for (let y = sy; y <= ey; y++) {
            for (let x = sx; x <= ex; x++) {
                if (x !== point[0] || y !== point[1]) {
                    list.push([x, y]);
                }
            }
        }
        return list;
    }
    static createInstanceFromRawPixelData(pixelData, width, height, voiRange) {
        const numPixels = pixelData.length;
        const grayscalePixelData = new Float32Array(numPixels);
        const { lower: minPixelValue, upper: maxPixelValue } = voiRange;
        const pixelRange = maxPixelValue - minPixelValue;
        for (let i = 0, len = pixelData.length; i < len; i++) {
            grayscalePixelData[i] = Math.max(0, Math.min(1, (pixelData[i] - minPixelValue) / pixelRange));
        }
        return new LivewireScissors(grayscalePixelData, width, height);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   midPoint2: () => (/* binding */ midPoint2)
/* harmony export */ });
const midPoint = (...args) => {
    const ret = args[0].length === 2 ? [0, 0] : [0, 0, 0];
    const len = args.length;
    for (const arg of args) {
        ret[0] += arg[0] / len;
        ret[1] += arg[1] / len;
        if (ret.length === 3) {
            ret[2] += arg[2] / len;
        }
    }
    return ret;
};
const midPoint2 = midPoint;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (midPoint);



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec3/interpolateVec3.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec3/interpolateVec3.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ interpolateVec3),
/* harmony export */   interpolateVec3: () => (/* binding */ interpolateVec3)
/* harmony export */ });
const interpolateVec3 = (a, b, t) => {
    return [
        a[0] * (1 - t) + b[0] * t,
        a[1] * (1 - t) + b[1] * t,
        a[2] * (1 - t) + b[2] * t,
    ];
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/moveAnnotationToViewPlane.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/moveAnnotationToViewPlane.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   moveAnnotationToViewPlane: () => (/* binding */ moveAnnotationToViewPlane)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../../node_modules/gl-matrix/esm/vec3.js");


function moveAnnotationToViewPlane(annotation, viewport) {
    const { data } = annotation;
    const { points } = data.handles;
    const { focalPoint, viewPlaneNormal } = viewport.getCamera();
    const projectedDistance = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.dot(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.sub(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.create(), points[0], focalPoint), viewPlaneNormal);
    points.forEach((point) => {
        gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.add(point, point, gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.scale(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.create(), [-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]], projectedDistance));
    });
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        annotation.metadata.referencedImageId = viewport.getCurrentImageId();
    }
    return annotation;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOrientationStringLPS)
/* harmony export */ });
function getOrientationStringLPS(vector) {
    let orientation = '';
    const orientationX = vector[0] < 0 ? 'R' : 'L';
    const orientationY = vector[1] < 0 ? 'A' : 'P';
    const orientationZ = vector[2] < 0 ? 'F' : 'H';
    const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];
    const MIN = 0.0001;
    for (let i = 0; i < 3; i++) {
        if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {
            orientation += orientationX;
            abs[0] = 0;
        }
        else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {
            orientation += orientationY;
            abs[1] = 0;
        }
        else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {
            orientation += orientationZ;
            abs[2] = 0;
        }
        else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {
            orientation += orientationX + orientationY;
            abs[0] = 0;
            abs[1] = 0;
        }
        else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {
            orientation += orientationX + orientationZ;
            abs[0] = 0;
            abs[2] = 0;
        }
        else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {
            orientation += orientationY + orientationZ;
            abs[1] = 0;
            abs[2] = 0;
        }
        else {
            break;
        }
    }
    return orientation;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getOrientationStringLPS: () => (/* reexport safe */ _getOrientationStringLPS__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   invertOrientationStringLPS: () => (/* reexport safe */ _invertOrientationStringLPS__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _getOrientationStringLPS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getOrientationStringLPS */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js");
/* harmony import */ var _invertOrientationStringLPS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invertOrientationStringLPS */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ invertOrientationStringLPS)
/* harmony export */ });
function invertOrientationStringLPS(orientationString) {
    let inverted = orientationString.replace('H', 'f');
    inverted = inverted.replace('F', 'h');
    inverted = inverted.replace('R', 'l');
    inverted = inverted.replace('L', 'r');
    inverted = inverted.replace('A', 'p');
    inverted = inverted.replace('P', 'a');
    inverted = inverted.toUpperCase();
    return inverted;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   smoothAnnotation: () => (/* reexport safe */ _smoothAnnotation__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _smoothAnnotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./smoothAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothAnnotation.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    smoothAnnotation: _smoothAnnotation__WEBPACK_IMPORTED_MODULE_0__["default"],
});



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothAnnotation.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothAnnotation.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ smoothAnnotation)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _interpolation_interpolateSegmentPoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interpolation/interpolateSegmentPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js");


function shouldPreventInterpolation(annotation, options) {
    const knotsRatioPercentage = options?.knotsRatioPercentage || 30;
    if (!annotation?.data?.contour?.polyline?.length ||
        knotsRatioPercentage <= 0) {
        return true;
    }
    return false;
}
function rotateMatrix(normal, focal) {
    const mat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create();
    const eye = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), focal, normal);
    const up = Math.abs(normal[0]) > 0.1
        ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(-normal[1], normal[0], 0)
        : gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(0, -normal[2], normal[1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.lookAt(mat, focal, eye, up);
    return mat;
}
function rotate(list, count = Math.floor(Math.random() * (list.length - 1))) {
    if (count === 0) {
        return 0;
    }
    const srcList = [...list];
    const { length } = list;
    for (let i = 0; i < length; i++) {
        list[i] = srcList[(i + count + length) % length];
    }
    return count;
}
function smoothAnnotation(annotation, options) {
    if (shouldPreventInterpolation(annotation, options)) {
        return false;
    }
    const { viewPlaneNormal } = annotation.metadata;
    const { closed, polyline } = annotation.data.contour;
    const rotateMat = rotateMatrix(viewPlaneNormal, annotation.data.contour.polyline[0]);
    const canvasPoints = annotation.data.contour.polyline.map((p) => {
        const planeP = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), p, rotateMat);
        return [planeP[0], planeP[1]];
    });
    let rotation = closed ? rotate(canvasPoints) : 0;
    let interpolatedCanvasPoints = ((0,_interpolation_interpolateSegmentPoints__WEBPACK_IMPORTED_MODULE_1__["default"])(canvasPoints, 0, canvasPoints.length, options?.knotsRatioPercentage || 30));
    if (interpolatedCanvasPoints === canvasPoints) {
        return false;
    }
    rotate(interpolatedCanvasPoints, -rotation);
    for (let i = 1; i < options?.loop; i++) {
        rotation = closed ? rotate(interpolatedCanvasPoints) : 0;
        interpolatedCanvasPoints = ((0,_interpolation_interpolateSegmentPoints__WEBPACK_IMPORTED_MODULE_1__["default"])(interpolatedCanvasPoints, 0, canvasPoints.length, options?.knotsRatioPercentage || 30));
        rotate(interpolatedCanvasPoints, -rotation);
    }
    const unRotate = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.invert(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create(), rotateMat);
    annotation.data.contour.polyline = (interpolatedCanvasPoints.map((p) => gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4([0, 0, 0], [...p, 0], unRotate)));
    return true;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pointInSurroundingSphereCallback: () => (/* binding */ pointInSurroundingSphereCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _math_sphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math/sphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/index.js");
/* harmony import */ var _boundingBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./boundingBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js");




const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {
    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);
    const sphereObj = {
        center: centerWorld,
        radius: radiusWorld,
    };
    const dimensions = imageData.getDimensions();
    const voxelManager = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
        dimensions: dimensions,
        scalarData: imageData.getPointData().getScalars().getData(),
    });
    voxelManager.forEach(callback, {
        boundsIJK,
        isInObject: (pointLPS) => (0,_math_sphere__WEBPACK_IMPORTED_MODULE_2__.pointInSphere)(sphereObj, pointLPS),
        imageData,
    });
}
function _getBounds(circlePoints, imageData, viewport) {
    const [bottom, top] = circlePoints;
    const centerWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
    const radiusWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(bottom, top) / 2;
    let boundsIJK;
    if (!viewport) {
        const centerIJK = transformWorldToIndex(imageData, centerWorld);
        const spacings = imageData.getSpacing();
        const minSpacing = Math.min(...spacings);
        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);
        boundsIJK = [
            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],
            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],
            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],
        ];
        return {
            boundsIJK,
            centerWorld: centerWorld,
            radiusWorld,
        };
    }
    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);
    return {
        boundsIJK,
        centerWorld: centerWorld,
        radiusWorld,
    };
}
function _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {
    const [bottom, top] = circlePoints;
    const dimensions = imageData.getDimensions();
    const camera = viewport.getCamera();
    const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(viewRight, viewUp, viewPlaneNormal);
    const topLeftWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    const bottomRightWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);
    const sphereCornersIJK = [
        transformWorldToIndex(imageData, topLeftWorld),
        (transformWorldToIndex(imageData, bottomRightWorld)),
    ];
    const boundsIJK = (0,_boundingBox__WEBPACK_IMPORTED_MODULE_3__.getBoundingBoxAroundShape)(sphereCornersIJK, dimensions);
    return boundsIJK;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pointToString: () => (/* binding */ pointToString)
/* harmony export */ });
function pointToString(point, decimals = 5) {
    return (parseFloat(point[0]).toFixed(decimals) +
        ',' +
        parseFloat(point[1]).toFixed(decimals) +
        ',' +
        parseFloat(point[2]).toFixed(decimals) +
        ',');
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPoint: () => (/* binding */ getPoint),
/* harmony export */   getPolyDataPointIndexes: () => (/* binding */ getPolyDataPointIndexes),
/* harmony export */   getPolyDataPoints: () => (/* binding */ getPolyDataPoints)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function getPoint(points, idx) {
    const idx3 = idx * 3;
    if (idx3 < points.length) {
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);
    }
}
function getPolyDataPointIndexes(polyData) {
    const linesData = polyData.getLines().getData();
    let idx = 0;
    const lineSegments = new Map();
    while (idx < linesData.length) {
        const segmentSize = linesData[idx++];
        const segment = [];
        for (let i = 0; i < segmentSize; i++) {
            segment.push(linesData[idx + i]);
        }
        lineSegments.set(segment[0], segment);
        idx += segmentSize;
    }
    const contours = [];
    const findStartingPoint = (map) => {
        for (const [key, value] of map.entries()) {
            if (value !== undefined) {
                return key;
            }
        }
        return -1;
    };
    let startPoint = findStartingPoint(lineSegments);
    while (startPoint !== -1) {
        const contour = [startPoint];
        while (lineSegments.has(startPoint)) {
            const nextPoint = lineSegments.get(startPoint)[1];
            if (lineSegments.has(nextPoint)) {
                contour.push(nextPoint);
            }
            lineSegments.delete(startPoint);
            startPoint = nextPoint;
        }
        contours.push(contour);
        startPoint = findStartingPoint(lineSegments);
    }
    return contours.length ? contours : undefined;
}
function getPolyDataPoints(polyData) {
    const contoursIndexes = getPolyDataPointIndexes(polyData);
    if (!contoursIndexes) {
        return;
    }
    const rawPointsData = polyData.getPoints().getData();
    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBoundsIJKFromRectangleAnnotations: () => (/* reexport safe */ _getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   isAxisAlignedRectangle: () => (/* reexport safe */ _isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_1__.isAxisAlignedRectangle)
/* harmony export */ });
/* harmony import */ var _getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundsIJKFromRectangleAnnotations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js");
/* harmony import */ var _isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isAxisAlignedRectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setAnnotationLabel)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


function setAnnotationLabel(annotation, element, updatedLabel) {
    annotation.data.label = updatedLabel;
    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_0__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.LabelChange);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/index.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stackContextPrefetch: () => (/* reexport safe */ _stackContextPrefetch__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   stackPrefetch: () => (/* reexport safe */ _stackPrefetch__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _stackPrefetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stackPrefetch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js");
/* harmony import */ var _stackContextPrefetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stackContextPrefetch */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js");
/* harmony import */ var _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stackPrefetchUtils */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetchUtils.js");



let configuration = {
    maxImagesToPrefetch: Infinity,
    minBefore: 2,
    maxAfter: 2,
    directionExtraImages: 10,
    preserveExistingPool: false,
};
let resetPrefetchTimeout;
const resetPrefetchDelay = 5;
const enable = (element) => {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getStackData)(element);
    if (!stack) {
        return;
    }
    if (!stack.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    updateToolState(element);
    prefetch(element);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getPromiseRemovedHandler)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
};
function prefetch(element) {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getStackData)(element);
    if (!stack) {
        return;
    }
    if (!stack?.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__.getToolState)(element);
    if (!stackPrefetchData) {
        return;
    }
    const stackPrefetch = (stackPrefetchData || {});
    stackPrefetch.enabled =
        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;
    if (stackPrefetch.enabled === false) {
        return;
    }
    function removeFromList(imageIdIndex) {
        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);
        if (index > -1) {
            stackPrefetch.indicesToRequest.splice(index, 1);
        }
    }
    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();
    const { currentImageIdIndex } = stack;
    indicesToRequestCopy.forEach((imageIdIndex) => {
        const imageId = stack.imageIds[imageIdIndex];
        if (!imageId) {
            return;
        }
        const distance = Math.abs(currentImageIdIndex - imageIdIndex);
        const imageCached = distance < 6
            ? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImageLoadObject(imageId)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.isLoaded(imageId);
        if (imageCached) {
            removeFromList(imageIdIndex);
        }
    });
    if (!stackPrefetch.indicesToRequest.length) {
        return;
    }
    if (!configuration.preserveExistingPool) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.filterRequests((0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.clearFromImageIds)(stack));
    }
    function doneCallback(imageId) {
        const imageIdIndex = stack.imageIds.indexOf(imageId);
        removeFromList(imageIdIndex);
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getCachedImageBasedOnImageURI(imageId);
        const { stats } = stackPrefetch;
        const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;
        if (decodeTimeInMS) {
            stats.imageIds.set(imageId, decodeTimeInMS);
            stats.decodeTimeInMS += decodeTimeInMS;
            const loadTimeInMS = image?.image?.loadTimeInMS || 0;
            stats.loadTimeInMS += loadTimeInMS;
        }
        if (!stackPrefetch.indicesToRequest.length) {
            if (image?.sizeInBytes) {
                const { sizeInBytes } = image;
                const usage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getMaxCacheSize() / 4 / sizeInBytes;
                if (!stackPrefetch.cacheFill) {
                    stats.initialTime = Date.now() - stats.start;
                    stats.initialSize = stats.imageIds.size;
                    updateToolState(element, usage);
                    prefetch(element);
                }
                else if (stats.imageIds.size) {
                    stats.fillTime = Date.now() - stats.start;
                    const { size } = stats.imageIds;
                    stats.fillSize = size;
                }
            }
        }
    }
    const requestFn = (imageId, options) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoader.loadAndCacheImage(imageId, options)
        .then(() => doneCallback(imageId));
    stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {
        const imageId = stack.imageIds[imageIdIndex];
        const options = {
            requestType: _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.requestType,
        };
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.requestType, {
            imageId,
        }, _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.priority);
    });
}
function onImageUpdated(e) {
    clearTimeout(resetPrefetchTimeout);
    resetPrefetchTimeout = setTimeout(function () {
        const element = e.target;
        try {
            updateToolState(element);
            prefetch(element);
        }
        catch (error) {
            return;
        }
    }, resetPrefetchDelay);
}
const signum = (x) => (x < 0 ? -1 : 1);
const updateToolState = (element, usage) => {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getStackData)(element);
    if (!stack) {
        return;
    }
    if (!stack.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const { currentImageIdIndex } = stack;
    let { maxAfter = 2, minBefore = 2 } = configuration;
    const { directionExtraImages = 10 } = configuration;
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__.getToolState)(element) ||
        {
            indicesToRequest: [],
            currentImageIdIndex,
            stackCount: 0,
            enabled: true,
            direction: 1,
            stats: {
                start: Date.now(),
                imageIds: new Map(),
                decodeTimeInMS: 0,
                loadTimeInMS: 0,
                totalBytes: 0,
            },
        };
    const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;
    stackPrefetchData.direction = signum(delta);
    stackPrefetchData.currentImageIdIndex = currentImageIdIndex;
    stackPrefetchData.enabled = true;
    if (stackPrefetchData.stackCount < 100) {
        stackPrefetchData.stackCount += directionExtraImages;
    }
    if (Math.abs(delta) > maxAfter || !delta) {
        stackPrefetchData.stackCount = 0;
        if (usage) {
            const positionFraction = currentImageIdIndex / stack.imageIds.length;
            minBefore = Math.ceil(usage * positionFraction);
            maxAfter = Math.ceil(usage * (1 - positionFraction));
            stackPrefetchData.cacheFill = true;
        }
        else {
            stackPrefetchData.cacheFill = false;
        }
    }
    else if (delta < 0) {
        minBefore += stackPrefetchData.stackCount;
        maxAfter = 0;
    }
    else {
        maxAfter += stackPrefetchData.stackCount;
        minBefore = 0;
    }
    const minIndex = Math.max(0, currentImageIdIndex - minBefore);
    const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);
    const indicesToRequest = [];
    for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {
        indicesToRequest.push(i);
    }
    for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {
        indicesToRequest.push(i);
    }
    stackPrefetchData.indicesToRequest = indicesToRequest;
    (0,_state__WEBPACK_IMPORTED_MODULE_1__.addToolState)(element, stackPrefetchData);
};
function disable(element) {
    clearTimeout(resetPrefetchTimeout);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getPromiseRemovedHandler)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__.getToolState)(element);
    if (stackPrefetchData) {
        stackPrefetchData.enabled = false;
    }
}
function getConfiguration() {
    return configuration;
}
function setConfiguration(config) {
    configuration = config;
}
const stackContextPrefetch = {
    enable,
    disable,
    getConfiguration,
    setConfiguration,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackContextPrefetch);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js");
/* harmony import */ var _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stackPrefetchUtils */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetchUtils.js");



let configuration = {
    maxImagesToPrefetch: Infinity,
    preserveExistingPool: true,
};
let resetPrefetchTimeout;
const resetPrefetchDelay = 10;
function prefetch(element) {
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__.getToolState)(element);
    if (!stackPrefetchData) {
        return;
    }
    const stackPrefetch = (stackPrefetchData || {});
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getStackData)(element);
    if (!stack?.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const { currentImageIdIndex } = stack;
    stackPrefetch.enabled =
        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;
    if (stackPrefetch.enabled === false) {
        return;
    }
    function removeFromList(imageIdIndex) {
        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);
        if (index > -1) {
            stackPrefetch.indicesToRequest.splice(index, 1);
        }
    }
    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);
    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();
    indicesToRequestCopy.forEach(function (imageIdIndex) {
        const imageId = stack.imageIds[imageIdIndex];
        if (!imageId) {
            return;
        }
        const distance = Math.abs(currentImageIdIndex - imageIdIndex);
        const imageCached = distance < 6
            ? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImageLoadObject(imageId)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.isLoaded(imageId);
        if (imageCached) {
            removeFromList(imageIdIndex);
        }
    });
    if (!stackPrefetch.indicesToRequest.length) {
        return;
    }
    if (!configuration.preserveExistingPool) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.clearRequestStack(_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.requestType);
    }
    const nearest = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.nearestIndex)(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);
    let imageId;
    let nextImageIdIndex;
    const preventCache = false;
    function doneCallback(image) {
        console.log('prefetch done: %s', image.imageId);
        const imageIdIndex = stack.imageIds.indexOf(image.imageId);
        removeFromList(imageIdIndex);
    }
    let lowerIndex = nearest.low;
    let higherIndex = nearest.high;
    const imageIdsToPrefetch = [];
    while (lowerIndex >= 0 ||
        higherIndex < stackPrefetch.indicesToRequest.length) {
        const currentIndex = stack.currentImageIdIndex;
        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >
            configuration.maxImagesToPrefetch;
        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >
            configuration.maxImagesToPrefetch;
        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;
        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;
        if (!shouldLoadHigher && !shouldLoadLower) {
            break;
        }
        if (shouldLoadLower) {
            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];
            imageId = stack.imageIds[nextImageIdIndex];
            imageIdsToPrefetch.push(imageId);
        }
        if (shouldLoadHigher) {
            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];
            imageId = stack.imageIds[nextImageIdIndex];
            imageIdsToPrefetch.push(imageId);
        }
    }
    const requestFn = (imageId, options) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoader.loadAndCacheImage(imageId, options);
    imageIdsToPrefetch.forEach((imageId) => {
        const options = {
            requestType: _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.requestType,
        };
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.requestType, {
            imageId,
        }, _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.priority);
    });
}
function onImageUpdated(e) {
    clearTimeout(resetPrefetchTimeout);
    resetPrefetchTimeout = setTimeout(function () {
        const element = e.target;
        try {
            prefetch(element);
        }
        catch (error) {
            return;
        }
    }, resetPrefetchDelay);
}
function enable(element) {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getStackData)(element);
    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const stackPrefetchData = {
        indicesToRequest: (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.range)(0, stack.imageIds.length - 1),
        enabled: true,
        direction: 1,
    };
    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);
    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);
    (0,_state__WEBPACK_IMPORTED_MODULE_1__.addToolState)(element, stackPrefetchData);
    prefetch(element);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getPromiseRemovedHandler)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
}
function disable(element) {
    clearTimeout(resetPrefetchTimeout);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.getPromiseRemovedHandler)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__.getToolState)(element);
    if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {
        stackPrefetchData.enabled = false;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.clearRequestStack(_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__.requestType);
    }
}
function getConfiguration() {
    return configuration;
}
function setConfiguration(config) {
    configuration = config;
}
const stackPrefetch = { enable, disable, getConfiguration, setConfiguration };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackPrefetch);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetchUtils.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetchUtils.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearFromImageIds: () => (/* binding */ clearFromImageIds),
/* harmony export */   getPromiseRemovedHandler: () => (/* binding */ getPromiseRemovedHandler),
/* harmony export */   getStackData: () => (/* binding */ getStackData),
/* harmony export */   nearestIndex: () => (/* binding */ nearestIndex),
/* harmony export */   priority: () => (/* binding */ priority),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   requestType: () => (/* binding */ requestType)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js");


const requestType = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.RequestType.Prefetch;
const priority = 0;
function range(lowEnd, highEnd) {
    lowEnd = Math.round(lowEnd) || 0;
    highEnd = Math.round(highEnd) || 0;
    const arr = [];
    let c = highEnd - lowEnd + 1;
    if (c <= 0) {
        return arr;
    }
    while (c--) {
        arr[c] = highEnd--;
    }
    return arr;
}
function nearestIndex(arr, x) {
    let low = 0;
    let high = arr.length - 1;
    arr.forEach((v, idx) => {
        if (v < x) {
            low = Math.max(idx, low);
        }
        else if (v > x) {
            high = Math.min(idx, high);
        }
    });
    return { low, high };
}
function getStackData(element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        return null;
    }
    const { viewport } = enabledElement;
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport)) {
        return null;
    }
    return {
        currentImageIdIndex: viewport.getCurrentImageIdIndex(),
        imageIds: viewport.getImageIds(),
    };
}
function getPromiseRemovedHandler(element) {
    return function (e) {
        const eventData = e.detail;
        let stackData;
        try {
            stackData = getStackData(element);
        }
        catch (error) {
            return;
        }
        if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {
            return;
        }
        const stack = stackData;
        const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);
        if (imageIdIndex < 0) {
            return;
        }
        const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__.getToolState)(element);
        if (!stackPrefetchData ||
            !stackPrefetchData.indicesToRequest ||
            !stackPrefetchData.indicesToRequest.length) {
            return;
        }
        stackPrefetchData.indicesToRequest.push(imageIdIndex);
    };
}
const clearFromImageIds = (stack) => {
    const imageIdSet = new Set(stack.imageIds);
    return (requestDetails) => requestDetails.type !== requestType ||
        !imageIdSet.has(requestDetails.additionalDetails.imageId);
};


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addToolState: () => (/* binding */ addToolState),
/* harmony export */   getToolState: () => (/* binding */ getToolState)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const state = {};
function addToolState(element, data) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId } = enabledElement;
    state[viewportId] = data;
}
function getToolState(element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId } = enabledElement;
    return state[viewportId];
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyPoints: () => (/* binding */ copyPoints),
/* harmony export */   copyPointsList: () => (/* binding */ copyPointsList),
/* harmony export */   getDeltaDistance: () => (/* binding */ getDeltaDistance),
/* harmony export */   getDeltaDistanceBetweenIPoints: () => (/* binding */ getDeltaDistanceBetweenIPoints),
/* harmony export */   getDeltaPoints: () => (/* binding */ getDeltaPoints),
/* harmony export */   getDeltaRotation: () => (/* binding */ getDeltaRotation),
/* harmony export */   getMeanPoints: () => (/* binding */ getMeanPoints),
/* harmony export */   getMeanTouchPoints: () => (/* binding */ getMeanTouchPoints)
/* harmony export */ });
function getDeltaPoints(currentPoints, lastPoints) {
    const curr = getMeanPoints(currentPoints);
    const last = getMeanPoints(lastPoints);
    return {
        page: _subtractPoints2D(curr.page, last.page),
        client: _subtractPoints2D(curr.client, last.client),
        canvas: _subtractPoints2D(curr.canvas, last.canvas),
        world: _subtractPoints3D(curr.world, last.world),
    };
}
function getDeltaDistance(currentPoints, lastPoints) {
    const curr = getMeanPoints(currentPoints);
    const last = getMeanPoints(lastPoints);
    return {
        page: _getDistance2D(curr.page, last.page),
        client: _getDistance2D(curr.client, last.client),
        canvas: _getDistance2D(curr.canvas, last.canvas),
        world: _getDistance3D(curr.world, last.world),
    };
}
function getDeltaRotation(currentPoints, lastPoints) {
}
function getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {
    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);
    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);
    const deltaDistance = {
        page: currentDistance.page - lastDistance.page,
        client: currentDistance.client - lastDistance.client,
        canvas: currentDistance.canvas - lastDistance.canvas,
        world: currentDistance.world - lastDistance.world,
    };
    return deltaDistance;
}
function copyPointsList(points) {
    return JSON.parse(JSON.stringify(points));
}
function copyPoints(points) {
    return JSON.parse(JSON.stringify(points));
}
function getMeanPoints(points) {
    return points.reduce((prev, curr) => {
        return {
            page: [
                prev.page[0] + curr.page[0] / points.length,
                prev.page[1] + curr.page[1] / points.length,
            ],
            client: [
                prev.client[0] + curr.client[0] / points.length,
                prev.client[1] + curr.client[1] / points.length,
            ],
            canvas: [
                prev.canvas[0] + curr.canvas[0] / points.length,
                prev.canvas[1] + curr.canvas[1] / points.length,
            ],
            world: [
                prev.world[0] + curr.world[0] / points.length,
                prev.world[1] + curr.world[1] / points.length,
                prev.world[2] + curr.world[2] / points.length,
            ],
        };
    }, {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    });
}
function getMeanTouchPoints(points) {
    return points.reduce((prev, curr) => {
        return {
            page: [
                prev.page[0] + curr.page[0] / points.length,
                prev.page[1] + curr.page[1] / points.length,
            ],
            client: [
                prev.client[0] + curr.client[0] / points.length,
                prev.client[1] + curr.client[1] / points.length,
            ],
            canvas: [
                prev.canvas[0] + curr.canvas[0] / points.length,
                prev.canvas[1] + curr.canvas[1] / points.length,
            ],
            world: [
                prev.world[0] + curr.world[0] / points.length,
                prev.world[1] + curr.world[1] / points.length,
                prev.world[2] + curr.world[2] / points.length,
            ],
            touch: {
                identifier: null,
                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,
                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,
                force: prev.touch.force + curr.touch.force / points.length,
                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,
            },
        };
    }, {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
        touch: {
            identifier: null,
            radiusX: 0,
            radiusY: 0,
            force: 0,
            rotationAngle: 0,
        },
    });
}
function _subtractPoints2D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1]];
}
function _subtractPoints3D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];
}
function _getMeanDistanceBetweenAllIPoints(points) {
    const pairedDistance = [];
    for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points.length; j++) {
            if (i < j) {
                pairedDistance.push({
                    page: _getDistance2D(points[i].page, points[j].page),
                    client: _getDistance2D(points[i].client, points[j].client),
                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),
                    world: _getDistance3D(points[i].world, points[j].world),
                });
            }
        }
    }
    return pairedDistance.reduce((prev, curr) => {
        return {
            page: prev.page + curr.page / pairedDistance.length,
            client: prev.client + curr.client / pairedDistance.length,
            canvas: prev.canvas + curr.canvas / pairedDistance.length,
            world: prev.world + curr.world / pairedDistance.length,
        };
    }, {
        page: 0,
        client: 0,
        canvas: 0,
        world: 0,
    });
}
function _getDistance2D(point0, point1) {
    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));
}
function _getDistance3D(point0, point1) {
    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +
        Math.pow(point0[1] - point1[1], 2) +
        Math.pow(point0[2] - point1[2], 2));
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isViewportPreScaled: () => (/* reexport safe */ _isViewportPreScaled__WEBPACK_IMPORTED_MODULE_0__.isViewportPreScaled)
/* harmony export */ });
/* harmony import */ var _isViewportPreScaled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Colorbar: () => (/* binding */ Colorbar),
/* harmony export */   "default": () => (/* binding */ Colorbar)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/index.js");
/* harmony import */ var _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enums/ColorbarRangeTextPosition */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js");
/* harmony import */ var _ColorbarCanvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ColorbarCanvas */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarCanvas.js");
/* harmony import */ var _ColorbarTicks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ColorbarTicks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarTicks.js");
/* harmony import */ var _common_isRangeTextPositionValid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./common/isRangeTextPositionValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeTextPositionValid.js");
/* harmony import */ var _widgets_Widget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../widgets/Widget */ "../../../node_modules/@cornerstonejs/tools/dist/esm/widgets/Widget.js");








const DEFAULTS = {
    MULTIPLIER: 1,
    RANGE_TEXT_POSITION: _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__.ColorbarRangeTextPosition.Right,
    TICKS_BAR_SIZE: 50,
};
class Colorbar extends _widgets_Widget__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor(props) {
        super(props);
        this._isMouseOver = false;
        this._isInteracting = false;
        this._mouseOverCallback = (evt) => {
            this._isMouseOver = true;
            this.showTicks();
            evt.stopPropagation();
        };
        this._mouseOutCallback = (evt) => {
            this._isMouseOver = false;
            this.hideTicks();
            evt.stopPropagation();
        };
        this._mouseDownCallback = (evt) => {
            this._isInteracting = true;
            this.showTicks();
            this._addVOIEventListeners(evt);
            evt.stopPropagation();
        };
        this._mouseDragCallback = (evt, initialState) => {
            const multipliers = this.getVOIMultipliers();
            const currentPoints = this._getPointsFromMouseEvent(evt);
            const { points: startPoints, voiRange: startVOIRange } = initialState;
            const canvasDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), currentPoints.local, startPoints.local);
            const wwDelta = canvasDelta[0] * multipliers[0];
            const wcDelta = canvasDelta[1] * multipliers[1];
            if (!wwDelta && !wcDelta) {
                return;
            }
            const { lower: voiLower, upper: voiUpper } = startVOIRange;
            let { windowWidth, windowCenter } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toWindowLevel(voiLower, voiUpper);
            windowWidth = Math.max(windowWidth + wwDelta, 1);
            windowCenter += wcDelta;
            const newVoiRange = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);
            this.voiRange = newVoiRange;
            evt.stopPropagation();
            evt.preventDefault();
        };
        this._mouseUpCallback = (evt) => {
            this._isInteracting = false;
            this.hideTicks();
            this._removeVOIEventListeners();
            evt.stopPropagation();
        };
        this._eventListenersManager =
            new _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.eventListener.MultiTargetEventListenerManager();
        this._colormaps = Colorbar.getColormapsMap(props);
        this._activeColormapName = Colorbar.getInitialColormapName(props);
        this._canvas = this._createCanvas(props);
        this._ticksBar = this._createTicksBar(props);
        this._rangeTextPosition =
            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;
        this._canvas.appendTo(this.rootElement);
        this._ticksBar.appendTo(this.rootElement);
        this._addRootElementEventListeners();
    }
    get activeColormapName() {
        return this._activeColormapName;
    }
    set activeColormapName(colormapName) {
        if (colormapName === this._activeColormapName) {
            return;
        }
        const colormap = this._colormaps.get(colormapName);
        if (!colormap) {
            console.warn(`Invalid colormap name (${colormapName})`);
            return;
        }
        this._activeColormapName = colormapName;
        this._canvas.colormap = colormap;
    }
    get imageRange() {
        return this._canvas.imageRange;
    }
    set imageRange(imageRange) {
        this._canvas.imageRange = imageRange;
        this._ticksBar.imageRange = imageRange;
    }
    get voiRange() {
        return this._canvas.voiRange;
    }
    set voiRange(voiRange) {
        const { voiRange: currentVoiRange } = this._canvas;
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_2__.isRangeValid)(voiRange) ||
            (0,_common__WEBPACK_IMPORTED_MODULE_2__.areColorbarRangesEqual)(voiRange, currentVoiRange)) {
            return;
        }
        this._canvas.voiRange = voiRange;
        this._ticksBar.voiRange = voiRange;
        this.onVoiChange(voiRange);
    }
    get showFullImageRange() {
        return this._canvas.showFullImageRange;
    }
    set showFullImageRange(value) {
        this._canvas.showFullImageRange = value;
        this._ticksBar.showFullPixelValueRange = value;
    }
    destroy() {
        super.destroy();
        this._eventListenersManager.reset();
    }
    createRootElement() {
        const rootElement = document.createElement('div');
        Object.assign(rootElement.style, {
            position: 'relative',
            fontSize: '0',
            width: '100%',
            height: '100%',
        });
        return rootElement;
    }
    onContainerResize() {
        super.onContainerResize();
        this.updateTicksBar();
        this._canvas.size = this.containerSize;
    }
    getVOIMultipliers() {
        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];
    }
    onVoiChange(voiRange) {
    }
    showTicks() {
        this.updateTicksBar();
        this._ticksBar.visible = true;
    }
    hideTicks() {
        if (this._isInteracting || this._isMouseOver) {
            return;
        }
        this._ticksBar.visible = false;
    }
    static getColormapsMap(props) {
        const { colormaps } = props;
        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());
    }
    static getInitialColormapName(props) {
        const { activeColormapName, colormaps } = props;
        const colormapExists = !!activeColormapName &&
            colormaps.some((cm) => cm.Name === activeColormapName);
        return colormapExists ? activeColormapName : colormaps[0].Name;
    }
    _createCanvas(props) {
        const { imageRange, voiRange, showFullPixelValueRange } = props;
        const colormap = this._colormaps.get(this._activeColormapName);
        return new _ColorbarCanvas__WEBPACK_IMPORTED_MODULE_4__.ColorbarCanvas({
            colormap,
            imageRange,
            voiRange: voiRange,
            showFullPixelValueRange,
        });
    }
    _createTicksBar(props) {
        const ticksProps = props.ticks;
        return new _ColorbarTicks__WEBPACK_IMPORTED_MODULE_5__.ColorbarTicks({
            imageRange: props.imageRange,
            voiRange: props.voiRange,
            ticks: ticksProps,
            showFullPixelValueRange: props.showFullPixelValueRange,
        });
    }
    _getPointsFromMouseEvent(evt) {
        const { rootElement: element } = this;
        const clientPoint = [evt.clientX, evt.clientY];
        const pagePoint = [evt.pageX, evt.pageY];
        const rect = element.getBoundingClientRect();
        const localPoints = [
            pagePoint[0] - rect.left - window.pageXOffset,
            pagePoint[1] - rect.top - window.pageYOffset,
        ];
        return { client: clientPoint, page: pagePoint, local: localPoints };
    }
    updateTicksBar() {
        const { width: containerWidth, height: containerHeight } = this.containerSize;
        if (containerWidth === 0 && containerHeight === 0) {
            return;
        }
        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;
        const isHorizontal = containerWidth >= containerHeight;
        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;
        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;
        if (!(0,_common_isRangeTextPositionValid__WEBPACK_IMPORTED_MODULE_6__["default"])(containerWidth, containerHeight, rangeTextPosition)) {
            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');
        }
        let ticksBarTop;
        let ticksBarLeft;
        ticksBar.size = { width, height };
        if (isHorizontal) {
            ticksBarLeft = 0;
            ticksBarTop =
                rangeTextPosition === _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__.ColorbarRangeTextPosition.Top
                    ? -height
                    : containerHeight;
        }
        else {
            ticksBarTop = 0;
            ticksBarLeft =
                rangeTextPosition === _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__.ColorbarRangeTextPosition.Left
                    ? -width
                    : containerWidth;
        }
        ticksBar.top = ticksBarTop;
        ticksBar.left = ticksBarLeft;
    }
    _addRootElementEventListeners() {
        const { _eventListenersManager: manager } = this;
        const { rootElement: element } = this;
        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);
        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);
        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);
    }
    _addVOIEventListeners(evt) {
        const { _eventListenersManager: manager } = this;
        const points = this._getPointsFromMouseEvent(evt);
        const voiRange = { ...this._canvas.voiRange };
        const initialDragState = { points, voiRange };
        this._removeVOIEventListeners();
        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);
        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));
    }
    _removeVOIEventListeners() {
        const { _eventListenersManager: manager } = this;
        manager.removeEventListener(document, 'voi.mouseup');
        manager.removeEventListener(document, 'voi.mousemove');
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarCanvas.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarCanvas.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorbarCanvas: () => (/* binding */ ColorbarCanvas),
/* harmony export */   "default": () => (/* binding */ ColorbarCanvas)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _math_vec3_interpolateVec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/vec3/interpolateVec3 */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec3/interpolateVec3.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/index.js");



const { clamp } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class ColorbarCanvas {
    constructor(props) {
        ColorbarCanvas.validateProps(props);
        const { colormap, size = { width: 20, height: 100 }, imageRange = { lower: 0, upper: 1 }, voiRange = { lower: 0, upper: 1 }, container, showFullPixelValueRange = false, } = props;
        this._colormap = colormap;
        this._imageRange = imageRange;
        this._voiRange = voiRange;
        this._showFullImageRange = showFullPixelValueRange;
        this._canvas = this._createRootElement(size);
        if (container) {
            this.appendTo(container);
        }
    }
    get colormap() {
        return this._colormap;
    }
    set colormap(colormap) {
        this._colormap = colormap;
        this.render();
    }
    get size() {
        const { width, height } = this._canvas;
        return { width, height };
    }
    set size(size) {
        const { _canvas: canvas } = this;
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_2__.isColorbarSizeValid)(size) || (0,_common__WEBPACK_IMPORTED_MODULE_2__.areColorbarSizesEqual)(canvas, size)) {
            return;
        }
        this._setCanvasSize(canvas, size);
        this.render();
    }
    get imageRange() {
        return { ...this._imageRange };
    }
    set imageRange(imageRange) {
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_2__.isRangeValid)(imageRange) ||
            (0,_common__WEBPACK_IMPORTED_MODULE_2__.areColorbarRangesEqual)(imageRange, this._imageRange)) {
            return;
        }
        this._imageRange = imageRange;
        this.render();
    }
    get voiRange() {
        return { ...this._voiRange };
    }
    set voiRange(voiRange) {
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_2__.isRangeValid)(voiRange) ||
            (0,_common__WEBPACK_IMPORTED_MODULE_2__.areColorbarRangesEqual)(voiRange, this._voiRange)) {
            return;
        }
        this._voiRange = voiRange;
        this.render();
    }
    get showFullImageRange() {
        return this._showFullImageRange;
    }
    set showFullImageRange(showFullImageRange) {
        if (showFullImageRange === this._showFullImageRange) {
            return;
        }
        this._showFullImageRange = showFullImageRange;
        this.render();
    }
    appendTo(container) {
        container.appendChild(this._canvas);
        this.render();
    }
    dispose() {
        const { _canvas: canvas } = this;
        const { parentElement } = canvas;
        parentElement?.removeChild(canvas);
    }
    static validateProps(props) {
        const { size, imageRange, voiRange } = props;
        if (size && !(0,_common__WEBPACK_IMPORTED_MODULE_2__.isColorbarSizeValid)(size)) {
            throw new Error('Invalid "size"');
        }
        if (imageRange && !(0,_common__WEBPACK_IMPORTED_MODULE_2__.isRangeValid)(imageRange)) {
            throw new Error('Invalid "imageRange"');
        }
        if (voiRange && !(0,_common__WEBPACK_IMPORTED_MODULE_2__.isRangeValid)(voiRange)) {
            throw new Error('Invalid "voiRange"');
        }
    }
    _setCanvasSize(canvas, size) {
        const { width, height } = size;
        canvas.width = width;
        canvas.height = height;
        Object.assign(canvas.style, {
            width: `${width}px`,
            height: `${height}px`,
        });
    }
    _createRootElement(size) {
        const canvas = document.createElement('canvas');
        Object.assign(canvas.style, {
            position: 'absolute',
            top: '0',
            left: '0',
            pointerEvents: 'none',
            boxSizing: 'border-box',
        });
        this._setCanvasSize(canvas, size);
        return canvas;
    }
    render() {
        if (!this._canvas.isConnected) {
            return;
        }
        const { _colormap: colormap } = this;
        const { RGBPoints: rgbPoints } = colormap;
        const colorsCount = rgbPoints.length / 4;
        const getColorPoint = (index) => {
            const offset = 4 * index;
            if (index < 0 || index >= colorsCount) {
                return;
            }
            return {
                index,
                position: rgbPoints[offset],
                color: [
                    rgbPoints[offset + 1],
                    rgbPoints[offset + 2],
                    rgbPoints[offset + 3],
                ],
            };
        };
        const { width, height } = this._canvas;
        const canvasContext = this._canvas.getContext('2d');
        if (!canvasContext) {
            return;
        }
        const isHorizontal = width > height;
        const maxValue = isHorizontal ? width : height;
        const { _voiRange: voiRange } = this;
        const range = this._showFullImageRange ? this._imageRange : { ...voiRange };
        let previousColorPoint = undefined;
        let currentColorPoint = getColorPoint(0);
        const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);
        let rawPixelValue = range.lower;
        for (let i = 0; i < maxValue; i++) {
            const tVoiRange = (rawPixelValue - voiRange.lower) /
                Math.abs(voiRange.upper - voiRange.lower);
            if (currentColorPoint) {
                for (let i = currentColorPoint.index; i < colorsCount; i++) {
                    if (tVoiRange <= currentColorPoint.position) {
                        break;
                    }
                    previousColorPoint = currentColorPoint;
                    currentColorPoint = getColorPoint(i + 1);
                }
            }
            let normColor;
            if (!previousColorPoint) {
                normColor = [...currentColorPoint.color];
            }
            else if (!currentColorPoint) {
                normColor = [...previousColorPoint.color];
            }
            else {
                const tColorRange = (tVoiRange - previousColorPoint.position) /
                    (currentColorPoint.position - previousColorPoint.position);
                normColor = (0,_math_vec3_interpolateVec3__WEBPACK_IMPORTED_MODULE_1__["default"])(previousColorPoint.color, currentColorPoint.color, tColorRange);
            }
            const color = normColor.map((color) => clamp(Math.round(color * 255), 0, 255));
            canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            if (isHorizontal) {
                canvasContext.fillRect(i, 0, 1, height);
            }
            else {
                canvasContext.fillRect(0, height - i - 1, width, 1);
            }
            rawPixelValue += incRawPixelValue;
        }
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarTicks.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarTicks.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorbarTicks: () => (/* binding */ ColorbarTicks),
/* harmony export */   "default": () => (/* binding */ ColorbarTicks)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/index.js");
/* harmony import */ var _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/ColorbarRangeTextPosition */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js");


const DEFAULTS = {
    FONT: '10px Arial',
    COLOR: 'white',
    TICK_SIZE: 5,
    TICK_WIDTH: 1,
    TICK_LABEL_MARGIN: 3,
    MAX_NUM_TICKS: 8,
    TICKS_STEPS: [1, 2.5, 5, 10],
};
class ColorbarTicks {
    constructor(props) {
        ColorbarTicks.validateProps(props);
        const { top = 0, left = 0, size = { width: 20, height: 100 }, imageRange = { lower: 0, upper: 1 }, voiRange = { lower: 0, upper: 1 }, ticks: ticksProps, container, showFullPixelValueRange = false, } = props;
        const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};
        this._imageRange = imageRange;
        this._voiRange = voiRange;
        this._font = ticksStyle?.font ?? DEFAULTS.FONT;
        this._color = ticksStyle?.color ?? DEFAULTS.COLOR;
        this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;
        this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;
        this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;
        this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;
        this._rangeTextPosition =
            rangeTextPosition ?? _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_1__.ColorbarRangeTextPosition.Right;
        this._showFullPixelValueRange = showFullPixelValueRange;
        this._canvas = this._createCanvasElement(size, top, left);
        if (container) {
            this.appendTo(container);
        }
    }
    get size() {
        const { width, height } = this._canvas;
        return { width, height };
    }
    set size(size) {
        const { _canvas: canvas } = this;
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_0__.isColorbarSizeValid)(size) || (0,_common__WEBPACK_IMPORTED_MODULE_0__.areColorbarSizesEqual)(canvas, size)) {
            return;
        }
        this._setCanvasSize(canvas, size);
        this.render();
    }
    get top() {
        return Number.parseInt(this._canvas.style.top);
    }
    set top(top) {
        const { _canvas: canvas } = this;
        const currentTop = this.top;
        if (top === currentTop) {
            return;
        }
        canvas.style.top = `${top}px`;
        this.render();
    }
    get left() {
        return Number.parseInt(this._canvas.style.left);
    }
    set left(left) {
        const { _canvas: canvas } = this;
        const currentLeft = this.left;
        if (left === currentLeft) {
            return;
        }
        canvas.style.left = `${left}px`;
        this.render();
    }
    get imageRange() {
        return { ...this._imageRange };
    }
    set imageRange(imageRange) {
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_0__.isRangeValid)(imageRange) ||
            (0,_common__WEBPACK_IMPORTED_MODULE_0__.areColorbarRangesEqual)(imageRange, this._imageRange)) {
            return;
        }
        this._imageRange = imageRange;
        this.render();
    }
    get voiRange() {
        return { ...this._voiRange };
    }
    set voiRange(voiRange) {
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_0__.isRangeValid)(voiRange) ||
            (0,_common__WEBPACK_IMPORTED_MODULE_0__.areColorbarRangesEqual)(voiRange, this._voiRange)) {
            return;
        }
        this._voiRange = voiRange;
        this.render();
    }
    get tickSize() {
        return this._tickSize;
    }
    set tickSize(tickSize) {
        if (tickSize === this._tickSize) {
            return;
        }
        this._tickSize = tickSize;
        this.render();
    }
    get tickWidth() {
        return this._tickWidth;
    }
    set tickWidth(tickWidth) {
        if (tickWidth === this._tickWidth) {
            return;
        }
        this._tickWidth = tickWidth;
        this.render();
    }
    get color() {
        return this._color;
    }
    set color(color) {
        if (color === this._color) {
            return;
        }
        this._color = color;
        this.render();
    }
    get showFullPixelValueRange() {
        return this._showFullPixelValueRange;
    }
    set showFullPixelValueRange(showFullRange) {
        if (showFullRange === this._showFullPixelValueRange) {
            return;
        }
        this._showFullPixelValueRange = showFullRange;
        this.render();
    }
    get visible() {
        return this._canvas.style.display === 'block';
    }
    set visible(visible) {
        if (visible === this.visible) {
            return;
        }
        this._canvas.style.display = visible ? 'block' : 'none';
        if (visible) {
            this.render();
        }
    }
    appendTo(container) {
        container.appendChild(this._canvas);
        this.render();
    }
    static validateProps(props) {
        const { size, imageRange, voiRange } = props;
        if (size && !(0,_common__WEBPACK_IMPORTED_MODULE_0__.isColorbarSizeValid)(size)) {
            throw new Error('Invalid "size"');
        }
        if (imageRange && !(0,_common__WEBPACK_IMPORTED_MODULE_0__.isRangeValid)(imageRange)) {
            throw new Error('Invalid "imageRange"');
        }
        if (voiRange && !(0,_common__WEBPACK_IMPORTED_MODULE_0__.isRangeValid)(voiRange)) {
            throw new Error('Invalid "voiRange"');
        }
    }
    _setCanvasSize(canvas, size) {
        const { width, height } = size;
        canvas.width = width;
        canvas.height = height;
        Object.assign(canvas.style, {
            width: `${width}px`,
            height: `${height}px`,
        });
    }
    _createCanvasElement(size, top, left) {
        const canvas = document.createElement('canvas');
        Object.assign(canvas.style, {
            display: 'none',
            position: 'absolute',
            boxSizing: 'border-box',
            top: `${top}px`,
            left: `${left}px`,
        });
        this._setCanvasSize(canvas, size);
        return canvas;
    }
    _getTicks(range) {
        const { lower, upper } = range;
        const rangeValue = upper - lower;
        const roughStep = rangeValue / (this._maxNumTicks - 1);
        const stepPower = Math.pow(10, -Math.floor(Math.log10(Math.abs(roughStep))));
        const roughtStepNormalized = roughStep * stepPower;
        const normalizedStep = DEFAULTS.TICKS_STEPS.find((n) => n >= roughtStepNormalized);
        const step = normalizedStep / stepPower;
        const scaleMax = Math.ceil(upper / step) * step;
        const scaleMin = Math.floor(lower / step) * step;
        const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;
        const ticks = [];
        for (let i = 0; i < ticksCount; i++) {
            ticks.push(scaleMin + i * step);
        }
        return { scaleMin, scaleMax, step, ticks };
    }
    _getLeftTickInfo({ position, labelMeasure }) {
        const { width } = this._canvas;
        const labelX = width - this.tickSize - labelMeasure.width - this._labelMargin;
        const labelPoint = [labelX, position];
        const tickPoints = {
            start: [width - this._tickSize, position],
            end: [width, position],
        };
        return { labelPoint, tickPoints };
    }
    _getRightTickInfo({ position }) {
        const labelPoint = [this._tickSize + this._labelMargin, position];
        const tickPoints = {
            start: [0, position],
            end: [this._tickSize, position],
        };
        return { labelPoint, tickPoints };
    }
    _getTopTickInfo({ position, labelMeasure }) {
        const { height } = this._canvas;
        const labelY = height - this.tickSize - this._labelMargin;
        const labelPoint = [position, labelY];
        const tickPoints = {
            start: [position, height - this._tickSize],
            end: [position, height],
        };
        return { labelPoint, tickPoints };
    }
    _getBottomTickInfo({ position, labelMeasure }) {
        const labelPoint = [position, this._tickSize + this._labelMargin];
        const tickPoints = {
            start: [position, 0],
            end: [position, this._tickSize],
        };
        return { labelPoint, tickPoints };
    }
    render() {
        const { _canvas: canvas } = this;
        if (!canvas.isConnected || !this.visible) {
            return;
        }
        const { width, height } = canvas;
        const isHorizontal = width >= height;
        const maxCanvasPixelValue = isHorizontal ? width : height;
        const canvasContext = canvas.getContext('2d');
        const { _voiRange: voiRange } = this;
        const range = this._showFullPixelValueRange
            ? this._imageRange
            : { ...voiRange };
        const rangeWidth = range.upper - range.lower;
        const { ticks } = this._getTicks(range);
        canvasContext.clearRect(0, 0, width, height);
        canvasContext.font = this._font;
        canvasContext.textBaseline = isHorizontal ? 'top' : 'middle';
        canvasContext.textAlign = isHorizontal ? 'center' : 'left';
        canvasContext.fillStyle = this._color;
        canvasContext.strokeStyle = this._color;
        canvasContext.lineWidth = this.tickWidth;
        ticks.forEach((tick) => {
            let position = Math.round(maxCanvasPixelValue * ((tick - range.lower) / rangeWidth));
            if (!isHorizontal) {
                position = height - position;
            }
            if (position < 0 || position > maxCanvasPixelValue) {
                return;
            }
            const label = tick.toString();
            const labelMeasure = canvasContext.measureText(label);
            let tickInfo;
            if (isHorizontal) {
                if (this._rangeTextPosition === _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_1__.ColorbarRangeTextPosition.Top) {
                    tickInfo = this._getTopTickInfo({ position, labelMeasure });
                }
                else {
                    tickInfo = this._getBottomTickInfo({ position, labelMeasure });
                }
            }
            else {
                if (this._rangeTextPosition === _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_1__.ColorbarRangeTextPosition.Left) {
                    tickInfo = this._getLeftTickInfo({ position, labelMeasure });
                }
                else {
                    tickInfo = this._getRightTickInfo({ position });
                }
            }
            const { labelPoint, tickPoints } = tickInfo;
            const { start: tickStart, end: tickEnd } = tickPoints;
            canvasContext.beginPath();
            canvasContext.moveTo(tickStart[0], tickStart[1]);
            canvasContext.lineTo(tickEnd[0], tickEnd[1]);
            canvasContext.fillText(label, labelPoint[0], labelPoint[1]);
            canvasContext.stroke();
            return position;
        });
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ViewportColorbar: () => (/* binding */ ViewportColorbar),
/* harmony export */   "default": () => (/* binding */ ViewportColorbar)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _Colorbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Colorbar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js");
/* harmony import */ var _getVOIMultipliers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../getVOIMultipliers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getVOIMultipliers.js");



const { Events } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums;
const defaultImageRange = { lower: -1000, upper: 1000 };
class ViewportColorbar extends _Colorbar__WEBPACK_IMPORTED_MODULE_1__.Colorbar {
    constructor(props) {
        const { element, volumeId } = props;
        const imageRange = ViewportColorbar._getImageRange(element, volumeId);
        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);
        super({ ...props, imageRange, voiRange });
        this.autoHideTicks = () => {
            if (this._hideTicksTimeoutId) {
                return;
            }
            const timeLeft = this._hideTicksTime - Date.now();
            if (timeLeft <= 0) {
                this.hideTicks();
            }
            else {
                this._hideTicksTimeoutId = window.setTimeout(() => {
                    this._hideTicksTimeoutId = 0;
                    this.autoHideTicks();
                }, timeLeft);
            }
        };
        this._stackNewImageCallback = () => {
            this.imageRange = ViewportColorbar._getImageRange(this._element);
        };
        this._imageVolumeModifiedCallback = (evt) => {
            const { volumeId } = evt.detail;
            if (volumeId !== this._volumeId) {
                return;
            }
            const { _element: element } = this;
            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);
        };
        this._viewportVOIModifiedCallback = (evt) => {
            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;
            const { viewport } = this.enabledElement;
            if (viewportId !== viewport.id || volumeId !== this._volumeId) {
                return;
            }
            this.voiRange = voiRange;
            if (colormap) {
                this.activeColormapName = colormap.name;
            }
            this.showAndAutoHideTicks();
        };
        this._viewportColormapModifiedCallback = (evt) => {
            const { viewportId, colormap, volumeId } = evt.detail;
            const { viewport } = this.enabledElement;
            if (viewportId !== viewport.id || volumeId !== this._volumeId) {
                return;
            }
            this.activeColormapName = colormap.name;
        };
        this._element = element;
        this._volumeId = volumeId;
        this._addCornerstoneEventListener();
    }
    get element() {
        return this._element;
    }
    get enabledElement() {
        return (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._element);
    }
    getVOIMultipliers() {
        const { viewport } = this.enabledElement;
        return (0,_getVOIMultipliers__WEBPACK_IMPORTED_MODULE_2__.getVOIMultipliers)(viewport, this._volumeId);
    }
    onVoiChange(voiRange) {
        super.onVoiChange(voiRange);
        const { viewport } = this.enabledElement;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
            viewport.setProperties({
                voiRange: voiRange,
            });
            viewport.render();
        }
        else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            const { _volumeId: volumeId } = this;
            const viewportsContainingVolumeUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithVolumeId(volumeId);
            viewport.setProperties({ voiRange }, volumeId);
            viewportsContainingVolumeUID.forEach((vp) => vp.render());
        }
    }
    static _getImageRange(element, volumeId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const actor = viewport.getImageActor(volumeId);
        if (!actor) {
            return defaultImageRange;
        }
        const imageData = actor.getMapper().getInputData();
        const scalarData = imageData.getPointData().getScalars();
        let imageRange;
        if (!scalarData) {
            if (!volumeId) {
                throw new Error('volumeId is required when scalarData is not available');
            }
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            const [minValue, maxValue] = volume.voxelManager.getRange();
            imageRange = [minValue, maxValue];
        }
        else {
            imageRange = scalarData.getRange();
        }
        return imageRange[0] === 0 && imageRange[1] === 0
            ? defaultImageRange
            : { lower: imageRange[0], upper: imageRange[1] };
    }
    static _getVOIRange(element, volumeId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const actor = viewport.getImageActor(volumeId);
        if (!actor) {
            return defaultImageRange;
        }
        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();
        return voiRange[0] === 0 && voiRange[1] === 0
            ? defaultImageRange
            : { lower: voiRange[0], upper: voiRange[1] };
    }
    showAndAutoHideTicks(interval = 1000) {
        this._hideTicksTime = Date.now() + interval;
        this.showTicks();
        this.autoHideTicks();
    }
    _addCornerstoneEventListener() {
        const { _element: element } = this;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);
        element.addEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);
        element.addEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);
        element.addEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);
    }
    destroy() {
        super.destroy();
        const { _element: element } = this;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);
        element.removeEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);
        element.removeEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);
        element.removeEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarRangesEqual.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarRangesEqual.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   areColorbarRangesEqual: () => (/* binding */ areColorbarRangesEqual),
/* harmony export */   "default": () => (/* binding */ areColorbarRangesEqual)
/* harmony export */ });
const areColorbarRangesEqual = (a, b) => {
    return !!a && !!b && a.lower === b.lower && a.upper === b.upper;
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarSizesEqual.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarSizesEqual.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   areColorbarSizesEqual: () => (/* binding */ areColorbarSizesEqual),
/* harmony export */   "default": () => (/* binding */ areColorbarSizesEqual)
/* harmony export */ });
const areColorbarSizesEqual = (a, b) => {
    return !!a && !!b && a.width === b.width && a.height === b.height;
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/index.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   areColorbarRangesEqual: () => (/* reexport safe */ _areColorbarRangesEqual__WEBPACK_IMPORTED_MODULE_2__.areColorbarRangesEqual),
/* harmony export */   areColorbarSizesEqual: () => (/* reexport safe */ _areColorbarSizesEqual__WEBPACK_IMPORTED_MODULE_3__.areColorbarSizesEqual),
/* harmony export */   isColorbarSizeValid: () => (/* reexport safe */ _isColorbarSizeValid__WEBPACK_IMPORTED_MODULE_1__.isColorbarSizeValid),
/* harmony export */   isRangeValid: () => (/* reexport safe */ _isRangeValid__WEBPACK_IMPORTED_MODULE_0__.isRangeValid)
/* harmony export */ });
/* harmony import */ var _isRangeValid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isRangeValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeValid.js");
/* harmony import */ var _isColorbarSizeValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isColorbarSizeValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isColorbarSizeValid.js");
/* harmony import */ var _areColorbarRangesEqual__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./areColorbarRangesEqual */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarRangesEqual.js");
/* harmony import */ var _areColorbarSizesEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./areColorbarSizesEqual */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarSizesEqual.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isColorbarSizeValid.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isColorbarSizeValid.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isColorbarSizeValid),
/* harmony export */   isColorbarSizeValid: () => (/* binding */ isColorbarSizeValid)
/* harmony export */ });
const isColorbarSizeValid = (size) => {
    return !!size && size.width > 0 && size.height > 0;
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeTextPositionValid.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeTextPositionValid.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isRangeTextPositionValid),
/* harmony export */   isRangeTextPositionValid: () => (/* binding */ isRangeTextPositionValid)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/index.js");

function isRangeTextPositionValid(colorbarWidth, colorbarHeight, rangeTextPosition) {
    const isHorizontal = colorbarWidth >= colorbarHeight;
    const validRangeTextPositions = isHorizontal
        ? [_enums__WEBPACK_IMPORTED_MODULE_0__.ColorbarRangeTextPosition.Top, _enums__WEBPACK_IMPORTED_MODULE_0__.ColorbarRangeTextPosition.Bottom]
        : [_enums__WEBPACK_IMPORTED_MODULE_0__.ColorbarRangeTextPosition.Left, _enums__WEBPACK_IMPORTED_MODULE_0__.ColorbarRangeTextPosition.Right];
    return validRangeTextPositions.includes(rangeTextPosition);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeValid.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeValid.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isRangeValid),
/* harmony export */   isRangeValid: () => (/* binding */ isRangeValid)
/* harmony export */ });
const isRangeValid = (range) => {
    return range && range.upper > range.lower;
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorbarRangeTextPosition: () => (/* binding */ ColorbarRangeTextPosition)
/* harmony export */ });
var ColorbarRangeTextPosition;
(function (ColorbarRangeTextPosition) {
    ColorbarRangeTextPosition["Top"] = "top";
    ColorbarRangeTextPosition["Left"] = "left";
    ColorbarRangeTextPosition["Bottom"] = "bottom";
    ColorbarRangeTextPosition["Right"] = "right";
})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/index.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorbarRangeTextPosition: () => (/* reexport safe */ _ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_0__.ColorbarRangeTextPosition)
/* harmony export */ });
/* harmony import */ var _ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorbarRangeTextPosition */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js");



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/index.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Colorbar: () => (/* reexport safe */ _Colorbar__WEBPACK_IMPORTED_MODULE_1__.Colorbar),
/* harmony export */   Enums: () => (/* reexport module object */ _enums__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   ViewportColorbar: () => (/* reexport safe */ _ViewportColorbar__WEBPACK_IMPORTED_MODULE_2__.ViewportColorbar)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/index.js");
/* harmony import */ var _Colorbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Colorbar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js");
/* harmony import */ var _ViewportColorbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ViewportColorbar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorbar: () => (/* reexport module object */ _colorbar__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   windowLevel: () => (/* reexport module object */ _windowlevel__WEBPACK_IMPORTED_MODULE_1__)
/* harmony export */ });
/* harmony import */ var _colorbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorbar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/index.js");
/* harmony import */ var _windowlevel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./windowlevel */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/index.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateMinMaxMean: () => (/* binding */ calculateMinMaxMean)
/* harmony export */ });
function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {
    const numPixels = pixelLuminance.length;
    let min = globalMax;
    let max = globalMin;
    let sum = 0;
    if (numPixels < 2) {
        return {
            min,
            max,
            mean: (globalMin + globalMax) / 2,
        };
    }
    for (let index = 0; index < numPixels; index++) {
        const spv = pixelLuminance[index];
        min = Math.min(min, spv);
        max = Math.max(max, spv);
        sum += spv;
    }
    return {
        min,
        max,
        mean: sum / numPixels,
    };
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractWindowLevelRegionToolData: () => (/* binding */ extractWindowLevelRegionToolData)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function extractWindowLevelRegionToolData(viewport) {
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
        return extractImageDataVolume(viewport);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        return extractImageDataStack(viewport);
    }
    throw new Error('Viewport not supported');
}
function extractImageDataVolume(viewport) {
    const { scalarData, width, height } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getCurrentVolumeViewportSlice(viewport);
    const { min: minPixelValue, max: maxPixelValue } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getMinMax(scalarData);
    return {
        scalarData,
        minPixelValue,
        maxPixelValue,
        width,
        height,
        rows: width,
        columns: height,
    };
}
function extractImageDataStack(viewport) {
    const imageData = viewport.getImageData();
    const { scalarData } = imageData;
    const { min: minPixelValue, max: maxPixelValue } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getMinMax(scalarData);
    const width = imageData.dimensions[0];
    const height = imageData.dimensions[1];
    const { rows, columns, color } = viewport.getCornerstoneImage();
    return {
        scalarData,
        width,
        height,
        minPixelValue,
        maxPixelValue,
        rows,
        columns,
        color,
    };
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLuminanceFromRegion: () => (/* binding */ getLuminanceFromRegion)
/* harmony export */ });
function getLuminanceFromRegion(imageData, x, y, width, height) {
    const luminance = [];
    let index = 0;
    const pixelData = imageData.scalarData;
    let spIndex, row, column;
    if (imageData.color) {
        for (row = 0; row < height; row++) {
            for (column = 0; column < width; column++) {
                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;
                const red = pixelData[spIndex];
                const green = pixelData[spIndex + 1];
                const blue = pixelData[spIndex + 2];
                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;
            }
        }
    }
    else {
        for (row = 0; row < height; row++) {
            for (column = 0; column < width; column++) {
                spIndex = (row + y) * imageData.columns + (column + x);
                luminance[index++] = pixelData[spIndex];
            }
        }
    }
    return luminance;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/index.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateMinMaxMean: () => (/* reexport safe */ _calculateMinMaxMean__WEBPACK_IMPORTED_MODULE_1__.calculateMinMaxMean),
/* harmony export */   extractWindowLevelRegionToolData: () => (/* reexport safe */ _extractWindowLevelRegionToolData__WEBPACK_IMPORTED_MODULE_2__.extractWindowLevelRegionToolData),
/* harmony export */   getLuminanceFromRegion: () => (/* reexport safe */ _getLuminanceFromRegion__WEBPACK_IMPORTED_MODULE_0__.getLuminanceFromRegion)
/* harmony export */ });
/* harmony import */ var _getLuminanceFromRegion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getLuminanceFromRegion */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js");
/* harmony import */ var _calculateMinMaxMean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculateMinMaxMean */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js");
/* harmony import */ var _extractWindowLevelRegionToolData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extractWindowLevelRegionToolData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/version.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
const version = '3.15.1';


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/widgets/Widget.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/widgets/Widget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Widget: () => (/* binding */ Widget),
/* harmony export */   "default": () => (/* binding */ Widget)
/* harmony export */ });
class Widget {
    constructor({ id, container }) {
        this._containerResizeCallback = (entries) => {
            let width;
            let height;
            const { contentRect, contentBoxSize } = entries[0];
            if (contentRect) {
                width = contentRect.width;
                height = contentRect.height;
            }
            else if (contentBoxSize?.length) {
                width = contentBoxSize[0].inlineSize;
                height = contentBoxSize[0].blockSize;
            }
            this._containerSize = { width, height };
            this.onContainerResize();
        };
        this._id = id;
        this._containerSize = { width: 0, height: 0 };
        this._rootElement = this.createRootElement(id);
        this._containerResizeObserver = new ResizeObserver(this._containerResizeCallback);
        if (container) {
            this.appendTo(container);
        }
    }
    get id() {
        return this._id;
    }
    get rootElement() {
        return this._rootElement;
    }
    appendTo(container) {
        const { _rootElement: rootElement, _containerResizeObserver: resizeObserver, } = this;
        const { parentElement: currentContainer } = rootElement;
        if (!container || container === currentContainer) {
            return;
        }
        if (currentContainer) {
            resizeObserver.unobserve(currentContainer);
        }
        container.appendChild(rootElement);
        resizeObserver.observe(container);
    }
    destroy() {
        const { _rootElement: rootElement, _containerResizeObserver: resizeObserver, } = this;
        const { parentElement } = rootElement;
        parentElement?.removeChild(rootElement);
        resizeObserver.disconnect();
    }
    get containerSize() {
        return { ...this._containerSize };
    }
    createRootElement(id) {
        const rootElement = document.createElement('div');
        rootElement.id = id;
        rootElement.classList.add('widget');
        Object.assign(rootElement.style, {
            width: '100%',
            height: '100%',
        });
        return rootElement;
    }
    onContainerResize() {
    }
}



/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Common/Core/ImageHelper.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Common/Core/ImageHelper.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageHelper)
/* harmony export */ });
/* harmony import */ var _DataModel_ImageData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DataModel/ImageData.js */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js");
/* harmony import */ var _DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataArray.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js");



/**
 * Takes a canvas and converts it to a vtkImageData.
 *
 * Optionally supply a bounding box to get a particular subset of the canvas.
 *
 * @param canvas       The HTML canvas to convert
 * @param boundingBox  A bounding box of type [top, left, width, height]
 */
function canvasToImageData(canvas) {
  let boundingBox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0];
  const [top, left, width, height] = boundingBox;
  const ctxt = canvas.getContext('2d');
  const idata = ctxt.getImageData(top, left, width || canvas.width, height || canvas.height);
  const imageData = _DataModel_ImageData_js__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance({
    type: 'vtkImageData'
  });
  imageData.setOrigin(0, 0, 0);
  imageData.setSpacing(1, 1, 1);
  imageData.setExtent(0, (width || canvas.width) - 1, 0, (height || canvas.height) - 1, 0, 0);
  const scalars = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
    numberOfComponents: 4,
    values: new Uint8Array(idata.data.buffer)
  });
  scalars.setName('scalars');
  imageData.getPointData().setScalars(scalars);
  return imageData;
}

/**
 * Converts an Image object to a vtkImageData.
 */
function imageToImageData(image) {
  let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    flipX: false,
    flipY: false,
    rotate: 0
  };
  const canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  const ctx = canvas.getContext('2d');
  const {
    flipX,
    flipY,
    rotate
  } = transform;
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
  ctx.rotate(rotate * Math.PI / 180);
  ctx.drawImage(image, -image.width / 2, -image.height / 2);
  return canvasToImageData(canvas);
}
var ImageHelper = {
  canvasToImageData,
  imageToImageData
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkAppendPolyData$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Common/Core/DataArray.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js");
/* harmony import */ var _Common_Core_Points_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Common/Core/Points.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/Points.js");
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Common/DataModel/PolyData.js */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js");
/* harmony import */ var _Common_DataModel_DataSetAttributes_Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Common/DataModel/DataSetAttributes/Constants.js */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js");
/* harmony import */ var _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Common/Core/DataArray/Constants.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js");







const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;
function offsetCellArray(typedArray, offset) {
  let currentIdx = 0;
  return typedArray.map((value, index) => {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return value;
    }
    return value + offset;
  });
}
function appendCellData(dest, src, ptOffset, cellOffset) {
  dest.set(offsetCellArray(src, ptOffset), cellOffset);
}

// ----------------------------------------------------------------------------
// vtkAppendPolyData methods
// ----------------------------------------------------------------------------

function vtkAppendPolyData(publicAPI, model) {
  // Set our classname
  model.classHierarchy.push('vtkAppendPolyData');
  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const numberOfInputs = publicAPI.getNumberOfInputPorts();
    if (!numberOfInputs) {
      vtkErrorMacro('No input specified.');
      return;
    }
    if (numberOfInputs === 1) {
      // pass through filter
      outData[0] = inData[0];
      return;
    }

    // Allocate output
    const output = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    let numPts = 0;
    let pointType = 0;
    let ttype = 1;
    let firstType = 1;
    let numVerts = 0;
    let numLines = 0;
    let numStrips = 0;
    let numPolys = 0;

    // Field data is propagated to output only if present in all inputs
    let hasPtNormals = true; // assume present by default
    let hasPtTCoords = true;
    let hasPtScalars = true;
    for (let i = 0; i < numberOfInputs; i++) {
      const ds = inData[i];
      if (!ds) {
        // eslint-disable-next-line
        continue;
      }
      const dsNumPts = ds.getPoints().getNumberOfPoints();
      numPts += dsNumPts;
      numVerts += ds.getVerts().getNumberOfValues();
      numLines += ds.getLines().getNumberOfValues();
      numStrips += ds.getStrips().getNumberOfValues();
      numPolys += ds.getPolys().getNumberOfValues();
      if (dsNumPts) {
        if (firstType) {
          firstType = 0;
          pointType = ds.getPoints().getDataType();
        }
        ttype = ds.getPoints().getDataType();
        pointType = pointType > ttype ? pointType : ttype;
      }
      const ptD = ds.getPointData();
      if (ptD) {
        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;
        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;
        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;
      } else {
        hasPtNormals = false;
        hasPtTCoords = false;
        hasPtScalars = false;
      }
    }
    if (model.outputPointsPrecision === _Common_DataModel_DataSetAttributes_Constants_js__WEBPACK_IMPORTED_MODULE_4__.DesiredOutputPrecision.SINGLE) {
      pointType = _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_5__.VtkDataTypes.FLOAT;
    } else if (model.outputPointsPrecision === _Common_DataModel_DataSetAttributes_Constants_js__WEBPACK_IMPORTED_MODULE_4__.DesiredOutputPrecision.DOUBLE) {
      pointType = _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_5__.VtkDataTypes.DOUBLE;
    }
    const points = _Common_Core_Points_js__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
      dataType: pointType
    });
    points.setNumberOfPoints(numPts);
    const pointData = points.getData();
    const vertData = new Uint32Array(numVerts);
    const lineData = new Uint32Array(numLines);
    const stripData = new Uint32Array(numStrips);
    const polyData = new Uint32Array(numPolys);
    let newPtNormals = null;
    let newPtTCoords = null;
    let newPtScalars = null;
    const lds = inData[numberOfInputs - 1];
    if (hasPtNormals) {
      const dsNormals = lds.getPointData().getNormals();
      newPtNormals = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
        numberOfComponents: 3,
        numberOfTuples: numPts,
        size: 3 * numPts,
        dataType: dsNormals.getDataType(),
        name: dsNormals.getName()
      });
    }
    if (hasPtTCoords) {
      const dsTCoords = lds.getPointData().getTCoords();
      newPtTCoords = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
        numberOfComponents: 2,
        numberOfTuples: numPts,
        size: 2 * numPts,
        dataType: dsTCoords.getDataType(),
        name: dsTCoords.getName()
      });
    }
    if (hasPtScalars) {
      const dsScalars = lds.getPointData().getScalars();
      newPtScalars = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
        numberOfComponents: dsScalars.getNumberOfComponents(),
        numberOfTuples: numPts,
        size: numPts * dsScalars.getNumberOfComponents(),
        dataType: dsScalars.getDataType(),
        name: dsScalars.getName()
      });
    }
    numPts = 0;
    numVerts = 0;
    numLines = 0;
    numStrips = 0;
    numPolys = 0;
    for (let i = 0; i < numberOfInputs; i++) {
      const ds = inData[i];
      pointData.set(ds.getPoints().getData(), numPts * 3);
      appendCellData(vertData, ds.getVerts().getData(), numPts, numVerts);
      numVerts += ds.getVerts().getNumberOfValues();
      appendCellData(lineData, ds.getLines().getData(), numPts, numLines);
      numLines += ds.getLines().getNumberOfValues();
      appendCellData(stripData, ds.getStrips().getData(), numPts, numStrips);
      numStrips += ds.getStrips().getNumberOfValues();
      appendCellData(polyData, ds.getPolys().getData(), numPts, numPolys);
      numPolys += ds.getPolys().getNumberOfValues();
      const dsPD = ds.getPointData();
      if (hasPtNormals) {
        const ptNorms = dsPD.getNormals();
        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);
      }
      if (hasPtTCoords) {
        const ptTCoords = dsPD.getTCoords();
        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);
      }
      if (hasPtScalars) {
        const ptScalars = dsPD.getScalars();
        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());
      }
      numPts += ds.getPoints().getNumberOfPoints();
    }
    output.setPoints(points);
    output.getVerts().setData(vertData);
    output.getLines().setData(lineData);
    output.getStrips().setData(stripData);
    output.getPolys().setData(polyData);
    if (newPtNormals) {
      output.getPointData().setNormals(newPtNormals);
    }
    if (newPtTCoords) {
      output.getPointData().setTCoords(newPtTCoords);
    }
    if (newPtScalars) {
      output.getPointData().setScalars(newPtScalars);
    }
    outData[0] = output;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  outputPointsPrecision: _Common_DataModel_DataSetAttributes_Constants_js__WEBPACK_IMPORTED_MODULE_4__.DesiredOutputPrecision.DEFAULT
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['outputPointsPrecision']);

  // Make this a VTK object
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Also make it an algorithm with one input and one output
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 1, 1);

  // Object specific methods
  vtkAppendPolyData(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkAppendPolyData');

// ----------------------------------------------------------------------------

var vtkAppendPolyData$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Filters/Sources/ArrowSource.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Filters/Sources/ArrowSource.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkArrowSource$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _General_AppendPolyData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../General/AppendPolyData.js */ "../../../node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js");
/* harmony import */ var _ConeSource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ConeSource.js */ "../../../node_modules/@kitware/vtk.js/Filters/Sources/ConeSource.js");
/* harmony import */ var _CylinderSource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CylinderSource.js */ "../../../node_modules/@kitware/vtk.js/Filters/Sources/CylinderSource.js");
/* harmony import */ var _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Common/Core/MatrixBuilder.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js");






// ----------------------------------------------------------------------------
// vtkArrowSource methods
// ----------------------------------------------------------------------------

function vtkArrowSource(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkArrowSource');
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    const cylinder = _CylinderSource_js__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance({
      capping: true
    });
    cylinder.setResolution(model.shaftResolution);
    cylinder.setRadius(model.shaftRadius);
    cylinder.setHeight(1.0 - model.tipLength);
    cylinder.setCenter(0, (1.0 - model.tipLength) * 0.5, 0.0);
    const cylinderPD = cylinder.getOutputData();
    const cylinderPts = cylinderPD.getPoints().getData();
    const cylinderNormals = cylinderPD.getPointData().getNormals().getData();

    // Apply transformation to the cylinder
    _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"].buildFromDegree().rotateZ(-90).apply(cylinderPts).apply(cylinderNormals);
    const cone = _ConeSource_js__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    cone.setResolution(model.tipResolution);
    cone.setHeight(model.tipLength);
    cone.setRadius(model.tipRadius);
    const conePD = cone.getOutputData();
    const conePts = conePD.getPoints().getData();

    // Apply transformation to the cone
    _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"].buildFromRadian().translate(1.0 - model.tipLength * 0.5, 0.0, 0.0).apply(conePts);
    const append = _General_AppendPolyData_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
    append.setInputData(cylinderPD);
    append.addInputData(conePD);
    const appendPD = append.getOutputData();
    const appendPts = appendPD.getPoints().getData();
    // Center the arrow about [0, 0, 0]
    _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"].buildFromRadian().translate(-0.5 + model.tipLength * 0.5, 0.0, 0.0).apply(appendPts);
    if (model.invert) {
      // Apply transformation to the arrow
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"].buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(-1, -1, -1).apply(appendPts);

      // Update output
      outData[0] = appendPD;
    } else {
      // Apply transformation to the arrow
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"].buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(1, 1, 1).apply(appendPts);

      // Update output
      outData[0] = append.getOutputData();
    }
  }

  // Expose methods
  publicAPI.requestData = requestData;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  tipResolution: 6,
  tipRadius: 0.1,
  tipLength: 0.35,
  shaftResolution: 6,
  shaftRadius: 0.03,
  invert: false,
  direction: [1.0, 0.0, 0.0],
  pointType: 'Float64Array'
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['tipResolution', 'tipRadius', 'tipLength', 'shaftResolution', 'shaftRadius', 'invert']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['direction'], 3);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 0, 1);
  vtkArrowSource(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkArrowSource');

// ----------------------------------------------------------------------------

var vtkArrowSource$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Filters/Sources/ConeSource.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Filters/Sources/ConeSource.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkConeSource$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Common/DataModel/PolyData.js */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js");
/* harmony import */ var _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Common/Core/MatrixBuilder.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js");




// ----------------------------------------------------------------------------
// vtkConeSource methods
// ----------------------------------------------------------------------------

function vtkConeSource(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkConeSource');
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    let dataset = outData[0];
    const angle = 2 * Math.PI / model.resolution;
    const xbot = -model.height / 2.0;
    const numberOfPoints = model.resolution + 1;
    const cellArraySize = 4 * model.resolution + 1 + model.resolution;

    // Points
    let pointIdx = 0;
    const points = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * 3);

    // Cells
    let cellLocation = 0;
    const polys = new Uint32Array(cellArraySize);

    // Add summit point
    points[0] = model.height / 2.0;
    points[1] = 0.0;
    points[2] = 0.0;

    // Create bottom cell
    if (model.capping) {
      polys[cellLocation++] = model.resolution;
    }

    // Add all points
    for (let i = 0; i < model.resolution; i++) {
      pointIdx++;
      points[pointIdx * 3 + 0] = xbot;
      points[pointIdx * 3 + 1] = model.radius * Math.cos(i * angle);
      points[pointIdx * 3 + 2] = model.radius * Math.sin(i * angle);

      // Add points to bottom cell in reverse order
      if (model.capping) {
        polys[model.resolution - cellLocation++ + 1] = pointIdx;
      }
    }

    // Add all triangle cells
    for (let i = 0; i < model.resolution; i++) {
      polys[cellLocation++] = 3;
      polys[cellLocation++] = 0;
      polys[cellLocation++] = i + 1;
      polys[cellLocation++] = i + 2 > model.resolution ? 1 : i + 2;
    }

    // Apply transformation to the points coordinates
    _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_2__["default"].buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).apply(points);
    dataset = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);

    // Update output
    outData[0] = dataset;
  }

  // Expose methods
  publicAPI.requestData = requestData;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  height: 1.0,
  radius: 0.5,
  resolution: 6,
  center: [0, 0, 0],
  direction: [1.0, 0.0, 0.0],
  capping: true,
  pointType: 'Float64Array'
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['height', 'radius', 'resolution', 'capping']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['center', 'direction'], 3);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 0, 1);
  vtkConeSource(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkConeSource');

// ----------------------------------------------------------------------------

var vtkConeSource$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Filters/Sources/CylinderSource.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Filters/Sources/CylinderSource.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkCylinderSource$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Common/Core/DataArray.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js");
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Common/DataModel/PolyData.js */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js");
/* harmony import */ var _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Common/Core/MatrixBuilder.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js");





// ----------------------------------------------------------------------------
// vtkCylinderSource methods
// ----------------------------------------------------------------------------

function vtkCylinderSource(publicAPI, model) {
  // Set our classname
  model.classHierarchy.push('vtkCylinderSource');
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    let dataset = outData[0];
    const angle = 2.0 * Math.PI / model.resolution;
    let numberOfPoints = 2 * model.resolution;
    let numberOfPolys = 5 * model.resolution;
    if (model.capping) {
      numberOfPoints = 4 * model.resolution;
      numberOfPolys = 7 * model.resolution + 2;
    }

    // Points
    const points = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * 3);

    // Cells
    let cellLocation = 0;
    const polys = new Uint32Array(numberOfPolys);

    // Normals
    const normalsData = new Float32Array(numberOfPoints * 3);
    const normals = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
      numberOfComponents: 3,
      values: normalsData,
      name: 'Normals'
    });

    // Texture coords
    const tcData = new Float32Array(numberOfPoints * 2);
    const tcoords = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
      numberOfComponents: 2,
      values: tcData,
      name: 'TCoords'
    });

    // Generate points for all sides
    const nbot = [0.0, 0.0, 0.0];
    const ntop = [0.0, 0.0, 0.0];
    const xbot = [0.0, 0.0, 0.0];
    const xtop = [0.0, 0.0, 0.0];
    const tcbot = [0.0, 0.0];
    const tctop = [0.0, 0.0];
    const otherRadius = model.otherRadius == null ? model.radius : model.otherRadius;
    for (let i = 0; i < model.resolution; i++) {
      // x coordinate
      nbot[0] = Math.cos(i * angle + model.initAngle);
      ntop[0] = nbot[0];
      xbot[0] = model.radius * nbot[0] + model.center[0];
      xtop[0] = xbot[0];
      tcbot[0] = Math.abs(2.0 * i / model.resolution - 1.0);
      tctop[0] = tcbot[0];

      // y coordinate
      xbot[1] = 0.5 * model.height + model.center[1];
      xtop[1] = -0.5 * model.height + model.center[1];
      tcbot[1] = 0.0;
      tctop[1] = 1.0;

      // z coordinate
      nbot[2] = -Math.sin(i * angle + model.initAngle);
      ntop[2] = nbot[2];
      xbot[2] = otherRadius * nbot[2] + model.center[2];
      xtop[2] = xbot[2];
      const pointIdx = 2 * i;
      for (let j = 0; j < 3; j++) {
        normalsData[pointIdx * 3 + j] = nbot[j];
        normalsData[(pointIdx + 1) * 3 + j] = ntop[j];
        points[pointIdx * 3 + j] = xbot[j];
        points[(pointIdx + 1) * 3 + j] = xtop[j];
        if (j < 2) {
          tcData[pointIdx * 2 + j] = tcbot[j];
          tcData[(pointIdx + 1) * 2 + j] = tctop[j];
        }
      }
    }

    // Generate polygons for sides
    for (let i = 0; i < model.resolution; i++) {
      polys[cellLocation++] = 4;
      polys[cellLocation++] = 2 * i;
      polys[cellLocation++] = 2 * i + 1;
      const pt = (2 * i + 3) % (2 * model.resolution);
      polys[cellLocation++] = pt;
      polys[cellLocation++] = pt - 1;
    }
    if (model.capping) {
      // Generate points for top/bottom polygons
      for (let i = 0; i < model.resolution; i++) {
        // x coordinate
        xbot[0] = model.radius * Math.cos(i * angle + model.initAngle);
        xtop[0] = xbot[0];
        tcbot[0] = xbot[0];
        tctop[0] = xbot[0];
        xbot[0] += model.center[0];
        xtop[0] += model.center[0];

        // y coordinate
        nbot[1] = 1.0;
        ntop[1] = -1.0;
        xbot[1] = 0.5 * model.height + model.center[1];
        xtop[1] = -0.5 * model.height + model.center[1];

        // z coordinate
        xbot[2] = -otherRadius * Math.sin(i * angle + model.initAngle);
        xtop[2] = xbot[2];
        tcbot[1] = xbot[2];
        tctop[1] = xbot[2];
        xbot[2] += model.center[2];
        xtop[2] += model.center[2];
        const botIdx = 2 * model.resolution + i;
        const topIdx = 3 * model.resolution + model.resolution - i - 1;
        for (let j = 0; j < 3; j++) {
          normalsData[3 * botIdx + j] = nbot[j];
          normalsData[3 * topIdx + j] = ntop[j];
          points[3 * botIdx + j] = xbot[j];
          points[3 * topIdx + j] = xtop[j];
          if (j < 2) {
            tcData[2 * botIdx + j] = tcbot[j];
            tcData[2 * topIdx + j] = tctop[j];
          }
        }
      }

      // Generate polygons for top/bottom
      polys[cellLocation++] = model.resolution;
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 2 * model.resolution + i;
      }
      polys[cellLocation++] = model.resolution;
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 3 * model.resolution + i;
      }
    }

    // Apply transformation to the points coordinates
    _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_3__["default"].buildFromRadian().translate(...model.center).rotateFromDirections([0, 1, 0], model.direction).translate(...model.center.map(c => c * -1)).apply(points);
    dataset = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    dataset.getPointData().setNormals(normals);
    dataset.getPointData().setTCoords(tcoords);

    // Update output
    outData[0] = dataset;
  }

  // Expose methods
  publicAPI.requestData = requestData;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  height: 1.0,
  initAngle: 0,
  radius: 1.0,
  resolution: 6,
  center: [0, 0, 0],
  direction: [0.0, 1.0, 0.0],
  capping: true,
  pointType: 'Float64Array'
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['height', 'initAngle', 'otherRadius', 'radius', 'resolution', 'capping']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['center', 'direction'], 3);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 0, 1);
  vtkCylinderSource(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkCylinderSource');

// ----------------------------------------------------------------------------

var vtkCylinderSource$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_VALUES: () => (/* binding */ DEFAULT_VALUES),
/* harmony export */   "default": () => (/* binding */ vtkOrientationMarkerWidget$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _Rendering_Core_Renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Rendering/Core/Renderer.js */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js");
/* harmony import */ var _OrientationMarkerWidget_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OrientationMarkerWidget/Constants.js */ "../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants.js");




const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;
const {
  Corners
} = _OrientationMarkerWidget_Constants_js__WEBPACK_IMPORTED_MODULE_2__["default"];

// ----------------------------------------------------------------------------
// vtkOrientationMarkerWidget
// ----------------------------------------------------------------------------

function vtkOrientationMarkerWidget(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOrientationMarkerWidget');
  const superClass = {
    ...publicAPI
  };

  // Private variables

  const previousCameraInput = [];
  const selfRenderer = _Rendering_Core_Renderer_js__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
  const resizeObserver = new ResizeObserver(entries => {
    publicAPI.updateViewport();
  });
  let onCameraChangedSub = null;
  let onCameraModifiedSub = null;
  let onAnimationSub = null;
  let onEndAnimationSub = null;
  let selfSubscription = null;
  function onCameraModified() {
    // If animating, marker will be updated on Animation event
    if (!model._interactor.isAnimating()) {
      publicAPI.updateMarkerOrientation();
    }
  }
  model._onParentRendererChanged = () => publicAPI.updateViewport();
  publicAPI.computeViewport = () => {
    const parentRen = model.parentRenderer || model._interactor.getCurrentRenderer();
    const [xMin, yMin, xMax, yMax] = parentRen.getViewport();
    const view = model._interactor.getView();
    const canvasSize = view.getSize();
    const [viewXSize, viewYSize] = view.getViewportSize(parentRen);
    const minViewSize = Math.min(viewXSize, viewYSize);
    let pixelSize = model.viewportSize * minViewSize;
    // clamp pixel size
    pixelSize = Math.max(Math.min(model.minPixelSize, minViewSize), Math.min(model.maxPixelSize, pixelSize));
    const xFrac = pixelSize / canvasSize[0];
    const yFrac = pixelSize / canvasSize[1];
    // [left bottom right top]
    switch (model.viewportCorner) {
      case Corners.TOP_LEFT:
        return [xMin, yMax - yFrac, xMin + xFrac, yMax];
      case Corners.TOP_RIGHT:
        return [xMax - xFrac, yMax - yFrac, xMax, yMax];
      case Corners.BOTTOM_LEFT:
        return [xMin, yMin, xMin + xFrac, yMin + yFrac];
      case Corners.BOTTOM_RIGHT:
        return [xMax - xFrac, yMin, xMax, yMin + yFrac];
      default:
        vtkErrorMacro('Invalid widget corner');
        return null;
    }
  };
  publicAPI.updateViewport = () => {
    if (model.enabled) {
      selfRenderer.setViewport(...publicAPI.computeViewport());
      model._interactor.render();
    }
  };
  publicAPI.updateMarkerOrientation = () => {
    const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
    const currentCamera = ren.getActiveCamera();
    if (!currentCamera) {
      return;
    }
    const position = currentCamera.getReferenceByName('position');
    const focalPoint = currentCamera.getReferenceByName('focalPoint');
    const viewUp = currentCamera.getReferenceByName('viewUp');
    if (previousCameraInput[0] !== position[0] || previousCameraInput[1] !== position[1] || previousCameraInput[2] !== position[2] || previousCameraInput[3] !== focalPoint[0] || previousCameraInput[4] !== focalPoint[1] || previousCameraInput[5] !== focalPoint[2] || previousCameraInput[6] !== viewUp[0] || previousCameraInput[7] !== viewUp[1] || previousCameraInput[8] !== viewUp[2]) {
      previousCameraInput[0] = position[0];
      previousCameraInput[1] = position[1];
      previousCameraInput[2] = position[2];
      previousCameraInput[3] = focalPoint[0];
      previousCameraInput[4] = focalPoint[1];
      previousCameraInput[5] = focalPoint[2];
      previousCameraInput[6] = viewUp[0];
      previousCameraInput[7] = viewUp[1];
      previousCameraInput[8] = viewUp[2];
      const activeCamera = selfRenderer.getActiveCamera();
      activeCamera.setPosition(position[0], position[1], position[2]);
      activeCamera.setFocalPoint(focalPoint[0], focalPoint[1], focalPoint[2]);
      activeCamera.setViewUp(viewUp[0], viewUp[1], viewUp[2]);
      selfRenderer.resetCamera();
    }
  };

  /**
   * Enables/Disables the orientation marker.
   */
  publicAPI.setEnabled = enabling => {
    if (enabling) {
      if (model.enabled) {
        return;
      }
      if (!model.actor) {
        vtkErrorMacro('Must set actor before enabling orientation marker.');
        return;
      }
      if (!model._interactor) {
        vtkErrorMacro('Must set interactor before enabling orientation marker.');
        return;
      }
      const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
      const renderWindow = ren.getRenderWindow();
      renderWindow.addRenderer(selfRenderer);
      if (renderWindow.getNumberOfLayers() < 2) {
        renderWindow.setNumberOfLayers(2);
      }
      // Highest number is foreground
      selfRenderer.setLayer(renderWindow.getNumberOfLayers() - 1);
      selfRenderer.setInteractive(model.interactiveRenderer);
      selfRenderer.addViewProp(model.actor);
      model.actor.setVisibility(true);
      onCameraChangedSub = ren.onEvent(event => {
        if (event.type === 'ActiveCameraEvent') {
          if (onCameraModifiedSub) {
            onCameraModifiedSub.unsubscribe();
          }
          onCameraModifiedSub = event.camera.onModified(onCameraModified);
        }
      });
      onCameraModifiedSub = ren.getActiveCamera().onModified(onCameraModified);
      onAnimationSub = model._interactor.onAnimation(publicAPI.updateMarkerOrientation);
      onEndAnimationSub = model._interactor.onEndAnimation(publicAPI.updateMarkerOrientation);
      resizeObserver.observe(model._interactor.getView().getCanvas());
      publicAPI.updateViewport();
      publicAPI.updateMarkerOrientation();
      model.enabled = true;
    } else {
      if (!model.enabled) {
        return;
      }
      model.enabled = false;
      resizeObserver.disconnect();
      onCameraChangedSub.unsubscribe();
      onCameraChangedSub = null;
      onCameraModifiedSub.unsubscribe();
      onCameraModifiedSub = null;
      onAnimationSub.unsubscribe();
      onAnimationSub = null;
      onEndAnimationSub.unsubscribe();
      onEndAnimationSub = null;
      model.actor.setVisibility(false);
      selfRenderer.removeViewProp(model.actor);
      const renderWindow = model._interactor?.findPokedRenderer()?.getRenderWindow();
      if (renderWindow) {
        renderWindow.removeRenderer(selfRenderer);
      }
    }
    publicAPI.modified();
  };

  /**
   * Sets the viewport corner.
   */
  publicAPI.setViewportCorner = corner => {
    if (corner === model.viewportCorner) {
      return;
    }
    model.viewportCorner = corner;
    publicAPI.updateViewport();
  };

  /**
   * Sets the viewport size.
   */
  publicAPI.setViewportSize = sizeFactor => {
    const viewportSize = Math.min(1, Math.max(0, sizeFactor));
    if (viewportSize === model.viewportSize) {
      return;
    }
    model.viewportSize = viewportSize;
    publicAPI.updateViewport();
  };
  publicAPI.setActor = actor => {
    const previousState = model.enabled;
    publicAPI.setEnabled(false);
    model.actor = actor;
    publicAPI.setEnabled(previousState);
  };
  publicAPI.getRenderer = () => selfRenderer;
  publicAPI.delete = () => {
    superClass.delete();
    if (selfSubscription) {
      selfSubscription.unsubscribe();
      selfSubscription = null;
    }
    if (onCameraChangedSub) {
      onCameraChangedSub.unsubscribe();
      onCameraChangedSub = null;
    }
    if (onCameraModifiedSub) {
      onCameraModifiedSub.unsubscribe();
      onCameraModifiedSub = null;
    }
    if (onAnimationSub) {
      onAnimationSub.unsubscribe();
      onAnimationSub = null;
    }
    if (onEndAnimationSub) {
      onEndAnimationSub.unsubscribe();
      onEndAnimationSub = null;
    }
    resizeObserver.disconnect();
  };

  // --------------------------------------------------------------------------

  // update viewport whenever we are updated
  selfSubscription = publicAPI.onModified(publicAPI.updateViewport);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // actor: null,
  // _interactor: null,
  viewportCorner: _OrientationMarkerWidget_Constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].Corners.BOTTOM_LEFT,
  viewportSize: 0.2,
  minPixelSize: 50,
  maxPixelSize: 200,
  parentRenderer: null,
  interactiveRenderer: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['enabled', 'viewportCorner', 'viewportSize', 'interactiveRenderer']);

  // NOTE: setting these while the widget is enabled will
  // not update the widget.
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['_interactor', 'minPixelSize', 'maxPixelSize', 'parentRenderer']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['actor']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.moveToProtected(publicAPI, model, ['interactor']);

  // Object methods
  vtkOrientationMarkerWidget(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkOrientationMarkerWidget');

// ----------------------------------------------------------------------------

var vtkOrientationMarkerWidget$1 = {
  newInstance,
  extend,
  ..._OrientationMarkerWidget_Constants_js__WEBPACK_IMPORTED_MODULE_2__["default"]
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Corners: () => (/* binding */ Corners),
/* harmony export */   "default": () => (/* binding */ Constants)
/* harmony export */ });
const Corners = {
  TOP_LEFT: 'TOP_LEFT',
  TOP_RIGHT: 'TOP_RIGHT',
  BOTTOM_LEFT: 'BOTTOM_LEFT',
  BOTTOM_RIGHT: 'BOTTOM_RIGHT'
};
var Constants = {
  Corners
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_VALUES: () => (/* binding */ DEFAULT_VALUES),
/* harmony export */   "default": () => (/* binding */ vtkAnnotatedCubeActor$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actor.js */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js");
/* harmony import */ var _Mapper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Mapper.js */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js");
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Texture.js */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Texture.js");
/* harmony import */ var _Filters_Sources_CubeSource_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Filters/Sources/CubeSource.js */ "../../../node_modules/@kitware/vtk.js/Filters/Sources/CubeSource.js");
/* harmony import */ var _Common_Core_ImageHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Common/Core/ImageHelper.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/ImageHelper.js");
/* harmony import */ var _AnnotatedCubeActor_Presets_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnnotatedCubeActor/Presets.js */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor/Presets.js");








const FACE_TO_INDEX = {
  xPlus: 0,
  xMinus: 1,
  yPlus: 2,
  yMinus: 3,
  zPlus: 4,
  zMinus: 5
};

// ----------------------------------------------------------------------------
// vtkAnnotatedCubeActor
// ----------------------------------------------------------------------------

function vtkAnnotatedCubeActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkAnnotatedCubeActor');

  // Make sure face properties are not references to the default value
  model.xPlusFaceProperty = {
    ...model.xPlusFaceProperty
  };
  model.xMinusFaceProperty = {
    ...model.xMinusFaceProperty
  };
  model.yPlusFaceProperty = {
    ...model.yPlusFaceProperty
  };
  model.yMinusFaceProperty = {
    ...model.yMinusFaceProperty
  };
  model.zPlusFaceProperty = {
    ...model.zPlusFaceProperty
  };
  model.zMinusFaceProperty = {
    ...model.zMinusFaceProperty
  };

  // private variables

  let cubeSource = null;
  const canvas = document.createElement('canvas');
  const mapper = _Mapper_js__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
  const texture = _Texture_js__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
  texture.setInterpolate(true);

  // private methods

  function updateFaceTexture(faceName) {
    let newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (newProp) {
      Object.assign(model[`${faceName}FaceProperty`], newProp);
    }
    const prop = {
      ...model.defaultStyle,
      ...model[`${faceName}FaceProperty`]
    };

    // set canvas resolution
    canvas.width = prop.resolution;
    canvas.height = prop.resolution;
    const ctxt = canvas.getContext('2d');

    // set background color
    ctxt.fillStyle = prop.faceColor;
    ctxt.fillRect(0, 0, canvas.width, canvas.height);

    // draw edge
    if (prop.edgeThickness > 0) {
      ctxt.strokeStyle = prop.edgeColor;
      ctxt.lineWidth = prop.edgeThickness * canvas.width;
      ctxt.strokeRect(0, 0, canvas.width, canvas.height);
    }

    // set face rotation
    ctxt.save();

    // vertical flip
    ctxt.translate(0, canvas.height);
    ctxt.scale(1, -1);
    ctxt.translate(canvas.width / 2, canvas.height / 2);
    ctxt.rotate(-Math.PI * (prop.faceRotation / 180.0));

    // set foreground text
    const textSize = prop.fontSizeScale(prop.resolution);
    ctxt.fillStyle = prop.fontColor;
    ctxt.textAlign = 'center';
    ctxt.textBaseline = 'middle';
    ctxt.font = `${prop.fontStyle} ${textSize}px "${prop.fontFamily}"`;
    ctxt.fillText(prop.text, 0, 0);
    ctxt.restore();
    const vtkImage = _Common_Core_ImageHelper_js__WEBPACK_IMPORTED_MODULE_5__["default"].canvasToImageData(canvas);
    texture.setInputData(vtkImage, FACE_TO_INDEX[faceName]);
    publicAPI.modified();
  }
  function updateAllFaceTextures() {
    cubeSource = _Filters_Sources_CubeSource_js__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance({
      generate3DTextureCoordinates: true
    });
    mapper.setInputConnection(cubeSource.getOutputPort());
    updateFaceTexture('xPlus');
    updateFaceTexture('xMinus');
    updateFaceTexture('yPlus');
    updateFaceTexture('yMinus');
    updateFaceTexture('zPlus');
    updateFaceTexture('zMinus');
  }

  // public methods

  publicAPI.setDefaultStyle = style => {
    model.defaultStyle = {
      ...model.defaultStyle,
      ...style
    };
    updateAllFaceTextures();
  };
  publicAPI.setXPlusFaceProperty = prop => updateFaceTexture('xPlus', prop);
  publicAPI.setXMinusFaceProperty = prop => updateFaceTexture('xMinus', prop);
  publicAPI.setYPlusFaceProperty = prop => updateFaceTexture('yPlus', prop);
  publicAPI.setYMinusFaceProperty = prop => updateFaceTexture('yMinus', prop);
  publicAPI.setZPlusFaceProperty = prop => updateFaceTexture('zPlus', prop);
  publicAPI.setZMinusFaceProperty = prop => updateFaceTexture('zMinus', prop);

  // constructor

  updateAllFaceTextures();

  // set mapper
  mapper.setInputConnection(cubeSource.getOutputPort());
  publicAPI.setMapper(mapper);

  // set texture
  publicAPI.addTexture(texture);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  defaultStyle: {
    text: '',
    faceColor: 'white',
    faceRotation: 0,
    fontFamily: 'Arial',
    fontColor: 'black',
    fontStyle: 'normal',
    fontSizeScale: resolution => resolution / 1.8,
    edgeThickness: 0.1,
    edgeColor: 'black',
    resolution: 200
  }
  // xPlusFaceProperty: null,
  // xMinusFaceProperty: null,
  // yPlusFaceProperty: null,
  // yMinusFaceProperty: null,
  // zPlusFaceProperty: null,
  // zMinusFaceProperty: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _Actor_js__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['defaultStyle', 'xPlusFaceProperty', 'xMinusFaceProperty', 'yPlusFaceProperty', 'yMinusFaceProperty', 'zPlusFaceProperty', 'zMinusFaceProperty']);

  // Object methods
  vtkAnnotatedCubeActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkAnnotatedCubeActor');

// ----------------------------------------------------------------------------

var vtkAnnotatedCubeActor$1 = {
  newInstance,
  extend,
  Presets: _AnnotatedCubeActor_Presets_js__WEBPACK_IMPORTED_MODULE_6__["default"]
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor/Presets.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor/Presets.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnnotatedCubePresets)
/* harmony export */ });
const STYLES = {
  default: {
    defaultStyle: {
      fontStyle: 'bold',
      fontFamily: 'Arial',
      fontColor: 'black',
      fontSizeScale: res => res / 2,
      faceColor: 'white',
      edgeThickness: 0.1,
      edgeColor: 'black',
      resolution: 400
    },
    xMinusFaceProperty: {
      text: 'X-',
      faceColor: 'yellow'
    },
    xPlusFaceProperty: {
      text: 'X+',
      faceColor: 'yellow'
    },
    yMinusFaceProperty: {
      text: 'Y-',
      faceColor: 'red'
    },
    yPlusFaceProperty: {
      text: 'Y+',
      faceColor: 'red'
    },
    zMinusFaceProperty: {
      text: 'Z-',
      faceColor: '#008000'
    },
    zPlusFaceProperty: {
      text: 'Z+',
      faceColor: '#008000'
    }
  },
  lps: {
    xMinusFaceProperty: {
      text: 'R',
      faceRotation: -90
    },
    xPlusFaceProperty: {
      text: 'L',
      faceRotation: 90
    },
    yMinusFaceProperty: {
      text: 'A',
      faceRotation: 0
    },
    yPlusFaceProperty: {
      text: 'P',
      faceRotation: 180
    },
    zMinusFaceProperty: {
      text: 'I',
      faceRotation: 180
    },
    zPlusFaceProperty: {
      text: 'S',
      faceRotation: 0
    }
  }
};
function applyDefinitions(definitions, cubeActor) {
  cubeActor.set(definitions);
}
function applyPreset(name, cubeActor) {
  return applyDefinitions(STYLES[name], cubeActor);
}
function registerStylePreset(name, definitions) {
  STYLES[name] = definitions;
}
var AnnotatedCubePresets = {
  applyDefinitions,
  applyPreset,
  registerStylePreset
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtkAxesActor$1),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   newInstance: () => (/* binding */ newInstance)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../macros2.js */ "../../../node_modules/@kitware/vtk.js/macros2.js");
/* harmony import */ var _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Common/Core/MatrixBuilder.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js");
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Common/Core/DataArray.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Actor.js */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js");
/* harmony import */ var _Mapper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Mapper.js */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js");
/* harmony import */ var _Filters_Sources_ArrowSource_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Filters/Sources/ArrowSource.js */ "../../../node_modules/@kitware/vtk.js/Filters/Sources/ArrowSource.js");
/* harmony import */ var _Filters_General_AppendPolyData_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Filters/General/AppendPolyData.js */ "../../../node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js");








// ----------------------------------------------------------------------------

function centerDataSet(ds) {
  const bounds = ds.getPoints().getBounds();
  const center = [-(bounds[0] + bounds[1]) * 0.5, -(bounds[2] + bounds[3]) * 0.5, -(bounds[4] + bounds[5]) * 0.5];
  _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_1__["default"].buildFromDegree().translate(...center).apply(ds.getPoints().getData());
}
function shiftDataset(ds, axis) {
  let invert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const bounds = ds.getPoints().getBounds();
  const center = [0, 0, 0];
  if (invert) {
    center[axis] = -bounds[axis * 2 + 1];
  } else {
    center[axis] = -bounds[axis * 2];
  }
  _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_1__["default"].buildFromDegree().translate(...center).apply(ds.getPoints().getData());
}

// ----------------------------------------------------------------------------

function addColor(ds, r, g, b) {
  const size = ds.getPoints().getData().length;
  const rgbArray = new Uint8ClampedArray(size);
  let offset = 0;
  while (offset < size) {
    rgbArray[offset++] = r;
    rgbArray[offset++] = g;
    rgbArray[offset++] = b;
  }
  ds.getPointData().setScalars(_Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
    name: 'color',
    numberOfComponents: 3,
    values: rgbArray
  }));
}

// ----------------------------------------------------------------------------
// vtkAxesActor
// ----------------------------------------------------------------------------

function vtkAxesActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkAxesActor');
  const _mapper = _Mapper_js__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance();
  publicAPI.setMapper(_mapper);
  publicAPI.update = () => {
    let currentConfig = {
      ...model.config,
      ...model.xConfig
    };
    const xAxis = _Filters_Sources_ArrowSource_js__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance({
      direction: [1, 0, 0],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(xAxis);
    } else {
      shiftDataset(xAxis, 0, currentConfig.invert);
    }
    addColor(xAxis, ...currentConfig.color);
    currentConfig = {
      ...model.config,
      ...model.yConfig
    };
    const yAxis = _Filters_Sources_ArrowSource_js__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance({
      direction: [0, 1, 0],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(yAxis);
    } else {
      shiftDataset(yAxis, 1, currentConfig.invert);
    }
    addColor(yAxis, ...currentConfig.color);
    currentConfig = {
      ...model.config,
      ...model.zConfig
    };
    const zAxis = _Filters_Sources_ArrowSource_js__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance({
      direction: [0, 0, 1],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(zAxis);
    } else {
      shiftDataset(zAxis, 2, currentConfig.invert);
    }
    addColor(zAxis, ...currentConfig.color);
    const source = _Filters_General_AppendPolyData_js__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance();
    source.setInputData(xAxis);
    source.addInputData(yAxis);
    source.addInputData(zAxis);
    _mapper.setInputConnection(source.getOutputPort());
  };
  publicAPI.update();
  const _debouncedUpdate = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.debounce(publicAPI.update, 0);
  publicAPI.setXAxisColor = color => publicAPI.setXConfig({
    ...publicAPI.getXConfig(),
    color
  });
  publicAPI.setYAxisColor = color => publicAPI.setYConfig({
    ...publicAPI.getYConfig(),
    color
  });
  publicAPI.setZAxisColor = color => publicAPI.setZConfig({
    ...publicAPI.getZConfig(),
    color
  });
  publicAPI.getXAxisColor = () => model.getXConfig().color;
  publicAPI.getYAxisColor = () => model.getYConfig().color;
  publicAPI.getZAxisColor = () => model.getZConfig().color;
  model._onConfigChanged = _debouncedUpdate;
  model._onXConfigChanged = _debouncedUpdate;
  model._onYConfigChanged = _debouncedUpdate;
  model._onZConfigChanged = _debouncedUpdate;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function defaultValues(initialValues) {
  return {
    config: {
      recenter: true,
      tipResolution: 60,
      tipRadius: 0.1,
      tipLength: 0.2,
      shaftResolution: 60,
      shaftRadius: 0.03,
      invert: false,
      ...initialValues?.config
    },
    xConfig: {
      color: [255, 0, 0],
      invert: false,
      ...initialValues?.xConfig
    },
    yConfig: {
      color: [255, 255, 0],
      invert: false,
      ...initialValues?.yConfig
    },
    zConfig: {
      color: [0, 128, 0],
      invert: false,
      ...initialValues?.zConfig
    }
  };
}

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Inheritance
  _Actor_js__WEBPACK_IMPORTED_MODULE_3__["default"].extend(publicAPI, model, defaultValues(initialValues));
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['config', 'xConfig', 'yConfig', 'zConfig']);

  // Object methods
  vtkAxesActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkAxesActor');

// ----------------------------------------------------------------------------

var vtkAxesActor$1 = {
  newInstance,
  extend
};




/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_cornerstonejs_tools_dist_esm_index_js.js.map