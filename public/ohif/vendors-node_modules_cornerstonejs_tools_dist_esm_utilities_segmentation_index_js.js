(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_cornerstonejs_tools_dist_esm_utilities_segmentation_index_js"],{

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/config.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/config.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAddOns: () => (/* binding */ getAddOns),
/* harmony export */   getConfig: () => (/* binding */ getConfig),
/* harmony export */   getPolySeg: () => (/* binding */ getPolySeg),
/* harmony export */   setConfig: () => (/* binding */ setConfig)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");


let config = {};
function getConfig() {
    return config;
}
function setConfig(newConfig) {
    config = newConfig;
}
function getAddOns() {
    return config.addons;
}
let polysegInitialized = false;
function getPolySeg() {
    if (!config.addons?.polySeg) {
        console.warn('PolySeg add-on not configured. This will prevent automatic conversion between segmentation representations (labelmap, contour, surface). To enable these features, install @cornerstonejs/polymorphic-segmentation and register it during initialization: cornerstoneTools.init({ addons: { polySeg } }).');
        return null;
    }
    const polyseg = config.addons.polySeg;
    if (!polysegInitialized) {
        polyseg.init();
        polysegInitialized = true;
    }
    return polyseg;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const CORNERSTONE_COLOR_LUT = [
    [0, 0, 0, 0],
    [221, 84, 84, 255],
    [77, 228, 121, 255],
    [166, 70, 235, 255],
    [189, 180, 116, 255],
    [109, 182, 196, 255],
    [204, 101, 157, 255],
    [123, 211, 94, 255],
    [93, 87, 218, 255],
    [225, 128, 80, 255],
    [73, 232, 172, 255],
    [181, 119, 186, 255],
    [176, 193, 112, 255],
    [105, 153, 200, 255],
    [208, 97, 120, 255],
    [90, 215, 101, 255],
    [135, 83, 222, 255],
    [229, 178, 76, 255],
    [122, 183, 181, 255],
    [190, 115, 171, 255],
    [149, 197, 108, 255],
    [100, 118, 205, 255],
    [212, 108, 93, 255],
    [86, 219, 141, 255],
    [183, 79, 226, 255],
    [233, 233, 72, 255],
    [118, 167, 187, 255],
    [194, 111, 146, 255],
    [116, 201, 104, 255],
    [115, 96, 209, 255],
    [216, 147, 89, 255],
    [82, 223, 188, 255],
    [230, 75, 224, 255],
    [163, 184, 121, 255],
    [114, 143, 191, 255],
    [198, 107, 114, 255],
    [99, 206, 122, 255],
    [153, 92, 213, 255],
    [220, 192, 85, 255],
    [78, 215, 227, 255],
    [234, 71, 173, 255],
    [141, 188, 117, 255],
    [110, 113, 195, 255],
    [202, 128, 103, 255],
    [95, 210, 157, 255],
    [195, 88, 217, 255],
    [206, 224, 81, 255],
    [74, 166, 231, 255],
    [185, 120, 139, 255],
    [113, 192, 113, 255],
    [133, 106, 199, 255],
    [207, 162, 98, 255],
    [91, 214, 198, 255],
    [221, 84, 198, 255],
    [159, 228, 77, 255],
    [70, 111, 235, 255],
    [189, 119, 116, 255],
    [109, 196, 138, 255],
    [165, 101, 204, 255],
    [211, 201, 94, 255],
    [87, 191, 218, 255],
    [225, 80, 153, 255],
    [106, 232, 73, 255],
    [124, 119, 186, 255],
    [193, 142, 112, 255],
    [105, 200, 168, 255],
    [203, 97, 208, 255],
    [184, 215, 90, 255],
    [83, 147, 222, 255],
    [229, 76, 101, 255],
    [122, 183, 130, 255],
    [146, 115, 190, 255],
    [197, 171, 108, 255],
    [100, 205, 205, 255],
    [212, 93, 177, 255],
    [141, 219, 86, 255],
    [79, 97, 226, 255],
    [233, 99, 72, 255],
    [118, 187, 150, 255],
    [173, 111, 194, 255],
    [197, 201, 104, 255],
    [96, 171, 209, 255],
    [216, 89, 137, 255],
    [94, 223, 82, 255],
    [107, 75, 230, 255],
    [184, 153, 121, 255],
    [114, 191, 175, 255],
    [198, 107, 191, 255],
    [166, 206, 99, 255],
    [92, 132, 213, 255],
    [220, 85, 91, 255],
    [78, 227, 115, 255],
    [159, 71, 234, 255],
    [188, 176, 117, 255],
    [110, 185, 195, 255],
    [202, 103, 161, 255],
    [129, 210, 95, 255],
    [88, 88, 217, 255],
    [224, 123, 81, 255],
    [74, 231, 166, 255],
    [177, 120, 185, 255],
    [179, 192, 113, 255],
    [106, 156, 199, 255],
    [207, 98, 125, 255],
    [91, 214, 96, 255],
    [130, 84, 221, 255],
    [228, 171, 77, 255],
    [70, 235, 221, 255],
    [189, 116, 174, 255],
    [153, 196, 109, 255],
    [101, 123, 204, 255],
    [211, 104, 94, 255],
    [87, 218, 136, 255],
    [177, 80, 225, 255],
    [232, 225, 73, 255],
    [119, 169, 186, 255],
    [193, 112, 149, 255],
    [121, 200, 105, 255],
    [111, 97, 208, 255],
    [215, 142, 90, 255],
    [83, 222, 181, 255],
    [229, 76, 229, 255],
    [165, 183, 122, 255],
    [115, 146, 190, 255],
    [197, 108, 119, 255],
    [100, 205, 118, 255],
    [148, 93, 212, 255],
    [219, 186, 86, 255],
    [79, 220, 226, 255],
    [233, 72, 179, 255],
    [144, 187, 118, 255],
    [111, 118, 194, 255],
    [201, 124, 104, 255],
    [96, 209, 153, 255],
    [189, 89, 216, 255],
    [211, 223, 82, 255],
    [75, 172, 230, 255],
    [184, 121, 142, 255],
    [117, 191, 114, 255],
    [130, 107, 198, 255],
    [206, 157, 99, 255],
    [92, 213, 193, 255],
    [220, 85, 203, 255],
    [165, 227, 78, 255],
    [71, 118, 234, 255],
    [188, 117, 117, 255],
    [110, 195, 135, 255],
    [161, 103, 202, 255],
    [210, 195, 95, 255],
    [88, 195, 217, 255],
    [224, 81, 158, 255],
    [113, 231, 74, 255],
    [123, 120, 185, 255],
    [192, 139, 113, 255],
    [106, 199, 164, 255],
    [198, 98, 207, 255],
    [188, 214, 91, 255],
    [84, 153, 221, 255],
    [228, 77, 108, 255],
    [70, 235, 84, 255],
    [143, 116, 189, 255],
    [196, 167, 109, 255],
    [101, 204, 199, 255],
    [211, 94, 182, 255],
    [147, 218, 87, 255],
    [80, 104, 225, 255],
    [232, 93, 73, 255],
    [119, 186, 147, 255],
    [170, 112, 193, 255],
    [200, 200, 105, 255],
    [97, 175, 208, 255],
    [215, 90, 142, 255],
    [100, 222, 83, 255],
    [101, 76, 229, 255],
    [183, 150, 122, 255],
    [115, 190, 171, 255],
    [197, 108, 194, 255],
    [170, 205, 100, 255],
    [93, 138, 212, 255],
    [219, 86, 97, 255],
    [79, 226, 110, 255],
    [153, 72, 233, 255],
    [187, 173, 118, 255],
    [111, 187, 194, 255],
    [201, 104, 165, 255],
    [134, 209, 96, 255],
    [89, 95, 216, 255],
    [223, 117, 82, 255],
    [75, 230, 159, 255],
    [174, 121, 184, 255],
    [182, 191, 114, 255],
    [107, 160, 198, 255],
    [206, 99, 130, 255],
    [92, 213, 92, 255],
    [124, 85, 220, 255],
    [227, 165, 78, 255],
    [71, 234, 214, 255],
    [188, 117, 176, 255],
    [156, 195, 110, 255],
    [103, 128, 202, 255],
    [210, 100, 95, 255],
    [88, 217, 131, 255],
    [170, 81, 224, 255],
    [231, 218, 74, 255],
    [120, 172, 185, 255],
    [192, 113, 153, 255],
    [125, 199, 106, 255],
    [107, 98, 207, 255],
    [214, 137, 91, 255],
    [84, 221, 175, 255],
    [222, 77, 228, 255],
    [194, 235, 70, 255],
    [116, 149, 189, 255],
    [196, 109, 123, 255],
    [101, 204, 114, 255],
    [143, 94, 211, 255],
    [218, 180, 87, 255],
    [80, 225, 225, 255],
    [232, 73, 186, 255],
    [147, 186, 119, 255],
    [112, 122, 193, 255],
    [200, 121, 105, 255],
    [97, 208, 148, 255],
    [184, 90, 215, 255],
    [216, 222, 83, 255],
    [76, 178, 229, 255],
    [183, 122, 145, 255],
    [121, 190, 115, 255],
    [126, 108, 197, 255],
    [205, 153, 100, 255],
    [93, 212, 187, 255],
    [219, 86, 208, 255],
    [171, 226, 79, 255],
    [72, 126, 233, 255],
    [187, 118, 121, 255],
    [111, 194, 132, 255],
    [157, 104, 201, 255],
    [209, 190, 96, 255],
    [89, 200, 216, 255],
    [223, 82, 164, 255],
    [120, 230, 75, 255],
    [121, 121, 184, 255],
    [191, 136, 114, 255],
    [107, 198, 160, 255],
    [192, 99, 206, 255],
    [193, 213, 92, 255],
    [85, 158, 220, 255],
    [227, 78, 115, 255],
    [71, 234, 78, 255],
    [141, 117, 188, 255],
    [195, 163, 110, 255],
    [103, 202, 194, 255],
    [210, 95, 186, 255],
    [153, 217, 88, 255],
    [81, 111, 224, 255],
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CORNERSTONE_COLOR_LUT);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageMouseCursor)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _MouseCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js");


const DEFAULT_NAME = 'image-cursor';
class ImageMouseCursor extends _MouseCursor__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(url, x, y, name, fallback) {
        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);
        this.url = url;
        this.x = Number(x) || 0;
        this.y = Number(y) || 0;
    }
    getStyleProperty() {
        const { url, x, y } = this;
        let style = `url('${url}')`;
        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {
            style += ` ${x} ${y}`;
        }
        return this.addFallbackStyleProperty(style);
    }
    static getUniqueInstanceName(prefix) {
        return `${prefix}-${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getRuntimeId(ImageMouseCursor)}`;
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MouseCursor),
/* harmony export */   standardCursorNames: () => (/* binding */ standardCursorNames)
/* harmony export */ });
const DEFINED_CURSORS = Symbol('DefinedCursors');
const STANDARD_CURSORS = new Set([
    'alias',
    'all-scroll',
    'auto',
    'cell',
    'col-resize',
    'context-menu',
    'copy',
    'crosshair',
    'default',
    'e-resize',
    'ew-resize',
    'grab',
    'grabbing',
    'help',
    'move',
    'ne-resize',
    'nesw-resize',
    'no-drop',
    'none',
    'not-allowed',
    'n-resize',
    'ns-resize',
    'nw-resize',
    'nwse-resize',
    'pointer',
    'progress',
    'row-resize',
    'se-resize',
    's-resize',
    'sw-resize',
    'text',
    'vertical-text',
    'wait',
    'w-resize',
    'zoom-in',
    'zoom-out',
]);
class MouseCursor {
    constructor(name, fallback) {
        this.name = name + '';
        this.fallback = fallback;
    }
    getName() {
        return this.name + '';
    }
    addFallbackStyleProperty(style) {
        const { fallback } = this;
        if (fallback instanceof MouseCursor) {
            return `${style}, ${fallback.getStyleProperty()}`;
        }
        return style + '';
    }
    getStyleProperty() {
        return this.addFallbackStyleProperty(this.name) + '';
    }
    static getDefinedCursor(name) {
        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
        let mouseCursor = definedCursors.get(name);
        if (mouseCursor instanceof MouseCursor) {
            return mouseCursor;
        }
        if (STANDARD_CURSORS.has(name)) {
            mouseCursor = new MouseCursor(name);
            definedCursors.set(name, mouseCursor);
            return mouseCursor;
        }
    }
    static setDefinedCursor(name, cursor) {
        if (cursor instanceof MouseCursor) {
            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
            definedCursors.set(name, cursor);
            return true;
        }
        return false;
    }
}
function getDefinedCursors(context, symbol) {
    let definedCursors = context[symbol];
    if (!(definedCursors instanceof Map)) {
        definedCursors = new Map();
        Object.defineProperty(context, symbol, { value: definedCursors });
    }
    return definedCursors;
}
const standardCursorNames = STANDARD_CURSORS.values();



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CursorSVG: () => (/* binding */ CursorSVG),
/* harmony export */   getDefinedSVGCursorDescriptor: () => (/* binding */ getDefinedSVGCursorDescriptor),
/* harmony export */   registerCursor: () => (/* binding */ registerCursor),
/* harmony export */   svgCursorNames: () => (/* binding */ svgCursorNames)
/* harmony export */ });
const BASE = {
    iconContent: '',
    iconSize: 16,
    viewBox: {
        x: 16,
        y: 16,
    },
    mousePoint: {
        x: 8,
        y: 8,
    },
    mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `,
};
const SEGMENTATION_CURSOR_BOUNDARIES = {
    x: 127,
    y: 60,
};
const MINUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`;
const PLUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`;
const SCISSOR_ICON = `<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>`;
const RECTANGLE_ICON = `<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>`;
const CIRCLE_ICON = `<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>`;
const CursorSVG = {
    Angle: extend(BASE, {
        name: 'Angle',
        iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    ArrowAnnotate: extend(BASE, {
        name: 'ArrowAnnotate',
        iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Bidirectional: extend(BASE, {
        name: 'Bidirectional',
        iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
        viewBox: {
            x: 48,
            y: 48,
        },
    }),
    CobbAngle: extend(BASE, {
        name: 'CobbAngle',
        iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    CircleROI: extend(BASE, {
        name: 'CircleROI',
        iconContent: `<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    EllipticalROI: extend(BASE, {
        name: 'EllipticalROI',
        iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    FreehandROI: extend(BASE, {
        name: 'FreehandROI',
        iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    FreehandROISculptor: extend(BASE, {
        name: 'FreehandROISculptor',
        iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Length: extend(BASE, {
        name: 'Length',
        iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Height: extend(BASE, {
        name: 'Height',
        iconContent: `<path d="m 6 22 l 8.5 0 v -16 h 8" stroke-width="3" fill="none" stroke="{{color}}" />`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Probe: extend(BASE, {
        name: 'Probe',
        iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    RectangleROI: extend(BASE, {
        name: 'RectangleROI',
        iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Label: extend(BASE, {
        name: 'Label',
        iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Crosshairs: extend(BASE, {
        name: 'Crosshairs',
        iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Eraser: extend(BASE, {
        name: 'Eraser',
        iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
        viewBox: {
            x: 2048,
            y: 1792,
        },
    }),
    Magnify: extend(BASE, {
        name: 'Magnify',
        iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
        viewBox: {
            x: 512,
            y: 512,
        },
    }),
    Pan: extend(BASE, {
        name: 'Pan',
        iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Rotate: extend(BASE, {
        name: 'Rotate',
        iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    StackScroll: extend(BASE, {
        name: 'StackScroll',
        iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
        viewBox: {
            x: 24,
            y: 28,
        },
    }),
    WindowLevelRegion: extend(BASE, {
        name: 'WindowLevelRegion',
        iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    WindowLevel: extend(BASE, {
        name: 'WindowLevel',
        iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Zoom: extend(BASE, {
        name: 'Zoom',
        iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
        viewBox: {
            x: 640,
            y: 512,
        },
    }),
    SegmentationFreeHandEraseInside: extend(BASE, {
        name: 'SegmentationFreeHandEraseInside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillInside: extend(BASE, {
        name: 'SegmentationFreeHandFillInside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandEraseOutside: extend(BASE, {
        name: 'SegmentationFreeHandEraseOutside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillOutside: extend(BASE, {
        name: 'SegmentationFreeHandFillOutside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationRectangleEraseInside: extend(BASE, {
        name: 'SegmentationRectangleEraseInside',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    RectangleScissor: extend(BASE, {
        name: 'RectangleScissor',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_INSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_INSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    CircleScissor: extend(BASE, {
        name: 'CircleScissor',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_INSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_INSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.ERASE_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
};
function extend(base, values) {
    return Object.assign(Object.create(base), {
        ...values,
        name: values.name || base.name,
    });
}
function registerCursor(toolName, iconContent, viewBox) {
    CursorSVG[toolName] = extend(BASE, {
        iconContent,
        viewBox,
    });
}
function getDefinedSVGCursorDescriptor(name) {
    return CursorSVG[name];
}
const svgCursorNames = Object.keys(CursorSVG);



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SVGMouseCursor)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _ImageMouseCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageMouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js");
/* harmony import */ var _SVGCursorDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SVGCursorDescriptor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js");
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stateManagement/annotation/config/helpers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js");




const PROPERTY = 'color';
const STATE = _enums__WEBPACK_IMPORTED_MODULE_0__.AnnotationStyleStates.Highlighted;
const MODE = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Active;
class SVGMouseCursor extends _ImageMouseCursor__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(url, x, y, name, fallback) {
        super(url, x, y, name, fallback);
    }
    static getDefinedCursor(name, pointer = false, color) {
        if (!color) {
            color = (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_3__.getStyleProperty)(PROPERTY, {}, STATE, MODE);
        }
        const urn = getCursorURN(name, pointer, color);
        let cursor = super.getDefinedCursor(urn);
        if (!cursor) {
            const descriptor = (0,_SVGCursorDescriptor__WEBPACK_IMPORTED_MODULE_2__.getDefinedSVGCursorDescriptor)(name);
            if (descriptor) {
                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor('default'));
                super.setDefinedCursor(urn, cursor);
            }
        }
        return cursor;
    }
}
function format(template, dictionary) {
    const dict = Object(dictionary);
    const defined = Object.prototype.hasOwnProperty.bind(dict);
    return (template + '').replace(/\{\{(\w+)\}\}/g, (match, key) => {
        return defined(key) ? dict[key] + '' : '';
    });
}
function getCursorURN(name, pointer, color) {
    const type = pointer ? 'pointer' : 'cursor';
    return `${type}:${name}/${color}`;
}
function createSVGMouseCursor(descriptor, name, pointer, color, fallback) {
    const { x, y } = descriptor.mousePoint;
    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);
}
function createSVGIconUrl(descriptor, pointer, options) {
    const blob = createSVGIconBlob(descriptor, pointer, options);
    const url = URL.createObjectURL(blob);
    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;
    return urn;
}
function createSVGIconBlob(descriptor, pointer, options) {
    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);
    return new Blob([svgString], { type: 'image/svg+xml' });
}
function createSVGIcon(descriptor, options) {
    const { iconContent, iconSize, viewBox } = descriptor;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${iconSize}" height="${iconSize}" viewBox="0 0
      ${viewBox.x} ${viewBox.y}">
      ${iconContent}
    </svg>`;
    return format(svgString, options);
}
function createSVGIconWithPointer(descriptor, options) {
    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;
    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);
    const svgSize = 16 + iconSize;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">
      <g>${mousePointerGroupString}</g>
      <g transform="translate(16, 16) scale(${scale})">${iconContent}</g>
    </svg>`;
    return format(svgString, options);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hideElementCursor: () => (/* binding */ hideElementCursor),
/* harmony export */   initElementCursor: () => (/* binding */ initElementCursor),
/* harmony export */   resetElementCursor: () => (/* binding */ resetElementCursor),
/* harmony export */   setElementCursor: () => (/* binding */ _setElementCursor)
/* harmony export */ });
/* harmony import */ var _MouseCursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js");

const ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');
function initElementCursor(element, cursor) {
    _getElementCursors(element)[0] = cursor;
    _setElementCursor(element, cursor);
}
function _setElementCursor(element, cursor) {
    const cursors = _getElementCursors(element);
    cursors[1] = cursors[0];
    cursors[0] = cursor;
    element.style.cursor = (cursor instanceof _MouseCursor__WEBPACK_IMPORTED_MODULE_0__["default"]
        ? cursor
        : _MouseCursor__WEBPACK_IMPORTED_MODULE_0__["default"].getDefinedCursor('auto')).getStyleProperty();
}
function resetElementCursor(element) {
    _setElementCursor(element, _getElementCursors(element)[1]);
}
function hideElementCursor(element) {
    _setElementCursor(element, _MouseCursor__WEBPACK_IMPORTED_MODULE_0__["default"].getDefinedCursor('none'));
}
function _getElementCursors(element) {
    let map = _getElementCursors[ELEMENT_CURSORS_MAP];
    if (!(map instanceof WeakMap)) {
        map = new WeakMap();
        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {
            value: map,
        });
    }
    let cursors = map.get(element);
    if (!cursors) {
        cursors = [null, null];
        map.set(element, cursors);
    }
    return cursors;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CursorNames: () => (/* binding */ CursorNames),
/* harmony export */   CursorSVG: () => (/* reexport safe */ _SVGCursorDescriptor__WEBPACK_IMPORTED_MODULE_5__.CursorSVG),
/* harmony export */   ImageMouseCursor: () => (/* reexport safe */ _ImageMouseCursor__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   MouseCursor: () => (/* reexport safe */ _MouseCursor__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   SVGMouseCursor: () => (/* reexport safe */ _SVGMouseCursor__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   elementCursor: () => (/* reexport module object */ _elementCursor__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   registerCursor: () => (/* reexport safe */ _SVGCursorDescriptor__WEBPACK_IMPORTED_MODULE_5__.registerCursor),
/* harmony export */   setCursorForElement: () => (/* reexport safe */ _setCursorForElement__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _MouseCursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js");
/* harmony import */ var _ImageMouseCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageMouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js");
/* harmony import */ var _SVGMouseCursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SVGMouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js");
/* harmony import */ var _elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _setCursorForElement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./setCursorForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js");
/* harmony import */ var _SVGCursorDescriptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SVGCursorDescriptor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js");






const CursorNames = [..._SVGCursorDescriptor__WEBPACK_IMPORTED_MODULE_5__.svgCursorNames, ..._MouseCursor__WEBPACK_IMPORTED_MODULE_0__.standardCursorNames];



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _elementCursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _MouseCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js");
/* harmony import */ var _SVGMouseCursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SVGMouseCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js");



function setCursorForElement(element, cursorName) {
    let cursor = _SVGMouseCursor__WEBPACK_IMPORTED_MODULE_2__["default"].getDefinedCursor(cursorName, true);
    if (!cursor) {
        cursor = _MouseCursor__WEBPACK_IMPORTED_MODULE_1__["default"].getDefinedCursor(cursorName);
    }
    if (!cursor) {
        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);
        cursor = _MouseCursor__WEBPACK_IMPORTED_MODULE_1__["default"].getDefinedCursor(cursorName);
    }
    (0,_elementCursor__WEBPACK_IMPORTED_MODULE_0__.setElementCursor)(element, cursor);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setCursorForElement);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _getHash(annotationUID, drawingElementType, nodeUID) {
    return `${annotationUID}::${drawingElementType}::${nodeUID}`;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_getHash);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getSvgDrawingHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSvgDrawingHelper */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js");

function draw(element, fn) {
    const svgDrawingHelper = (0,_getSvgDrawingHelper__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
    fn(svgDrawingHelper);
    svgDrawingHelper.clearUntouched();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (draw);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawArrow)
/* harmony export */ });
/* harmony import */ var _drawLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawLine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js");

const svgns = 'http://www.w3.org/2000/svg';
function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;
    if (!viaMarker) {
        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);
        return;
    }
    const layerId = svgDrawingHelper.svgLayerElement.id;
    const markerBaseId = `arrow-${annotationUID}`;
    const markerFullId = `${markerBaseId}-${layerId}`;
    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');
    let arrowMarker = defs.querySelector(`#${markerFullId}`);
    if (!arrowMarker) {
        arrowMarker = document.createElementNS(svgns, 'marker');
        arrowMarker.setAttribute('id', markerFullId);
        arrowMarker.setAttribute('viewBox', '0 0 10 10');
        arrowMarker.setAttribute('refX', '8');
        arrowMarker.setAttribute('refY', '5');
        arrowMarker.setAttribute('markerWidth', `${markerSize}`);
        arrowMarker.setAttribute('markerHeight', `${markerSize}`);
        arrowMarker.setAttribute('orient', 'auto');
        const arrowPath = document.createElementNS(svgns, 'path');
        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
        arrowPath.setAttribute('fill', color);
        arrowMarker.appendChild(arrowPath);
        defs.appendChild(arrowMarker);
    }
    else {
        arrowMarker.setAttribute('markerWidth', `${markerSize}`);
        arrowMarker.setAttribute('markerHeight', `${markerSize}`);
        const arrowPath = arrowMarker.querySelector('path');
        if (arrowPath) {
            arrowPath.setAttribute('fill', color);
        }
    }
    options.markerEndId = markerFullId;
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, arrowUID, start, end, options);
}
function legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;
    const headLength = 10;
    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);
    const firstLine = {
        start: [
            end[0] - headLength * Math.cos(angle - Math.PI / 7),
            end[1] - headLength * Math.sin(angle - Math.PI / 7),
        ],
        end: end,
    };
    const secondLine = {
        start: [
            end[0] - headLength * Math.cos(angle + Math.PI / 7),
            end[1] - headLength * Math.sin(angle + Math.PI / 7),
        ],
        end: end,
    };
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, arrowUID, start, end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");



function drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {
    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        fill: 'transparent',
        width: '2',
        lineDash: undefined,
        lineWidth: undefined,
        strokeOpacity: 1,
        fillOpacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'circle', circleUID);
    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    const attributes = {
        cx: `${center[0]}`,
        cy: `${center[1]}`,
        r: `${radius}`,
        stroke: color,
        fill,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'fill-opacity': fillOpacity,
        'stroke-opacity': strokeOpacity,
    };
    if (existingCircleElement) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, existingCircleElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newCircleElement = document.createElementNS(svgns, 'circle');
        if (dataId !== '') {
            newCircleElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, newCircleElement);
        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawCircle);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _drawEllipseByCoordinates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawEllipseByCoordinates */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js");


function drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {
    const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];
    const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];
    const left = [corner1[0], (corner1[1] + corner2[1]) / 2];
    const right = [corner2[0], (corner1[1] + corner2[1]) / 2];
    (0,_drawEllipseByCoordinates__WEBPACK_IMPORTED_MODULE_1__["default"])(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], (options = {}), (dataId = ''));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawEllipse);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");



function drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'ellipse', ellipseUID);
    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [bottom, top, left, right] = canvasCoordinates;
    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);
    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);
    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;
    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];
    const radiusX = w / 2;
    const radiusY = h / 2;
    const attributes = {
        cx: `${center[0]}`,
        cy: `${center[1]}`,
        rx: `${radiusX}`,
        ry: `${radiusY}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingEllipse) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, existingEllipse);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');
        if (dataId !== '') {
            svgEllipseElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, svgEllipseElement);
        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawEllipseByCoordinates);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");



function drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {
    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({
        color: 'rgb(0, 255, 0)',
        handleRadius: '6',
        width: '2',
        lineWidth: undefined,
        fill: 'transparent',
        type: 'circle',
        opacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);
    let attributes;
    if (type === 'circle') {
        attributes = {
            cx: `${handle[0]}`,
            cy: `${handle[1]}`,
            r: handleRadius,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            opacity: opacity,
        };
    }
    else if (type === 'rect') {
        const handleRadiusFloat = parseFloat(handleRadius);
        const side = handleRadiusFloat * 1.5;
        const x = handle[0] - side * 0.5;
        const y = handle[1] - side * 0.5;
        attributes = {
            x: `${x}`,
            y: `${y}`,
            width: `${side}`,
            height: `${side}`,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            rx: `${side * 0.1}`,
            opacity: opacity,
        };
    }
    else {
        throw new Error(`Unsupported handle type: ${type}`);
    }
    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingHandleElement) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, existingHandleElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newHandleElement = document.createElementNS(svgns, type);
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, newHandleElement);
        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawHandle);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _drawHandle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawHandle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js");

function drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {
    handlePoints.forEach((handle, i) => {
        (0,_drawHandle__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawHandles);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawHeight)
/* harmony export */ });
/* harmony import */ var _drawLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawLine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js");

function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const midX = end[0] + (start[0] - end[0]) / 2;
    const endfirstLine = [midX, start[1]];
    const endsecondLine = [midX, end[1]];
    const firstLine = {
        start: start,
        end: endfirstLine,
    };
    const secondLine = {
        start: endfirstLine,
        end: endsecondLine,
    };
    const threeLine = {
        start: endsecondLine,
        end: end,
    };
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawLine)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");



function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color = 'rgb(0, 255, 0)', width = 10, lineWidth, lineDash, markerStartId = null, markerEndId = null, shadow = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'line', lineUID);
    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    const layerId = svgDrawingHelper.svgLayerElement.id;
    const dropShadowStyle = shadow ? `filter:url(#shadow-${layerId});` : '';
    const attributes = {
        x1: `${start[0]}`,
        y1: `${start[1]}`,
        x2: `${end[0]}`,
        y2: `${end[1]}`,
        stroke: color,
        style: dropShadowStyle,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'marker-start': markerStartId ? `url(#${markerStartId})` : '',
        'marker-end': markerEndId ? `url(#${markerEndId})` : '',
    };
    if (existingLine) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, existingLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newLine = document.createElementNS(svgns, 'line');
        if (dataId !== '') {
            newLine.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, newLine);
        svgDrawingHelper.appendNode(newLine, svgNodeHash);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _drawLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawLine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js");
/* harmony import */ var _utilities_math_vec2_findClosestPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/math/vec2/findClosestPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js");


function drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {
    const start = annotationAnchorPoints.length > 0
        ? (0,_utilities_math_vec2_findClosestPoint__WEBPACK_IMPORTED_MODULE_1__["default"])(annotationAnchorPoints, refPoint)
        : refPoint;
    const boundingBoxPoints = _boundingBoxPoints(boundingBox);
    const end = (0,_utilities_math_vec2_findClosestPoint__WEBPACK_IMPORTED_MODULE_1__["default"])(boundingBoxPoints, start);
    const mergedOptions = Object.assign({
        color: 'rgb(255, 255, 0)',
        lineWidth: '1',
        lineDash: '2,3',
    }, options);
    (0,_drawLine__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);
}
function _boundingBoxPoints(boundingBox) {
    const { x: left, y: top, height, width } = boundingBox;
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const topMiddle = [left + halfWidth, top];
    const leftMiddle = [left, top + halfHeight];
    const bottomMiddle = [left + halfWidth, top + height];
    const rightMiddle = [left + width, top + halfHeight];
    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawLink);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _drawTextBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawTextBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js");
/* harmony import */ var _drawLink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawLink */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js");


function drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {
    const mergedOptions = Object.assign({
        handleRadius: '6',
        centering: {
            x: false,
            y: true,
        },
    }, options);
    const canvasBoundingBox = (0,_drawTextBox__WEBPACK_IMPORTED_MODULE_0__["default"])(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);
    (0,_drawLink__WEBPACK_IMPORTED_MODULE_1__["default"])(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);
    return canvasBoundingBox;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawLinkedTextBox);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawPath)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");



function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {
    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);
    const pointsArrays = hasSubArrays ? points : [points];
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'path', pathUID);
    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {
        const points = pointsArrays[i];
        const numPoints = points.length;
        if (numPoints < 2) {
            continue;
        }
        for (let j = 0; j < numPoints; j++) {
            const point = points[j];
            const cmd = j ? 'L' : 'M';
            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
        }
        if (closePath) {
            pointsAttribute += 'Z ';
        }
    }
    if (!pointsAttribute) {
        return;
    }
    const attributes = {
        d: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingNode) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, existingNode);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newNode = document.createElementNS(svgns, 'path');
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, newNode);
        svgDrawingHelper.appendNode(newNode, svgNodeHash);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawPolyline)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");



function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {
    if (points.length < 2) {
        return;
    }
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, markerStartId = null, markerEndId = null, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'polyline', polylineUID);
    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (const point of points) {
        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
    }
    if (closePath) {
        const firstPoint = points[0];
        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;
    }
    const attributes = {
        points: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'marker-start': markerStartId ? `url(#${markerStartId})` : '',
        'marker-end': markerEndId ? `url(#${markerEndId})` : '',
    };
    if (existingPolyLine) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, existingPolyLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newPolyLine = document.createElementNS(svgns, 'polyline');
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, newPolyLine);
        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawRect)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _drawRectByCoordinates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawRectByCoordinates */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js");


function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {
    const topLeft = [start[0], start[1]];
    const topRight = [end[0], start[1]];
    const bottomLeft = [start[0], end[1]];
    const bottomRight = [end[0], end[1]];
    (0,_drawRectByCoordinates__WEBPACK_IMPORTED_MODULE_1__["default"])(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawRectByCoordinates)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");



function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;
    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);
    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);
    const center = [
        (bottomRight[0] + topLeft[0]) / 2,
        (bottomRight[1] + topLeft[1]) / 2,
    ];
    const leftEdgeCenter = [
        (bottomLeft[0] + topLeft[0]) / 2,
        (bottomLeft[1] + topLeft[1]) / 2,
    ];
    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *
        180) /
        Math.PI;
    const attributes = {
        x: `${center[0] - width / 2}`,
        y: `${center[1] - height / 2}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        if (dataId !== '') {
            svgRectElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ drawRedactionRect)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");



function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];
    const width = Math.abs(start[0] - end[0]);
    const height = Math.abs(start[1] - end[1]);
    const attributes = {
        x: `${tlhc[0]}`,
        y: `${tlhc[1]}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'black',
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__["default"])(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getHash */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");


function drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {
    const mergedOptions = Object.assign({
        fontFamily: 'Helvetica, Arial, sans-serif',
        fontSize: '14px',
        color: 'rgb(255, 255, 0)',
        background: '',
        padding: 25,
        centerX: false,
        centerY: true,
    }, options);
    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);
    return textGroupBoundingBox;
}
function _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {
    const { padding, color, fontFamily, fontSize, background } = options;
    let textGroupBoundingBox;
    const [x, y] = [position[0] + padding, position[1] + padding];
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__["default"])(annotationUID, 'text', textUID);
    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingTextGroup) {
        const textElement = existingTextGroup.querySelector('text');
        const textSpans = Array.from(textElement.children);
        for (let i = 0; i < textSpans.length; i++) {
            const textSpanElement = textSpans[i];
            const text = textLines[i] || '';
            textSpanElement.textContent = text;
        }
        if (textLines.length > textSpans.length) {
            for (let i = 0; i < textLines.length - textSpans.length; i++) {
                const textLine = textLines[i + textSpans.length];
                const textSpan = _createTextSpan(textLine);
                textElement.appendChild(textSpan);
            }
            existingTextGroup.appendChild(textElement);
            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);
        }
        const textAttributes = {
            fill: color,
            'font-size': fontSize,
            'font-family': fontFamily,
        };
        const textGroupAttributes = {
            transform: `translate(${x} ${y})`,
        };
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__["default"])(textAttributes, textElement);
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__["default"])(textGroupAttributes, existingTextGroup);
        existingTextGroup.setAttribute('data-annotation-uid', annotationUID);
        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const textGroup = document.createElementNS(svgns, 'g');
        textGroup.setAttribute('data-annotation-uid', annotationUID);
        textGroup.setAttribute('transform', `translate(${x} ${y})`);
        const textElement = _createTextElement(svgDrawingHelper, options);
        for (let i = 0; i < textLines.length; i++) {
            const textLine = textLines[i];
            const textSpan = _createTextSpan(textLine);
            textElement.appendChild(textSpan);
        }
        textGroup.appendChild(textElement);
        svgDrawingHelper.appendNode(textGroup, svgNodeHash);
        textGroupBoundingBox = _drawTextBackground(textGroup, background);
    }
    return Object.assign({}, textGroupBoundingBox, {
        x,
        y,
        height: textGroupBoundingBox.height + padding,
        width: textGroupBoundingBox.width + padding,
    });
}
function _createTextElement(svgDrawingHelper, options) {
    const { color, fontFamily, fontSize } = options;
    const svgns = 'http://www.w3.org/2000/svg';
    const textElement = document.createElementNS(svgns, 'text');
    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';
    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;
    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;
    textElement.setAttribute('x', '0');
    textElement.setAttribute('y', '0');
    textElement.setAttribute('fill', color);
    textElement.setAttribute('font-family', fontFamily);
    textElement.setAttribute('font-size', fontSize);
    textElement.setAttribute('style', combinedStyle);
    textElement.setAttribute('pointer-events', 'visible');
    return textElement;
}
function _createTextSpan(text) {
    const svgns = 'http://www.w3.org/2000/svg';
    const textSpanElement = document.createElementNS(svgns, 'tspan');
    textSpanElement.setAttribute('x', '0');
    textSpanElement.setAttribute('dy', '1.2em');
    textSpanElement.textContent = text;
    return textSpanElement;
}
function _drawTextBackground(group, color) {
    let element = group.querySelector('rect.background');
    if (!color) {
        if (element) {
            group.removeChild(element);
        }
        return group.getBBox();
    }
    if (!element) {
        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        element.setAttribute('class', 'background');
        group.insertBefore(element, group.firstChild);
    }
    const bBox = group.getBBox();
    const attributes = {
        x: `${bBox.x}`,
        y: `${bBox.y}`,
        width: `${bBox.width}`,
        height: `${bBox.height}`,
        fill: color,
    };
    (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__["default"])(attributes, element);
    return bBox;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawTextBox);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


const VIEWPORT_ELEMENT = 'viewport-element';
function getSvgDrawingHelper(element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement;
    const canvasHash = `${viewportId}:${renderingEngineId}`;
    const svgLayerElement = _getSvgLayer(element);
    Object.keys(_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash]).forEach((cacheKey) => {
        _store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey].touched = false;
    });
    return {
        svgLayerElement: svgLayerElement,
        svgNodeCacheForCanvas: _store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache,
        getSvgNode: getSvgNode.bind(this, canvasHash),
        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),
        setNodeTouched: setNodeTouched.bind(this, canvasHash),
        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),
    };
}
function _getSvgLayer(element) {
    const viewportElement = `.${VIEWPORT_ELEMENT}`;
    const internalDivElement = element.querySelector(viewportElement);
    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');
    return svgLayer;
}
function getSvgNode(canvasHash, cacheKey) {
    if (!_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash]) {
        return;
    }
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey]) {
        return _store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey].domRef;
    }
}
function appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {
    if (!_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash]) {
        return null;
    }
    _store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey] = {
        touched: true,
        domRef: svgNode,
    };
    svgLayerElement.appendChild(svgNode);
}
function setNodeTouched(canvasHash, cacheKey) {
    if (!_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash]) {
        return;
    }
    if (_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey]) {
        _store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey].touched = true;
    }
}
function clearUntouched(svgLayerElement, canvasHash) {
    if (!_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash]) {
        return;
    }
    Object.keys(_store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash]).forEach((cacheKey) => {
        const cacheEntry = _store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey];
        if (!cacheEntry.touched && cacheEntry.domRef) {
            svgLayerElement.removeChild(cacheEntry.domRef);
            delete _store_state__WEBPACK_IMPORTED_MODULE_0__.state.svgNodeCache[canvasHash][cacheKey];
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSvgDrawingHelper);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   draw: () => (/* reexport safe */ _draw__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   drawArrow: () => (/* reexport safe */ _drawArrow__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   drawCircle: () => (/* reexport safe */ _drawCircle__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   drawEllipse: () => (/* reexport safe */ _drawEllipse__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   drawEllipseByCoordinates: () => (/* reexport safe */ _drawEllipseByCoordinates__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   drawHandle: () => (/* reexport safe */ _drawHandle__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   drawHandles: () => (/* reexport safe */ _drawHandles__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   drawHeight: () => (/* reexport safe */ _drawHeight__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   drawLine: () => (/* reexport safe */ _drawLine__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   drawLinkedTextBox: () => (/* reexport safe */ _drawLinkedTextBox__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   drawPath: () => (/* reexport safe */ _drawPath__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   drawPolyline: () => (/* reexport safe */ _drawPolyline__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   drawRect: () => (/* reexport safe */ _drawRect__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   drawRectByCoordinates: () => (/* reexport safe */ _drawRectByCoordinates__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   drawRedactionRect: () => (/* reexport safe */ _drawRedactionRect__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   drawTextBox: () => (/* reexport safe */ _drawTextBox__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   setAttributesIfNecessary: () => (/* reexport safe */ _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   setNewAttributesIfValid: () => (/* reexport safe */ _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_17__["default"])
/* harmony export */ });
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js");
/* harmony import */ var _drawCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js");
/* harmony import */ var _drawEllipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawEllipse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js");
/* harmony import */ var _drawEllipseByCoordinates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawEllipseByCoordinates */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js");
/* harmony import */ var _drawHandles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawHandles */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js");
/* harmony import */ var _drawHandle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawHandle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js");
/* harmony import */ var _drawLine__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./drawLine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js");
/* harmony import */ var _drawHeight__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drawHeight */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js");
/* harmony import */ var _drawPolyline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./drawPolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js");
/* harmony import */ var _drawPath__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./drawPath */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js");
/* harmony import */ var _drawLinkedTextBox__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./drawLinkedTextBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js");
/* harmony import */ var _drawRect__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./drawRect */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js");
/* harmony import */ var _drawRectByCoordinates__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./drawRectByCoordinates */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js");
/* harmony import */ var _drawTextBox__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./drawTextBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js");
/* harmony import */ var _drawArrow__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./drawArrow */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js");
/* harmony import */ var _drawRedactionRect__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./drawRedactionRect */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js");
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./setAttributesIfNecessary */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js");
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./setNewAttributesIfValid */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js");





















/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   setAttributesIfNecessary: () => (/* binding */ setAttributesIfNecessary)
/* harmony export */ });
function setAttributesIfNecessary(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const currentValue = svgNode.getAttribute(key);
        const newValue = attributes[key];
        if (newValue === undefined || newValue === '') {
            svgNode.removeAttribute(key);
        }
        else if (currentValue !== newValue) {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setAttributesIfNecessary);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   setNewAttributesIfValid: () => (/* binding */ setNewAttributesIfValid)
/* harmony export */ });
function setNewAttributesIfValid(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const newValue = attributes[key];
        if (newValue !== undefined && newValue !== '') {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setNewAttributesIfValid);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");

const getMouseModifierKey = (evt) => {
    if (evt.shiftKey) {
        if (evt.ctrlKey) {
            return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.ShiftCtrl;
        }
        if (evt.altKey) {
            return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.ShiftAlt;
        }
        if (evt.metaKey) {
            return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.ShiftMeta;
        }
        return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.Shift;
    }
    if (evt.ctrlKey) {
        if (evt.altKey) {
            return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.CtrlAlt;
        }
        if (evt.metaKey) {
            return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.CtrlMeta;
        }
        return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.Ctrl;
    }
    if (evt.altKey) {
        return (evt.metaKey && _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.AltMeta) || _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.Alt;
    }
    if (evt.metaKey) {
        return _enums__WEBPACK_IMPORTED_MODULE_0__.KeyboardBindings.Meta;
    }
    return undefined;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getMouseModifierKey);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createPolylineHole: () => (/* binding */ createPolylineHole),
/* harmony export */   "default": () => (/* binding */ contourSegmentationCompletedListener)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utilities/getViewportsForAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../types/ContourAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utilities/contours/updateContourPolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js");
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../utilities/contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _store_addTool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../store/addTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js");












const DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';
async function contourSegmentationCompletedListener(evt) {
    const sourceAnnotation = evt.detail
        .annotation;
    if (!(0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.isContourSegmentationAnnotation)(sourceAnnotation)) {
        return;
    }
    const viewport = getViewport(sourceAnnotation);
    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);
    if (!contourSegmentationAnnotations.length) {
        return;
    }
    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);
    const targetAnnotationInfo = findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations);
    if (!targetAnnotationInfo) {
        return;
    }
    const { targetAnnotation, targetPolyline, isContourHole } = targetAnnotationInfo;
    if (isContourHole) {
        const { contourHoleProcessingEnabled = false } = evt.detail;
        if (!contourHoleProcessingEnabled) {
            return;
        }
        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);
    }
    else {
        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);
    }
}
function isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {
    const toolName = 'PlanarFreehandContourSegmentationTool';
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroupForViewport)(viewport.id, viewport.renderingEngineId);
    let errorMessage;
    if (!toolGroup.hasTool(toolName)) {
        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;
    }
    else if (!toolGroup.getToolOptions(toolName)) {
        errorMessage = `Tool ${toolName} must be in active/passive state`;
    }
    if (errorMessage && !silent) {
        console.warn(errorMessage);
    }
    return !errorMessage;
}
function getViewport(annotation) {
    const viewports = (0,_utilities_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_1__["default"])(annotation);
    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));
    return viewportWithToolRegistered ?? viewports[0];
}
function convertContourPolylineToCanvasSpace(polyline, viewport) {
    const numPoints = polyline.length;
    const projectedPolyline = new Array(numPoints);
    for (let i = 0; i < numPoints; i++) {
        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
    }
    return projectedPolyline;
}
function getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {
    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;
    const allAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAllAnnotations)();
    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&
        targetAnnotation.annotationUID !== sourceAnnotationUID &&
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.isContourSegmentationAnnotation)(targetAnnotation) &&
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.areSameSegment)(targetAnnotation, sourceAnnotation) &&
        viewport.isReferenceViewable(targetAnnotation.metadata));
}
function findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations) {
    const sourceAABB = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.getAABB(sourcePolyline);
    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {
        const targetAnnotation = contourSegmentationAnnotations[i];
        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);
        const targetAABB = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.getAABB(targetPolyline);
        const aabbIntersect = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.aabb.intersectAABB(sourceAABB, targetAABB);
        const lineSegmentsIntersect = aabbIntersect &&
            _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.intersectPolyline(sourcePolyline, targetPolyline);
        const isContourHole = aabbIntersect &&
            !lineSegmentsIntersect &&
            _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoints(targetPolyline, sourcePolyline);
        if (lineSegmentsIntersect || isContourHole) {
            return { targetAnnotation, targetPolyline, isContourHole };
        }
    }
}
function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {
    const { windingDirection: targetWindingDirection } = targetAnnotation.data.contour;
    const { windingDirection: holeWindingDirection } = holeAnnotation.data.contour;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addChildAnnotation)(targetAnnotation, holeAnnotation);
    (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.removeContourSegmentationAnnotation)(holeAnnotation);
    const { contour: holeContour } = holeAnnotation.data;
    const holePolyline = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);
    (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__["default"])(holeAnnotation, {
        points: holePolyline,
        closed: holeContour.closed,
    }, viewport);
    const { element } = viewport;
    const updatedToolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOL_NAME,
        targetAnnotation.metadata.toolName,
        holeAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedToolNames.values()) {
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, toolName);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportIdsToRender);
    }
}
function getContourHolesData(viewport, annotation) {
    return (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getChildAnnotations)(annotation).map((holeAnnotation) => {
        const polyline = convertContourPolylineToCanvasSpace(holeAnnotation.data.contour.polyline, viewport);
        return { annotation: holeAnnotation, polyline };
    });
}
function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {
    if (!(0,_store_addTool__WEBPACK_IMPORTED_MODULE_11__.hasToolByName)(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {
        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone`);
        return;
    }
    if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {
        return;
    }
    const sourceStartPoint = sourcePolyline[0];
    const mergePolylines = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoint(targetPolyline, sourceStartPoint);
    const contourHolesData = getContourHolesData(viewport, targetAnnotation);
    const unassignedContourHolesSet = new Set(contourHolesData);
    const reassignedContourHolesMap = new Map();
    const assignHoleToPolyline = (parentPolyline, holeData) => {
        let holes = reassignedContourHolesMap.get(parentPolyline);
        if (!holes) {
            holes = [];
            reassignedContourHolesMap.set(parentPolyline, holes);
        }
        holes.push(holeData);
        unassignedContourHolesSet.delete(holeData);
    };
    const newPolylines = [];
    if (mergePolylines) {
        const mergedPolyline = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.mergePolylines(targetPolyline, sourcePolyline);
        newPolylines.push(mergedPolyline);
        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));
    }
    else {
        const subtractedPolylines = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.subtractPolylines(targetPolyline, sourcePolyline);
        subtractedPolylines.forEach((newPolyline) => {
            newPolylines.push(newPolyline);
            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {
                const containsHole = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoints(newPolyline, holeData.polyline);
                if (containsHole) {
                    assignHoleToPolyline(newPolyline, holeData);
                    unassignedContourHolesSet.delete(holeData);
                }
            });
        });
    }
    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.clearParentAnnotation)(contourHoleData.annotation)));
    const { element } = viewport;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { metadata, data } = targetAnnotation;
    const { handles, segmentation } = data;
    const { textBox } = handles;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(sourceAnnotation.annotationUID);
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(targetAnnotation.annotationUID);
    for (let i = 0; i < newPolylines.length; i++) {
        const polyline = newPolylines[i];
        const startPoint = viewport.canvasToWorld(polyline[0]);
        const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);
        const newAnnotation = {
            metadata: {
                ...metadata,
                toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,
                originalToolName: metadata.originalToolName || metadata.toolName,
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [startPoint, endPoint],
                    textBox: textBox ? { ...textBox } : undefined,
                },
                contour: {
                    polyline: [],
                    closed: true,
                },
                spline: targetAnnotation.data.spline,
                segmentation: {
                    ...segmentation,
                },
            },
            annotationUID: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
            highlighted: true,
            invalidated: true,
            isLocked: false,
            isVisible: undefined,
            interpolationUID: targetAnnotation.interpolationUID,
            interpolationCompleted: targetAnnotation.interpolationCompleted,
        };
        (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__["default"])(newAnnotation, {
            points: polyline,
            closed: true,
            targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__.ContourWindingDirection.Clockwise,
        }, viewport);
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(newAnnotation, element);
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.addContourSegmentationAnnotation)(newAnnotation);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(newAnnotation, viewport.element);
        reassignedContourHolesMap
            .get(polyline)
            ?.forEach((holeData) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addChildAnnotation)(newAnnotation, holeData.annotation));
    }
    updateViewports(enabledElement, targetAnnotation, sourceAnnotation);
}
function updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {
    const { viewport } = enabledElement;
    const { element } = viewport;
    const updatedTtoolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOL_NAME,
        targetAnnotation.metadata.toolName,
        sourceAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedTtoolNames.values()) {
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, toolName);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportIdsToRender);
    }
    return new Promise((resolve) => window.requestAnimationFrame(resolve));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnnotationGroup)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");



class AnnotationGroup {
    constructor() {
        this.annotationUIDs = new Set();
        this._isVisible = true;
        this.visibleFilter = this.unboundVisibleFilter.bind(this);
    }
    unboundVisibleFilter(uid) {
        return !this._isVisible || !this.annotationUIDs.has(uid);
    }
    has(uid) {
        return this.annotationUIDs.has(uid);
    }
    setVisible(isVisible = true, baseEvent, filter) {
        if (this._isVisible === isVisible) {
            return;
        }
        this._isVisible = isVisible;
        this.annotationUIDs.forEach((uid) => {
            const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(uid);
            if (!annotation) {
                this.annotationUIDs.delete(uid);
                return;
            }
            if (annotation.isVisible === isVisible) {
                return;
            }
            if (!isVisible && filter?.(uid) === false) {
                return;
            }
            annotation.isVisible = isVisible;
            const eventDetail = {
                ...baseEvent,
                annotation,
            };
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums_Events__WEBPACK_IMPORTED_MODULE_1__["default"].ANNOTATION_MODIFIED, eventDetail);
        });
    }
    get isVisible() {
        return this._isVisible;
    }
    findNearby(uid, direction) {
        const uids = [...this.annotationUIDs];
        if (uids.length === 0) {
            return null;
        }
        if (!uid) {
            return uids[direction === 1 ? 0 : uids.length - 1];
        }
        const index = uids.indexOf(uid);
        if (index === -1 ||
            index + direction < 0 ||
            index + direction >= uids.length) {
            return null;
        }
        return uids[index + direction];
    }
    add(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));
    }
    remove(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));
    }
    clear() {
        this.annotationUIDs.clear();
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotationRenderingEngine: () => (/* binding */ annotationRenderingEngine)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/getToolsWithModesForElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js");




const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
class AnnotationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._renderFlaggedViewports = () => {
            this._throwIfDestroyed();
            const elements = Array.from(this._viewportElements.values());
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                if (this._needsRender.has(element)) {
                    this._triggerRender(element);
                    this._needsRender.delete(element);
                    if (this._needsRender.size === 0) {
                        break;
                    }
                }
            }
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            this._render();
        };
        this._viewportElements = new Map();
    }
    addViewportElement(viewportId, element) {
        this._viewportElements.set(viewportId, element);
    }
    removeViewportElement(viewportId, element) {
        this._viewportElements.delete(viewportId);
        this._needsRender.delete(element);
        this._reset();
    }
    renderViewport(element) {
        this._setViewportsToBeRenderedNextFrame([element]);
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setAllViewportsToBeRenderedNextFrame() {
        const elements = [...this._viewportElements.values()];
        elements.forEach((element) => {
            this._needsRender.add(element);
        });
        this._renderFlaggedViewports();
    }
    _setViewportsToBeRenderedNextFrame(elements) {
        const elementsEnabled = [...this._viewportElements.values()];
        elements.forEach((element) => {
            if (elementsEnabled.indexOf(element) !== -1) {
                this._needsRender.add(element);
            }
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(element) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(enabledElement.renderingEngineId);
        if (!renderingEngine) {
            console.warn('rendering Engine has been destroyed');
            return;
        }
        const enabledTools = (0,_utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__["default"])(element, [
            Active,
            Passive,
            Enabled,
        ]);
        const { renderingEngineId, viewportId } = enabledElement;
        const eventDetail = {
            element,
            renderingEngineId,
            viewportId,
        };
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.draw)(element, (svgDrawingHelper) => {
            let anyRendered = false;
            const handleDrawSvg = (tool) => {
                if (tool.renderAnnotation) {
                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);
                    anyRendered = anyRendered || rendered;
                }
            };
            enabledTools.forEach(handleDrawSvg);
            if (anyRendered) {
                (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(element, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_RENDERED, { ...eventDetail });
            }
        });
    }
    _reset() {
        window.cancelAnimationFrame(this._animationFrameHandle);
        this._needsRender.clear();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._setAllViewportsToBeRenderedNextFrame();
    }
}
const annotationRenderingEngine = new AnnotationRenderingEngine();



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultFrameOfReferenceSpecificAnnotationManager: () => (/* binding */ defaultFrameOfReferenceSpecificAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

class FrameOfReferenceSpecificAnnotationManager {
    constructor(uid) {
        this.getGroupKey = (annotationGroupSelector) => {
            if (typeof annotationGroupSelector === 'string') {
                return annotationGroupSelector;
            }
            const element = annotationGroupSelector;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');
            }
            return enabledElement.FrameOfReferenceUID;
        };
        this._imageVolumeModifiedHandler = (evt) => {
            const eventDetail = evt.detail;
            const { FrameOfReferenceUID } = eventDetail;
            const annotations = this.annotations;
            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
            if (!frameOfReferenceSpecificAnnotations) {
                return;
            }
            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                toolSpecificAnnotations.forEach((annotation) => {
                    const invalidated = annotation.invalidated;
                    if (invalidated !== undefined) {
                        annotation.invalidated = true;
                    }
                });
            });
        };
        this.getFramesOfReference = () => {
            return Object.keys(this.annotations);
        };
        this.getAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (!annotations[groupKey]) {
                return [];
            }
            if (toolName) {
                return annotations[groupKey][toolName]
                    ? annotations[groupKey][toolName]
                    : [];
            }
            return annotations[groupKey];
        };
        this.getAnnotation = (annotationUID) => {
            const annotations = this.annotations;
            for (const frameOfReferenceUID in annotations) {
                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];
                for (const toolName in frameOfReferenceAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];
                    for (const annotation of toolSpecificAnnotations) {
                        if (annotationUID === annotation.annotationUID) {
                            return annotation;
                        }
                    }
                }
            }
        };
        this.getNumberOfAnnotations = (groupKey, toolName) => {
            const annotations = this.getAnnotations(groupKey, toolName);
            if (!annotations.length) {
                return 0;
            }
            if (toolName) {
                return annotations.length;
            }
            let total = 0;
            for (const toolName in annotations) {
                total += annotations[toolName].length;
            }
            return total;
        };
        this.addAnnotation = (annotation, groupKey) => {
            const { metadata } = annotation;
            const { FrameOfReferenceUID, toolName } = metadata;
            groupKey = groupKey || FrameOfReferenceUID;
            const annotations = this.annotations;
            let frameOfReferenceSpecificAnnotations = annotations[groupKey];
            if (!frameOfReferenceSpecificAnnotations) {
                annotations[groupKey] = {};
                frameOfReferenceSpecificAnnotations = annotations[groupKey];
            }
            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            if (!toolSpecificAnnotations) {
                frameOfReferenceSpecificAnnotations[toolName] = [];
                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            }
            if (this.preprocessingFn) {
                annotation = this.preprocessingFn(annotation);
            }
            toolSpecificAnnotations.push(annotation);
        };
        this.removeAnnotation = (annotationUID) => {
            const { annotations } = this;
            for (const groupKey in annotations) {
                const groupAnnotations = annotations[groupKey];
                for (const toolName in groupAnnotations) {
                    const toolAnnotations = groupAnnotations[toolName];
                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);
                    if (index !== -1) {
                        toolAnnotations.splice(index, 1);
                        if (toolAnnotations.length === 0) {
                            delete groupAnnotations[toolName];
                        }
                    }
                }
                if (Object.keys(groupAnnotations).length === 0) {
                    delete annotations[groupKey];
                }
            }
        };
        this.removeAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            const removedAnnotations = [];
            if (!annotations[groupKey]) {
                return removedAnnotations;
            }
            if (toolName) {
                const annotationsForTool = annotations[groupKey][toolName];
                for (const annotation of annotationsForTool) {
                    this.removeAnnotation(annotation.annotationUID);
                    removedAnnotations.push(annotation);
                }
            }
            else {
                for (const toolName in annotations[groupKey]) {
                    const annotationsForTool = annotations[groupKey][toolName];
                    for (const annotation of annotationsForTool) {
                        this.removeAnnotation(annotation.annotationUID);
                        removedAnnotations.push(annotation);
                    }
                }
            }
            return removedAnnotations;
        };
        this.saveAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    return;
                }
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                return structuredClone(toolSpecificAnnotations);
            }
            else if (groupKey) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                return structuredClone(frameOfReferenceSpecificAnnotations);
            }
            return structuredClone(annotations);
        };
        this.restoreAnnotations = (state, groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                let frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    annotations[groupKey] = {};
                    frameOfReferenceSpecificAnnotations = annotations[groupKey];
                }
                frameOfReferenceSpecificAnnotations[toolName] = state;
            }
            else if (groupKey) {
                annotations[groupKey] = state;
            }
            else {
                this.annotations = structuredClone(state);
            }
        };
        this.getAllAnnotations = () => {
            return Object.values(this.annotations)
                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))
                .flat(2);
        };
        this.getNumberOfAllAnnotations = () => {
            let count = 0;
            const annotations = this.annotations;
            for (const groupKey in annotations) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                for (const toolName in frameOfReferenceSpecificAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                    count += toolSpecificAnnotations.length;
                }
            }
            return count;
        };
        this.removeAllAnnotations = () => {
            const removedAnnotations = [];
            for (const annotation of this.getAllAnnotations()) {
                this.removeAnnotation(annotation.annotationUID);
                removedAnnotations.push(annotation);
            }
            return removedAnnotations;
        };
        if (!uid) {
            uid = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        }
        this.annotations = {};
        this.uid = uid;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
    }
    setPreprocessingFn(preprocessingFn) {
        this.preprocessingFn = preprocessingFn;
    }
}
const defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FrameOfReferenceSpecificAnnotationManager);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationLocked: () => (/* binding */ checkAndSetAnnotationLocked),
/* harmony export */   getAnnotationsLocked: () => (/* binding */ getAnnotationsLocked),
/* harmony export */   getAnnotationsLockedCount: () => (/* binding */ getAnnotationsLockedCount),
/* harmony export */   isAnnotationLocked: () => (/* binding */ isAnnotationLocked),
/* harmony export */   setAnnotationLocked: () => (/* binding */ setAnnotationLocked),
/* harmony export */   unlockAllAnnotations: () => (/* binding */ unlockAllAnnotations)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");



const globalLockedAnnotationUIDsSet = new Set();
function setAnnotationLocked(annotationUID, locked = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (locked) {
            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
        else {
            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
    }
    publish(detail, globalLockedAnnotationUIDsSet);
}
function unlockAllAnnotations() {
    const detail = makeEventDetail();
    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);
    publish(detail, globalLockedAnnotationUIDsSet);
}
function getAnnotationsLocked() {
    return Array.from(globalLockedAnnotationUIDsSet);
}
function isAnnotationLocked(annotationUID) {
    return globalLockedAnnotationUIDsSet.has(annotationUID);
}
function getAnnotationsLockedCount() {
    return globalLockedAnnotationUIDsSet.size;
}
function checkAndSetAnnotationLocked(annotationUID) {
    const isLocked = isAnnotationLocked(annotationUID);
    setAnnotationLocked(annotationUID, isLocked);
    return isLocked;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        locked: [],
    });
}
function lock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (!lockedAnnotationUIDsSet.has(annotationUID)) {
        lockedAnnotationUIDsSet.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isLocked = true;
        }
    }
}
function unlock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (lockedAnnotationUIDsSet.delete(annotationUID)) {
        detail.removed.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isLocked = false;
        }
    }
}
function clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {
    lockedAnnotationUIDsSet.forEach((annotationUID) => {
        unlock(annotationUID, lockedAnnotationUIDsSet, detail);
    });
}
function publish(detail, lockedAnnotationUIDsSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_LOCK_CHANGE, detail);
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deselectAnnotation: () => (/* binding */ deselectAnnotation),
/* harmony export */   getAnnotationsSelected: () => (/* binding */ getAnnotationsSelected),
/* harmony export */   getAnnotationsSelectedByToolName: () => (/* binding */ getAnnotationsSelectedByToolName),
/* harmony export */   getAnnotationsSelectedCount: () => (/* binding */ getAnnotationsSelectedCount),
/* harmony export */   isAnnotationSelected: () => (/* binding */ isAnnotationSelected),
/* harmony export */   setAnnotationSelected: () => (/* binding */ setAnnotationSelected)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");



const selectedAnnotationUIDs = new Set();
function setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {
    if (selected) {
        selectAnnotation(annotationUID, preserveSelected);
    }
    else {
        deselectAnnotation(annotationUID);
    }
}
function selectAnnotation(annotationUID, preserveSelected = false) {
    const detail = makeEventDetail();
    if (!preserveSelected) {
        clearSelectionSet(selectedAnnotationUIDs, detail);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {
        selectedAnnotationUIDs.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    publish(detail, selectedAnnotationUIDs);
}
function deselectAnnotation(annotationUID) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (selectedAnnotationUIDs.delete(annotationUID)) {
            detail.removed.push(annotationUID);
            const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
            annotation.isSelected = false;
        }
    }
    else {
        clearSelectionSet(selectedAnnotationUIDs, detail);
    }
    publish(detail, selectedAnnotationUIDs);
}
function getAnnotationsSelected() {
    return Array.from(selectedAnnotationUIDs);
}
function getAnnotationsSelectedByToolName(toolName) {
    return getAnnotationsSelected().filter((annotationUID) => {
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        return annotation?.metadata?.toolName === toolName;
    });
}
function isAnnotationSelected(annotationUID) {
    return selectedAnnotationUIDs.has(annotationUID);
}
function getAnnotationsSelectedCount() {
    return selectedAnnotationUIDs.size;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        selection: [],
    });
}
function clearSelectionSet(selectionSet, detail) {
    selectionSet.forEach((value) => {
        if (selectionSet.delete(value)) {
            detail.removed.push(value);
            const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(value);
            if (annotation) {
                annotation.isSelected = false;
            }
        }
    });
}
function publish(detail, selectionSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        selectionSet.forEach((item) => void detail.selection.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_SELECTION_CHANGE, detail);
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAnnotation: () => (/* binding */ addAnnotation),
/* harmony export */   addChildAnnotation: () => (/* binding */ addChildAnnotation),
/* harmony export */   clearParentAnnotation: () => (/* binding */ clearParentAnnotation),
/* harmony export */   getAllAnnotations: () => (/* binding */ getAllAnnotations),
/* harmony export */   getAnnotation: () => (/* binding */ getAnnotation),
/* harmony export */   getAnnotationManager: () => (/* binding */ getAnnotationManager),
/* harmony export */   getAnnotations: () => (/* binding */ getAnnotations),
/* harmony export */   getChildAnnotations: () => (/* binding */ getChildAnnotations),
/* harmony export */   getNumberOfAnnotations: () => (/* binding */ getNumberOfAnnotations),
/* harmony export */   getParentAnnotation: () => (/* binding */ getParentAnnotation),
/* harmony export */   invalidateAnnotation: () => (/* binding */ invalidateAnnotation),
/* harmony export */   removeAllAnnotations: () => (/* binding */ removeAllAnnotations),
/* harmony export */   removeAnnotation: () => (/* binding */ removeAnnotation),
/* harmony export */   removeAnnotations: () => (/* binding */ removeAnnotations),
/* harmony export */   setAnnotationManager: () => (/* binding */ setAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _helpers_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");


let defaultManager;
function getAnnotationManager() {
    return defaultManager;
}
function setAnnotationManager(annotationManager) {
    defaultManager = annotationManager;
}
function getAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getAnnotations(groupKey, toolName);
}
function getAnnotation(annotationUID) {
    const manager = getAnnotationManager();
    return manager.getAnnotation(annotationUID);
}
function getAllAnnotations() {
    const manager = getAnnotationManager();
    return manager.getAllAnnotations();
}
function clearParentAnnotation(annotation) {
    const { annotationUID: childUID, parentAnnotationUID } = annotation;
    if (!parentAnnotationUID) {
        return;
    }
    const parentAnnotation = getAnnotation(parentAnnotationUID);
    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);
    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);
    annotation.parentAnnotationUID = undefined;
}
function addChildAnnotation(parentAnnotation, childAnnotation) {
    const { annotationUID: parentUID } = parentAnnotation;
    const { annotationUID: childUID } = childAnnotation;
    clearParentAnnotation(childAnnotation);
    if (!parentAnnotation.childAnnotationUIDs) {
        parentAnnotation.childAnnotationUIDs = [];
    }
    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {
        return;
    }
    parentAnnotation.childAnnotationUIDs.push(childUID);
    childAnnotation.parentAnnotationUID = parentUID;
}
function getParentAnnotation(annotation) {
    return annotation.parentAnnotationUID
        ? getAnnotation(annotation.parentAnnotationUID)
        : undefined;
}
function getChildAnnotations(annotation) {
    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => getAnnotation(childAnnotationUID)) ?? []);
}
function addAnnotation(annotation, annotationGroupSelector) {
    if (!annotation.annotationUID) {
        annotation.annotationUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    }
    const manager = getAnnotationManager();
    if (annotationGroupSelector instanceof HTMLDivElement) {
        const groupKey = manager.getGroupKey(annotationGroupSelector);
        manager.addAnnotation(annotation, groupKey);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationAddedForElement)(annotation, annotationGroupSelector);
    }
    else {
        manager.addAnnotation(annotation, undefined);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationAddedForFOR)(annotation);
    }
    return annotation.annotationUID;
}
function getNumberOfAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getNumberOfAnnotations(groupKey, toolName);
}
function removeAnnotation(annotationUID) {
    if (!annotationUID) {
        return;
    }
    const manager = getAnnotationManager();
    const annotation = manager.getAnnotation(annotationUID);
    if (!annotation) {
        return;
    }
    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));
    manager.removeAnnotation(annotationUID);
    (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({ annotation, annotationManagerUID: manager.uid });
}
function removeAllAnnotations() {
    const manager = getAnnotationManager();
    const removedAnnotations = manager.removeAllAnnotations();
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function removeAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function invalidateAnnotation(annotation) {
    let currAnnotation = annotation;
    while (currAnnotation) {
        currAnnotation.invalidated = true;
        currAnnotation = currAnnotation.parentAnnotationUID
            ? getAnnotation(currAnnotation.parentAnnotationUID)
            : undefined;
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationVisibility: () => (/* binding */ checkAndSetAnnotationVisibility),
/* harmony export */   isAnnotationVisible: () => (/* binding */ isAnnotationVisible),
/* harmony export */   setAnnotationVisibility: () => (/* binding */ setAnnotationVisibility),
/* harmony export */   showAllAnnotations: () => (/* binding */ showAllAnnotations)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");




const globalHiddenAnnotationUIDsSet = new Set();
function setAnnotationVisibility(annotationUID, visible = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (visible) {
            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
        else {
            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
    }
    publish(detail);
}
function showAllAnnotations() {
    const detail = makeEventDetail();
    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {
        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    });
    publish(detail);
}
function isAnnotationVisible(annotationUID) {
    const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotation)(annotationUID);
    if (annotation) {
        return !globalHiddenAnnotationUIDsSet.has(annotationUID);
    }
}
function makeEventDetail() {
    return Object.freeze({
        lastVisible: [],
        lastHidden: [],
        hidden: [],
    });
}
function show(annotationUID, annotationUIDsSet, detail) {
    if (annotationUIDsSet.delete(annotationUID)) {
        detail.lastVisible.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotation)(annotationUID);
        annotation.isVisible = true;
    }
}
function hide(annotationUID, annotationUIDsSet, detail) {
    if (!annotationUIDsSet.has(annotationUID)) {
        annotationUIDsSet.add(annotationUID);
        if ((0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.isAnnotationSelected)(annotationUID)) {
            (0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.deselectAnnotation)(annotationUID);
        }
        detail.lastHidden.push(annotationUID);
    }
}
function publish(detail) {
    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {
        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_VISIBILITY_CHANGE, detail);
    }
}
function checkAndSetAnnotationVisibility(annotationUID) {
    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);
    setAnnotationVisibility(annotationUID, isVisible);
    return isVisible;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class ToolStyle {
    constructor() {
        const defaultConfig = {
            color: 'rgb(255, 255, 0)',
            colorHighlighted: 'rgb(0, 255, 0)',
            colorSelected: 'rgb(0, 220, 0)',
            colorLocked: 'rgb(209, 193, 90)',
            lineWidth: '1',
            lineDash: '',
            shadow: true,
            textBoxVisibility: true,
            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            textBoxFontSize: '14px',
            textBoxColor: 'rgb(255, 255, 0)',
            textBoxColorHighlighted: 'rgb(0, 255, 0)',
            textBoxColorSelected: 'rgb(0, 255, 0)',
            textBoxColorLocked: 'rgb(209, 193, 90)',
            textBoxBackground: '',
            textBoxLinkLineWidth: '1',
            textBoxLinkLineDash: '2,3',
            textBoxShadow: true,
            markerSize: '10',
            angleArcLineDash: '',
        };
        this._initializeConfig(defaultConfig);
    }
    getAnnotationToolStyles(annotationUID) {
        return this.config.annotations && this.config.annotations[annotationUID];
    }
    getViewportToolStyles(viewportId) {
        return this.config.viewports && this.config.viewports[viewportId];
    }
    getToolGroupToolStyles(toolGroupId) {
        return this.config.toolGroups && this.config.toolGroups[toolGroupId];
    }
    getDefaultToolStyles() {
        return this.config.default;
    }
    setAnnotationStyles(annotationUID, styles) {
        let annotationSpecificStyles = this.config.annotations;
        if (!annotationSpecificStyles) {
            this.config = {
                ...this.config,
                annotations: {},
            };
            annotationSpecificStyles = this.config.annotations;
        }
        annotationSpecificStyles[annotationUID] = styles;
    }
    setViewportToolStyles(viewportId, styles) {
        let viewportSpecificStyles = this.config.viewports;
        if (!viewportSpecificStyles) {
            this.config = {
                ...this.config,
                viewports: {},
            };
            viewportSpecificStyles = this.config.viewports;
        }
        viewportSpecificStyles[viewportId] = styles;
    }
    setToolGroupToolStyles(toolGroupId, styles) {
        let toolGroupSpecificStyles = this.config.toolGroups;
        if (!toolGroupSpecificStyles) {
            this.config = {
                ...this.config,
                toolGroups: {},
            };
            toolGroupSpecificStyles = this.config.toolGroups;
        }
        toolGroupSpecificStyles[toolGroupId] = styles;
    }
    setDefaultToolStyles(styles) {
        this.config.default = styles;
    }
    getStyleProperty(toolStyle, specifications) {
        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;
        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);
    }
    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {
        if (annotationUID) {
            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);
            if (annotationToolStyles) {
                if (annotationToolStyles[property] !== undefined) {
                    return annotationToolStyles[property];
                }
            }
        }
        if (viewportId) {
            const viewportToolStyles = this.getViewportToolStyles(viewportId);
            if (viewportToolStyles) {
                if (viewportToolStyles[toolName] &&
                    viewportToolStyles[toolName][property] !== undefined) {
                    return viewportToolStyles[toolName][property];
                }
                if (viewportToolStyles.global &&
                    viewportToolStyles.global[property] !== undefined) {
                    return viewportToolStyles.global[property];
                }
            }
        }
        if (toolGroupId) {
            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);
            if (toolGroupToolStyles) {
                if (toolGroupToolStyles[toolName] &&
                    toolGroupToolStyles[toolName][property] !== undefined) {
                    return toolGroupToolStyles[toolName][property];
                }
                if (toolGroupToolStyles.global &&
                    toolGroupToolStyles.global[property] !== undefined) {
                    return toolGroupToolStyles.global[property];
                }
            }
        }
        const globalStyles = this.getDefaultToolStyles();
        if (globalStyles[toolName] &&
            globalStyles[toolName][property] !== undefined) {
            return globalStyles[toolName][property];
        }
        if (globalStyles.global && globalStyles.global[property] !== undefined) {
            return globalStyles.global[property];
        }
    }
    _initializeConfig(config) {
        const toolStyles = {};
        for (const name in config) {
            toolStyles[name] = config[name];
        }
        this.config = {
            default: {
                global: toolStyles,
            },
        };
    }
}
const toolStyle = new ToolStyle();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toolStyle);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js");

function getFont(styleSpecifier, state, mode) {
    const fontSize = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getStyleProperty)('textBoxFontSize', styleSpecifier, state, mode);
    const fontFamily = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getStyleProperty)('textBoxFontFamily', styleSpecifier, state, mode);
    return `${fontSize}px ${fontFamily}`;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getFont);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _annotationLocking__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _annotationSelection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");



function getState(annotation) {
    if (annotation) {
        if (annotation.data && annotation.highlighted) {
            return _enums__WEBPACK_IMPORTED_MODULE_2__.AnnotationStyleStates.Highlighted;
        }
        if ((0,_annotationSelection__WEBPACK_IMPORTED_MODULE_1__.isAnnotationSelected)(annotation.annotationUID)) {
            return _enums__WEBPACK_IMPORTED_MODULE_2__.AnnotationStyleStates.Selected;
        }
        if ((0,_annotationLocking__WEBPACK_IMPORTED_MODULE_0__.isAnnotationLocked)(annotation.annotationUID)) {
            return _enums__WEBPACK_IMPORTED_MODULE_2__.AnnotationStyleStates.Locked;
        }
        if (annotation.data && annotation.autoGenerated) {
            return _enums__WEBPACK_IMPORTED_MODULE_2__.AnnotationStyleStates.AutoGenerated;
        }
    }
    return _enums__WEBPACK_IMPORTED_MODULE_2__.AnnotationStyleStates.Default;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getState);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getStyleProperty: () => (/* binding */ getStyleProperty)
/* harmony export */ });
/* harmony import */ var _ToolStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ToolStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js");

function getHierarchalPropertyStyles(property, state, mode) {
    const list = [`${property}`];
    if (state) {
        list.push(`${list[0]}${state}`);
    }
    if (mode) {
        list.push(`${list[list.length - 1]}${mode}`);
    }
    return list;
}
function getStyleProperty(property, styleSpecifier, state, mode) {
    const alternatives = getHierarchalPropertyStyles(property, state, mode);
    for (let i = alternatives.length - 1; i >= 0; --i) {
        const style = _ToolStyle__WEBPACK_IMPORTED_MODULE_0__["default"].getStyleProperty(alternatives[i], styleSpecifier);
        if (style !== undefined) {
            return style;
        }
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFont: () => (/* reexport safe */ _getFont__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   getState: () => (/* reexport safe */ _getState__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   style: () => (/* reexport safe */ _ToolStyle__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _getState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js");
/* harmony import */ var _getFont__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getFont */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js");
/* harmony import */ var _ToolStyle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ToolStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerAnnotationAddedForElement: () => (/* binding */ triggerAnnotationAddedForElement),
/* harmony export */   triggerAnnotationAddedForFOR: () => (/* binding */ triggerAnnotationAddedForFOR),
/* harmony export */   triggerAnnotationCompleted: () => (/* binding */ triggerAnnotationCompleted),
/* harmony export */   triggerAnnotationModified: () => (/* binding */ triggerAnnotationModified),
/* harmony export */   triggerAnnotationRemoved: () => (/* binding */ triggerAnnotationRemoved),
/* harmony export */   triggerContourAnnotationCompleted: () => (/* binding */ triggerContourAnnotationCompleted)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");



function triggerAnnotationAddedForElement(annotation, element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngine, viewportId } = enabledElement;
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId: renderingEngine.id,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationAddedForFOR(annotation) {
    const { toolName } = annotation.metadata;
    const toolGroups = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupsWithToolName)(toolName);
    if (!toolGroups.length) {
        return;
    }
    const viewportsToRender = [];
    toolGroups.forEach((toolGroup) => {
        toolGroup.viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const { FrameOfReferenceUID } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {
                viewportsToRender.push(viewportInfo);
            }
        });
    });
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = { annotation };
    if (!viewportsToRender.length) {
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        return;
    }
    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {
        eventDetail.viewportId = viewportId;
        eventDetail.renderingEngineId = renderingEngineId;
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
    });
}
function triggerAnnotationRemoved(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_REMOVED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationModified(annotation, element, changeType = _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.HandlesUpdated) {
    const enabledElement = element && (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement || {};
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_MODIFIED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId,
        changeType,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationCompleted(annotation) {
    const eventDetail = {
        annotation,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {
    const eventDetail = {
        annotation,
        contourHoleProcessingEnabled,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function _triggerAnnotationCompleted(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_COMPLETED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotationGroup: () => (/* reexport safe */ _AnnotationGroup__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   FrameOfReferenceSpecificAnnotationManager: () => (/* reexport safe */ _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   config: () => (/* reexport module object */ _config__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   locking: () => (/* reexport module object */ _annotationLocking__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   selection: () => (/* reexport module object */ _annotationSelection__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   state: () => (/* binding */ state),
/* harmony export */   visibility: () => (/* reexport module object */ _annotationVisibility__WEBPACK_IMPORTED_MODULE_5__)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js");
/* harmony import */ var _annotationLocking__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _helpers_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _annotationVisibility__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FrameOfReferenceSpecificAnnotationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js");
/* harmony import */ var _AnnotationGroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AnnotationGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js");
/* harmony import */ var _resetAnnotationManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./resetAnnotationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js");









const state = {
    ..._annotationState__WEBPACK_IMPORTED_MODULE_3__,
    ..._helpers_state__WEBPACK_IMPORTED_MODULE_4__,
    resetAnnotationManager: _resetAnnotationManager__WEBPACK_IMPORTED_MODULE_8__.resetAnnotationManager,
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resetAnnotationManager: () => (/* binding */ resetAnnotationManager)
/* harmony export */ });
/* harmony import */ var _utilities_defineProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities/defineProperties */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js");
/* harmony import */ var _annotationLocking__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _annotationVisibility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FrameOfReferenceSpecificAnnotationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js");
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");





const defaultManager = _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_3__.defaultFrameOfReferenceSpecificAnnotationManager;
const preprocessingFn = (annotation) => {
    annotation = (0,_utilities_defineProperties__WEBPACK_IMPORTED_MODULE_0__.checkAndDefineTextBoxProperty)(annotation);
    annotation = (0,_utilities_defineProperties__WEBPACK_IMPORTED_MODULE_0__.checkAndDefineCachedStatsProperty)(annotation);
    const uid = annotation.annotationUID;
    const isLocked = (0,_annotationLocking__WEBPACK_IMPORTED_MODULE_1__.checkAndSetAnnotationLocked)(uid);
    annotation.isLocked = isLocked;
    const isVisible = (0,_annotationVisibility__WEBPACK_IMPORTED_MODULE_2__.checkAndSetAnnotationVisibility)(uid);
    annotation.isVisible = isVisible;
    return annotation;
};
defaultManager.setPreprocessingFn(preprocessingFn);
(0,_annotationState__WEBPACK_IMPORTED_MODULE_4__.setAnnotationManager)(defaultManager);
function resetAnnotationManager() {
    (0,_annotationState__WEBPACK_IMPORTED_MODULE_4__.setAnnotationManager)(defaultManager);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndDefineCachedStatsProperty: () => (/* binding */ checkAndDefineCachedStatsProperty),
/* harmony export */   checkAndDefineTextBoxProperty: () => (/* binding */ checkAndDefineTextBoxProperty)
/* harmony export */ });
const checkAndDefineTextBoxProperty = (annotation) => {
    if (!annotation.data) {
        annotation.data = {};
    }
    if (!annotation.data.handles) {
        annotation.data.handles = {};
    }
    if (!annotation.data.handles.textBox) {
        annotation.data.handles.textBox = {};
    }
    return annotation;
};
const checkAndDefineCachedStatsProperty = (annotation) => {
    if (!annotation.data) {
        annotation.data = {};
    }
    if (!annotation.data.cachedStats) {
        annotation.data.cachedStats = {};
    }
    return annotation;
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FrameOfReferenceSpecificAnnotationManager: () => (/* reexport safe */ _annotation_FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   addAnnotation: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation),
/* harmony export */   addChildAnnotation: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addChildAnnotation),
/* harmony export */   annotationLocking: () => (/* reexport module object */ _annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   annotationSelection: () => (/* reexport module object */ _annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   clearParentAnnotation: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.clearParentAnnotation),
/* harmony export */   defaultFrameOfReferenceSpecificAnnotationManager: () => (/* reexport safe */ _annotation_FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_0__.defaultFrameOfReferenceSpecificAnnotationManager),
/* harmony export */   getAnnotation: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotation),
/* harmony export */   getAnnotationManager: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotationManager),
/* harmony export */   getAnnotations: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations),
/* harmony export */   getChildAnnotations: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getChildAnnotations),
/* harmony export */   getNumberOfAnnotations: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getNumberOfAnnotations),
/* harmony export */   getParentAnnotation: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getParentAnnotation),
/* harmony export */   invalidateAnnotation: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.invalidateAnnotation),
/* harmony export */   removeAnnotation: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation),
/* harmony export */   resetAnnotationManager: () => (/* reexport safe */ _annotation_resetAnnotationManager__WEBPACK_IMPORTED_MODULE_4__.resetAnnotationManager),
/* harmony export */   setAnnotationManager: () => (/* reexport safe */ _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.setAnnotationManager)
/* harmony export */ });
/* harmony import */ var _annotation_FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotation/FrameOfReferenceSpecificAnnotationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js");
/* harmony import */ var _annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotation/annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _annotation_resetAnnotationManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./annotation/resetAnnotationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js");








/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   segmentationRenderingEngine: () => (/* binding */ segmentationRenderingEngine),
/* harmony export */   triggerSegmentationRender: () => (/* binding */ triggerSegmentationRender),
/* harmony export */   triggerSegmentationRenderBySegmentationId: () => (/* binding */ triggerSegmentationRenderBySegmentationId)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/displayTools/Surface/surfaceDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js");
/* harmony import */ var _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/displayTools/Contour/contourDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js");
/* harmony import */ var _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/displayTools/Labelmap/labelmapDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js");
/* harmony import */ var _store_addTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/addTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../tools/annotation/PlanarFreehandContourSegmentationTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");











const renderers = {
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__["default"].Labelmap]: _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__["default"],
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__["default"].Contour]: _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__["default"],
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__["default"].Surface]: _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__["default"],
};
const planarContourToolName = _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__["default"].toolName;
class SegmentationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._getAllViewports = () => {
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)();
            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());
        };
        this._renderFlaggedSegmentations = () => {
            this._throwIfDestroyed();
            const viewportIds = Array.from(this._needsRender);
            viewportIds.forEach((viewportId) => {
                this._triggerRender(viewportId);
            });
            this._needsRender.clear();
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
        };
    }
    renderSegmentationsForViewport(viewportId) {
        const viewportIds = viewportId
            ? [viewportId]
            : this._getViewportIdsForSegmentation();
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderSegmentation(segmentationId) {
        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    _getViewportIdsForSegmentation(segmentationId) {
        const viewports = this._getAllViewports();
        const viewportIds = [];
        for (const viewport of viewports) {
            const viewportId = viewport.id;
            if (segmentationId) {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__.getSegmentationRepresentations)(viewportId, { segmentationId });
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
            else {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__.getSegmentationRepresentations)(viewportId);
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
        }
        return viewportIds;
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setViewportsToBeRenderedNextFrame(viewportIds) {
        viewportIds.forEach((viewportId) => {
            this._needsRender.add(viewportId);
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(viewportId) {
        const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__.getSegmentationRepresentations)(viewportId);
        if (!segmentationRepresentations?.length) {
            return;
        }
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId) || {};
        if (!viewport) {
            return;
        }
        const viewportRenderList = [];
        const segmentationRenderList = segmentationRepresentations.map((representation) => {
            if (representation.type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour) {
                this._addPlanarFreeHandToolIfAbsent(viewport);
            }
            const display = renderers[representation.type];
            try {
                const viewportId = display.render(viewport, representation);
                viewportRenderList.push(viewportId);
            }
            catch (error) {
                console.error(error);
            }
            return Promise.resolve({
                segmentationId: representation.segmentationId,
                type: representation.type,
            });
        });
        Promise.allSettled(segmentationRenderList).then((results) => {
            const segmentationDetails = results
                .filter((r) => r.status === 'fulfilled')
                .map((r) => r.value);
            function onSegmentationRender(evt) {
                const { element, viewportId } = evt.detail;
                element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
                segmentationDetails.forEach((detail) => {
                    const eventDetail = {
                        viewportId,
                        segmentationId: detail.segmentationId,
                        type: detail.type,
                    };
                    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_RENDERED, {
                        ...eventDetail,
                    });
                });
            }
            const element = viewport.element;
            element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
            viewport.render();
        });
    }
    _addPlanarFreeHandToolIfAbsent(viewport) {
        if (!(planarContourToolName in _store_state__WEBPACK_IMPORTED_MODULE_8__.state.tools)) {
            (0,_store_addTool__WEBPACK_IMPORTED_MODULE_7__.addTool)(_tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__["default"]);
        }
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroupForViewport)(viewport.id);
        if (!toolGroup.hasTool(planarContourToolName)) {
            toolGroup.addTool(planarContourToolName);
            toolGroup.setToolPassive(planarContourToolName);
        }
    }
}
function triggerSegmentationRender(viewportId) {
    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);
}
function triggerSegmentationRenderBySegmentationId(segmentationId) {
    segmentationRenderingEngine.renderSegmentation(segmentationId);
}
const segmentationRenderingEngine = new SegmentationRenderingEngine();



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SegmentationStateManager),
/* harmony export */   defaultSegmentationStateManager: () => (/* binding */ defaultSegmentationStateManager),
/* harmony export */   internalComputeVolumeLabelmapFromStack: () => (/* binding */ internalComputeVolumeLabelmapFromStack),
/* harmony export */   internalConvertStackToVolumeLabelmap: () => (/* binding */ internalConvertStackToVolumeLabelmap)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @kitware/vtk.js/Rendering/Core/ColorTransferFunction */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js");
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @kitware/vtk.js/Common/DataModel/PiecewiseFunction */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SegmentationStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js");
/* harmony import */ var _events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events/triggerSegmentationAdded */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js");







const initialDefaultState = {
    colorLUT: [],
    segmentations: [],
    viewportSegRepresentations: {},
};
class SegmentationStateManager {
    constructor(uid) {
        this._stackLabelmapImageIdReferenceMap = new Map();
        this._labelmapImageIdReferenceMap = new Map();
        uid ||= _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
        this.uid = uid;
    }
    getState() {
        return this.state;
    }
    updateState(updater) {
        const newState = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(this.state);
        updater(newState);
        this.state = Object.freeze(newState);
    }
    getColorLUT(lutIndex) {
        return this.state.colorLUT[lutIndex];
    }
    getNextColorLUTIndex() {
        return this.state.colorLUT.length;
    }
    resetState() {
        this._stackLabelmapImageIdReferenceMap.clear();
        this._labelmapImageIdReferenceMap.clear();
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
    }
    getSegmentation(segmentationId) {
        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
    }
    updateSegmentation(segmentationId, payload) {
        this.updateState((draftState) => {
            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
            if (!segmentation) {
                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);
                return;
            }
            Object.assign(segmentation, payload);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    addSegmentation(segmentation) {
        if (this.getSegmentation(segmentation.segmentationId)) {
            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);
        }
        this.updateState((state) => {
            const newSegmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(segmentation);
            if (newSegmentation.representationData.Labelmap &&
                'volumeId' in newSegmentation.representationData.Labelmap &&
                !('imageIds' in newSegmentation.representationData.Labelmap)) {
                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);
                newSegmentation.representationData
                    .Labelmap.imageIds = imageIds;
            }
            state.segmentations.push(newSegmentation);
        });
        (0,_events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__.triggerSegmentationAdded)(segmentation.segmentationId);
    }
    removeSegmentation(segmentationId) {
        this.updateState((state) => {
            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);
            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRemoved)(segmentationId);
    }
    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {
            type: type,
            segmentationId,
        });
        if (existingRepresentations.length > 0) {
            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);
            return;
        }
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                state.viewportSegRepresentations[viewportId] = [];
                _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__.segmentationStyle.setRenderInactiveSegmentations(viewportId, true);
            }
            if (type !== _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);
            }
            else {
                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);
            }
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId, type);
    }
    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {
        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
        if (!segmentation) {
            return;
        }
        const segmentReps = {};
        Object.keys(segmentation.segments).forEach((segmentIndex) => {
            segmentReps[Number(segmentIndex)] = {
                visible: true,
            };
        });
        state.viewportSegRepresentations[viewportId].push({
            segmentationId,
            type,
            active: true,
            visible: true,
            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,
            segments: segmentReps,
            config: {
                ...getDefaultRenderingConfig(type),
                ...renderingConfig,
            },
        });
        this._setActiveSegmentation(state, viewportId, segmentationId);
    }
    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap)) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
        }
        this.processLabelmapRepresentationAddition(viewportId, segmentationId);
        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
    }
    async processLabelmapRepresentationAddition(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const volumeViewport = enabledElement.viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport;
        const { representationData } = segmentation;
        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;
        const viewport = enabledElement.viewport;
        if (!volumeViewport && !isBaseVolumeSegmentation) {
            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);
        }
    }
    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {
        const referenceImageId = viewport.getCurrentImageId();
        let viewableLabelmapImageIdFound = false;
        for (const labelmapImageId of labelmapImageIds) {
            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });
            if (viewableImageId) {
                viewableLabelmapImageIdFound = true;
                this._stackLabelmapImageIdReferenceMap
                    .get(segmentationId)
                    .set(referenceImageId, labelmapImageId);
                this._updateLabelmapImageIdReferenceMap({
                    segmentationId,
                    referenceImageId,
                    labelmapImageId,
                });
            }
        }
        if (updateCallback) {
            updateCallback(viewport, segmentationId, labelmapImageIds);
        }
        return viewableLabelmapImageIdFound
            ? this._stackLabelmapImageIdReferenceMap
                .get(segmentationId)
                .get(referenceImageId)
            : undefined;
    }
    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);
    }
    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {
            const imageIds = stackViewport.getImageIds();
            imageIds.forEach((referenceImageId, index) => {
                for (const labelmapImageId of labelmapImageIds) {
                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });
                    if (viewableImageId) {
                        this._stackLabelmapImageIdReferenceMap
                            .get(segmentationId)
                            .set(referenceImageId, labelmapImageId);
                        this._updateLabelmapImageIdReferenceMap({
                            segmentationId,
                            referenceImageId,
                            labelmapImageId,
                        });
                    }
                }
            });
        });
    }
    getLabelmapImageIds(representationData) {
        const labelmapData = representationData.Labelmap;
        let labelmapImageIds;
        if (labelmapData.imageIds) {
            labelmapImageIds = labelmapData
                .imageIds;
        }
        else if (!labelmapImageIds &&
            labelmapData.volumeId) {
            const volumeId = labelmapData
                .volumeId;
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            labelmapImageIds = volume.imageIds;
        }
        return labelmapImageIds;
    }
    getLabelmapImageIdsForImageId(imageId, segmentationId) {
        const key = this._generateMapKey({
            segmentationId,
            referenceImageId: imageId,
        });
        return this._labelmapImageIdReferenceMap.get(key);
    }
    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const stackViewport = enabledElement.viewport;
        const referenceImageId = stackViewport.getCurrentImageId();
        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);
    }
    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            return;
        }
        const stackViewport = enabledElement.viewport;
        const currentImageId = stackViewport.getCurrentImageId();
        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIdReferenceMap.get(currentImageId);
    }
    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return [];
        }
        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const imageIds = viewport.getImageIds();
        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIds.map((imageId) => {
            return associatedReferenceImageAndLabelmapImageIds.get(imageId);
        });
    }
    removeSegmentationRepresentationsInternal(viewportId, specifier) {
        const removedRepresentations = [];
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                return;
            }
            const currentRepresentations = state.viewportSegRepresentations[viewportId];
            let activeRepresentationRemoved = false;
            if (!specifier ||
                Object.values(specifier).every((value) => value === undefined)) {
                removedRepresentations.push(...currentRepresentations);
                delete state.viewportSegRepresentations[viewportId];
            }
            else {
                const { segmentationId, type } = specifier;
                state.viewportSegRepresentations[viewportId] =
                    currentRepresentations.filter((representation) => {
                        const shouldRemove = (segmentationId &&
                            type &&
                            representation.segmentationId === segmentationId &&
                            representation.type === type) ||
                            (segmentationId &&
                                !type &&
                                representation.segmentationId === segmentationId) ||
                            (!segmentationId && type && representation.type === type);
                        if (shouldRemove) {
                            removedRepresentations.push(representation);
                            if (representation.active) {
                                activeRepresentationRemoved = true;
                            }
                        }
                        return !shouldRemove;
                    });
                if (state.viewportSegRepresentations[viewportId].length === 0) {
                    delete state.viewportSegRepresentations[viewportId];
                }
                else if (activeRepresentationRemoved) {
                    state.viewportSegRepresentations[viewportId][0].active = true;
                }
            }
        });
        return removedRepresentations;
    }
    removeSegmentationRepresentations(viewportId, specifier) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        removedRepresentations.forEach((representation) => {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, representation.segmentationId, representation.type);
        });
        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);
        if (remainingRepresentations.length > 0 &&
            remainingRepresentations[0].active) {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);
        }
        return removedRepresentations;
    }
    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        if (!suppressEvent) {
            removedRepresentations.forEach(({ segmentationId, type }) => {
                (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, segmentationId, type);
            });
        }
        return removedRepresentations;
    }
    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {
        const key = this._generateMapKey({ segmentationId, referenceImageId });
        if (!this._labelmapImageIdReferenceMap.has(key)) {
            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);
            return;
        }
        const currentValues = this._labelmapImageIdReferenceMap.get(key);
        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));
        this._labelmapImageIdReferenceMap.set(key, newValues);
    }
    _setActiveSegmentation(state, viewportId, segmentationId) {
        const viewport = state.viewportSegRepresentations[viewportId];
        if (!viewport) {
            return;
        }
        viewport.forEach((value) => {
            value.active = value.segmentationId === segmentationId;
        });
    }
    setActiveSegmentation(viewportId, segmentationId) {
        this.updateState((state) => {
            const viewport = state.viewportSegRepresentations[viewportId];
            if (!viewport) {
                return;
            }
            viewport.forEach((value) => {
                value.active = value.segmentationId === segmentationId;
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
    }
    getActiveSegmentation(viewportId) {
        if (!this.state.viewportSegRepresentations[viewportId]) {
            return;
        }
        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);
        if (!activeSegRep) {
            return;
        }
        return this.getSegmentation(activeSegRep.segmentationId);
    }
    getSegmentationRepresentations(viewportId, specifier = {}) {
        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];
        if (!viewportRepresentations) {
            return [];
        }
        if (!specifier.type && !specifier.segmentationId) {
            return viewportRepresentations;
        }
        return viewportRepresentations.filter((representation) => {
            const typeMatch = specifier.type
                ? representation.type === specifier.type
                : true;
            const idMatch = specifier.segmentationId
                ? representation.segmentationId === specifier.segmentationId
                : true;
            return typeMatch && idMatch;
        });
    }
    getSegmentationRepresentation(viewportId, specifier) {
        return this.getSegmentationRepresentations(viewportId, specifier)[0];
    }
    getSegmentationRepresentationVisibility(viewportId, specifier) {
        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);
        return viewportRepresentation?.visible;
    }
    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
        this.updateState((state) => {
            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);
            if (!viewportRepresentations) {
                return;
            }
            viewportRepresentations.forEach((representation) => {
                representation.visible = visible;
                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {
                    segment.visible = visible;
                });
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, specifier.segmentationId, specifier.type);
    }
    addColorLUT(colorLUT, lutIndex) {
        this.updateState((state) => {
            if (state.colorLUT[lutIndex]) {
                console.warn('Color LUT table already exists, overwriting');
            }
            state.colorLUT[lutIndex] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(colorLUT);
        });
    }
    removeColorLUT(colorLUTIndex) {
        this.updateState((state) => {
            delete state.colorLUT[colorLUTIndex];
        });
    }
    _getStackIdForImageIds(imageIds) {
        return imageIds
            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))
            .join('_');
    }
    getAllViewportSegmentationRepresentations() {
        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({
            viewportId,
            representations,
        }));
    }
    getSegmentationRepresentationsBySegmentationId(segmentationId) {
        const result = [];
        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {
            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);
            if (filteredReps.length > 0) {
                result.push({ viewportId, representations: filteredReps });
            }
        });
        return result;
    }
    _generateMapKey({ segmentationId, referenceImageId }) {
        return `${segmentationId}-${referenceImageId}`;
    }
}
async function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {
    const segmentationImageIds = imageIds;
    const volumeId = options?.volumeId || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);
    return { volumeId };
}
async function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {
    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);
    const data = segmentation.representationData
        .Labelmap;
    const { volumeId } = await internalComputeVolumeLabelmapFromStack({
        imageIds: data.imageIds,
        options,
    });
    segmentation.representationData.Labelmap.volumeId = volumeId;
}
function getDefaultRenderingConfig(type) {
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    ofun.addPoint(0, 0);
    if (type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
        return {
            cfun,
            ofun,
        };
    }
    else {
        return {};
    }
}
const defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   segmentationStyle: () => (/* binding */ segmentationStyle)
/* harmony export */ });
/* harmony import */ var _tools_displayTools_Contour_contourConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/displayTools/Contour/contourConfig */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js");
/* harmony import */ var _tools_displayTools_Labelmap_labelmapConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/displayTools/Labelmap/labelmapConfig */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");




class SegmentationStyle {
    constructor() {
        this.config = {
            global: {},
            segmentations: {},
            viewportsStyle: {},
        };
    }
    setStyle(specifier, styles) {
        const { viewportId, segmentationId, type, segmentIndex } = specifier;
        const currentStyles = this.getStyle(specifier);
        let updatedStyles;
        if (!viewportId && !segmentationId) {
            updatedStyles = {
                ...currentStyles,
                ...styles,
            };
        }
        else {
            updatedStyles = this.copyActiveToInactiveIfNotProvided({
                ...currentStyles,
                ...styles,
            }, type);
        }
        if (!type) {
            throw new Error('Type is required to set a style');
        }
        if (viewportId) {
            if (!this.config.viewportsStyle[viewportId]) {
                this.config.viewportsStyle[viewportId] = {
                    renderInactiveSegmentations: false,
                    representations: {},
                };
            }
            const representations = this.config.viewportsStyle[viewportId].representations;
            if (segmentationId) {
                if (!representations[segmentationId]) {
                    representations[segmentationId] = {};
                }
                if (!representations[segmentationId][type]) {
                    representations[segmentationId][type] = {};
                }
                const repConfig = representations[segmentationId][type];
                if (segmentIndex !== undefined) {
                    if (!repConfig.perSegment) {
                        repConfig.perSegment = {};
                    }
                    repConfig.perSegment[segmentIndex] = updatedStyles;
                }
                else {
                    repConfig.allSegments = updatedStyles;
                }
            }
            else {
                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';
                if (!representations[ALL_SEGMENTATIONS_KEY]) {
                    representations[ALL_SEGMENTATIONS_KEY] = {};
                }
                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {
                    representations[ALL_SEGMENTATIONS_KEY][type] = {};
                }
                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =
                    updatedStyles;
            }
        }
        else if (segmentationId) {
            if (!this.config.segmentations[segmentationId]) {
                this.config.segmentations[segmentationId] = {};
            }
            if (!this.config.segmentations[segmentationId][type]) {
                this.config.segmentations[segmentationId][type] = {};
            }
            const segConfig = this.config.segmentations[segmentationId][type];
            if (segmentIndex !== undefined) {
                if (!segConfig.perSegment) {
                    segConfig.perSegment = {};
                }
                segConfig.perSegment[segmentIndex] = updatedStyles;
            }
            else {
                segConfig.allSegments = updatedStyles;
            }
        }
        else {
            this.config.global[type] = updatedStyles;
        }
    }
    copyActiveToInactiveIfNotProvided(styles, type) {
        const processedStyles = { ...styles };
        if (type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap) {
            const labelmapStyles = processedStyles;
            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;
            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;
            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;
            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;
            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;
        }
        else if (type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour) {
            const contourStyles = processedStyles;
            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;
            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;
            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;
            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;
            contourStyles.renderFillInactive ??= contourStyles.renderFill;
            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;
        }
        return processedStyles;
    }
    getStyle(specifier) {
        const { viewportId, segmentationId, type, segmentIndex } = specifier;
        let combinedStyle = this.getDefaultStyle(type);
        let renderInactiveSegmentations = false;
        if (this.config.global[type]) {
            combinedStyle = {
                ...combinedStyle,
                ...this.config.global[type],
            };
        }
        if (this.config.segmentations[segmentationId]?.[type]) {
            combinedStyle = {
                ...combinedStyle,
                ...this.config.segmentations[segmentationId][type].allSegments,
            };
            if (segmentIndex !== undefined &&
                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],
                };
            }
        }
        if (viewportId && this.config.viewportsStyle[viewportId]) {
            renderInactiveSegmentations =
                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;
            const allSegmentationsKey = '__allSegmentations__';
            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,
                };
            }
            if (segmentationId &&
                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,
                };
                if (segmentIndex !== undefined &&
                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {
                    combinedStyle = {
                        ...combinedStyle,
                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],
                    };
                }
            }
        }
        return combinedStyle;
    }
    getRenderInactiveSegmentations(viewportId) {
        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;
    }
    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
        if (!this.config.viewportsStyle[viewportId]) {
            this.config.viewportsStyle[viewportId] = {
                renderInactiveSegmentations: false,
                representations: {},
            };
        }
        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =
            renderInactiveSegmentations;
    }
    getDefaultStyle(type) {
        switch (type) {
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap:
                return (0,_tools_displayTools_Labelmap_labelmapConfig__WEBPACK_IMPORTED_MODULE_1__["default"])();
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour:
                return (0,_tools_displayTools_Contour_contourConfig__WEBPACK_IMPORTED_MODULE_0__["default"])();
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Surface:
                return {};
            default:
                throw new Error(`Unknown representation type: ${type}`);
        }
    }
    clearSegmentationStyle(segmentationId) {
        if (this.config.segmentations[segmentationId]) {
            delete this.config.segmentations[segmentationId];
        }
    }
    clearAllSegmentationStyles() {
        this.config.segmentations = {};
    }
    clearViewportStyle(viewportId) {
        if (this.config.viewportsStyle[viewportId]) {
            delete this.config.viewportsStyle[viewportId];
        }
    }
    clearAllViewportStyles() {
        for (const viewportId in this.config.viewportsStyle) {
            const viewportStyle = this.config.viewportsStyle[viewportId];
            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;
            this.config.viewportsStyle[viewportId] = {
                renderInactiveSegmentations,
                representations: {},
            };
        }
    }
    resetToGlobalStyle() {
        this.clearAllSegmentationStyles();
        this.clearAllViewportStyles();
    }
    hasCustomStyle(specifier) {
        const { type } = specifier;
        const style = this.getStyle(specifier);
        const defaultStyle = this.getDefaultStyle(type);
        return !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_3__.utilities.deepEqual(style, defaultStyle);
    }
}
const segmentationStyle = new SegmentationStyle();



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActiveSegmentation: () => (/* binding */ getActiveSegmentation),
/* harmony export */   setActiveSegmentation: () => (/* binding */ setActiveSegmentation)
/* harmony export */ });
/* harmony import */ var _getActiveSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getActiveSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js");
/* harmony import */ var _setActiveSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setActiveSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js");


function getActiveSegmentation(viewportId) {
    return (0,_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_0__.getActiveSegmentation)(viewportId);
}
function setActiveSegmentation(viewportId, segmentationId) {
    (0,_setActiveSegmentation__WEBPACK_IMPORTED_MODULE_1__.setActiveSegmentation)(viewportId, segmentationId);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addColorLUT: () => (/* binding */ addColorLUT)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNextColorLUTIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js");
/* harmony import */ var _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants/COLOR_LUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js");




function addColorLUT(colorLUT, index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__.defaultSegmentationStateManager;
    const indexToUse = index ?? (0,_getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__.getNextColorLUTIndex)();
    let colorLUTToUse = [...colorLUT];
    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {
        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');
        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];
    }
    colorLUTToUse = colorLUTToUse.map((color) => {
        if (color.length === 3) {
            return [color[0], color[1], color[2], 255];
        }
        return color;
    });
    if (colorLUTToUse.length < 255) {
        const missingColorLUTs = _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__["default"].slice(colorLUTToUse.length);
        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];
    }
    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);
    return indexToUse;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js":
/*!************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addContourRepresentationToViewport: () => (/* binding */ addContourRepresentationToViewport),
/* harmony export */   addContourRepresentationToViewportMap: () => (/* binding */ addContourRepresentationToViewportMap),
/* harmony export */   addLabelmapRepresentationToViewport: () => (/* binding */ addLabelmapRepresentationToViewport),
/* harmony export */   addLabelmapRepresentationToViewportMap: () => (/* binding */ addLabelmapRepresentationToViewportMap),
/* harmony export */   addSegmentationRepresentations: () => (/* binding */ addSegmentationRepresentations),
/* harmony export */   addSurfaceRepresentationToViewport: () => (/* binding */ addSurfaceRepresentationToViewport),
/* harmony export */   addSurfaceRepresentationToViewportMap: () => (/* binding */ addSurfaceRepresentationToViewportMap)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _internalAddSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internalAddSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js");


function addSegmentationRepresentations(viewportId, segmentationInputArray) {
    segmentationInputArray.map((segmentationInput) => {
        return (0,_internalAddSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_1__.internalAddSegmentationRepresentation)(viewportId, segmentationInput);
    });
}
function addContourRepresentationToViewport(viewportId, contourInputArray) {
    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({
        ...input,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
    })));
}
function addContourRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}
function addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {
    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({
        ...input,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap,
    })));
}
function addLabelmapRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({
            ...input,
            type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap,
        })));
    }
}
function addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {
    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({
        ...input,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Surface,
    })));
}
function addSurfaceRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addSegmentations: () => (/* binding */ addSegmentations),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _helpers_normalizeSegmentationInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/normalizeSegmentationInput */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js");



function addSegmentations(segmentationInputArray, suppressEvents) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    segmentationInputArray.forEach((segmentationInput) => {
        const segmentation = (0,_helpers_normalizeSegmentationInput__WEBPACK_IMPORTED_MODULE_2__["default"])(segmentationInput);
        segmentationStateManager.addSegmentation(segmentation);
        if (!suppressEvents) {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationModified)(segmentation.segmentationId);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addSegmentations);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addColorLUT: () => (/* binding */ addColorLUT),
/* harmony export */   getSegmentIndexColor: () => (/* binding */ getSegmentIndexColor),
/* harmony export */   setColorLUT: () => (/* binding */ setColorLUT),
/* harmony export */   setSegmentIndexColor: () => (/* binding */ setSegmentIndexColor)
/* harmony export */ });
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../addColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js");
/* harmony import */ var _getColorLUT__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js");
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");




function addColorLUT(colorLUT, colorLUTIndex) {
    if (!colorLUT) {
        throw new Error('addColorLUT: colorLUT is required');
    }
    return (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_0__.addColorLUT)(colorLUT, colorLUTIndex);
}
function setColorLUT(viewportId, segmentationId, colorLUTsIndex) {
    if (!(0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__.getColorLUT)(colorLUTsIndex)) {
        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);
    }
    const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentationRepresentations)(viewportId, { segmentationId });
    if (!segmentationRepresentations) {
        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);
    }
    segmentationRepresentations.forEach((segmentationRepresentation) => {
        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;
    });
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}
function getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {
    const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentationRepresentations)(viewportId, {
        segmentationId,
    });
    if (!representations || representations.length === 0) {
        return null;
    }
    const representation = representations[0];
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__.getColorLUT)(colorLUTIndex);
    let colorValue = colorLUT[segmentIndex];
    if (!colorValue) {
        if (typeof segmentIndex !== 'number') {
            console.warn(`Can't create colour for LUT index ${segmentIndex}`);
            return null;
        }
        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];
    }
    return colorValue;
}
function setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {
    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
    for (let i = 0; i < color.length; i++) {
        colorReference[i] = color[i];
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationAdded: () => (/* binding */ triggerSegmentationAdded)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


function triggerSegmentationAdded(segmentationId) {
    const eventDetail = {
        segmentationId,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_ADDED, eventDetail);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationDataModified: () => (/* binding */ triggerSegmentationDataModified)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_segmentation_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utilities/segmentation/utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js");



function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {
    const eventDetail = {
        segmentationId,
        modifiedSlicesToUse,
        segmentIndex,
    };
    (0,_utilities_segmentation_utilities__WEBPACK_IMPORTED_MODULE_2__.setSegmentationDirty)(segmentationId);
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, eventDetail);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js":
/*!******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationModified: () => (/* binding */ triggerSegmentationModified)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


function triggerSegmentationModified(segmentationId) {
    const eventDetail = {
        segmentationId,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_MODIFIED, eventDetail);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationRemoved: () => (/* binding */ triggerSegmentationRemoved)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


function triggerSegmentationRemoved(segmentationId) {
    const eventDetail = {
        segmentationId,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_REMOVED, eventDetail);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js":
/*!********************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationRepresentationModified: () => (/* binding */ triggerSegmentationRepresentationModified)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {
    const eventDetail = {
        segmentationId,
        type,
        viewportId,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationRepresentationRemoved: () => (/* binding */ triggerSegmentationRepresentationRemoved)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {
    const eventDetail = {
        viewportId,
        segmentationId,
        type,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActiveSegmentIndex: () => (/* binding */ getActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");

function getActiveSegmentIndex(segmentationId) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    if (segmentation) {
        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);
        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;
    }
    return undefined;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActiveSegmentation: () => (/* binding */ getActiveSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getActiveSegmentation(viewportId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getActiveSegmentation(viewportId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLUT: () => (/* binding */ getColorLUT)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getColorLUT(index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getColorLUT(index);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js":
/*!********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCurrentLabelmapImageIdForViewport: () => (/* binding */ getCurrentLabelmapImageIdForViewport),
/* harmony export */   getCurrentLabelmapImageIdsForViewport: () => (/* binding */ getCurrentLabelmapImageIdsForViewport),
/* harmony export */   getLabelmapImageIdsForImageId: () => (/* binding */ getLabelmapImageIdsForImageId)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
    const imageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);
    return imageIds[0];
}
function getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);
}
function getLabelmapImageIdsForImageId(imageId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getLabelmapImageIdsForImageId(imageId, segmentationId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNextColorLUTIndex: () => (/* binding */ getNextColorLUTIndex)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getNextColorLUTIndex() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getNextColorLUTIndex();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSegmentation: () => (/* binding */ getSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getSegmentation(segmentationId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSegmentationRepresentation: () => (/* binding */ getSegmentationRepresentation),
/* harmony export */   getSegmentationRepresentations: () => (/* binding */ getSegmentationRepresentations),
/* harmony export */   getSegmentationRepresentationsBySegmentationId: () => (/* binding */ getSegmentationRepresentationsBySegmentationId)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getSegmentationRepresentations(viewportId, specifier = {}) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
}
function getSegmentationRepresentation(viewportId, specifier) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    if (!specifier.segmentationId || !specifier.type) {
        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');
    }
    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
    return representations?.[0];
}
function getSegmentationRepresentationsBySegmentationId(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSegmentationRepresentationVisibility: () => (/* binding */ getSegmentationRepresentationVisibility)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getSegmentationRepresentationVisibility(viewportId, specifier) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSegmentations: () => (/* binding */ getSegmentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    const state = segmentationStateManager.getState();
    return state.segmentations;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getStackSegmentationImageIdsForViewport: () => (/* binding */ getStackSegmentationImageIdsForViewport)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js":
/*!**************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getViewportIdsWithSegmentation: () => (/* binding */ getViewportIdsWithSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function getViewportIdsWithSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    const state = segmentationStateManager.getState();
    const viewportSegRepresentations = state.viewportSegRepresentations;
    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)
        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))
        .map(([viewportId]) => viewportId);
    return viewportIdsWithSegmentation;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getViewportSegmentationRepresentations: () => (/* binding */ getViewportSegmentationRepresentations),
/* harmony export */   getViewportSegmentations: () => (/* binding */ getViewportSegmentations)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");


function getViewportSegmentations(viewportId, type) {
    const viewportRepresentations = getViewportSegmentationRepresentations(viewportId);
    const segmentations = viewportRepresentations.map((representation) => {
        if (type && representation.type === type) {
            return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(representation.segmentationId);
        }
        return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(representation.segmentationId);
    });
    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);
    return filteredSegmentations;
}
function getViewportSegmentationRepresentations(viewportId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__.defaultSegmentationStateManager;
    const state = segmentationStateManager.getState();
    const viewportRepresentations = state.viewportSegRepresentations[viewportId];
    return viewportRepresentations;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeStackLabelmapFromVolume: () => (/* binding */ computeStackLabelmapFromVolume),
/* harmony export */   convertVolumeToStackLabelmap: () => (/* binding */ convertVolumeToStackLabelmap)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _helpers_updateStackSegmentationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/updateStackSegmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/updateStackSegmentationState.js");



async function computeStackLabelmapFromVolume({ volumeId, }) {
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    return { imageIds: segmentationVolume.imageIds };
}
function convertVolumeToStackLabelmap({ segmentationId, options, }) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    if (!segmentation) {
        return;
    }
    const { volumeId } = segmentation.representationData
        .Labelmap;
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    return (0,_helpers_updateStackSegmentationState__WEBPACK_IMPORTED_MODULE_2__.updateStackSegmentationState)({
        segmentationId,
        viewportId: options.viewportId,
        imageIds: segmentationVolume.imageIds,
        options,
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeVolumeLabelmapFromStack: () => (/* binding */ computeVolumeLabelmapFromStack)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

async function computeVolumeLabelmapFromStack(args) {
    return (0,_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.internalComputeVolumeLabelmapFromStack)(args);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLabelmapActorEntries: () => (/* binding */ getLabelmapActorEntries),
/* harmony export */   getLabelmapActorEntry: () => (/* binding */ getLabelmapActorEntry),
/* harmony export */   getLabelmapActorUID: () => (/* binding */ getLabelmapActorUID),
/* harmony export */   getSurfaceActorEntry: () => (/* binding */ getSurfaceActorEntry),
/* harmony export */   getSurfaceRepresentationUID: () => (/* binding */ getSurfaceRepresentationUID)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


function getActorEntry(viewportId, segmentationId, filterFn) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { renderingEngine, viewport } = enabledElement;
    if (!renderingEngine || !viewport) {
        return;
    }
    const actors = viewport.getActors();
    const filteredActors = actors.filter(filterFn);
    return filteredActors.length > 0 ? filteredActors[0] : undefined;
}
function getActorEntries(viewportId, filterFn) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { renderingEngine, viewport } = enabledElement;
    if (!renderingEngine || !viewport) {
        return;
    }
    const actors = viewport.getActors();
    const filteredActors = actors.filter(filterFn);
    return filteredActors.length > 0 ? filteredActors : undefined;
}
function getLabelmapActorUID(viewportId, segmentationId) {
    const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);
    return actorEntry?.uid;
}
function getLabelmapActorEntries(viewportId, segmentationId) {
    return getActorEntries(viewportId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap}`));
}
function getLabelmapActorEntry(viewportId, segmentationId) {
    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap}`));
}
function getSurfaceActorEntry(viewportId, segmentationId, segmentIndex) {
    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID ===
        getSurfaceRepresentationUID(segmentationId, segmentIndex));
}
function getSurfaceRepresentationUID(segmentationId, segmentIndex) {
    return `${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Surface}-${segmentIndex}`;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/index.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLabelmapActorEntries: () => (/* reexport safe */ _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__.getLabelmapActorEntries),
/* harmony export */   getLabelmapActorEntry: () => (/* reexport safe */ _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__.getLabelmapActorEntry),
/* harmony export */   getLabelmapActorUID: () => (/* reexport safe */ _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__.getLabelmapActorUID),
/* harmony export */   getSurfaceActorEntry: () => (/* reexport safe */ _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__.getSurfaceActorEntry),
/* harmony export */   validateSegmentationInput: () => (/* reexport safe */ _validateSegmentationInput__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _validateSegmentationInput__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validateSegmentationInput */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/validateSegmentationInput.js");
/* harmony import */ var _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getSegmentationActor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   internalGetHiddenSegmentIndices: () => (/* binding */ internalGetHiddenSegmentIndices)
/* harmony export */ });
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");

function internalGetHiddenSegmentIndices(viewportId, specifier) {
    const representation = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentationRepresentation)(viewportId, specifier);
    if (!representation) {
        return new Set();
    }
    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {
        if (!segment.visible) {
            acc.add(Number(segmentIndex));
        }
        return acc;
    }, new Set());
    return segmentsHidden;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js":
/*!******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


function normalizeSegmentationInput(segmentationInput) {
    const { segmentationId, representation, config } = segmentationInput;
    const { type, data: inputData } = representation;
    const data = inputData ? { ...inputData } : {};
    if (!data) {
        throw new Error('Segmentation representation data may not be undefined');
    }
    if (type === _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour) {
        normalizeContourData(data);
    }
    const normalizedSegments = normalizeSegments(config?.segments, type, data);
    delete config?.segments;
    return {
        segmentationId,
        label: config?.label ?? null,
        cachedStats: config?.cachedStats ?? {},
        segments: normalizedSegments,
        representationData: {
            [type]: {
                ...data,
            },
        },
    };
}
function normalizeContourData(contourData) {
    contourData.geometryIds = contourData.geometryIds ?? [];
    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();
}
function normalizeSegments(segmentsConfig, type, data) {
    const normalizedSegments = {};
    if (segmentsConfig) {
        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {
            const { label, locked, cachedStats, active, ...rest } = segment;
            const normalizedSegment = {
                segmentIndex: Number(segmentIndex),
                label: label ?? `Segment ${segmentIndex}`,
                locked: locked ?? false,
                cachedStats: cachedStats ?? {},
                active: active ?? false,
                ...rest,
            };
            normalizedSegments[segmentIndex] = normalizedSegment;
        });
    }
    else if (type === _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Surface) {
        normalizeSurfaceSegments(normalizedSegments, data);
    }
    else {
        normalizedSegments[1] = createDefaultSegment();
    }
    return normalizedSegments;
}
function normalizeSurfaceSegments(normalizedSegments, surfaceData) {
    const { geometryIds } = surfaceData;
    geometryIds?.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getGeometry(geometryId);
        if (geometry?.data) {
            const { segmentIndex } = geometry.data;
            normalizedSegments[segmentIndex] = { segmentIndex };
        }
    });
}
function createDefaultSegment() {
    return {
        segmentIndex: 1,
        label: 'Segment 1',
        locked: false,
        cachedStats: {},
        active: true,
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (normalizeSegmentationInput);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/updateStackSegmentationState.js":
/*!********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/updateStackSegmentationState.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateStackSegmentationState: () => (/* binding */ updateStackSegmentationState)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../addSegmentationRepresentationsToViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js");





async function updateStackSegmentationState({ segmentationId, viewportId, imageIds, options, }) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
    if (options?.removeOriginal) {
        const data = segmentation.representationData
            .Labelmap;
        if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(data.volumeId)) {
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.removeVolumeLoadObject(data.volumeId);
        }
        segmentation.representationData.Labelmap = {
            imageIds,
        };
    }
    else {
        segmentation.representationData.Labelmap = {
            ...segmentation.representationData.Labelmap,
            imageIds,
        };
    }
    await (0,_addSegmentationRepresentationsToViewport__WEBPACK_IMPORTED_MODULE_4__.addSegmentationRepresentations)(viewportId, [
        {
            segmentationId,
            type: _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap,
        },
    ]);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListenerOnce(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_RENDERED, () => (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationDataModified)(segmentationId));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/validateSegmentationInput.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/validateSegmentationInput.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_segmentation_validateLabelmap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utilities/segmentation/validateLabelmap */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/validateLabelmap.js");


function validateSegmentationInput(segmentationInputArray) {
    if (!segmentationInputArray || segmentationInputArray.length === 0) {
        throw new Error('The segmentationInputArray is undefined or an empty array');
    }
    segmentationInputArray.forEach((segmentationInput) => {
        if (segmentationInput.segmentationId === undefined) {
            throw new Error('Undefined segmentationInput.segmentationId. Please provide a valid segmentationId');
        }
        if (segmentationInput.representation === undefined) {
            throw new Error('Undefined segmentationInput.representation. Please provide a valid representation');
        }
        if (segmentationInput.representation.type ===
            _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap) {
            (0,_utilities_segmentation_validateLabelmap__WEBPACK_IMPORTED_MODULE_1__.validatePublic)(segmentationInput);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateSegmentationInput);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");


function internalAddRepresentationData({ segmentationId, type, data, }) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    if (!segmentation) {
        throw new Error(`Segmentation ${segmentationId} not found`);
    }
    if (segmentation.representationData[type]) {
        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);
    }
    switch (type) {
        case _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Labelmap:
            if (data) {
                segmentation.representationData[type] =
                    data;
            }
            break;
        case _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Contour:
            if (data) {
                segmentation.representationData[type] = data;
            }
            break;
        case _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Surface:
            if (data) {
                segmentation.representationData[type] = data;
            }
            break;
        default:
            throw new Error(`Invalid representation type ${type}`);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (internalAddRepresentationData);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   internalAddSegmentationRepresentation: () => (/* binding */ internalAddSegmentationRepresentation)
/* harmony export */ });
/* harmony import */ var _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants/COLOR_LUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./addColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js");
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");






function internalAddSegmentationRepresentation(viewportId, representationInput) {
    const { segmentationId, config } = representationInput;
    const renderingConfig = {
        colorLUTIndex: getColorLUTIndex(config),
        ...config,
    };
    _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__.defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);
    if (representationInput.type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour) {
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRenderForViewportIds)([viewportId]);
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
}
function getColorLUTIndex(config) {
    const { colorLUTOrIndex } = config || {};
    if (colorLUTOrIndex === undefined) {
        const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__.addColorLUT)(JSON.parse(JSON.stringify(_constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__["default"])));
        return index;
    }
    if (typeof colorLUTOrIndex === 'number') {
        return colorLUTOrIndex;
    }
    if (Array.isArray(colorLUTOrIndex) &&
        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {
        const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__.addColorLUT)(colorLUTOrIndex);
        return index;
    }
    const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__.addColorLUT)(JSON.parse(JSON.stringify(_constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__["default"])));
    return index;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeColorLUT: () => (/* binding */ removeColorLUT)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function removeColorLUT(colorLUTIndex) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    segmentationStateManager.removeColorLUT(colorLUTIndex);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeAllSegmentations: () => (/* binding */ removeAllSegmentations),
/* harmony export */   removeSegmentation: () => (/* binding */ removeSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./removeSegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js");



function removeSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    const viewportsWithSegmentation = segmentationStateManager
        .getAllViewportSegmentationRepresentations()
        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))
        .map(({ viewportId }) => viewportId);
    viewportsWithSegmentation.forEach((viewportId) => {
        (0,_removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__.removeSegmentationRepresentations)(viewportId, { segmentationId });
    });
    segmentationStateManager.removeSegmentation(segmentationId);
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationRemoved)(segmentationId);
}
function removeAllSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    const segmentations = segmentationStateManager.getState().segmentations;
    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);
    segmentationIds.forEach((segmentationId) => {
        removeSegmentation(segmentationId);
    });
    segmentationStateManager.resetState();
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeAllSegmentationRepresentations: () => (/* binding */ removeAllSegmentationRepresentations),
/* harmony export */   removeContourRepresentation: () => (/* binding */ removeContourRepresentation),
/* harmony export */   removeLabelmapRepresentation: () => (/* binding */ removeLabelmapRepresentation),
/* harmony export */   removeSegmentationRepresentation: () => (/* binding */ removeSegmentationRepresentation),
/* harmony export */   removeSegmentationRepresentations: () => (/* binding */ removeSegmentationRepresentations),
/* harmony export */   removeSurfaceRepresentation: () => (/* binding */ removeSurfaceRepresentation)
/* harmony export */ });
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/displayTools/Labelmap/labelmapDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js");
/* harmony import */ var _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/displayTools/Contour/contourDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js");
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
/* harmony import */ var _tools_displayTools_Surface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/displayTools/Surface */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/index.js");







function removeSegmentationRepresentation(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function removeSegmentationRepresentations(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function _removeSegmentationRepresentations(viewportId, specifier, immediate) {
    const { segmentationId, type } = specifier;
    _removeRepresentationObject(viewportId, segmentationId, type, immediate);
    return _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__.defaultSegmentationStateManager.removeSegmentationRepresentations(viewportId, {
        segmentationId,
        type,
    });
}
function removeAllSegmentationRepresentations() {
    const state = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__.defaultSegmentationStateManager.getAllViewportSegmentationRepresentations();
    state.forEach(({ viewportId, representations }) => {
        representations.forEach(({ segmentationId, type }) => {
            removeSegmentationRepresentation(viewportId, {
                segmentationId,
                type,
            });
        });
    });
    _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__.defaultSegmentationStateManager.resetState();
}
function removeLabelmapRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__["default"].Labelmap,
    }, immediate);
}
function removeContourRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__["default"].Contour,
    }, immediate);
}
function removeSurfaceRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__["default"].Surface,
    }, immediate);
}
function _removeRepresentationObject(viewportId, segmentationId, type, immediate) {
    const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__.getSegmentationRepresentations)(viewportId, {
        segmentationId,
        type,
    });
    representations.forEach((representation) => {
        if (representation.type === _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__["default"].Labelmap) {
            _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_1__["default"].removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__["default"].Contour) {
            _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_2__["default"].removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_0__["default"].Surface) {
            _tools_displayTools_Surface__WEBPACK_IMPORTED_MODULE_6__.surfaceDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
    });
    const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByViewportId)(viewportId) || {};
    if (viewport) {
        viewport.render();
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLockedSegmentIndices: () => (/* binding */ getLockedSegmentIndices),
/* harmony export */   isSegmentIndexLocked: () => (/* binding */ isSegmentIndexLocked),
/* harmony export */   setSegmentIndexLocked: () => (/* binding */ setSegmentIndexLocked)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");


function isSegmentIndexLocked(segmentationId, segmentIndex) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    return segments[segmentIndex].locked;
}
function setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    segments[segmentIndex].locked = locked;
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationModified)(segmentationId);
}
function getLockedSegmentIndices(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);
    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addColorLUT: () => (/* reexport safe */ _addColorLUT__WEBPACK_IMPORTED_MODULE_5__.addColorLUT),
/* harmony export */   addSegmentations: () => (/* reexport safe */ _addSegmentations__WEBPACK_IMPORTED_MODULE_2__.addSegmentations),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   getColorLUT: () => (/* reexport safe */ _getColorLUT__WEBPACK_IMPORTED_MODULE_6__.getColorLUT),
/* harmony export */   getCurrentLabelmapImageIdForViewport: () => (/* reexport safe */ _getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_11__.getCurrentLabelmapImageIdForViewport),
/* harmony export */   getCurrentLabelmapImageIdsForViewport: () => (/* reexport safe */ _getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_11__.getCurrentLabelmapImageIdsForViewport),
/* harmony export */   getNextColorLUTIndex: () => (/* reexport safe */ _getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_7__.getNextColorLUTIndex),
/* harmony export */   getSegmentation: () => (/* reexport safe */ _getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation),
/* harmony export */   getSegmentationRepresentation: () => (/* reexport safe */ _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_14__.getSegmentationRepresentation),
/* harmony export */   getSegmentationRepresentations: () => (/* reexport safe */ _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_14__.getSegmentationRepresentations),
/* harmony export */   getSegmentationRepresentationsBySegmentationId: () => (/* reexport safe */ _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_14__.getSegmentationRepresentationsBySegmentationId),
/* harmony export */   getSegmentations: () => (/* reexport safe */ _getSegmentations__WEBPACK_IMPORTED_MODULE_1__.getSegmentations),
/* harmony export */   getStackSegmentationImageIdsForViewport: () => (/* reexport safe */ _getStackSegmentationImageIdsForViewport__WEBPACK_IMPORTED_MODULE_13__.getStackSegmentationImageIdsForViewport),
/* harmony export */   getViewportIdsWithSegmentation: () => (/* reexport safe */ _getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithSegmentation),
/* harmony export */   getViewportSegmentationRepresentations: () => (/* reexport safe */ _getViewportSegmentations__WEBPACK_IMPORTED_MODULE_9__.getViewportSegmentationRepresentations),
/* harmony export */   getViewportSegmentations: () => (/* reexport safe */ _getViewportSegmentations__WEBPACK_IMPORTED_MODULE_9__.getViewportSegmentations),
/* harmony export */   removeAllSegmentationRepresentations: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__.removeAllSegmentationRepresentations),
/* harmony export */   removeAllSegmentations: () => (/* reexport safe */ _removeSegmentation__WEBPACK_IMPORTED_MODULE_3__.removeAllSegmentations),
/* harmony export */   removeColorLUT: () => (/* reexport safe */ _removeColorLUT__WEBPACK_IMPORTED_MODULE_8__.removeColorLUT),
/* harmony export */   removeContourRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__.removeContourRepresentation),
/* harmony export */   removeLabelmapRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__.removeLabelmapRepresentation),
/* harmony export */   removeSegmentation: () => (/* reexport safe */ _removeSegmentation__WEBPACK_IMPORTED_MODULE_3__.removeSegmentation),
/* harmony export */   removeSegmentationRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__.removeSegmentationRepresentation),
/* harmony export */   removeSurfaceRepresentation: () => (/* reexport safe */ _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__.removeSurfaceRepresentation),
/* harmony export */   updateLabelmapSegmentationImageReferences: () => (/* reexport safe */ _updateLabelmapSegmentationImageReferences__WEBPACK_IMPORTED_MODULE_12__.updateLabelmapSegmentationImageReferences)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _getSegmentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js");
/* harmony import */ var _addSegmentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js");
/* harmony import */ var _removeSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./removeSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js");
/* harmony import */ var _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./removeSegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js");
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./addColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js");
/* harmony import */ var _getColorLUT__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js");
/* harmony import */ var _getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getNextColorLUTIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js");
/* harmony import */ var _removeColorLUT__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./removeColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js");
/* harmony import */ var _getViewportSegmentations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getViewportSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js");
/* harmony import */ var _getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getViewportIdsWithSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js");
/* harmony import */ var _getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");
/* harmony import */ var _updateLabelmapSegmentationImageReferences__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./updateLabelmapSegmentationImageReferences */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js");
/* harmony import */ var _getStackSegmentationImageIdsForViewport__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./getStackSegmentationImageIdsForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js");
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
















function destroy() {
    _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__.defaultSegmentationStateManager.resetState();
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setActiveSegmentation: () => (/* binding */ setActiveSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function setActiveSegmentation(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationDataModified: () => (/* reexport safe */ _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationDataModified),
/* harmony export */   triggerSegmentationModified: () => (/* reexport safe */ _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationModified),
/* harmony export */   triggerSegmentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationRemoved),
/* harmony export */   triggerSegmentationRepresentationModified: () => (/* reexport safe */ _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified),
/* harmony export */   triggerSegmentationRepresentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)
/* harmony export */ });
/* harmony import */ var _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/triggerSegmentationDataModified */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js");
/* harmony import */ var _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/triggerSegmentationModified */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js");
/* harmony import */ var _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/triggerSegmentationRemoved */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js");
/* harmony import */ var _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/triggerSegmentationRepresentationModified */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js");
/* harmony import */ var _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/triggerSegmentationRepresentationRemoved */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js");








/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateLabelmapSegmentationImageReferences: () => (/* binding */ updateLabelmapSegmentationImageReferences)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");

function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__.defaultSegmentationStateManager;
    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ToolGroup)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.get */ "../../../node_modules/lodash.get/index.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _cursors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../cursors */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _getToolGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js");








const { Active, Passive, Enabled, Disabled } = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes;
const PRIMARY_BINDINGS = [{ mouseButton: _enums__WEBPACK_IMPORTED_MODULE_0__.MouseBindings.Primary }];
class ToolGroup {
    constructor(id) {
        this.viewportsInfo = [];
        this.toolOptions = {};
        this.currentActivePrimaryToolName = null;
        this.prevActivePrimaryToolName = null;
        this.restoreToolOptions = {};
        this._toolInstances = {};
        this.id = id;
    }
    getViewportIds() {
        return this.viewportsInfo.map(({ viewportId }) => viewportId);
    }
    getViewportsInfo() {
        return this.viewportsInfo.slice();
    }
    getToolInstance(toolInstanceName) {
        const toolInstance = this._toolInstances[toolInstanceName];
        if (!toolInstance) {
            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);
            return;
        }
        return toolInstance;
    }
    getToolInstances() {
        return this._toolInstances;
    }
    hasTool(toolName) {
        return !!this._toolInstances[toolName];
    }
    addTool(toolName, configuration = {}) {
        const toolDefinition = _state__WEBPACK_IMPORTED_MODULE_3__.state.tools[toolName];
        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';
        const localToolInstance = this.toolOptions[toolName];
        if (!hasToolName) {
            console.warn('Tool with configuration did not produce a toolName: ', configuration);
            return;
        }
        if (!toolDefinition) {
            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);
            return;
        }
        if (localToolInstance) {
            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);
            return;
        }
        const { toolClass: ToolClass } = toolDefinition;
        const toolProps = {
            name: toolName,
            toolGroupId: this.id,
            configuration,
        };
        const instantiatedTool = new ToolClass(toolProps);
        this._toolInstances[toolName] = instantiatedTool;
    }
    addToolInstance(toolName, parentClassName, configuration = {}) {
        let ToolClassToUse = _state__WEBPACK_IMPORTED_MODULE_3__.state.tools[toolName]
            ?.toolClass;
        if (!ToolClassToUse) {
            const ParentClass = _state__WEBPACK_IMPORTED_MODULE_3__.state.tools[parentClassName]
                .toolClass;
            class ToolInstance extends ParentClass {
            }
            ToolInstance.toolName = toolName;
            ToolClassToUse = ToolInstance;
            _state__WEBPACK_IMPORTED_MODULE_3__.state.tools[toolName] = {
                toolClass: ToolInstance,
            };
        }
        this.addTool(ToolClassToUse.toolName, configuration);
    }
    addViewport(viewportId, renderingEngineId) {
        if (typeof viewportId !== 'string') {
            throw new Error('viewportId must be defined and be a string');
        }
        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);
        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {
            this.viewportsInfo.push({
                viewportId,
                renderingEngineId: renderingEngineUIDToUse,
            });
        }
        const toolName = this.getActivePrimaryMouseButtonTool();
        const runtimeSettings = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Settings.getRuntimeSettings();
        if (runtimeSettings.get('useCursors')) {
            this.setViewportsCursorByToolName(toolName);
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId: renderingEngineUIDToUse,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);
    }
    removeViewports(renderingEngineId, viewportId) {
        const indices = [];
        this.viewportsInfo.forEach((vpInfo, index) => {
            let match = false;
            if (vpInfo.renderingEngineId === renderingEngineId) {
                match = true;
                if (viewportId && vpInfo.viewportId !== viewportId) {
                    match = false;
                }
            }
            if (match) {
                indices.push(index);
            }
        });
        if (indices.length) {
            for (let i = indices.length - 1; i >= 0; i--) {
                this.viewportsInfo.splice(indices[i], 1);
            }
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);
    }
    setActiveStrategy(toolName, strategyName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);
            return;
        }
        toolInstance.setActiveStrategy(strategyName);
    }
    setToolMode(toolName, mode, options = {}) {
        if (!toolName) {
            console.warn('setToolMode: toolName must be defined');
            return;
        }
        if (mode === _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Active) {
            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);
            return;
        }
        if (mode === _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Passive) {
            this.setToolPassive(toolName);
            return;
        }
        if (mode === _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Enabled) {
            this.setToolEnabled(toolName);
            return;
        }
        if (mode === _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Disabled) {
            this.setToolDisabled(toolName);
            return;
        }
        console.warn('setToolMode: mode must be defined');
    }
    setToolActive(toolName, toolBindingsOptions = {}) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        if (!toolInstance) {
            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);
            return;
        }
        const prevBindings = this.toolOptions[toolName]
            ? this.toolOptions[toolName].bindings
            : [];
        const newBindings = toolBindingsOptions.bindings
            ? toolBindingsOptions.bindings
            : [];
        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {
            const TouchBinding = binding.numTouchPoints !== undefined;
            const MouseBinding = binding.mouseButton !== undefined;
            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&
                (TouchBinding || MouseBinding)) {
                unique.push(binding);
            }
            return unique;
        }, []);
        const toolOptions = {
            bindings: bindingsToUse,
            mode: Active,
        };
        this.toolOptions[toolName] = toolOptions;
        this._toolInstances[toolName].mode = Active;
        const runtimeSettings = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Settings.getRuntimeSettings();
        const useCursor = runtimeSettings.get('useCursors');
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {
            this.setViewportsCursorByToolName(toolName);
        }
        else {
            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();
            if (!activeToolIdentifier && useCursor) {
                const cursor = _cursors__WEBPACK_IMPORTED_MODULE_4__.MouseCursor.getDefinedCursor('default');
                this._setCursorForViewports(cursor);
            }
        }
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {
            if (this.prevActivePrimaryToolName === null) {
                this.prevActivePrimaryToolName = toolName;
            }
            else {
                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;
            }
            this.currentActivePrimaryToolName = toolName;
        }
        if (typeof toolInstance.onSetToolActive === 'function') {
            toolInstance.onSetToolActive();
        }
        this._renderViewports();
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            toolBindingsOptions,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOOL_ACTIVATED, eventDetail);
        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);
    }
    setToolPassive(toolName, options) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const prevToolOptions = this.getToolOptions(toolName);
        const toolOptions = Object.assign({
            bindings: prevToolOptions ? prevToolOptions.bindings : [],
        }, prevToolOptions, {
            mode: Passive,
        });
        const matchBindings = Array.isArray(options?.removeAllBindings)
            ? options.removeAllBindings
            : this.getDefaultPrimaryBindings();
        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&
            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));
        let mode = Passive;
        if (toolOptions.bindings.length !== 0) {
            mode = Active;
            toolOptions.mode = mode;
        }
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = mode;
        if (typeof toolInstance.onSetToolPassive === 'function') {
            toolInstance.onSetToolPassive();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Passive);
    }
    setToolEnabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Enabled,
        };
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Enabled;
        if (typeof toolInstance.onSetToolEnabled === 'function') {
            toolInstance.onSetToolEnabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Enabled);
    }
    setToolDisabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Disabled,
        };
        this.restoreToolOptions[toolName] = this.toolOptions[toolName];
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Disabled;
        if (typeof toolInstance.onSetToolDisabled === 'function') {
            toolInstance.onSetToolDisabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Disabled);
    }
    getToolOptions(toolName) {
        const toolOptionsForTool = this.toolOptions[toolName];
        if (toolOptionsForTool === undefined) {
            return;
        }
        return toolOptionsForTool;
    }
    getActivePrimaryMouseButtonTool() {
        return Object.keys(this.toolOptions).find((toolName) => {
            const toolOptions = this.toolOptions[toolName];
            return (toolOptions.mode === Active &&
                this._hasMousePrimaryButtonBinding(toolOptions));
        });
    }
    setViewportsCursorByToolName(toolName, strategyName) {
        const cursor = this._getCursor(toolName, strategyName);
        this._setCursorForViewports(cursor);
    }
    _getCursor(toolName, strategyName) {
        let cursorName;
        let cursor;
        if (strategyName) {
            cursorName = `${toolName}.${strategyName}`;
            cursor = _cursors__WEBPACK_IMPORTED_MODULE_4__.SVGMouseCursor.getDefinedCursor(cursorName, true);
            if (cursor) {
                return cursor;
            }
        }
        cursorName = `${toolName}`;
        cursor = _cursors__WEBPACK_IMPORTED_MODULE_4__.SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        cursorName = toolName;
        cursor = _cursors__WEBPACK_IMPORTED_MODULE_4__.SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        return _cursors__WEBPACK_IMPORTED_MODULE_4__.MouseCursor.getDefinedCursor('default');
    }
    _setCursorForViewports(cursor) {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.initElementCursor)(viewport.element, cursor);
        });
    }
    setToolConfiguration(toolName, configuration, overwrite) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return false;
        }
        let _configuration;
        if (overwrite) {
            _configuration = configuration;
        }
        else {
            _configuration = Object.assign(toolInstance.configuration, configuration);
        }
        toolInstance.configuration = _configuration;
        if (typeof toolInstance.onSetToolConfiguration === 'function') {
            toolInstance.onSetToolConfiguration();
        }
        this._renderViewports();
        return true;
    }
    getDefaultMousePrimary() {
        return _enums__WEBPACK_IMPORTED_MODULE_0__.MouseBindings.Primary;
    }
    getDefaultPrimaryBindings() {
        return PRIMARY_BINDINGS;
    }
    getToolConfiguration(toolName, configurationPath) {
        if (this._toolInstances[toolName] === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return;
        }
        const _configuration = lodash_get__WEBPACK_IMPORTED_MODULE_1___default()(this._toolInstances[toolName].configuration, configurationPath) ||
            this._toolInstances[toolName].configuration;
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.deepClone(_configuration);
    }
    getPrevActivePrimaryToolName() {
        return this.prevActivePrimaryToolName;
    }
    setActivePrimaryTool(toolName) {
        const activeToolName = this.getCurrentActivePrimaryToolName();
        this.setToolDisabled(activeToolName);
        this.setToolActive(toolName, {
            bindings: [{ mouseButton: _enums__WEBPACK_IMPORTED_MODULE_0__.MouseBindings.Primary }],
        });
    }
    getCurrentActivePrimaryToolName() {
        return this.currentActivePrimaryToolName;
    }
    clone(newToolGroupId, fnToolFilter = null) {
        let toolGroup = (0,_getToolGroup__WEBPACK_IMPORTED_MODULE_6__["default"])(newToolGroupId);
        if (toolGroup) {
            console.debug(`ToolGroup ${newToolGroupId} already exists`);
            return toolGroup;
        }
        toolGroup = new ToolGroup(newToolGroupId);
        _state__WEBPACK_IMPORTED_MODULE_3__.state.toolGroups.push(toolGroup);
        fnToolFilter = fnToolFilter ?? (() => true);
        Object.keys(this._toolInstances)
            .filter(fnToolFilter)
            .forEach((toolName) => {
            const sourceToolInstance = this._toolInstances[toolName];
            const sourceToolOptions = this.toolOptions[toolName];
            const sourceToolMode = sourceToolInstance.mode;
            toolGroup.addTool(toolName);
            toolGroup.setToolMode(toolName, sourceToolMode, {
                bindings: sourceToolOptions.bindings ?? [],
            });
        });
        return toolGroup;
    }
    _hasMousePrimaryButtonBinding(toolOptions) {
        const primaryBindings = this.getDefaultPrimaryBindings();
        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));
    }
    _renderViewports() {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getRenderingEngine)(renderingEngineId).renderViewport(viewportId);
        });
    }
    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            mode,
            toolBindingsOptions,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOOL_MODE_CHANGED, eventDetail);
    }
    _findRenderingEngine(viewportId, renderingEngineId) {
        const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getRenderingEngines)();
        if (renderingEngines?.length === 0) {
            throw new Error('No rendering engines found.');
        }
        if (renderingEngineId) {
            return renderingEngineId;
        }
        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));
        if (matchingEngines.length === 0) {
            if (renderingEngines.length === 1) {
                return renderingEngines[0].id;
            }
            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        if (matchingEngines.length > 1) {
            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        return matchingEngines[0].id;
    }
}
function hasSameBinding(binding1, binding2) {
    if (binding1.mouseButton !== binding2.mouseButton) {
        return false;
    }
    if (binding1.numTouchPoints !== binding2.numTouchPoints) {
        return false;
    }
    return binding1.modifierKey === binding2.modifierKey;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _ToolGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js");


function createToolGroup(toolGroupId) {
    const toolGroupWithIdExists = _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups.some((tg) => tg.id === toolGroupId);
    if (toolGroupWithIdExists) {
        console.warn(`'${toolGroupId}' already exists.`);
        return;
    }
    const toolGroup = new _ToolGroup__WEBPACK_IMPORTED_MODULE_1__["default"](toolGroupId);
    _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups.push(toolGroup);
    return toolGroup;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createToolGroup);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _destroyToolGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./destroyToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js");


function destroy() {
    const toolGroups = [..._state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups];
    for (const toolGroup of toolGroups) {
        (0,_destroyToolGroup__WEBPACK_IMPORTED_MODULE_1__["default"])(toolGroup.id);
    }
    _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups = [];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (destroy);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function destroyToolGroup(toolGroupId) {
    const toolGroupIndex = _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups.findIndex((tg) => tg.id === toolGroupId);
    if (toolGroupIndex > -1) {
        _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups.splice(toolGroupIndex, 1);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (destroyToolGroup);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function getAllToolGroups() {
    return _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getAllToolGroups);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function getToolGroup(toolGroupId) {
    return _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups.find((s) => s.id === toolGroupId);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getToolGroup);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");


function getToolGroupForViewport(viewportId, renderingEngineId) {
    if (!renderingEngineId) {
        renderingEngineId = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;
    }
    const toolGroupFilteredByIds = _state__WEBPACK_IMPORTED_MODULE_1__.state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&
        (!vp.viewportId || vp.viewportId === viewportId)));
    if (!toolGroupFilteredByIds.length) {
        return;
    }
    if (toolGroupFilteredByIds.length > 1) {
        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only
      have one tool group per viewport in a renderingEngine.`);
    }
    return toolGroupFilteredByIds[0];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getToolGroupForViewport);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");


const MODES = [_enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes.Active, _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes.Passive, _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes.Enabled];
function getToolGroupsWithToolName(toolName) {
    return _state__WEBPACK_IMPORTED_MODULE_0__.state.toolGroups.filter(({ toolOptions }) => {
        const toolGroupToolNames = Object.keys(toolOptions);
        for (let i = 0; i < toolGroupToolNames.length; i++) {
            if (toolName !== toolGroupToolNames[i]) {
                continue;
            }
            if (!toolOptions[toolName]) {
                continue;
            }
            if (MODES.includes(toolOptions[toolName].mode)) {
                return true;
            }
        }
        return false;
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getToolGroupsWithToolName);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createToolGroup: () => (/* reexport safe */ _createToolGroup__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   destroy: () => (/* reexport safe */ _destroy__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   destroyToolGroup: () => (/* reexport safe */ _destroyToolGroup__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   getAllToolGroups: () => (/* reexport safe */ _getAllToolGroups__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   getToolGroup: () => (/* reexport safe */ _getToolGroup__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   getToolGroupForViewport: () => (/* reexport safe */ _getToolGroupForViewport__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   getToolGroupsWithToolName: () => (/* reexport safe */ _getToolGroupsWithToolName__WEBPACK_IMPORTED_MODULE_6__["default"])
/* harmony export */ });
/* harmony import */ var _createToolGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js");
/* harmony import */ var _destroyToolGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./destroyToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js");
/* harmony import */ var _destroy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./destroy */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js");
/* harmony import */ var _getToolGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js");
/* harmony import */ var _getToolGroupForViewport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getToolGroupForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js");
/* harmony import */ var _getAllToolGroups__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getAllToolGroups */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js");
/* harmony import */ var _getToolGroupsWithToolName__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getToolGroupsWithToolName */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js");










/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addTool: () => (/* binding */ addTool),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   hasTool: () => (/* binding */ hasTool),
/* harmony export */   hasToolByName: () => (/* binding */ hasToolByName),
/* harmony export */   removeTool: () => (/* binding */ removeTool)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");

function addTool(ToolClass) {
    const toolName = ToolClass.toolName;
    if (!toolName) {
        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);
    }
    if (!_state__WEBPACK_IMPORTED_MODULE_0__.state.tools[toolName]) {
        _state__WEBPACK_IMPORTED_MODULE_0__.state.tools[toolName] = {
            toolClass: ToolClass,
        };
    }
}
function hasTool(ToolClass) {
    const toolName = ToolClass.toolName;
    return !!(toolName && _state__WEBPACK_IMPORTED_MODULE_0__.state.tools[toolName]);
}
function hasToolByName(toolName) {
    return !!(toolName && _state__WEBPACK_IMPORTED_MODULE_0__.state.tools[toolName]);
}
function removeTool(ToolClass) {
    const toolName = ToolClass.toolName;
    if (!toolName) {
        throw new Error(`No tool found for: ${ToolClass.name}`);
    }
    if (!_state__WEBPACK_IMPORTED_MODULE_0__.state.tools[toolName] !== undefined) {
        delete _state__WEBPACK_IMPORTED_MODULE_0__.state.tools[toolName];
    }
    else {
        throw new Error(`${toolName} cannot be removed because it has not been added`);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ state),
/* harmony export */   resetCornerstoneToolsState: () => (/* binding */ resetCornerstoneToolsState),
/* harmony export */   state: () => (/* binding */ state)
/* harmony export */ });
/* harmony import */ var _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svgNodeCache */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js");

const defaultState = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__["default"],
    enabledElements: [],
    handleRadius: 6,
};
let state = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__["default"],
    enabledElements: [],
    handleRadius: 6,
};
function resetCornerstoneToolsState() {
    (0,_svgNodeCache__WEBPACK_IMPORTED_MODULE_0__.resetSvgNodeCache)();
    state = {
        ...structuredClone({
            ...defaultState,
            svgNodeCache: {},
        }),
        svgNodeCache: {
            ...defaultState.svgNodeCache,
        },
    };
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   resetSvgNodeCache: () => (/* binding */ resetSvgNodeCache)
/* harmony export */ });
let svgNodeCache = {};
function resetSvgNodeCache() {
    svgNodeCache = {};
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (svgNodeCache);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/math/line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");

















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class BidirectionalTool extends _base__WEBPACK_IMPORTED_MODULE_3__.AnnotationTool {
    static { this.toolName = 'Bidirectional'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            let canvasPoint1 = viewport.worldToCanvas(points[0]);
            let canvasPoint2 = viewport.worldToCanvas(points[1]);
            let line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            let distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            canvasPoint1 = viewport.worldToCanvas(points[2]);
            canvasPoint2 = viewport.worldToCanvas(points[3]);
            line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const data = annotation.data;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            if (this.editData.handleIndex !== undefined) {
                const { points } = data.handles;
                const firstLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.distance(points[0], points[1]);
                const secondLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.distance(points[2], points[3]);
                if (secondLineSegmentLength > firstLineSegmentLength) {
                    const longAxis = [[...points[2]], [...points[3]]];
                    const shortAxisPoint0 = [...points[0]];
                    const shortAxisPoint1 = [...points[1]];
                    const longAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);
                    const counterClockWisePerpendicularToLongAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);
                    const currentShortAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);
                    let shortAxis;
                    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {
                        shortAxis = [shortAxisPoint0, shortAxisPoint1];
                    }
                    else {
                        shortAxis = [shortAxisPoint1, shortAxisPoint0];
                    }
                    data.handles.points = [
                        longAxis[0],
                        longAxis[1],
                        shortAxis[0],
                        shortAxis[1],
                    ];
                }
            }
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { worldToCanvas } = viewport;
            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            const worldPos = currentPoints.world;
            data.handles.points[handleIndex] = [...worldPos];
            const canvasCoordPoints = data.handles.points.map(worldToCanvas);
            const canvasCoords = {
                longLineSegment: {
                    start: {
                        x: canvasCoordPoints[0][0],
                        y: canvasCoordPoints[0][1],
                    },
                    end: {
                        x: canvasCoordPoints[1][0],
                        y: canvasCoordPoints[1][1],
                    },
                },
                shortLineSegment: {
                    start: {
                        x: canvasCoordPoints[2][0],
                        y: canvasCoordPoints[2][1],
                    },
                    end: {
                        x: canvasCoordPoints[3][0],
                        y: canvasCoordPoints[3][1],
                    },
                },
            };
            const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);
            const shortAxisDistFromCenter = dist / 3;
            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;
            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const vectorX = dx / length;
            const vectorY = dy / length;
            const xMid = (canvasCoords.longLineSegment.start.x +
                canvasCoords.longLineSegment.end.x) /
                2;
            const yMid = (canvasCoords.longLineSegment.start.y +
                canvasCoords.longLineSegment.end.y) /
                2;
            const startX = xMid + shortAxisDistFromCenter * vectorY;
            const startY = yMid - shortAxisDistFromCenter * vectorX;
            const endX = xMid - shortAxisDistFromCenter * vectorY;
            const endY = yMid + shortAxisDistFromCenter * vectorX;
            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);
            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.HandlesUpdated);
            this.editData.hasMoved = true;
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragModifyHandle(evt);
                annotation.invalidated = true;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragModifyHandle = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { annotation, handleIndex: movingHandleIndex } = this.editData;
            const { data } = annotation;
            const worldPos = currentPoints.world;
            const canvasCoordHandlesCurrent = [
                viewport.worldToCanvas(data.handles.points[0]),
                viewport.worldToCanvas(data.handles.points[1]),
                viewport.worldToCanvas(data.handles.points[2]),
                viewport.worldToCanvas(data.handles.points[3]),
            ];
            const firstLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[0][0],
                    y: canvasCoordHandlesCurrent[0][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[1][0],
                    y: canvasCoordHandlesCurrent[1][1],
                },
            };
            const secondLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[2][0],
                    y: canvasCoordHandlesCurrent[2][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[3][0],
                    y: canvasCoordHandlesCurrent[3][1],
                },
            };
            const proposedPoint = [...worldPos];
            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);
            if (movingHandleIndex === 0 || movingHandleIndex === 1) {
                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;
                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];
                const fixedHandleToProposedCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);
                const fixedHandleToOldCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -
                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -
                    fixedHandleCanvasCoord[1]);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);
                const proposedFirstLineSegment = {
                    start: {
                        x: fixedHandleCanvasCoord[0],
                        y: fixedHandleCanvasCoord[1],
                    },
                    end: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                };
                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {
                    return;
                }
                const centerOfRotation = fixedHandleCanvasCoord;
                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);
                let firstPointX = canvasCoordHandlesCurrent[2][0];
                let firstPointY = canvasCoordHandlesCurrent[2][1];
                let secondPointX = canvasCoordHandlesCurrent[3][0];
                let secondPointY = canvasCoordHandlesCurrent[3][1];
                firstPointX -= centerOfRotation[0];
                firstPointY -= centerOfRotation[1];
                secondPointX -= centerOfRotation[0];
                secondPointY -= centerOfRotation[1];
                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);
                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);
                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);
                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);
                firstPointX = rotatedFirstPoint + centerOfRotation[0];
                firstPointY = rotatedFirstPointY + centerOfRotation[1];
                secondPointX = rotatedSecondPoint + centerOfRotation[0];
                secondPointY = rotatedSecondPointY + centerOfRotation[1];
                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);
                const newSecondPoint = viewport.canvasToWorld([
                    secondPointX,
                    secondPointY,
                ]);
                data.handles.points[movingHandleIndex] = proposedPoint;
                data.handles.points[2] = newFirstPoint;
                data.handles.points[3] = newSecondPoint;
            }
            else {
                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;
                const canvasCoordsCurrent = {
                    longLineSegment: {
                        start: firstLineSegment.start,
                        end: firstLineSegment.end,
                    },
                    shortLineSegment: {
                        start: secondLineSegment.start,
                        end: secondLineSegment.end,
                    },
                };
                const longLineSegmentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), [
                    canvasCoordsCurrent.longLineSegment.end.x,
                    canvasCoordsCurrent.longLineSegment.end.y,
                ], [
                    canvasCoordsCurrent.longLineSegment.start.x,
                    canvasCoordsCurrent.longLineSegment.start.y,
                ]);
                const longLineSegmentVecNormalized = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), longLineSegmentVec);
                const proposedToCurrentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [
                    canvasCoordHandlesCurrent[movingHandleIndex][0],
                    canvasCoordHandlesCurrent[movingHandleIndex][1],
                ]);
                const movementLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.length(proposedToCurrentVec);
                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);
                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;
                const newTranslatedPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), [
                    canvasCoordHandlesCurrent[translateHandleIndex][0],
                    canvasCoordHandlesCurrent[translateHandleIndex][1],
                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);
                if (this._movingLongAxisWouldPutItThroughShortAxis({
                    start: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                    end: {
                        x: newTranslatedPoint[0],
                        y: newTranslatedPoint[1],
                    },
                }, {
                    start: {
                        x: canvasCoordsCurrent.longLineSegment.start.x,
                        y: canvasCoordsCurrent.longLineSegment.start.y,
                    },
                    end: {
                        x: canvasCoordsCurrent.longLineSegment.end.x,
                        y: canvasCoordsCurrent.longLineSegment.end.y,
                    },
                })) {
                    return;
                }
                const intersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
                if (!intersectionPoint) {
                    return;
                }
                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);
                data.handles.points[movingHandleIndex] = proposedPoint;
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = true;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        width: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId1 = `${annotationUID}-line-1`;
                const dataId2 = `${annotationUID}-line-2`;
                const lineUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId1);
                const secondLineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId2);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_14__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {
            const vectorInSecondLineDirection = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);
            const extendedSecondLineSegment = {
                start: {
                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,
                },
                end: {
                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,
                },
            };
            const proposedIntersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
            const wouldPutThroughShortAxis = !proposedIntersectionPoint;
            return wouldPutThroughShortAxis;
        };
        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { element } = enabledElement.viewport;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const worldPos3 = data.handles.points[2];
            const worldPos4 = data.handles.points[3];
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { imageData, dimensions } = image;
                const index1 = transformWorldToIndex(imageData, worldPos1);
                const index2 = transformWorldToIndex(imageData, worldPos2);
                const index3 = transformWorldToIndex(imageData, worldPos3);
                const index4 = transformWorldToIndex(imageData, worldPos4);
                const handles1 = [index1, index2];
                const handles2 = [index3, index4];
                const { scale: scale1, unit: units1 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, handles1);
                const { scale: scale2, unit: units2 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, handles2);
                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;
                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;
                const length = dist1 > dist2 ? dist1 : dist2;
                const width = dist1 > dist2 ? dist2 : dist1;
                const unit = dist1 > dist2 ? units1 : units2;
                const widthUnit = dist1 > dist2 ? units2 : units1;
                this._isInsideVolume(index1, index2, index3, index4, dimensions)
                    ? (this.isHandleOutsideImage = false)
                    : (this.isHandleOutsideImage = true);
                cachedStats[targetId] = {
                    length,
                    width,
                    unit,
                    widthUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index3, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index4, dimensions));
        };
        this._getSignedAngle = (vector1, vector2) => {
            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const worldPos = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        this.isDrawing = true;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const annotation = {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID,
                referencedImageId,
                ...viewport.getViewReference({ points: [worldPos] }),
            },
            data: {
                handles: {
                    points: [
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                    ],
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex: 1,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
        };
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
        return annotation;
    }
    static { this.hydrate = (viewportId, axis, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, [], options);
        const [majorAxis, minorAxis] = axis;
        const [major0, major1] = majorAxis;
        const [minor0, minor1] = minorAxis;
        const points = [major0, major1, minor0, minor1];
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])([viewport.id]);
        return annotation;
    }; }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
}
function defaultGetTextLines(data, targetId) {
    const { cachedStats, label } = data;
    const { length, width, unit } = cachedStats[targetId];
    const textLines = [];
    if (label) {
        textLines.push(label);
    }
    if (length === undefined) {
        return textLines;
    }
    textLines.push(`L: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(length)} ${unit || unit}`, `W: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(width)} ${unit}`);
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BidirectionalTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PlanarFreehandROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js");



class PlanarFreehandContourSegmentationTool extends _PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }
    constructor(toolProps) {
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge({
            configuration: {
                calculateStats: false,
                allowOpenContours: false,
            },
        }, toolProps);
        super(initialProps);
    }
    isContourSegmentationTool() {
        return true;
    }
    renderAnnotationInstance(renderContext) {
        const annotation = renderContext.annotation;
        const { invalidated } = annotation;
        const renderResult = super.renderAnnotationInstance(renderContext);
        if (invalidated) {
            const { segmentationId } = annotation.data.segmentation;
            (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(segmentationId);
        }
        return renderResult;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarFreehandContourSegmentationTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/planar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _planarFreehandROITool_drawLoop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./planarFreehandROITool/drawLoop */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js");
/* harmony import */ var _planarFreehandROITool_editLoopCommon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./planarFreehandROITool/editLoopCommon */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js");
/* harmony import */ var _planarFreehandROITool_closedContourEditLoop__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./planarFreehandROITool/closedContourEditLoop */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js");
/* harmony import */ var _planarFreehandROITool_openContourEditLoop__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./planarFreehandROITool/openContourEditLoop */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js");
/* harmony import */ var _planarFreehandROITool_openContourEndEditLoop__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./planarFreehandROITool/openContourEndEditLoop */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js");
/* harmony import */ var _planarFreehandROITool_renderMethods__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./planarFreehandROITool/renderMethods */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_math_polyline__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/math/polyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js");
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/viewport/isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities/math/basic */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js");
/* harmony import */ var _utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../utilities/contours/calculatePerimeter */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js");
/* harmony import */ var _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../base/ContourSegmentationBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../utilities/getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");

























const { pointCanProjectOnLine } = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.polyline;
const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON;
class PlanarFreehandROITool extends _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_21__["default"] {
    static { this.toolName = 'PlanarFreehandROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            shadow: true,
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: _enums__WEBPACK_IMPORTED_MODULE_22__.KeyboardBindings.Shift,
            alwaysRenderOpenContourHandles: {
                enabled: false,
                radius: 2,
            },
            allowOpenContours: true,
            closeContourProximity: 10,
            checkCanvasEditFallbackProximity: 6,
            makeClockWise: true,
            subPixelResolution: 4,
            smoothing: {
                smoothOnAdd: false,
                smoothOnEdit: false,
                knotsRatioPercentageOnAdd: 40,
                knotsRatioPercentageOnEdit: 40,
            },
            interpolation: {
                enabled: false,
                onInterpolationComplete: null,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            displayOnePointAsCrosshairs: false,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isEditingClosed = false;
        this.isEditingOpen = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const annotation = this.createAnnotation(evt);
            this.addAnnotation(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.activateDraw(evt, annotation, viewportIdsToRender);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            if (annotation.data.contour.closed) {
                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
            }
            else {
                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);
            }
            evt.preventDefault();
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { polyline: points } = annotation.data.contour;
            let previousPoint = viewport.worldToCanvas(points[0]);
            for (let i = 1; i < points.length; i++) {
                const p1 = previousPoint;
                const p2 = viewport.worldToCanvas(points[i]);
                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);
                if (canProject) {
                    return true;
                }
                previousPoint = p2;
            }
            if (!annotation.data.contour.closed) {
                return false;
            }
            const pStart = viewport.worldToCanvas(points[0]);
            const pEnd = viewport.worldToCanvas(points[points.length - 1]);
            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);
        };
        this.cancel = (element) => {
            const isDrawing = this.isDrawing;
            const isEditingOpen = this.isEditingOpen;
            const isEditingClosed = this.isEditingClosed;
            if (isDrawing) {
                this.cancelDrawing(element);
            }
            else if (isEditingOpen) {
                this.cancelOpenContourEdit(element);
            }
            else if (isEditingClosed) {
                this.cancelClosedContourEdit(element);
            }
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { cachedStats } = data;
            const { polyline: points, closed } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { imageData, metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const modalityUnitOptions = {
                    isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__.isViewportPreScaled)(viewport, targetId),
                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                };
                const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_23__.getPixelValueUnits)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
                const calibratedScale = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, () => {
                    const polyline = data.contour.polyline;
                    const numPoints = polyline.length;
                    const projectedPolyline = new Array(numPoints);
                    for (let i = 0; i < numPoints; i++) {
                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
                    }
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.polyline.getAABB(projectedPolyline);
                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);
                    const topLeftBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                if (closed) {
                    this.updateClosedCachedStats({
                        targetId,
                        viewport,
                        canvasCoordinates,
                        points,
                        imageData,
                        metadata,
                        cachedStats,
                        modalityUnit,
                        calibratedScale,
                    });
                }
                else {
                    this.updateOpenCachedStats({
                        metadata,
                        canvasCoordinates,
                        targetId,
                        cachedStats,
                        modalityUnit,
                        calibratedScale,
                    });
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__.triggerAnnotationModified)(annotation, enabledElement.viewport.element, _enums__WEBPACK_IMPORTED_MODULE_22__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {
            const { data } = annotation;
            const targetId = this.getTargetId(viewport);
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
                annotationUID: annotation.annotationUID,
            };
            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
            if (!options.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_16__.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = '1';
            const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_15__.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        (0,_planarFreehandROITool_drawLoop__WEBPACK_IMPORTED_MODULE_8__["default"])(this);
        (0,_planarFreehandROITool_editLoopCommon__WEBPACK_IMPORTED_MODULE_9__["default"])(this);
        (0,_planarFreehandROITool_closedContourEditLoop__WEBPACK_IMPORTED_MODULE_10__["default"])(this);
        (0,_planarFreehandROITool_openContourEditLoop__WEBPACK_IMPORTED_MODULE_11__["default"])(this);
        (0,_planarFreehandROITool_openContourEndEditLoop__WEBPACK_IMPORTED_MODULE_12__["default"])(this);
        (0,_planarFreehandROITool_renderMethods__WEBPACK_IMPORTED_MODULE_13__["default"])(this);
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_5__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations || !annotations.length) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let annotationsToDisplay;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            const camera = viewport.getCamera();
            const { spacingInNormalDirection } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
        }
        else {
            annotationsToDisplay = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_4__.filterAnnotationsForDisplay)(viewport, annotations);
        }
        return annotationsToDisplay;
    }
    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
        const { viewPlaneNormal } = camera;
        const annotationsWithParallelNormals = annotations.filter((td) => {
            let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
            if (!td.metadata.referencedImageId &&
                !annotationViewPlaneNormal &&
                td.metadata.FrameOfReferenceUID) {
                for (const point of td.data.contour.polyline) {
                    const vector = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), point, camera.focalPoint);
                    const dotProduct = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(vector, camera.viewPlaneNormal);
                    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(dotProduct, 0)) {
                        return false;
                    }
                }
                td.metadata.viewPlaneNormal = camera.viewPlaneNormal;
                td.metadata.cameraFocalPoint = camera.focalPoint;
                return true;
            }
            if (!annotationViewPlaneNormal) {
                const { referencedImageId } = td.metadata;
                const { imageOrientationPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('imagePlaneModule', referencedImageId);
                const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
                const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
                annotationViewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);
                td.metadata.viewPlaneNormal = annotationViewPlaneNormal;
            }
            const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >
                PARALLEL_THRESHOLD;
            return annotationViewPlaneNormal && isParallel;
        });
        if (!annotationsWithParallelNormals.length) {
            return [];
        }
        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
        const { focalPoint } = camera;
        const annotationsWithinSlice = [];
        for (const annotation of annotationsWithParallelNormals) {
            const data = annotation.data;
            const point = data.contour.polyline[0];
            if (!annotation.isVisible) {
                continue;
            }
            const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.sub(dir, focalPoint, point);
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(dir, viewPlaneNormal);
            if (Math.abs(dot) < halfSpacingInNormalDirection) {
                annotationsWithinSlice.push(annotation);
            }
        }
        return annotationsWithinSlice;
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const worldPos = evt.detail.currentPoints.world;
        const contourAnnotation = super.createAnnotation(evt);
        const onInterpolationComplete = (annotation) => {
            annotation.data.handles.points.length = 0;
        };
        const annotation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(contourAnnotation, {
            data: {
                contour: {
                    polyline: [[...worldPos]],
                },
                label: '',
                cachedStats: {},
            },
            onInterpolationComplete,
        });
        return annotation;
    }
    getAnnotationStyle(context) {
        return super.getAnnotationStyle(context);
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, targetId, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        let renderStatus = false;
        const { viewport, renderingEngine } = enabledElement;
        const isDrawing = this.isDrawing;
        const isEditingOpen = this.isEditingOpen;
        const isEditingClosed = this.isEditingClosed;
        if (!(isDrawing || isEditingOpen || isEditingClosed)) {
            if (this.configuration.displayOnePointAsCrosshairs &&
                annotation.data.contour.polyline.length === 1) {
                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
            }
            else {
                this.renderContour(enabledElement, svgDrawingHelper, annotation);
            }
        }
        else {
            const activeAnnotationUID = this.commonData.annotation.annotationUID;
            if (annotation.annotationUID === activeAnnotationUID) {
                if (isDrawing) {
                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);
                }
                else if (isEditingClosed) {
                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                }
                else if (isEditingOpen) {
                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                }
                else {
                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
                }
            }
            else {
                if (this.configuration.displayOnePointAsCrosshairs &&
                    annotation.data.contour.polyline.length === 1) {
                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
                }
                else {
                    this.renderContour(enabledElement, svgDrawingHelper, annotation);
                }
            }
            renderStatus = true;
        }
        if (!this.configuration.calculateStats) {
            return;
        }
        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);
        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);
        return renderStatus;
    }
    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {
        const activeAnnotationUID = this.commonData?.annotation.annotationUID;
        if (annotation.annotationUID === activeAnnotationUID &&
            !this.commonData?.movingTextBox) {
            return;
        }
        if (!this.commonData?.movingTextBox) {
            const { data } = annotation;
            if (!data.cachedStats[targetId]?.unit) {
                data.cachedStats[targetId] = {
                    Modality: null,
                    area: null,
                    max: null,
                    mean: null,
                    stdDev: null,
                    areaUnit: null,
                    unit: null,
                };
                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
            }
            else if (annotation.invalidated) {
                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
            }
        }
    }
    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, }) {
        const { scale, areaUnit, unit } = calibratedScale;
        const { voxelManager } = viewport.getImageData();
        const canvasPoint = canvasCoordinates[0];
        const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
        const deltaXPoint = viewport.canvasToWorld([
            canvasPoint[0] + 1,
            canvasPoint[1],
        ]);
        const deltaYPoint = viewport.canvasToWorld([
            canvasPoint[0],
            canvasPoint[1] + 1,
        ]);
        const deltaInX = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(originalWorldPoint, deltaXPoint);
        const deltaInY = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(originalWorldPoint, deltaYPoint);
        const worldPosIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, points[0]);
        worldPosIndex[0] = Math.floor(worldPosIndex[0]);
        worldPosIndex[1] = Math.floor(worldPosIndex[1]);
        worldPosIndex[2] = Math.floor(worldPosIndex[2]);
        let iMin = worldPosIndex[0];
        let iMax = worldPosIndex[0];
        let jMin = worldPosIndex[1];
        let jMax = worldPosIndex[1];
        let kMin = worldPosIndex[2];
        let kMax = worldPosIndex[2];
        for (let j = 1; j < points.length; j++) {
            const worldPosIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, points[j]);
            worldPosIndex[0] = Math.floor(worldPosIndex[0]);
            worldPosIndex[1] = Math.floor(worldPosIndex[1]);
            worldPosIndex[2] = Math.floor(worldPosIndex[2]);
            iMin = Math.min(iMin, worldPosIndex[0]);
            iMax = Math.max(iMax, worldPosIndex[0]);
            jMin = Math.min(jMin, worldPosIndex[1]);
            jMax = Math.max(jMax, worldPosIndex[1]);
            kMin = Math.min(kMin, worldPosIndex[2]);
            kMax = Math.max(kMax, worldPosIndex[2]);
        }
        const worldPosIndex2 = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, points[1]);
        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);
        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);
        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);
        let area = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.polyline.getArea(canvasCoordinates) / scale / scale;
        area *= deltaInX * deltaInY;
        const iDelta = 0.01 * (iMax - iMin);
        const jDelta = 0.01 * (jMax - jMin);
        const kDelta = 0.01 * (kMax - kMin);
        iMin = Math.floor(iMin - iDelta);
        iMax = Math.ceil(iMax + iDelta);
        jMin = Math.floor(jMin - jDelta);
        jMax = Math.ceil(jMax + jDelta);
        kMin = Math.floor(kMin - kDelta);
        kMax = Math.ceil(kMax + kDelta);
        const boundsIJK = [
            [iMin, iMax],
            [jMin, jMax],
            [kMin, kMax],
        ];
        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);
        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);
        let curRow = 0;
        let intersections = [];
        let intersectionCounter = 0;
        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
            imageData,
            isInObject: (pointLPS, _pointIJK) => {
                let result = true;
                const point = viewport.worldToCanvas(pointLPS);
                if (point[1] != curRow) {
                    intersectionCounter = 0;
                    curRow = point[1];
                    intersections = (0,_utilities_math_polyline__WEBPACK_IMPORTED_MODULE_17__.getLineSegmentIntersectionsCoordinates)(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);
                    intersections.sort((function (index) {
                        return function (a, b) {
                            return a[index] === b[index]
                                ? 0
                                : a[index] < b[index]
                                    ? -1
                                    : 1;
                        };
                    })(0));
                }
                if (intersections.length && point[0] > intersections[0][0]) {
                    intersections.shift();
                    intersectionCounter++;
                }
                if (intersectionCounter % 2 === 0) {
                    result = false;
                }
                return result;
            },
            boundsIJK,
            returnPoints: this.configuration.storePointData,
        });
        const stats = this.configuration.statsCalculator.getStatistics();
        cachedStats[targetId] = {
            Modality: metadata.Modality,
            area,
            perimeter: (0,_utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_20__["default"])(canvasCoordinates, closed) / scale,
            mean: stats.mean?.value,
            max: stats.max?.value,
            stdDev: stats.stdDev?.value,
            statsArray: stats.array,
            pointsInShape: pointsInShape,
            areaUnit,
            modalityUnit,
            unit,
        };
    }
    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, }) {
        const { scale, unit } = calibratedScale;
        cachedStats[targetId] = {
            Modality: metadata.Modality,
            length: (0,_utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_20__["default"])(canvasCoordinates, false) / scale,
            modalityUnit,
            unit,
        };
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, stdDev, length, perimeter, max, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (Number.isFinite(max)) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    if (perimeter) {
        textLines.push(`Perimeter: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(perimeter)} ${unit}`);
    }
    if (length) {
        textLines.push(`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(length)} ${unit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarFreehandROITool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/math/rectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/planar/getWorldWidthAndHeightFromCorners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/viewport/isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities/math/basic */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js");




















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class RectangleROITool extends _base__WEBPACK_IMPORTED_MODULE_0__.AnnotationTool {
    static { this.toolName = 'RectangleROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            shadow: true,
            preventHandleOutsideImage: false,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    cachedStats: {},
                },
            });
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasPoint1 = viewport.worldToCanvas(points[0]);
            const canvasPoint2 = viewport.worldToCanvas(points[3]);
            const rect = this._getRectangleImageCoordinates([
                canvasPoint1,
                canvasPoint2,
            ]);
            const point = [canvasCoords[0], canvasCoords[1]];
            const { left, top, width, height } = rect;
            const distanceToPoint = _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_12__.distanceToPoint([left, top, width, height], point);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { points } = data.handles;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
                const worldPos = currentPoints.world;
                const { points } = data.handles;
                points[handleIndex] = [...worldPos];
                let bottomLeftCanvas;
                let bottomRightCanvas;
                let topLeftCanvas;
                let topRightCanvas;
                let bottomLeftWorld;
                let bottomRightWorld;
                let topLeftWorld;
                let topRightWorld;
                switch (handleIndex) {
                    case 0:
                    case 3:
                        bottomLeftCanvas = worldToCanvas(points[0]);
                        topRightCanvas = worldToCanvas(points[3]);
                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                        bottomRightWorld = canvasToWorld(bottomRightCanvas);
                        topLeftWorld = canvasToWorld(topLeftCanvas);
                        points[1] = bottomRightWorld;
                        points[2] = topLeftWorld;
                        break;
                    case 1:
                    case 2:
                        bottomRightCanvas = worldToCanvas(points[1]);
                        topLeftCanvas = worldToCanvas(points[2]);
                        bottomLeftCanvas = [
                            topLeftCanvas[0],
                            bottomRightCanvas[1],
                        ];
                        topRightCanvas = [
                            bottomRightCanvas[0],
                            topLeftCanvas[1],
                        ];
                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                        topRightWorld = canvasToWorld(topRightCanvas);
                        points[0] = bottomLeftWorld;
                        points[3] = topRightWorld;
                        break;
                }
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__.state.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const { viewPlaneNormal, viewUp } = viewport.getCamera();
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                    };
                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-rect`;
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawRectByCoordinates)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_13__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._getRectangleImageCoordinates = (points) => {
            const [point0, point1] = points;
            return {
                left: Math.min(point0[0], point1[0]),
                top: Math.min(point0[1], point1[1]),
                width: Math.abs(point0[0] - point1[0]),
                height: Math.abs(point0[1] - point1[1]),
            };
        };
        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const { data } = annotation;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[3];
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    this.isHandleOutsideImage = false;
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_14__["default"])(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const handles = [pos1Index, pos2Index];
                    const { scale, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__.getCalibratedLengthUnitsAndScale)(image, handles);
                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);
                    const pixelUnitsOptions = {
                        isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__.isViewportPreScaled)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__.getPixelValueUnits)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                        boundsIJK,
                        imageData,
                        returnPoints: this.configuration.storePointData,
                    });
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        stdDev: stats.stdDev?.value,
                        max: stats.max?.value,
                        statsArray: stats.array,
                        pointsInShape: pointsInShape,
                        areaUnit,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__["default"])(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__["default"])([viewport.id]);
    }; }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined || mean === null) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROITool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../types/ContourAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js");
/* harmony import */ var _utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utilities/planarFreehandROITool/smoothPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../utilities/contours/updateContourPolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");











const { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } = _utilities_math__WEBPACK_IMPORTED_MODULE_5__.polyline;
function activateClosedContourEdit(evt, annotation, viewportIdsToRender) {
    this.isEditingClosed = true;
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);
    this.editData = {
        prevCanvasPoints,
        editCanvasPoints: [canvasPos],
        startCrossingIndex: undefined,
        editIndex: 0,
        annotation,
    };
    this.commonData = {
        annotation,
        viewportIdsToRender,
        spacing,
        xDir,
        yDir,
        movingTextBox: false,
    };
    _store_state__WEBPACK_IMPORTED_MODULE_2__.state.isInteractingWithTool = true;
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this.mouseUpClosedContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);
    (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_4__.hideElementCursor)(element);
}
function deactivateClosedContourEdit(element) {
    _store_state__WEBPACK_IMPORTED_MODULE_2__.state.isInteractingWithTool = false;
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this.mouseUpClosedContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);
    (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_4__.resetElementCursor)(element);
}
function mouseDragClosedContourEditCallback(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const worldPos = currentPoints.world;
    const canvasPos = currentPoints.canvas;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;
    const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;
    this.createMemo(element, annotation);
    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];
    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);
    const worldPosDiff = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);
    const xDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(worldPosDiff, xDir));
    const yDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(worldPosDiff, yDir));
    if (xDist <= spacing[0] && yDist <= spacing[1]) {
        return;
    }
    if (startCrossingIndex !== undefined) {
        this.checkAndRemoveCrossesOnEditLine(evt);
    }
    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);
    const currentEditIndex = editIndex + numPointsAdded;
    this.editData.editIndex = currentEditIndex;
    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {
        this.checkForFirstCrossing(evt, true);
    }
    this.editData.snapIndex = this.findSnapIndex();
    if (this.editData.snapIndex === -1) {
        this.finishEditAndStartNewEdit(evt);
        return;
    }
    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);
    if (startCrossingIndex !== undefined &&
        this.checkForSecondCrossing(evt, true)) {
        this.removePointsAfterSecondCrossing(true);
        this.finishEditAndStartNewEdit(evt);
    }
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
}
function finishEditAndStartNewEdit(evt) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport, renderingEngine } = enabledElement;
    const { annotation, viewportIdsToRender } = this.commonData;
    const { fusedCanvasPoints, editCanvasPoints } = this.editData;
    (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_9__["default"])(annotation, {
        points: fusedCanvasPoints,
        closed: true,
        targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__.ContourWindingDirection.Clockwise,
    }, viewport);
    if (annotation.autoGenerated) {
        annotation.autoGenerated = false;
    }
    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element);
    const lastEditCanvasPoint = editCanvasPoints.pop();
    this.editData = {
        prevCanvasPoints: fusedCanvasPoints,
        editCanvasPoints: [lastEditCanvasPoint],
        startCrossingIndex: undefined,
        editIndex: 0,
        snapIndex: undefined,
        annotation,
    };
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
}
function fuseEditPointsWithClosedContour(evt) {
    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;
    if (startCrossingIndex === undefined || snapIndex === undefined) {
        return;
    }
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const augmentedEditCanvasPoints = [...editCanvasPoints];
    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);
    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {
        augmentedEditCanvasPoints.pop();
    }
    let lowIndex;
    let highIndex;
    if (startCrossingIndex > snapIndex) {
        lowIndex = snapIndex;
        highIndex = startCrossingIndex;
    }
    else {
        lowIndex = startCrossingIndex;
        highIndex = snapIndex;
    }
    const distanceBetweenLowAndFirstPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);
    const distanceBetweenLowAndLastPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
    const distanceBetweenHighAndFirstPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);
    const distanceBetweenHighAndLastPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
    const pointSet1 = [];
    for (let i = 0; i < lowIndex; i++) {
        const canvasPoint = prevCanvasPoints[i];
        pointSet1.push([canvasPoint[0], canvasPoint[1]]);
    }
    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;
    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;
    if (inPlaceDistance < reverseDistance) {
        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {
            const canvasPoint = augmentedEditCanvasPoints[i];
            pointSet1.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    else {
        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {
            const canvasPoint = augmentedEditCanvasPoints[i];
            pointSet1.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    for (let i = highIndex; i < prevCanvasPoints.length; i++) {
        const canvasPoint = prevCanvasPoints[i];
        pointSet1.push([canvasPoint[0], canvasPoint[1]]);
    }
    const pointSet2 = [];
    for (let i = lowIndex; i < highIndex; i++) {
        const canvasPoint = prevCanvasPoints[i];
        pointSet2.push([canvasPoint[0], canvasPoint[1]]);
    }
    inPlaceDistance =
        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;
    reverseDistance =
        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;
    if (inPlaceDistance < reverseDistance) {
        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {
            const canvasPoint = augmentedEditCanvasPoints[i];
            pointSet2.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    else {
        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {
            const canvasPoint = augmentedEditCanvasPoints[i];
            pointSet2.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    const areaPointSet1 = getArea(pointSet1);
    const areaPointSet2 = getArea(pointSet2);
    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;
    return pointsToRender;
}
function mouseUpClosedContourEditCallback(evt) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    this.completeClosedContourEdit(element);
}
function completeClosedContourEdit(element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const { annotation, viewportIdsToRender } = this.commonData;
    this.doneEditMemo();
    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;
    if (fusedCanvasPoints) {
        const updatedPoints = (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_7__.shouldSmooth)(this.configuration, annotation)
            ? (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_7__.getInterpolatedPoints)(this.configuration, fusedCanvasPoints, prevCanvasPoints)
            : fusedCanvasPoints;
        const decimateConfig = this.configuration?.decimate || {};
        (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_9__["default"])(annotation, {
            points: updatedPoints,
            closed: true,
            targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__.ContourWindingDirection.Clockwise,
        }, viewport, {
            decimate: {
                enabled: !!decimateConfig.enabled,
                epsilon: decimateConfig.epsilon,
            },
        });
        if (annotation.autoGenerated) {
            annotation.autoGenerated = false;
        }
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element);
    }
    this.isEditingClosed = false;
    this.editData = undefined;
    this.commonData = undefined;
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__["default"])(viewportIdsToRender);
    this.deactivateClosedContourEdit(element);
}
function cancelClosedContourEdit(element) {
    this.completeClosedContourEdit(element);
}
function registerClosedContourEditLoop(toolInstance) {
    toolInstance.activateClosedContourEdit =
        activateClosedContourEdit.bind(toolInstance);
    toolInstance.deactivateClosedContourEdit =
        deactivateClosedContourEdit.bind(toolInstance);
    toolInstance.mouseDragClosedContourEditCallback =
        mouseDragClosedContourEditCallback.bind(toolInstance);
    toolInstance.mouseUpClosedContourEditCallback =
        mouseUpClosedContourEditCallback.bind(toolInstance);
    toolInstance.finishEditAndStartNewEdit =
        finishEditAndStartNewEdit.bind(toolInstance);
    toolInstance.fuseEditPointsWithClosedContour =
        fuseEditPointsWithClosedContour.bind(toolInstance);
    toolInstance.cancelClosedContourEdit =
        cancelClosedContourEdit.bind(toolInstance);
    toolInstance.completeClosedContourEdit =
        completeClosedContourEdit.bind(toolInstance);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registerClosedContourEditLoop);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utilities/planarFreehandROITool/smoothPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js");
/* harmony import */ var _eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../eventDispatchers/shared/getMouseModifier */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _findOpenUShapedContourVectorToPeak__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./findOpenUShapedContourVectorToPeak */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../types/ContourAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js");













const { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstLineSegmentIntersectionIndexes, getSubPixelSpacingAndXYDirections, } = _utilities_math__WEBPACK_IMPORTED_MODULE_10__.polyline;
function activateDraw(evt, annotation, viewportIdsToRender) {
    this.isDrawing = true;
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const contourHoleProcessingEnabled = (0,_eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_6__["default"])(evt.detail.event) ===
        this.configuration.contourHoleAdditionModifierKey;
    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution) || {};
    if (!spacing || !xDir || !yDir) {
        return;
    }
    this.drawData = {
        canvasPoints: [canvasPos],
        polylineIndex: 0,
        contourHoleProcessingEnabled,
        newAnnotation: true,
    };
    this.commonData = {
        annotation,
        viewportIdsToRender,
        spacing,
        xDir,
        yDir,
        movingTextBox: false,
    };
    _store_state__WEBPACK_IMPORTED_MODULE_3__.state.isInteractingWithTool = true;
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this.mouseUpDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this.mouseDragDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this.mouseUpDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_END, this.mouseUpDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_DRAG, this.mouseDragDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_TAP, this.mouseUpDrawCallback);
    (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_1__.hideElementCursor)(element);
}
function deactivateDraw(element) {
    _store_state__WEBPACK_IMPORTED_MODULE_3__.state.isInteractingWithTool = false;
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this.mouseUpDrawCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this.mouseDragDrawCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this.mouseUpDrawCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_END, this.mouseUpDrawCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_DRAG, this.mouseDragDrawCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_TAP, this.mouseUpDrawCallback);
    (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_1__.resetElementCursor)(element);
}
function mouseDragDrawCallback(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const worldPos = currentPoints.world;
    const canvasPos = currentPoints.canvas;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;
    const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;
    this.createMemo(element, annotation, { newAnnotation });
    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];
    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);
    const worldPosDiff = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);
    const xDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.dot(worldPosDiff, xDir));
    const yDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.dot(worldPosDiff, yDir));
    if (xDist <= spacing[0] && yDist <= spacing[1]) {
        return;
    }
    if (movingTextBox) {
        this.isDrawing = false;
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = annotation.data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
    }
    else {
        const crossingIndex = this.findCrossingIndexDuringCreate(evt);
        if (crossingIndex !== undefined) {
            this.applyCreateOnCross(evt, crossingIndex);
        }
        else {
            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);
            this.drawData.polylineIndex = polylineIndex + numPointsAdded;
        }
        annotation.invalidated = true;
    }
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
    if (annotation.invalidated) {
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_2__.ChangeTypes.HandlesUpdated);
    }
}
function mouseUpDrawCallback(evt) {
    const { allowOpenContours } = this.configuration;
    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;
    const firstPoint = canvasPoints[0];
    const lastPoint = canvasPoints[canvasPoints.length - 1];
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    this.doneEditMemo();
    this.drawData.newAnnotation = false;
    if (allowOpenContours &&
        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {
        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });
    }
    else {
        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });
    }
}
function completeDrawClosedContour(element, options) {
    this.removeCrossedLinesOnCompleteDraw();
    const { canvasPoints } = this.drawData;
    const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};
    if (minPointsToSave && canvasPoints.length < minPointsToSave) {
        return false;
    }
    if (this.haltDrawing(element, canvasPoints)) {
        return false;
    }
    const { annotation, viewportIdsToRender } = this.commonData;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport, renderingEngine } = enabledElement;
    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);
    canvasPoints.pop();
    const updatedPoints = (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_5__.shouldSmooth)(this.configuration, annotation)
        ? (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_5__.getInterpolatedPoints)(this.configuration, canvasPoints)
        : canvasPoints;
    this.updateContourPolyline(annotation, {
        points: updatedPoints,
        closed: true,
        targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_12__.ContourWindingDirection.Clockwise,
    }, viewport);
    const { textBox } = annotation.data.handles;
    if (!textBox?.hasMoved) {
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerContourAnnotationCompleted)(annotation, contourHoleProcessingEnabled);
    }
    this.isDrawing = false;
    this.drawData = undefined;
    this.commonData = undefined;
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
    this.deactivateDraw(element);
    return true;
}
function removeCrossedLinesOnCompleteDraw() {
    const { canvasPoints } = this.drawData;
    const numPoints = canvasPoints.length;
    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];
    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);
    const lineSegment = getFirstLineSegmentIntersectionIndexes(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);
    if (lineSegment) {
        const indexToRemoveUpTo = lineSegment[1];
        if (indexToRemoveUpTo === 1) {
            this.drawData.canvasPoints = canvasPoints.splice(1);
        }
        else {
            this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);
        }
    }
}
function completeDrawOpenContour(element, options) {
    const { canvasPoints } = this.drawData;
    const { contourHoleProcessingEnabled } = options ?? {};
    if (this.haltDrawing(element, canvasPoints)) {
        return false;
    }
    const { annotation, viewportIdsToRender } = this.commonData;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport, renderingEngine } = enabledElement;
    const updatedPoints = (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_5__.shouldSmooth)(this.configuration, annotation)
        ? (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_5__.getInterpolatedPoints)(this.configuration, canvasPoints)
        : canvasPoints;
    this.updateContourPolyline(annotation, {
        points: updatedPoints,
        closed: false,
    }, viewport);
    const { textBox } = annotation.data.handles;
    const worldPoints = annotation.data.contour.polyline;
    annotation.data.handles.points = [
        worldPoints[0],
        worldPoints[worldPoints.length - 1],
    ];
    if (annotation.data.isOpenUShapeContour) {
        annotation.data.openUShapeContourVectorToPeak =
            (0,_findOpenUShapedContourVectorToPeak__WEBPACK_IMPORTED_MODULE_9__["default"])(canvasPoints, viewport);
    }
    if (!textBox.hasMoved) {
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerContourAnnotationCompleted)(annotation, contourHoleProcessingEnabled);
    }
    this.isDrawing = false;
    this.drawData = undefined;
    this.commonData = undefined;
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
    this.deactivateDraw(element);
    return true;
}
function findCrossingIndexDuringCreate(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, lastPoints } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const lastCanvasPoint = lastPoints.canvas;
    const { canvasPoints } = this.drawData;
    const pointsLessLastOne = canvasPoints.slice(0, -1);
    const lineSegment = getFirstLineSegmentIntersectionIndexes(pointsLessLastOne, canvasPos, lastCanvasPoint, false);
    if (lineSegment === undefined) {
        return;
    }
    const crossingIndex = lineSegment[0];
    return crossingIndex;
}
function applyCreateOnCross(evt, crossingIndex) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;
    const { annotation, viewportIdsToRender } = this.commonData;
    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);
    canvasPoints.pop();
    const remainingPoints = canvasPoints.slice(crossingIndex);
    const newArea = _utilities_math__WEBPACK_IMPORTED_MODULE_10__.polyline.getArea(remainingPoints);
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(newArea, 0)) {
        canvasPoints.splice(crossingIndex + 1);
        return;
    }
    canvasPoints.splice(0, crossingIndex);
    const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };
    if (this.completeDrawClosedContour(element, options)) {
        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
    }
}
function cancelDrawing(element) {
    const { allowOpenContours } = this.configuration;
    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;
    const firstPoint = canvasPoints[0];
    const lastPoint = canvasPoints[canvasPoints.length - 1];
    if (allowOpenContours &&
        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {
        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });
    }
    else {
        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });
    }
}
function shouldHaltDrawing(canvasPoints, subPixelResolution) {
    const minPoints = Math.max(subPixelResolution * 3, 3);
    return canvasPoints.length < minPoints;
}
function haltDrawing(element, canvasPoints) {
    const { subPixelResolution } = this.configuration;
    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {
        const { annotation, viewportIdsToRender } = this.commonData;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_11__.removeAnnotation)(annotation.annotationUID);
        this.isDrawing = false;
        this.drawData = undefined;
        this.commonData = undefined;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
        this.deactivateDraw(element);
        return true;
    }
    return false;
}
function registerDrawLoop(toolInstance) {
    toolInstance.activateDraw = activateDraw.bind(toolInstance);
    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);
    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);
    toolInstance.findCrossingIndexDuringCreate =
        findCrossingIndexDuringCreate.bind(toolInstance);
    toolInstance.completeDrawOpenContour =
        completeDrawOpenContour.bind(toolInstance);
    toolInstance.removeCrossedLinesOnCompleteDraw =
        removeCrossedLinesOnCompleteDraw.bind(toolInstance);
    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);
    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);
    toolInstance.completeDrawClosedContour =
        completeDrawClosedContour.bind(toolInstance);
    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);
    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registerDrawLoop);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");


const { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } = _utilities_math__WEBPACK_IMPORTED_MODULE_1__.polyline;
function checkForFirstCrossing(evt, isClosedContour) {
    const eventDetail = evt.detail;
    const { element, currentPoints, lastPoints } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const lastCanvasPoint = lastPoints.canvas;
    const { editCanvasPoints, prevCanvasPoints } = this.editData;
    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);
    if (crossedLineSegment) {
        this.editData.startCrossingIndex = crossedLineSegment[0];
        this.removePointsUpUntilFirstCrossing(isClosedContour);
    }
    else if (prevCanvasPoints.length >= 2) {
        if (editCanvasPoints.length >
            this.configuration.checkCanvasEditFallbackProximity) {
            const firstEditCanvasPoint = editCanvasPoints[0];
            const distanceIndexPairs = [];
            for (let i = 0; i < prevCanvasPoints.length; i++) {
                const prevCanvasPoint = prevCanvasPoints[i];
                const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoint, firstEditCanvasPoint);
                distanceIndexPairs.push({ distance, index: i });
            }
            distanceIndexPairs.sort((a, b) => a.distance - b.distance);
            const twoClosestDistanceIndexPairs = [
                distanceIndexPairs[0],
                distanceIndexPairs[1],
            ];
            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);
            this.editData.startCrossingIndex = lowestIndex;
        }
        else {
            const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(dir, dir);
            const proximity = 6;
            const extendedPoint = [
                editCanvasPoints[0][0] - dir[0] * proximity,
                editCanvasPoints[0][1] - dir[1] * proximity,
            ];
            const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);
            if (crossedLineSegmentFromExtendedPoint) {
                const pointsToPrepend = [extendedPoint];
                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);
                editCanvasPoints.unshift(...pointsToPrepend);
                this.removePointsUpUntilFirstCrossing(isClosedContour);
                this.editData.editIndex = editCanvasPoints.length - 1;
                this.editData.startCrossingIndex =
                    crossedLineSegmentFromExtendedPoint[0];
            }
        }
    }
}
function removePointsUpUntilFirstCrossing(isClosedContour) {
    const { editCanvasPoints, prevCanvasPoints } = this.editData;
    let numPointsToRemove = 0;
    for (let i = 0; i < editCanvasPoints.length - 1; i++) {
        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];
        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);
        numPointsToRemove++;
        if (didCrossLine) {
            break;
        }
    }
    editCanvasPoints.splice(0, numPointsToRemove);
    this.editData.editIndex = editCanvasPoints.length - 1;
}
function checkForSecondCrossing(evt, isClosedContour) {
    const eventDetail = evt.detail;
    const { currentPoints, lastPoints } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const lastCanvasPoint = lastPoints.canvas;
    const { prevCanvasPoints } = this.editData;
    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);
    if (!crossedLineSegment) {
        return false;
    }
    return true;
}
function removePointsAfterSecondCrossing(isClosedContour) {
    const { prevCanvasPoints, editCanvasPoints } = this.editData;
    for (let i = editCanvasPoints.length - 1; i > 0; i--) {
        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];
        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);
        editCanvasPoints.pop();
        if (didCrossLine) {
            break;
        }
    }
}
function findSnapIndex() {
    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;
    if (startCrossingIndex === undefined) {
        return;
    }
    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];
    const distanceIndexPairs = [];
    for (let i = 0; i < prevCanvasPoints.length; i++) {
        const prevCanvasPoint = prevCanvasPoints[i];
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoint, lastEditCanvasPoint);
        distanceIndexPairs.push({ distance, index: i });
    }
    distanceIndexPairs.sort((a, b) => a.distance - b.distance);
    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);
    for (let i = 0; i < distanceIndexPairs.length; i++) {
        const { index } = distanceIndexPairs[i];
        const snapCanvasPosition = prevCanvasPoints[index];
        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];
        const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);
        if (!crossedLineSegment) {
            return index;
        }
    }
    return -1;
}
function checkAndRemoveCrossesOnEditLine(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, lastPoints } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const lastCanvasPoint = lastPoints.canvas;
    const { editCanvasPoints } = this.editData;
    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);
    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);
    if (!crossedLineSegment) {
        return;
    }
    const editIndexCrossed = crossedLineSegment[0];
    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;
    for (let i = 0; i < numPointsToRemove; i++) {
        editCanvasPoints.pop();
    }
}
function registerEditLoopCommon(toolInstance) {
    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);
    toolInstance.removePointsUpUntilFirstCrossing =
        removePointsUpUntilFirstCrossing.bind(toolInstance);
    toolInstance.checkForSecondCrossing =
        checkForSecondCrossing.bind(toolInstance);
    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);
    toolInstance.removePointsAfterSecondCrossing =
        removePointsAfterSecondCrossing.bind(toolInstance);
    toolInstance.checkAndRemoveCrossesOnEditLine =
        checkAndRemoveCrossesOnEditLine.bind(toolInstance);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registerEditLoopCommon);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js":
/*!****************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findOpenUShapedContourVectorToPeak),
/* harmony export */   findOpenUShapedContourVectorToPeakOnRender: () => (/* binding */ findOpenUShapedContourVectorToPeakOnRender)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {
    const first = canvasPoints[0];
    const last = canvasPoints[canvasPoints.length - 1];
    const firstToLastUnitVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);
    const normalVector1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
    const normalVector2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);
    const centerOfFirstToLast = [
        (first[0] + last[0]) / 2,
        (first[1] + last[1]) / 2,
    ];
    const furthest = {
        dist: 0,
        index: null,
    };
    for (let i = 0; i < canvasPoints.length; i++) {
        const canvasPoint = canvasPoints[i];
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.dist(canvasPoint, centerOfFirstToLast);
        if (distance > furthest.dist) {
            furthest.dist = distance;
            furthest.index = i;
        }
    }
    const toFurthest = [
        canvasPoints[furthest.index],
        centerOfFirstToLast,
    ];
    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);
    return toFurthestWorld;
}
function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {
    const { viewport } = enabledElement;
    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utilities/planarFreehandROITool/smoothPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utilities/contours/updateContourPolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js");
/* harmony import */ var _findOpenUShapedContourVectorToPeak__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./findOpenUShapedContourVectorToPeak */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");











const { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = _utilities_math__WEBPACK_IMPORTED_MODULE_5__.polyline;
function activateOpenContourEdit(evt, annotation, viewportIdsToRender) {
    this.isEditingOpen = true;
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    this.doneEditMemo();
    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);
    this.editData = {
        prevCanvasPoints,
        editCanvasPoints: [canvasPos],
        startCrossingIndex: undefined,
        editIndex: 0,
    };
    this.commonData = {
        annotation,
        viewportIdsToRender,
        spacing,
        xDir,
        yDir,
        movingTextBox: false,
    };
    _store_state__WEBPACK_IMPORTED_MODULE_2__.state.isInteractingWithTool = true;
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this.mouseUpOpenContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);
    (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_4__.hideElementCursor)(element);
}
function deactivateOpenContourEdit(element) {
    _store_state__WEBPACK_IMPORTED_MODULE_2__.state.isInteractingWithTool = false;
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this.mouseUpOpenContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);
    element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);
    (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_4__.resetElementCursor)(element);
}
function mouseDragOpenContourEditCallback(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const worldPos = currentPoints.world;
    const canvasPos = currentPoints.canvas;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;
    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;
    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];
    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);
    const worldPosDiff = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    this.createMemo(element, this.commonData.annotation);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);
    const xDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(worldPosDiff, xDir));
    const yDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(worldPosDiff, yDir));
    if (xDist <= spacing[0] && yDist <= spacing[1]) {
        return;
    }
    if (startCrossingIndex !== undefined) {
        this.checkAndRemoveCrossesOnEditLine(evt);
    }
    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);
    const currentEditIndex = editIndex + numPointsAdded;
    this.editData.editIndex = currentEditIndex;
    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {
        this.checkForFirstCrossing(evt, false);
    }
    this.editData.snapIndex = this.findSnapIndex();
    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);
    if (startCrossingIndex !== undefined &&
        this.checkForSecondCrossing(evt, false)) {
        this.removePointsAfterSecondCrossing(false);
        this.finishEditOpenOnSecondCrossing(evt);
    }
    else if (this.checkIfShouldOverwriteAnEnd(evt)) {
        this.openContourEditOverwriteEnd(evt);
    }
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
}
function openContourEditOverwriteEnd(evt) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const { annotation, viewportIdsToRender } = this.commonData;
    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();
    (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__["default"])(annotation, {
        points: fusedCanvasPoints,
        closed: false,
    }, viewport);
    const worldPoints = annotation.data.contour.polyline;
    annotation.data.handles.points = [
        worldPoints[0],
        worldPoints[worldPoints.length - 1],
    ];
    annotation.data.handles.activeHandleIndex = 1;
    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element);
    this.isEditingOpen = false;
    this.editData = undefined;
    this.commonData = undefined;
    this.doneEditMemo();
    this.deactivateOpenContourEdit(element);
    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);
}
function checkIfShouldOverwriteAnEnd(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, lastPoints } = eventDetail;
    const canvasPos = currentPoints.canvas;
    const lastCanvasPos = lastPoints.canvas;
    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;
    if (startCrossingIndex === undefined || snapIndex === undefined) {
        return false;
    }
    if (snapIndex === -1) {
        return true;
    }
    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {
        return false;
    }
    const p1 = canvasPos;
    const p2 = lastCanvasPos;
    const p3 = prevCanvasPoints[snapIndex];
    const a = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
    const b = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);
    const aDotb = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.dot(a, b);
    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
    const theta = Math.acos(aDotb / (magA * magB));
    if (theta < Math.PI / 2) {
        return true;
    }
    return false;
}
function fuseEditPointsForOpenContourEndEdit() {
    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;
    const newCanvasPoints = [];
    if (snapIndex === 0) {
        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {
            const canvasPoint = prevCanvasPoints[i];
            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    else {
        for (let i = 0; i < startCrossingIndex; i++) {
            const canvasPoint = prevCanvasPoints[i];
            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    const distanceBetweenCrossingIndexAndFirstPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);
    const distanceBetweenCrossingIndexAndLastPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);
    if (distanceBetweenCrossingIndexAndFirstPoint <
        distanceBetweenCrossingIndexAndLastPoint) {
        for (let i = 0; i < editCanvasPoints.length; i++) {
            const canvasPoint = editCanvasPoints[i];
            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    else {
        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {
            const canvasPoint = editCanvasPoints[i];
            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    return newCanvasPoints;
}
function fuseEditPointsWithOpenContour(evt) {
    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;
    if (startCrossingIndex === undefined || snapIndex === undefined) {
        return undefined;
    }
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const augmentedEditCanvasPoints = [...editCanvasPoints];
    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);
    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {
        augmentedEditCanvasPoints.pop();
    }
    let lowIndex;
    let highIndex;
    if (startCrossingIndex > snapIndex) {
        lowIndex = snapIndex;
        highIndex = startCrossingIndex;
    }
    else {
        lowIndex = startCrossingIndex;
        highIndex = snapIndex;
    }
    const distanceBetweenLowAndFirstPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);
    const distanceBetweenLowAndLastPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
    const distanceBetweenHighAndFirstPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);
    const distanceBetweenHighAndLastPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
    const pointsToRender = [];
    for (let i = 0; i < lowIndex; i++) {
        const canvasPoint = prevCanvasPoints[i];
        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
    }
    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;
    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;
    if (inPlaceDistance < reverseDistance) {
        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {
            const canvasPoint = augmentedEditCanvasPoints[i];
            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    else {
        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {
            const canvasPoint = augmentedEditCanvasPoints[i];
            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
        }
    }
    for (let i = highIndex; i < prevCanvasPoints.length; i++) {
        const canvasPoint = prevCanvasPoints[i];
        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
    }
    return pointsToRender;
}
function finishEditOpenOnSecondCrossing(evt) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport, renderingEngine } = enabledElement;
    const { annotation, viewportIdsToRender } = this.commonData;
    const { fusedCanvasPoints, editCanvasPoints } = this.editData;
    (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__["default"])(annotation, {
        points: fusedCanvasPoints,
        closed: false,
    }, viewport);
    const worldPoints = annotation.data.contour.polyline;
    annotation.data.handles.points = [
        worldPoints[0],
        worldPoints[worldPoints.length - 1],
    ];
    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element);
    const lastEditCanvasPoint = editCanvasPoints.pop();
    this.editData = {
        prevCanvasPoints: fusedCanvasPoints,
        editCanvasPoints: [lastEditCanvasPoint],
        startCrossingIndex: undefined,
        editIndex: 0,
    };
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
}
function mouseUpOpenContourEditCallback(evt) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    this.completeOpenContourEdit(element);
}
function completeOpenContourEdit(element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const { annotation, viewportIdsToRender } = this.commonData;
    this.doneEditMemo();
    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;
    if (fusedCanvasPoints) {
        const updatedPoints = (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_6__.shouldSmooth)(this.configuration)
            ? (0,_utilities_planarFreehandROITool_smoothPoints__WEBPACK_IMPORTED_MODULE_6__.getInterpolatedPoints)(this.configuration, fusedCanvasPoints, prevCanvasPoints)
            : fusedCanvasPoints;
        const decimateConfig = this.configuration?.decimate || {};
        (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__["default"])(annotation, {
            points: updatedPoints,
            closed: false,
        }, viewport, {
            decimate: {
                enabled: !!decimateConfig.enabled,
                epsilon: decimateConfig.epsilon,
            },
        });
        const worldPoints = annotation.data.contour.polyline;
        annotation.data.handles.points = [
            worldPoints[0],
            worldPoints[worldPoints.length - 1],
        ];
        if (annotation.data.isOpenUShapeContour) {
            annotation.data.openUShapeContourVectorToPeak =
                (0,_findOpenUShapedContourVectorToPeak__WEBPACK_IMPORTED_MODULE_9__["default"])(fusedCanvasPoints, viewport);
        }
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element);
    }
    this.isEditingOpen = false;
    this.editData = undefined;
    this.commonData = undefined;
    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__["default"])(viewportIdsToRender);
    this.deactivateOpenContourEdit(element);
}
function cancelOpenContourEdit(element) {
    this.completeOpenContourEdit(element);
}
function registerOpenContourEditLoop(toolInstance) {
    toolInstance.activateOpenContourEdit =
        activateOpenContourEdit.bind(toolInstance);
    toolInstance.deactivateOpenContourEdit =
        deactivateOpenContourEdit.bind(toolInstance);
    toolInstance.mouseDragOpenContourEditCallback =
        mouseDragOpenContourEditCallback.bind(toolInstance);
    toolInstance.mouseUpOpenContourEditCallback =
        mouseUpOpenContourEditCallback.bind(toolInstance);
    toolInstance.fuseEditPointsWithOpenContour =
        fuseEditPointsWithOpenContour.bind(toolInstance);
    toolInstance.finishEditOpenOnSecondCrossing =
        finishEditOpenOnSecondCrossing.bind(toolInstance);
    toolInstance.checkIfShouldOverwriteAnEnd =
        checkIfShouldOverwriteAnEnd.bind(toolInstance);
    toolInstance.fuseEditPointsForOpenContourEndEdit =
        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);
    toolInstance.openContourEditOverwriteEnd =
        openContourEditOverwriteEnd.bind(toolInstance);
    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);
    toolInstance.completeOpenContourEdit =
        completeOpenContourEdit.bind(toolInstance);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registerOpenContourEditLoop);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js":
/*!****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../store/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");





const { getSubPixelSpacingAndXYDirections } = _utilities_math__WEBPACK_IMPORTED_MODULE_4__.polyline;
function activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {
    this.isDrawing = true;
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);
    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;
    if (handleIndexGrabbed === 0) {
        canvasPoints.reverse();
    }
    let movingTextBox = false;
    if (handle?.worldPosition) {
        movingTextBox = true;
    }
    this.drawData = {
        canvasPoints: canvasPoints,
        polylineIndex: canvasPoints.length - 1,
    };
    this.commonData = {
        annotation,
        viewportIdsToRender,
        spacing,
        xDir,
        yDir,
        movingTextBox,
    };
    _store_state__WEBPACK_IMPORTED_MODULE_1__.state.isInteractingWithTool = true;
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this.mouseUpDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this.mouseDragDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this.mouseUpDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_END, this.mouseUpDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_DRAG, this.mouseDragDrawCallback);
    element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.TOUCH_TAP, this.mouseUpDrawCallback);
    (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.hideElementCursor)(element);
}
function registerOpenContourEndEditLoop(toolInstance) {
    toolInstance.activateOpenContourEndEdit =
        activateOpenContourEndEdit.bind(toolInstance);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registerOpenContourEndEditLoop);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utilities/math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _findOpenUShapedContourVectorToPeak__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./findOpenUShapedContourVectorToPeak */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js");
/* harmony import */ var _utilities_contours_getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utilities/contours/getContourHolesDataCanvas */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js");




const { pointsAreWithinCloseContourProximity } = _utilities_math__WEBPACK_IMPORTED_MODULE_1__.polyline;
function _getRenderingOptions(enabledElement, annotation) {
    const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id,
        annotationUID: annotation.annotationUID,
    };
    const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({
        annotation,
        styleSpecifier,
    });
    const { closed: isClosedContour } = annotation.data.contour;
    const options = {
        color,
        width: lineWidth,
        lineDash,
        fillColor,
        fillOpacity,
        closePath: isClosedContour,
    };
    return options;
}
function renderContour(enabledElement, svgDrawingHelper, annotation) {
    if (!enabledElement?.viewport?.getImageData()) {
        return;
    }
    if (annotation.data.contour.closed) {
        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);
    }
    else {
        if (annotation.data.isOpenUShapeContour) {
            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);
            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);
        }
        else {
            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);
        }
    }
}
function calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {
    if (!annotation.data.openUShapeContourVectorToPeak) {
        annotation.data.openUShapeContourVectorToPeak =
            (0,_findOpenUShapedContourVectorToPeak__WEBPACK_IMPORTED_MODULE_2__.findOpenUShapedContourVectorToPeakOnRender)(enabledElement, annotation);
    }
}
function renderClosedContour(enabledElement, svgDrawingHelper, annotation) {
    if (annotation.parentAnnotationUID) {
        return;
    }
    const { viewport } = enabledElement;
    const options = this._getRenderingOptions(enabledElement, annotation);
    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));
    const childContours = (0,_utilities_contours_getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_3__["default"])(annotation, viewport);
    const allContours = [canvasPolyline, ...childContours];
    const polylineUID = '1';
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPath)(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);
}
function renderOpenContour(enabledElement, svgDrawingHelper, annotation) {
    const { viewport } = enabledElement;
    const options = this._getRenderingOptions(enabledElement, annotation);
    const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));
    const polylineUID = '1';
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPolyline)(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);
    const activeHandleIndex = annotation.data.handles.activeHandleIndex;
    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {
        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;
        const handleGroupUID = '0';
        const handlePoints = [
            canvasPoints[0],
            canvasPoints[canvasPoints.length - 1],
        ];
        if (activeHandleIndex === 0) {
            handlePoints.shift();
        }
        else if (activeHandleIndex === 1) {
            handlePoints.pop();
        }
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawHandles)(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {
            color: options.color,
            handleRadius: radius,
        });
    }
    if (activeHandleIndex !== null) {
        const handleGroupUID = '1';
        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;
        const handlePoint = canvasPoints[indexOfCanvasPoints];
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawHandles)(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });
    }
}
function renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {
    const { viewport } = enabledElement;
    const { openUShapeContourVectorToPeak } = annotation.data;
    const { polyline } = annotation.data.contour;
    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);
    if (!openUShapeContourVectorToPeak) {
        return;
    }
    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);
    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);
    const openUShapeContourVectorToPeakCanvas = [
        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),
        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),
    ];
    const options = this._getRenderingOptions(enabledElement, annotation);
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPolyline)(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {
        color: options.color,
        width: options.width,
        closePath: false,
        lineDash: '2,2',
    });
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPolyline)(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [
        openUShapeContourVectorToPeakCanvas[0],
        openUShapeContourVectorToPeakCanvas[1],
    ], {
        color: options.color,
        width: options.width,
        closePath: false,
        lineDash: '2,2',
    });
}
function renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {
    const options = this._getRenderingOptions(enabledElement, annotation);
    const { allowOpenContours } = this.configuration;
    const { canvasPoints } = this.drawData;
    options.closePath = false;
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPolyline)(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);
    if (allowOpenContours) {
        const firstPoint = canvasPoints[0];
        const lastPoint = canvasPoints[canvasPoints.length - 1];
        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPolyline)(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);
        }
        else {
            const handleGroupUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawHandles)(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });
        }
    }
}
function renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {
    const { viewport } = enabledElement;
    const { fusedCanvasPoints } = this.editData;
    if (fusedCanvasPoints === undefined) {
        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);
        return;
    }
    const childContours = (0,_utilities_contours_getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_3__["default"])(annotation, viewport);
    const allContours = [fusedCanvasPoints, ...childContours];
    const options = this._getRenderingOptions(enabledElement, annotation);
    const polylineUIDToRender = 'preview-1';
    if (annotation.parentAnnotationUID && options.fillOpacity) {
        options.fillOpacity = 0;
    }
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPath)(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);
}
function renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {
    const { fusedCanvasPoints } = this.editData;
    if (fusedCanvasPoints === undefined) {
        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);
        return;
    }
    const options = this._getRenderingOptions(enabledElement, annotation);
    const polylineUIDToRender = 'preview-1';
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPolyline)(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);
}
function renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {
    if (annotation.parentAnnotationUID) {
        return;
    }
    const { viewport } = enabledElement;
    const options = this._getRenderingOptions(enabledElement, annotation);
    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));
    const childContours = (0,_utilities_contours_getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_3__["default"])(annotation, viewport);
    const polylineUID = '1';
    const center = canvasPolyline[0];
    const radius = 6;
    const numberOfPoints = 100;
    const circlePoints = [];
    for (let i = 0; i < numberOfPoints; i++) {
        const angle = (i / numberOfPoints) * 2 * Math.PI;
        const x = center[0] + radius * Math.cos(angle);
        const y = center[1] + radius * Math.sin(angle);
        circlePoints.push([x, y]);
    }
    const crosshair = [
        [center[0] - radius * 2, center[1]],
        [center[0] + radius * 2, center[1]],
        [center[0], center[1] - radius * 2],
        [center[0], center[1] + radius * 2],
    ];
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPath)(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_v', [crosshair[0], crosshair[1]], options);
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPath)(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_h', [crosshair[2], crosshair[3]], options);
    const allContours = [circlePoints, ...childContours];
    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_0__.drawPath)(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);
}
function registerRenderMethods(toolInstance) {
    toolInstance.renderContour = renderContour.bind(toolInstance);
    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);
    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);
    toolInstance.renderPointContourWithMarker =
        renderPointContourWithMarker.bind(toolInstance);
    toolInstance.renderOpenUShapedContour =
        renderOpenUShapedContour.bind(toolInstance);
    toolInstance.renderContourBeingDrawn =
        renderContourBeingDrawn.bind(toolInstance);
    toolInstance.renderClosedContourBeingEdited =
        renderClosedContourBeingEdited.bind(toolInstance);
    toolInstance.renderOpenContourBeingEdited =
        renderOpenContourBeingEdited.bind(toolInstance);
    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (registerRenderMethods);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRender */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js");
/* harmony import */ var _utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/planar/filterAnnotationsForDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js");
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/config/helpers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js");
/* harmony import */ var _stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js");







class AnnotationDisplayTool extends _BaseTool__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.onImageSpacingCalibrated = (evt) => {
            const { element, imageId } = evt.detail;
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            const annotationManager = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotationManager)();
            const framesOfReference = annotationManager.getFramesOfReference();
            framesOfReference.forEach((frameOfReference) => {
                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];
                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {
                    return;
                }
                toolSpecificAnnotations.forEach((annotation) => {
                    if (!annotation.metadata?.referencedImageId) {
                        return;
                    }
                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(annotation.metadata.referencedImageId);
                    if (referencedImageURI === imageURI) {
                        annotation.invalidated = true;
                        annotation.data.cachedStats = {};
                    }
                });
                (0,_utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
            });
        };
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations?.length) {
            return [];
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        return (0,_utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__["default"])(viewport, annotations);
    }
    createAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const viewReference = viewport.getViewReference({ points: [worldPos] });
        return {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                ...viewReference,
                referencedImageId,
                viewUp,
                cameraPosition,
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [],
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
            },
        };
    }
    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
        }
        return referencedImageId;
    }
    getStyle(property, specifications, annotation) {
        return (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__.getStyleProperty)(property, specifications, (0,_stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__.getState)(annotation), this.mode);
    }
}
AnnotationDisplayTool.toolName = 'AnnotationDisplayTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationDisplayTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnnotationDisplayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../enums/ChangeTypes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js");
/* harmony import */ var _stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationSelection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js");
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");










const { DefaultHistoryMemo } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.HistoryMemo;
const { PointsManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class AnnotationTool extends _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static createAnnotation(...annotationBaseData) {
        let annotation = {
            annotationUID: null,
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.toolName,
            },
            data: {
                text: '',
                handles: {
                    points: new Array(),
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                label: '',
            },
        };
        for (const baseData of annotationBaseData) {
            annotation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(annotation, baseData);
        }
        return annotation;
    }
    static createAnnotationForViewport(viewport, ...annotationBaseData) {
        return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);
    }
    static createAndAddAnnotation(viewport, ...annotationBaseData) {
        const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, viewport.element);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_6__.triggerAnnotationModified)(annotation, viewport.element);
    }
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt, filteredAnnotations) => {
            if (!filteredAnnotations) {
                return false;
            }
            const { element, currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            let annotationsNeedToBeRedrawn = false;
            for (const annotation of filteredAnnotations) {
                if ((0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(annotation.annotationUID) ||
                    !(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__.isAnnotationVisible)(annotation.annotationUID)) {
                    continue;
                }
                const { data } = annotation;
                const activateHandleIndex = data.handles
                    ? data.handles.activeHandleIndex
                    : undefined;
                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);
                const nearToolAndNotMarkedActive = near && !annotation.highlighted;
                const notNearToolAndMarkedActive = !near && annotation.highlighted;
                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
                    annotation.highlighted = !annotation.highlighted;
                    annotationsNeedToBeRedrawn = true;
                }
                else if (data.handles &&
                    data.handles.activeHandleIndex !== activateHandleIndex) {
                    annotationsNeedToBeRedrawn = true;
                }
            }
            return annotationsNeedToBeRedrawn;
        };
        this.isSuvScaled = AnnotationTool.isSuvScaled;
        if (toolProps.configuration?.getTextLines) {
            this.configuration.getTextLines = toolProps.configuration.getTextLines;
        }
        if (toolProps.configuration?.statsCalculator) {
            this.configuration.statsCalculator =
                toolProps.configuration.statsCalculator;
        }
    }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const { isCanvasAnnotation } = data;
        const { points, textBox } = data.handles;
        if (textBox) {
            const { worldBoundingBox } = textBox;
            if (worldBoundingBox) {
                const canvasBoundingBox = {
                    topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),
                    topRight: viewport.worldToCanvas(worldBoundingBox.topRight),
                    bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),
                    bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),
                };
                if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&
                    canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&
                    canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&
                    canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {
                    data.handles.activeHandleIndex = null;
                    return textBox;
                }
            }
        }
        for (let i = 0; i < points?.length; i++) {
            const point = points[i];
            const annotationCanvasCoordinate = isCanvasAnnotation
                ? point.slice(0, 2)
                : viewport.worldToCanvas(point);
            const near = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
            if (near === true) {
                data.handles.activeHandleIndex = i;
                return point;
            }
        }
        data.handles.activeHandleIndex = null;
    }
    getLinkedTextBoxStyle(specifications, annotation) {
        return {
            visibility: this.getStyle('textBoxVisibility', specifications, annotation),
            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),
            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),
            color: this.getStyle('textBoxColor', specifications, annotation),
            shadow: this.getStyle('textBoxShadow', specifications, annotation),
            background: this.getStyle('textBoxBackground', specifications, annotation),
            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),
            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),
        };
    }
    static isSuvScaled(viewport, targetId, imageId) {
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            return volume?.scaling?.PT !== undefined;
        }
        const scalingModule = imageId && _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('scalingModule', imageId);
        return typeof scalingModule?.suvbw === 'number';
    }
    getAnnotationStyle(context) {
        const { annotation, styleSpecifier } = context;
        const getStyle = (property) => this.getStyle(property, styleSpecifier, annotation);
        const { annotationUID } = annotation;
        const visibility = (0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__.isAnnotationVisible)(annotationUID);
        const locked = (0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(annotationUID);
        const lineWidth = getStyle('lineWidth');
        const lineDash = getStyle('lineDash');
        const angleArcLineDash = getStyle('angleArcLineDash');
        const color = getStyle('color');
        const markerSize = getStyle('markerSize');
        const shadow = getStyle('shadow');
        const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        return {
            visibility,
            locked,
            color,
            lineWidth,
            lineDash,
            lineOpacity: 1,
            fillColor: color,
            fillOpacity: 0,
            shadow,
            textbox: textboxStyle,
            markerSize,
            angleArcLineDash,
        };
    }
    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {
        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);
        if (handleNearImagePoint) {
            return true;
        }
        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');
        if (toolNewImagePoint) {
            return true;
        }
    }
    static createAnnotationState(annotation, deleting) {
        const { data, annotationUID } = annotation;
        const cloneData = {
            ...data,
            cachedStats: {},
        };
        delete cloneData.contour;
        delete cloneData.spline;
        const state = {
            annotationUID,
            data: structuredClone(cloneData),
            deleting,
        };
        const contour = data.contour;
        if (contour) {
            state.data.contour = {
                ...contour,
                polyline: null,
                pointsManager: PointsManager.create3(contour.polyline.length, contour.polyline),
            };
        }
        return state;
    }
    static createAnnotationMemo(element, annotation, options) {
        if (!annotation) {
            return;
        }
        const { newAnnotation, deleting = newAnnotation ? false : undefined } = options || {};
        const { annotationUID } = annotation;
        const state = AnnotationTool.createAnnotationState(annotation, deleting);
        const annotationMemo = {
            restoreMemo: () => {
                const newState = AnnotationTool.createAnnotationState(annotation, deleting);
                const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element) || {};
                viewport?.setViewReference(annotation.metadata);
                if (state.deleting === true) {
                    state.deleting = false;
                    Object.assign(annotation.data, state.data);
                    if (annotation.data.contour) {
                        const annotationData = annotation.data;
                        annotationData.contour.polyline = state.data.contour.pointsManager.points;
                        delete state.data.contour.pointsManager;
                        if (annotationData.segmentation) {
                            (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.addContourSegmentationAnnotation)(annotation);
                        }
                    }
                    state.data = newState.data;
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
                    (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_8__.setAnnotationSelected)(annotation.annotationUID, true);
                    viewport?.render();
                    return;
                }
                if (state.deleting === false) {
                    state.deleting = true;
                    state.data = newState.data;
                    (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_8__.setAnnotationSelected)(annotation.annotationUID);
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
                    viewport?.render();
                    return;
                }
                const currentAnnotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotation)(annotationUID);
                if (!currentAnnotation) {
                    console.warn('No current annotation');
                    return;
                }
                Object.assign(currentAnnotation.data, state.data);
                if (currentAnnotation.data.contour) {
                    currentAnnotation.data
                        .contour.polyline = state.data.contour.pointsManager.points;
                }
                state.data = newState.data;
                currentAnnotation.invalidated = true;
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_6__.triggerAnnotationModified)(currentAnnotation, element, _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_7__["default"].History);
            },
            id: annotationUID,
            operationType: 'annotation',
        };
        DefaultHistoryMemo.push(annotationMemo);
        return annotationMemo;
    }
    createMemo(element, annotation, options) {
        this.memo ||= AnnotationTool.createAnnotationMemo(element, annotation, options);
    }
    static hydrateBase(ToolClass, enabledElement, points, options = {}) {
        if (!enabledElement) {
            return null;
        }
        const { viewport } = enabledElement;
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const camera = viewport.getCamera();
        const viewPlaneNormal = options.viewplaneNormal ?? camera.viewPlaneNormal;
        const viewUp = options.viewUp ?? camera.viewUp;
        const instance = options.toolInstance || new ToolClass();
        let referencedImageId;
        let finalViewPlaneNormal = viewPlaneNormal;
        let finalViewUp = viewUp;
        if (options.referencedImageId) {
            referencedImageId = options.referencedImageId;
            finalViewPlaneNormal = undefined;
            finalViewUp = undefined;
        }
        else {
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                const closestImageIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestStackImageIndexForPoint(points[0], viewport);
                if (closestImageIndex !== undefined) {
                    referencedImageId = viewport.getImageIds()[closestImageIndex];
                }
            }
            else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
                referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
            }
            else {
                throw new Error('Unsupported viewport type');
            }
        }
        return {
            FrameOfReferenceUID,
            referencedImageId,
            viewPlaneNormal: finalViewPlaneNormal,
            viewUp: finalViewUp,
            instance,
            viewport,
        };
    }
}
AnnotationTool.toolName = 'AnnotationTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/ToolModes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js");


const { DefaultHistoryMemo } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.HistoryMemo;
class BaseTool {
    static { this.defaults = {
        configuration: {
            strategies: {},
            defaultStrategy: undefined,
            activeStrategy: undefined,
            strategyOptions: {},
        },
    }; }
    constructor(toolProps, defaultToolProps) {
        const mergedDefaults = BaseTool.mergeDefaultProps(BaseTool.defaults, defaultToolProps);
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(mergedDefaults, toolProps);
        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;
        this.toolGroupId = toolGroupId;
        this.supportedInteractionTypes = supportedInteractionTypes || [];
        this.configuration = Object.assign({}, configuration);
        this.mode = _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__["default"].Disabled;
    }
    static mergeDefaultProps(defaultProps = {}, additionalProps) {
        if (!additionalProps) {
            return defaultProps;
        }
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(defaultProps, additionalProps);
    }
    get toolName() {
        return this.getToolName();
    }
    getToolName() {
        return this.constructor.toolName;
    }
    applyActiveStrategy(enabledElement, operationData) {
        const { strategies, activeStrategy } = this.configuration;
        return strategies[activeStrategy]?.call(this, enabledElement, operationData);
    }
    applyActiveStrategyCallback(enabledElement, operationData, callbackType, ...extraArgs) {
        const { strategies, activeStrategy } = this.configuration;
        if (!strategies[activeStrategy]) {
            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);
        }
        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData, ...extraArgs);
    }
    setConfiguration(newConfiguration) {
        this.configuration = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(this.configuration, newConfiguration);
    }
    setActiveStrategy(strategyName) {
        this.setConfiguration({ activeStrategy: strategyName });
    }
    getTargetImageData(targetId) {
        if (targetId.startsWith('imageId:')) {
            const imageId = targetId.split('imageId:')[1];
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            let viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            viewports = viewports.filter((viewport) => {
                return viewport.getCurrentImageId() === imageId;
            });
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('volumeId:')) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithVolumeId(volumeId);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('videoId:')) {
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else {
            throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
        }
    }
    getTargetId(viewport) {
        const targetId = viewport.getViewReferenceId?.();
        if (targetId) {
            return targetId;
        }
        throw new Error('getTargetId: viewport must have a getViewReferenceId method');
    }
    undo() {
        this.doneEditMemo();
        DefaultHistoryMemo.undo();
    }
    redo() {
        DefaultHistoryMemo.redo();
    }
    static createZoomPanMemo(viewport) {
        const state = {
            pan: viewport.getPan(),
            zoom: viewport.getZoom(),
        };
        const zoomPanMemo = {
            restoreMemo: () => {
                const currentPan = viewport.getPan();
                const currentZoom = viewport.getZoom();
                viewport.setZoom(state.zoom);
                viewport.setPan(state.pan);
                viewport.render();
                state.pan = currentPan;
                state.zoom = currentZoom;
            },
        };
        DefaultHistoryMemo.push(zoomPanMemo);
        return zoomPanMemo;
    }
    doneEditMemo() {
        if (this.memo?.commitMemo?.()) {
            DefaultHistoryMemo.push(this.memo);
        }
        this.memo = null;
    }
}
BaseTool.toolName = 'BaseTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContourBaseTool: () => (/* binding */ ContourBaseTool),
/* harmony export */   "default": () => (/* binding */ ContourBaseTool)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _AnnotationTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AnnotationTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js");
/* harmony import */ var _utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/contours/updateContourPolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js");
/* harmony import */ var _utilities_contours_getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/contours/getContourHolesDataCanvas */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js");






class ContourBaseTool extends _AnnotationTool__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        let renderStatus = false;
        const { viewport } = enabledElement;
        const { element } = viewport;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return renderStatus;
        }
        let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
        if (!annotations?.length) {
            return renderStatus;
        }
        annotations = this.filterInteractableAnnotationsForElement(element, annotations);
        if (!annotations?.length) {
            return renderStatus;
        }
        const targetId = this.getTargetId(viewport);
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        for (let i = 0; i < annotations.length; i++) {
            const annotation = annotations[i];
            styleSpecifier.annotationUID = annotation.annotationUID;
            const annotationStyle = this.getAnnotationStyle({
                annotation,
                styleSpecifier,
            });
            if (!annotationStyle.visibility) {
                continue;
            }
            const annotationRendered = this.renderAnnotationInstance({
                enabledElement,
                targetId,
                annotation,
                annotationStyle,
                svgDrawingHelper,
            });
            renderStatus ||= annotationRendered;
            annotation.invalidated = false;
        }
        return renderStatus;
    }
    createAnnotation(evt) {
        const annotation = super.createAnnotation(evt);
        Object.assign(annotation.data, {
            contour: {
                polyline: [],
                closed: false,
            },
        });
        Object.assign(annotation, {
            interpolationUID: '',
            autoGenerated: false,
        });
        return annotation;
    }
    addAnnotation(annotation, element) {
        return (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, element);
    }
    cancelAnnotation(annotation) {
    }
    moveAnnotation(annotation, worldPosDelta) {
        const { points } = annotation.data.handles;
        for (let i = 0, numPoints = points.length; i < numPoints; i++) {
            const point = points[i];
            point[0] += worldPosDelta[0];
            point[1] += worldPosDelta[1];
            point[2] += worldPosDelta[2];
        }
        annotation.invalidated = true;
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getChildAnnotations)(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));
    }
    updateContourPolyline(annotation, polylineData, transforms, options) {
        const decimateConfig = this.configuration?.decimate || {};
        (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_4__["default"])(annotation, polylineData, transforms, {
            decimate: {
                enabled: !!decimateConfig.enabled,
                epsilon: decimateConfig.epsilon,
            },
            updateWindingDirection: options?.updateWindingDirection,
        });
    }
    getPolylinePoints(annotation) {
        return annotation.data.contour?.polyline ?? annotation.data.polyline;
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        if (annotation.parentAnnotationUID) {
            return;
        }
        const { annotationUID } = annotation;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));
        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;
        const childContours = (0,_utilities_contours_getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_5__["default"])(annotation, viewport);
        const allContours = [polylineCanvasPoints, ...childContours];
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawPath)(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {
            color: color,
            lineDash: lineDash,
            lineWidth: Math.max(0.1, lineWidth),
            fillColor: fillColor,
            fillOpacity: fillOpacity,
        });
        return true;
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContourSegmentationBaseTool: () => (/* binding */ ContourSegmentationBaseTool),
/* harmony export */   "default": () => (/* binding */ ContourSegmentationBaseTool)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _ContourBaseTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ContourBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/segmentation/InterpolationManager/InterpolationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js");
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForToolGroupIds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForToolGroupIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentationRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../stateManagement/segmentation/getViewportIdsWithSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");
/* harmony import */ var _stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js");
/* harmony import */ var _utilities_segmentation_getSVGStyleForSegment__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/segmentation/getSVGStyleForSegment */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js");














class ContourSegmentationBaseTool extends _ContourBaseTool__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static { this.PreviewSegmentIndex = 255; }
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
        if (this.configuration.interpolation?.enabled) {
            _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_4__["default"].addTool(this.getToolName());
        }
    }
    isContourSegmentationTool() {
        return true;
    }
    createAnnotation(evt) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const contourAnnotation = super.createAnnotation(evt);
        if (!this.isContourSegmentationTool()) {
            return contourAnnotation;
        }
        const activeSeg = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_9__.getActiveSegmentation)(viewport.id);
        if (!activeSeg) {
            throw new Error('No active segmentation detected, create one before using scissors tool');
        }
        if (!activeSeg.representationData.Contour) {
            throw new Error(`A contour segmentation must be active`);
        }
        const { segmentationId } = activeSeg;
        const segmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_11__.getActiveSegmentIndex)(segmentationId);
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(contourAnnotation, {
            data: {
                segmentation: {
                    segmentationId,
                    segmentIndex,
                },
            },
        });
    }
    addAnnotation(annotation, element) {
        const annotationUID = super.addAnnotation(annotation, element);
        if (this.isContourSegmentationTool()) {
            const contourSegAnnotation = annotation;
            (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_5__.addContourSegmentationAnnotation)(contourSegAnnotation);
        }
        return annotationUID;
    }
    cancelAnnotation(annotation) {
        if (this.isContourSegmentationTool()) {
            (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_5__.removeContourSegmentationAnnotation)(annotation);
        }
        super.cancelAnnotation(annotation);
    }
    getAnnotationStyle(context) {
        const annotationStyle = super.getAnnotationStyle(context);
        if (!this.isContourSegmentationTool()) {
            return annotationStyle;
        }
        const contourSegmentationStyle = this._getContourSegmentationStyle(context);
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(annotationStyle, contourSegmentationStyle);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation } = renderContext;
        const { invalidated } = annotation;
        const renderResult = super.renderAnnotationInstance(renderContext);
        if (invalidated && this.isContourSegmentationTool()) {
            const { segmentationId } = (annotation).data.segmentation;
            (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationDataModified)(segmentationId);
            const viewportIds = (0,_stateManagement_segmentation_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithSegmentation)(segmentationId);
            const toolGroupIds = viewportIds.map((viewportId) => {
                const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__.getToolGroupForViewport)(viewportId);
                return toolGroup.id;
            });
            (0,_utilities_triggerAnnotationRenderForToolGroupIds__WEBPACK_IMPORTED_MODULE_6__.triggerAnnotationRenderForToolGroupIds)(toolGroupIds);
        }
        return renderResult;
    }
    _getContourSegmentationStyle(context) {
        const annotation = context.annotation;
        const { segmentationId, segmentIndex } = annotation.data.segmentation;
        const { viewportId } = context.styleSpecifier;
        const segmentationRepresentations = (0,_stateManagement_segmentation_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_8__.getSegmentationRepresentations)(viewportId, { segmentationId });
        if (!segmentationRepresentations?.length) {
            return {};
        }
        let segmentationRepresentation;
        if (segmentationRepresentations.length > 1) {
            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&
                rep.type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour);
        }
        else {
            segmentationRepresentation = segmentationRepresentations[0];
        }
        const { autoGenerated } = annotation;
        const segmentsLocked = (0,_stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_12__.getLockedSegmentIndices)(segmentationId);
        const annotationLocked = segmentsLocked.includes(segmentIndex);
        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = (0,_utilities_segmentation_getSVGStyleForSegment__WEBPACK_IMPORTED_MODULE_13__.getSVGStyleForSegment)({
            segmentationId,
            segmentIndex,
            viewportId,
            autoGenerated,
        });
        return {
            color,
            fillColor,
            lineWidth,
            fillOpacity,
            lineDash,
            textbox: {
                color,
            },
            visibility,
            locked: annotationLocked,
        };
    }
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotationDisplayTool: () => (/* reexport safe */ _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   AnnotationTool: () => (/* reexport safe */ _AnnotationTool__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   BaseTool: () => (/* reexport safe */ _BaseTool__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js");
/* harmony import */ var _AnnotationTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnnotationTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js");
/* harmony import */ var _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnnotationDisplayTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const defaultContourConfig = {
    renderOutline: true,
    outlineWidthAutoGenerated: 3,
    outlineWidth: 1,
    outlineWidthInactive: 1,
    outlineOpacity: 1,
    outlineOpacityInactive: 0.85,
    outlineDash: undefined,
    outlineDashInactive: undefined,
    outlineDashAutoGenerated: '5,3',
    activeSegmentOutlineWidthDelta: 0,
    renderFill: true,
    fillAlpha: 0.5,
    fillAlphaInactive: 0.3,
    fillAlphaAutoGenerated: 0.3,
};
function getDefaultContourStyle() {
    return defaultContourConfig;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getDefaultContourStyle);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contourHandler/handleContourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _removeContourFromElement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./removeContourFromElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/config.js");
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utilities/segmentation/computeAndAddRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js");
/* harmony import */ var _utilities_segmentation_getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utilities/segmentation/getUniqueSegmentIndices */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");










const polySegConversionInProgressForViewportId = new Map();
const processedViewportSegmentations = new Map();
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeContourFromElement__WEBPACK_IMPORTED_MODULE_4__["default"])(viewportId, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, contourRepresentation) {
    const { segmentationId } = contourRepresentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__.getSegmentation)(segmentationId);
    if (!segmentation) {
        return;
    }
    let contourData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Contour];
    const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_5__.getPolySeg)();
    if (!contourData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_5__.getPolySeg)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Contour) &&
        !polySegConversionInProgressForViewportId.get(viewport.id)) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        contourData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_6__.computeAndAddRepresentation)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Contour, () => polySeg.computeContourData(segmentationId, { viewport }), () => undefined);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    else if (!contourData && !(0,_config__WEBPACK_IMPORTED_MODULE_5__.getPolySeg)()) {
        console.debug(`No contour data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!contourData) {
        return;
    }
    if (!contourData.geometryIds?.length) {
        return;
    }
    let hasContourDataButNotMatchingViewport = false;
    const viewportNormal = viewport.getCamera().viewPlaneNormal;
    if (contourData.annotationUIDsMap) {
        hasContourDataButNotMatchingViewport = !_checkContourNormalsMatchViewport(contourData.annotationUIDsMap, viewportNormal);
    }
    if (contourData.geometryIds.length > 0) {
        hasContourDataButNotMatchingViewport = !_checkContourGeometryMatchViewport(contourData.geometryIds, viewportNormal);
    }
    const viewportProcessed = processedViewportSegmentations.get(viewport.id) || new Set();
    if (hasContourDataButNotMatchingViewport &&
        !polySegConversionInProgressForViewportId.get(viewport.id) &&
        !viewportProcessed.has(segmentationId) &&
        viewport.viewportStatus === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.ViewportStatus.RENDERED) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        const segmentIndices = (0,_utilities_segmentation_getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_7__.getUniqueSegmentIndices)(segmentationId);
        const surfacesInfo = await polySeg.computeSurfaceData(segmentationId, {
            segmentIndices,
            viewport,
        });
        const geometryIds = surfacesInfo.geometryIds;
        const pointsAndPolys = [];
        for (const geometryId of geometryIds.values()) {
            const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
            const data = geometry.data;
            pointsAndPolys.push({
                points: data.points,
                polys: data.polys,
                segmentIndex: data.segmentIndex,
                id: data.segmentIndex,
            });
        }
        const polyDataCache = await polySeg.clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);
        const rawResults = polySeg.extractContourData(polyDataCache);
        const annotationUIDsMap = polySeg.createAndAddContourSegmentationsFromClippedSurfaces(rawResults, viewport, segmentationId);
        contourData.annotationUIDsMap = new Map([
            ...contourData.annotationUIDsMap,
            ...annotationUIDsMap,
        ]);
        viewportProcessed.add(segmentationId);
        processedViewportSegmentations.set(viewport.id, viewportProcessed);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    (0,_contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__.handleContourSegmentation)(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);
}
function _checkContourGeometryMatchViewport(geometryIds, viewportNormal) {
    let validGeometry = null;
    let geometryData = null;
    for (const geometryId of geometryIds) {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        if (!geometry) {
            continue;
        }
        const data = geometry.data;
        if (data.contours?.[0]?.points?.length >= 3) {
            validGeometry = geometry;
            geometryData = data;
            break;
        }
    }
    if (!validGeometry || !geometryData) {
        return false;
    }
    const contours = geometryData.contours;
    const points = contours[0].points;
    const point1 = points[0];
    const point2 = points[1];
    const point3 = points[2];
    let normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.create(), point2, point1), gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.create(), point3, point1));
    normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.create(), normal);
    const dotProduct = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.vec3.dot(normal, viewportNormal);
    return Math.abs(dotProduct) > 0.9;
}
function _checkContourNormalsMatchViewport(annotationUIDsMap, viewportNormal) {
    const annotationUIDs = Array.from(annotationUIDsMap.values())
        .flat()
        .map((uidSet) => Array.from(uidSet))
        .flat();
    const randomAnnotationUIDs = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getRandomSampleFromArray(annotationUIDs, 3);
    for (const annotationUID of randomAnnotationUIDs) {
        const annotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_8__.getAnnotation)(annotationUID);
        if (annotation?.metadata) {
            if (!annotation.metadata.viewPlaneNormal) {
                continue;
            }
            const annotationNormal = annotation.metadata.viewPlaneNormal;
            const dotProduct = Math.abs(viewportNormal[0] * annotationNormal[0] +
                viewportNormal[1] * annotationNormal[1] +
                viewportNormal[2] * annotationNormal[2]);
            if (Math.abs(dotProduct - 1) > 0.01) {
                return false;
            }
        }
    }
    return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addContourSetsToElement: () => (/* binding */ addContourSetsToElement),
/* harmony export */   handleContourSegmentation: () => (/* binding */ handleContourSegmentation)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_annotationHydration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utilities/annotationHydration */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js");
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utilities/contourSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/SegmentationStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js");







function handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {
    if (annotationUIDsMap.size) {
        viewport.render();
    }
    else {
        addContourSetsToElement(viewport, geometryIds, contourRepresentation);
    }
}
function addContourSetsToElement(viewport, geometryIds, contourRepresentation) {
    const { segmentationId } = contourRepresentation;
    const segmentSpecificMap = new Map();
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getGeometry(geometryId);
        if (!geometry) {
            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);
            return;
        }
        const segmentIndex = geometry.data.segmentIndex;
        (0,_utils__WEBPACK_IMPORTED_MODULE_4__.validateGeometry)(geometry);
        const segmentSpecificConfig = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_6__.segmentationStyle.getStyle({
            viewportId: viewport.id,
            segmentationId,
            type: _enums__WEBPACK_IMPORTED_MODULE_5__.SegmentationRepresentations.Contour,
            segmentIndex,
        });
        const contourSet = geometry.data;
        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;
        contourSet.contours.forEach((contour) => {
            const { points, color, id } = contour;
            const referencedImageId = (0,_utilities_annotationHydration__WEBPACK_IMPORTED_MODULE_2__.getClosestImageIdForStackViewport)(viewport, points[0], viewPlaneNormal);
            const contourSegmentationAnnotation = {
                annotationUID: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
                data: {
                    contour: {
                        closed: true,
                        polyline: points,
                    },
                    segmentation: {
                        segmentationId,
                        segmentIndex,
                        color,
                        id,
                    },
                    handles: {},
                },
                handles: {},
                highlighted: false,
                autoGenerated: false,
                invalidated: false,
                isLocked: true,
                isVisible: true,
                metadata: {
                    referencedImageId,
                    toolName: 'PlanarFreehandContourSegmentationTool',
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,
                },
            };
            const annotationGroupSelector = viewport.element;
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__.addAnnotation)(contourSegmentationAnnotation, annotationGroupSelector);
            (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_3__.addContourSegmentationAnnotation)(contourSegmentationAnnotation);
        });
        if (segmentSpecificConfig) {
            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);
        }
    });
    viewport.render();
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPolyData: () => (/* binding */ getPolyData),
/* harmony export */   validateGeometry: () => (/* binding */ validateGeometry)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/CellArray */ "../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_Points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/Points */ "../../../node_modules/@kitware/vtk.js/Common/Core/Points.js");
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @kitware/vtk.js/Common/DataModel/PolyData */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js");




function validateGeometry(geometry) {
    if (!geometry) {
        throw new Error(`No contours found for geometryId ${geometry.id}`);
    }
    const geometryId = geometry.id;
    if (geometry.type !== _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GeometryType.CONTOUR) {
        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);
    }
    if (!geometry.data) {
        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);
        return;
    }
}
function getPolyData(contourSet) {
    const pointArray = [];
    const points = _kitware_vtk_js_Common_Core_Points__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    const lines = _kitware_vtk_js_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
    let pointIndex = 0;
    contourSet.contours.forEach((contour) => {
        const pointList = contour.points;
        const flatPoints = contour.flatPointsArray;
        const type = contour.type;
        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);
        if (type === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.ContourType.CLOSED_PLANAR) {
            pointIndexes.push(pointIndexes[0]);
        }
        const linePoints = Float32Array.from(flatPoints);
        pointArray.push(...linePoints);
        lines.insertNextCell([...pointIndexes]);
        pointIndex = pointIndex + pointList.length;
    });
    points.setData(pointArray, 3);
    const polygon = _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    polygon.setPoints(points);
    polygon.setLines(lines);
    return polygon;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");


function removeContourFromElement(viewportId, segmentationId, removeFromCache = false) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    const { annotationUIDsMap } = segmentation.representationData.Contour;
    annotationUIDsMap.forEach((annotationSet) => {
        annotationSet.forEach((annotationUID) => {
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__.removeAnnotation)(annotationUID);
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (removeContourFromElement);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _addVolumesAsIndependentComponents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./addVolumesAsIndependentComponents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js");






const { uuidv4 } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
async function addLabelmapToElement(element, labelMapData, segmentationId, config) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngine, viewport } = enabledElement;
    const { id: viewportId } = viewport;
    const visibility = true;
    const immediateRender = false;
    const suppressEvents = true;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const volumeLabelMapData = labelMapData;
        const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);
        if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId)) {
            await _handleMissingVolume(labelMapData);
        }
        let blendMode = config?.blendMode ?? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;
        let useIndependentComponents = blendMode === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;
        if (useIndependentComponents) {
            const referenceVolumeId = viewport.getVolumeId();
            const baseVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referenceVolumeId);
            const segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            const segDims = segVolume.dimensions;
            const refDims = baseVolume.dimensions;
            if (segDims[0] !== refDims[0] ||
                segDims[1] !== refDims[1] ||
                segDims[2] !== refDims[2]) {
                useIndependentComponents = false;
                blendMode = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;
                console.debug('Dimensions mismatch - falling back to regular volume addition');
            }
        }
        const volumeInputs = [
            {
                volumeId,
                visibility,
                representationUID: `${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_4__.SegmentationRepresentations.Labelmap}`,
                useIndependentComponents,
                blendMode,
            },
        ];
        if (!volumeInputs[0].useIndependentComponents) {
            await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.addVolumesToViewports)(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);
        }
        else {
            const result = await (0,_addVolumesAsIndependentComponents__WEBPACK_IMPORTED_MODULE_5__.addVolumesAsIndependentComponents)({
                viewport,
                volumeInputs,
                segmentationId,
            });
            return result;
        }
    }
    else {
        const segmentationImageIds = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_1__.getCurrentLabelmapImageIdsForViewport)(viewport.id, segmentationId);
        const stackInputs = segmentationImageIds.map((imageId) => ({
            imageId,
            representationUID: `${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_4__.SegmentationRepresentations.Labelmap}-${imageId}`,
        }));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.addImageSlicesToViewports)(renderingEngine, stackInputs, [viewportId]);
    }
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationDataModified)(segmentationId);
}
function _ensureVolumeHasVolumeId(labelMapData, segmentationId) {
    let { volumeId } = labelMapData;
    if (!volumeId) {
        volumeId = uuidv4();
        const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
        segmentation.representationData.Labelmap = {
            ...segmentation.representationData.Labelmap,
            volumeId,
        };
        labelMapData.volumeId = volumeId;
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
    }
    return volumeId;
}
async function _handleMissingVolume(labelMapData) {
    const stackData = labelMapData;
    const hasImageIds = stackData.imageIds.length > 0;
    if (!hasImageIds) {
        throw new Error('cannot create labelmap, no imageIds found for the volume labelmap');
    }
    const volume = await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv4(), stackData.imageIds);
    return volume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addLabelmapToElement);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js":
/*!****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addVolumesAsIndependentComponents: () => (/* binding */ addVolumesAsIndependentComponents)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");



const internalCache = new Map();
const load = ({ cfun, ofun, actor }) => {
    actor.getProperty().setRGBTransferFunction(1, cfun);
    actor.getProperty().setScalarOpacity(1, ofun);
};
async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId, }) {
    const defaultActor = viewport.getDefaultActor();
    const { actor } = defaultActor;
    const { uid, callback } = defaultActor;
    const referenceVolumeId = viewport.getVolumeId();
    if (internalCache.get(uid)?.added) {
        return {
            uid,
            actor,
        };
    }
    const volumeInputArray = volumeInputs;
    const firstImageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
        throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    const { volumeId } = volumeInputArray[0];
    const segImageVolume = await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.loadVolume(volumeId);
    if (!segImageVolume) {
        throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);
    }
    const segVoxelManager = segImageVolume.voxelManager;
    const segData = segVoxelManager.getCompleteScalarDataArray();
    const { imageData: segImageData } = segImageVolume;
    const baseVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referenceVolumeId);
    const baseVoxelManager = baseVolume.voxelManager;
    const baseData = baseVoxelManager.getCompleteScalarDataArray();
    const newComp = 2;
    const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());
    const dims = segImageData.getDimensions();
    for (let z = 0; z < dims[2]; ++z) {
        for (let y = 0; y < dims[1]; ++y) {
            for (let x = 0; x < dims[0]; ++x) {
                const iTuple = x + dims[0] * (y + dims[1] * z);
                cubeData[iTuple * newComp + 0] = baseData[iTuple];
                cubeData[iTuple * newComp + 1] = segData[iTuple];
            }
        }
    }
    viewport.removeActors([uid]);
    const oldMapper = actor.getMapper();
    const mapper = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.convertMapperToNotSharedMapper)(oldMapper);
    actor.setMapper(mapper);
    mapper.setBlendMode(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);
    const arrayAgain = mapper.getInputData().getPointData().getArray(0);
    arrayAgain.setData(cubeData);
    arrayAgain.setNumberOfComponents(2);
    actor.getProperty().setColorMixPreset(1);
    actor.getProperty().setForceNearestInterpolation(1, true);
    actor.getProperty().setIndependentComponents(true);
    viewport.addActor({
        actor,
        uid,
        callback,
        referencedId: referenceVolumeId,
        representationUID: `${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap}`,
    });
    internalCache.set(uid, {
        added: true,
        segmentationRepresentationUID: `${segmentationId}`,
        originalBlendMode: viewport.getBlendMode(),
    });
    actor.set({
        preLoad: load,
    });
    function onSegmentationDataModified(evt) {
        const { segmentationId } = evt.detail;
        const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
        const { volumeId: segVolumeId } = representationData.Labelmap;
        if (segVolumeId !== segImageVolume.volumeId) {
            return;
        }
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segVolumeId);
        const segVoxelManager = segmentationVolume.voxelManager;
        const imageData = mapper.getInputData();
        const array = imageData.getPointData().getArray(0);
        const baseData = array.getData();
        const newComp = 2;
        const dims = segImageData.getDimensions();
        const slices = Array.from({ length: dims[2] }, (_, i) => i);
        for (const z of slices) {
            for (let y = 0; y < dims[1]; ++y) {
                for (let x = 0; x < dims[0]; ++x) {
                    const iTuple = x + dims[0] * (y + dims[1] * z);
                    baseData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);
                }
            }
        }
        array.setData(baseData);
        imageData.modified();
        viewport.render();
    }
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListenerDebounced(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified, 200);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified);
        const actorEntry = viewport.getActor(uid);
        const { element, id } = viewport;
        viewport.removeActors([uid]);
        const actor = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.createVolumeActor)({
            volumeId: uid,
            blendMode: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,
            callback: ({ volumeActor }) => {
                if (actorEntry.callback) {
                    actorEntry.callback({
                        volumeActor,
                        volumeId,
                    });
                }
            },
        }, element, id);
        viewport.addActor({ actor, uid });
        viewport.render();
    });
    return {
        uid,
        actor,
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const defaultLabelmapConfig = {
    renderOutline: true,
    renderOutlineInactive: true,
    outlineWidth: 3,
    outlineWidthInactive: 2,
    activeSegmentOutlineWidthDelta: 0,
    renderFill: true,
    renderFillInactive: true,
    fillAlpha: 0.5,
    fillAlphaInactive: 0.4,
    outlineOpacity: 1,
    outlineOpacityInactive: 0.85,
};
function getDefaultLabelmapStyle() {
    return defaultLabelmapConfig;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getDefaultLabelmapStyle);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAX_NUMBER_COLORS: () => (/* binding */ MAX_NUMBER_COLORS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeRepresentation: () => (/* binding */ removeRepresentation),
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addLabelmapToElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js");
/* harmony import */ var _removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./removeLabelmapFromElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js");
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../stateManagement/segmentation/activeSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js");
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../stateManagement/segmentation/SegmentationStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js");
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../stateManagement/segmentation/helpers/getSegmentationActor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/config.js");
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../utilities/segmentation/computeAndAddRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../stateManagement/segmentation/SegmentationStateManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js");
















const MAX_NUMBER_COLORS = 255;
const labelMapConfigCache = new Map();
let polySegConversionInProgress = false;
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    labelMapConfigCache.forEach((value, key) => {
        if (key.includes(segmentationId)) {
            labelMapConfigCache.delete(key);
        }
    });
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__["default"])(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId, config } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__.getSegmentation)(segmentationId);
    if (!segmentation) {
        console.warn('No segmentation found for segmentationId: ', segmentationId);
        return;
    }
    let labelmapData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__["default"].Labelmap];
    let labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__.getLabelmapActorEntries)(viewport.id, segmentationId);
    if (!labelmapData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_12__.getPolySeg)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__["default"].Labelmap) &&
        !polySegConversionInProgress) {
        polySegConversionInProgress = true;
        const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_12__.getPolySeg)();
        labelmapData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_13__.computeAndAddRepresentation)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__["default"].Labelmap, () => polySeg.computeLabelmapData(segmentationId, { viewport }), () => null, () => {
            _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__.defaultSegmentationStateManager.processLabelmapRepresentationAddition(viewport.id, segmentationId);
            setTimeout(() => {
                (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__.triggerSegmentationDataModified)(segmentationId);
            }, 0);
        });
        if (!labelmapData) {
            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);
        }
        polySegConversionInProgress = false;
    }
    else if (!labelmapData && !(0,_config__WEBPACK_IMPORTED_MODULE_12__.getPolySeg)()) {
        console.debug(`No labelmap data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to labelmap. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!labelmapData) {
        return;
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
        if (!labelmapActorEntries?.length) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
        }
        labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__.getLabelmapActorEntries)(viewport.id, segmentationId);
    }
    else {
        const labelmapImageIds = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__.getCurrentLabelmapImageIdsForViewport)(viewport.id, segmentationId);
        if (!labelmapImageIds?.length) {
            return;
        }
        if (!labelmapActorEntries) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
        }
        labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__.getLabelmapActorEntries)(viewport.id, segmentationId);
    }
    if (!labelmapActorEntries?.length) {
        return;
    }
    for (const labelmapActorEntry of labelmapActorEntries) {
        _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);
    }
}
function _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {
    const { segmentationId } = segmentationRepresentation;
    const { cfun, ofun } = segmentationRepresentation.config;
    const { colorLUTIndex } = segmentationRepresentation;
    const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__.getActiveSegmentation)(viewportId);
    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;
    const labelmapStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__.segmentationStyle.getStyle({
        viewportId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__["default"].Labelmap,
        segmentationId,
    });
    const renderInactiveSegmentations = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__.segmentationStyle.getRenderInactiveSegmentations(viewportId);
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__.getColorLUT)(colorLUTIndex);
    const numColors = Math.min(256, colorLUT.length);
    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);
    const segmentsHidden = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_9__.internalGetHiddenSegmentIndices)(viewportId, {
        segmentationId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__["default"].Labelmap,
    });
    for (let i = 0; i < numColors; i++) {
        const segmentIndex = i;
        const segmentColor = colorLUT[segmentIndex];
        const perSegmentStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__.segmentationStyle.getStyle({
            viewportId,
            type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__["default"].Labelmap,
            segmentationId,
            segmentIndex,
        });
        const segmentSpecificLabelmapConfig = perSegmentStyle;
        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);
        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {
            fillAlpha,
            renderFill,
            renderOutline,
            segmentColor,
            outlineWidth,
            segmentsHidden: segmentsHidden,
            cfun,
            ofun,
        });
        if (forceColorUpdate) {
            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);
        }
        if (forceOpacityUpdate) {
            if (renderFill) {
                const segmentOpacity = segmentsHidden.has(segmentIndex)
                    ? 0
                    : (segmentColor[3] / 255) * fillAlpha;
                ofun.removePoint(segmentIndex);
                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);
            }
            else {
                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);
            }
        }
    }
    ofun.setClamping(false);
    const labelmapActor = labelmapActorEntry.actor;
    const { preLoad } = labelmapActor.get?.('preLoad') || { preLoad: null };
    if (preLoad) {
        preLoad({ cfun, ofun, actor: labelmapActor });
    }
    else {
        labelmapActor.getProperty().setRGBTransferFunction(0, cfun);
        labelmapActor.getProperty().setScalarOpacity(0, ofun);
        labelmapActor.getProperty().setInterpolationTypeToNearest();
    }
    if (renderOutline) {
        labelmapActor.getProperty().setUseLabelOutline(renderOutline);
        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);
        const activeSegmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_10__.getActiveSegmentIndex)(segmentationRepresentation.segmentationId);
        const outlineWidths = new Array(numColors - 1);
        for (let i = 1; i < numColors; i++) {
            const isHidden = segmentsHidden.has(i);
            if (isHidden) {
                outlineWidths[i - 1] = 0;
                continue;
            }
            outlineWidths[i - 1] =
                i === activeSegmentIndex
                    ? outlineWidth + activeSegmentOutlineWidthDelta
                    : outlineWidth;
        }
        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);
        labelmapActor.modified();
        labelmapActor.getProperty().modified();
        labelmapActor.getMapper().modified();
    }
    else {
        labelmapActor
            .getProperty()
            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));
    }
    const visible = isActiveLabelmap || renderInactiveSegmentations;
    labelmapActor.setVisibility(visible);
}
function _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {
    const segmentLabelmapConfig = segmentsLabelmapConfig || {};
    const configToUse = {
        ...labelmapConfig,
        ...segmentLabelmapConfig,
    };
    const fillAlpha = isActiveLabelmap
        ? configToUse.fillAlpha
        : configToUse.fillAlphaInactive;
    const outlineWidth = isActiveLabelmap
        ? configToUse.outlineWidth
        : configToUse.outlineWidthInactive;
    const renderFill = isActiveLabelmap
        ? configToUse.renderFill
        : configToUse.renderFillInactive;
    const renderOutline = isActiveLabelmap
        ? configToUse.renderOutline
        : configToUse.renderOutlineInactive;
    const outlineOpacity = isActiveLabelmap
        ? configToUse.outlineOpacity
        : configToUse.outlineOpacityInactive;
    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;
    return {
        fillAlpha,
        outlineWidth,
        renderFill,
        renderOutline,
        outlineOpacity,
        activeSegmentOutlineWidthDelta,
    };
}
function _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {
    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;
    const oldConfig = labelMapConfigCache.get(cacheUID);
    if (!oldConfig) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
        return {
            forceOpacityUpdate: true,
            forceColorUpdate: true,
        };
    }
    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;
    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||
        oldSegmentColor[1] !== segmentColor[1] ||
        oldSegmentColor[2] !== segmentColor[2];
    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||
        oldFillAlpha !== fillAlpha ||
        oldRenderFill !== renderFill ||
        oldRenderOutline !== renderOutline ||
        oldOutlineWidth !== outlineWidth ||
        oldSegmentsHidden !== segmentsHidden;
    if (forceOpacityUpdate || forceColorUpdate) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
    }
    return {
        forceOpacityUpdate,
        forceColorUpdate,
    };
}
async function _addLabelmapToViewport(viewport, labelmapData, segmentationId, config) {
    const result = await (0,_addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__["default"])(viewport.element, labelmapData, segmentationId, config);
    return result || undefined;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../stateManagement/segmentation/helpers/getSegmentationActor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js");


function removeLabelmapFromElement(element, segmentationId) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    viewport.removeActors([(0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__.getLabelmapActorUID)(viewport.id, segmentationId)]);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (removeLabelmapFromElement);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kitware/vtk.js/Rendering/Core/Mapper */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js");
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @kitware/vtk.js/Rendering/Core/Actor */ "../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js");
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @kitware/vtk.js/Common/DataModel/PolyData */ "../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js");
/* harmony import */ var _kitware_vtk_js_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @kitware/vtk.js/Common/Core/CellArray */ "../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js");
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../stateManagement/segmentation/helpers/getSegmentationActor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js");







function addOrUpdateSurfaceToElement(element, surface, segmentationId) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const surfaceActorEntry = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__.getSurfaceActorEntry)(viewport.id, segmentationId, surface.segmentIndex);
    const surfaceActor = surfaceActorEntry?.actor;
    const isVisible = surface.visible;
    if (surfaceActor) {
        surfaceActor.setVisibility(isVisible);
        if (!isVisible) {
            return;
        }
        const surfaceMapper = surfaceActor.getMapper();
        const currentPolyData = surfaceMapper.getInputData();
        const newPoints = surface.points;
        const newPolys = surface.polys;
        const currentPoints = currentPolyData.getPoints().getData();
        const currentPolys = currentPolyData.getPolys().getData();
        if (newPoints.length === currentPoints.length &&
            newPolys.length === currentPolys.length) {
            return;
        }
        const polyData = _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
        polyData.getPoints().setData(newPoints, 3);
        const triangles = _kitware_vtk_js_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance({
            values: Float32Array.from(newPolys),
        });
        polyData.setPolys(triangles);
        surfaceMapper.setInputData(polyData);
        surfaceMapper.modified();
        viewport.getRenderer().resetCameraClippingRange();
        return;
    }
    const points = surface.points;
    const polys = surface.polys;
    const color = surface.color;
    const surfacePolyData = _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    surfacePolyData.getPoints().setData(points, 3);
    const triangles = _kitware_vtk_js_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance({
        values: Float32Array.from(polys),
    });
    surfacePolyData.setPolys(triangles);
    const mapper = _kitware_vtk_js_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({});
    let clippingFilter;
    mapper.setInputData(surfacePolyData);
    const actor = _kitware_vtk_js_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    actor.setMapper(mapper);
    actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);
    actor.getProperty().setLineWidth(2);
    const representationUID = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__.getSurfaceRepresentationUID)(segmentationId, surface.segmentIndex);
    viewport.addActor({
        uid: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
        actor: actor,
        clippingFilter,
        representationUID,
    });
    viewport.resetCamera();
    viewport.getRenderer().resetCameraClippingRange();
    viewport.render();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addOrUpdateSurfaceToElement);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/index.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   surfaceDisplay: () => (/* reexport safe */ _surfaceDisplay__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _surfaceDisplay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./surfaceDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function removeSurfaceFromElement(element, segmentationId) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    const actorEntries = viewport.getActors();
    const filteredSurfaceActors = actorEntries.filter((actor) => actor.representationUID &&
        typeof actor.representationUID === 'string' &&
        actor.representationUID.startsWith(segmentationId));
    viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (removeSurfaceFromElement);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeRepresentation: () => (/* binding */ removeRepresentation),
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./removeSurfaceFromElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js");
/* harmony import */ var _addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./addOrUpdateSurfaceToElement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../stateManagement/segmentation/getColorLUT */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/config.js");
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utilities/segmentation/computeAndAddRepresentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js");
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js");









function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__["default"])(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId, type } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__.getSegmentation)(segmentationId);
    if (!segmentation) {
        return;
    }
    let SurfaceData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Surface];
    if (!SurfaceData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_6__.getPolySeg)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Surface)) {
        const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_6__.getPolySeg)();
        SurfaceData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_7__.computeAndAddRepresentation)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"].Surface, () => polySeg.computeSurfaceData(segmentationId, { viewport }), () => polySeg.updateSurfaceData(segmentationId, { viewport }));
        if (!SurfaceData) {
            throw new Error(`No Surface data found for segmentationId ${segmentationId} even we tried to compute it`);
        }
    }
    else if (!SurfaceData && !(0,_config__WEBPACK_IMPORTED_MODULE_6__.getPolySeg)()) {
        console.debug(`No surface data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to surface. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!SurfaceData) {
        console.warn(`No Surface data found for segmentationId ${segmentationId}. Skipping render.`);
        return;
    }
    const { geometryIds } = SurfaceData;
    if (!geometryIds?.size) {
        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);
    }
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__.getColorLUT)(colorLUTIndex);
    const surfaces = [];
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        if (!geometry?.data) {
            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);
            return;
        }
        const { segmentIndex } = geometry.data;
        const hiddenSegments = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_8__.internalGetHiddenSegmentIndices)(viewport.id, {
            segmentationId,
            type,
        });
        const isHidden = hiddenSegments.has(segmentIndex);
        const surface = geometry.data;
        const color = colorLUT[segmentIndex];
        surface.color = color.slice(0, 3);
        surface.visible = !isHidden;
        surfaces.push(surface);
        (0,_addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__["default"])(viewport.element, surface, segmentationId);
    });
    viewport.render();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategies/fillSphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js");
/* harmony import */ var _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./strategies/eraseSphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js");
/* harmony import */ var _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./strategies/fillCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js");
/* harmony import */ var _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./strategies/eraseCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LabelmapBaseTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js");
/* harmony import */ var _strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./strategies/utils/getStrategyData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js");












class BrushTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__.fillInsideCircle,
                ERASE_INSIDE_CIRCLE: _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__.eraseInsideCircle,
                FILL_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__.fillInsideSphere,
                ERASE_INSIDE_SPHERE: _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__.eraseInsideSphere,
                THRESHOLD_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__.thresholdInsideCircle,
                THRESHOLD_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__.thresholdInsideSphere,
                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__.thresholdInsideSphereIsland,
            },
            defaultStrategy: 'FILL_INSIDE_CIRCLE',
            activeStrategy: 'FILL_INSIDE_CIRCLE',
            brushSize: 25,
            useCenterSegmentIndex: false,
            preview: {
                enabled: false,
                previewColors: {
                    0: [255, 255, 255, 128],
                },
                previewTimeMs: 250,
                previewMoveDistance: 8,
                dragMoveDistance: 4,
                dragTimeMs: 500,
            },
            actions: {
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.AcceptPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.AcceptPreview,
                    bindings: [
                        {
                            key: 'Enter',
                        },
                    ],
                },
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview,
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate,
                    bindings: [
                        {
                            key: 'i',
                        },
                    ],
                    configuration: {
                        useBallStructuringElement: true,
                        noUseDistanceTransform: true,
                        noUseExtrapolation: true,
                    },
                },
                interpolateExtrapolation: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate,
                    bindings: [
                        {
                            key: 'e',
                        },
                    ],
                    configuration: {},
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.onSetToolPassive = (evt) => {
            this.disableCursor();
        };
        this.onSetToolEnabled = () => {
            this.disableCursor();
        };
        this.onSetToolDisabled = (evt) => {
            this.disableCursor();
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this._editData = this.createEditData(element);
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.hideElementCursor)(element);
            evt.preventDefault();
            this._previewData.isDrag = false;
            this._previewData.timerStart = Date.now();
            const hoverData = this._hoverData || this.createHoverData(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(hoverData.viewportIdsToRender);
            const operationData = this.getOperationData(element);
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.OnInteractionStart);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === _enums__WEBPACK_IMPORTED_MODULE_2__.ToolModes.Active) {
                this.updateCursor(evt);
                if (!this.configuration.preview.enabled) {
                    return;
                }
                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;
                const { currentPoints, element } = evt.detail;
                const { canvas } = currentPoints;
                const { startPoint, timer, timerStart, isDrag } = this._previewData;
                if (isDrag) {
                    return;
                }
                const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec2.distance(canvas, startPoint);
                const time = Date.now() - timerStart;
                if (delta > previewMoveDistance ||
                    (time > previewTimeMs && delta > dragMoveDistance)) {
                    if (timer) {
                        window.clearTimeout(timer);
                        this._previewData.timer = null;
                    }
                    if (!isDrag) {
                        this.rejectPreview(element);
                    }
                }
                if (!this._previewData.timer) {
                    const timer = window.setTimeout(this.previewCallback, 250);
                    Object.assign(this._previewData, {
                        timerStart: Date.now(),
                        timer,
                        startPoint: canvas,
                        element,
                    });
                }
            }
        };
        this.previewCallback = () => {
            if (this._previewData.isDrag) {
                this._previewData.timer = null;
                return;
            }
            this._previewData.timer = null;
            const operationData = this.getOperationData(this._previewData.element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._previewData.element);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            const activeStrategy = this.configuration.activeStrategy;
            const strategyData = (0,_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_11__.getStrategyData)({
                operationData,
                viewport,
                strategy: activeStrategy,
            });
            if (!operationData) {
                return;
            }
            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);
            this._previewData.preview = this.applyActiveStrategyCallback((0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._previewData.element), {
                ...operationData,
                ...strategyData,
                memo,
            }, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Preview);
        };
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.updateCursor(evt);
            const { viewportIdsToRender } = this._hoverData;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(viewportIdsToRender);
            const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec2.distance(currentPoints.canvas, this._previewData.startPoint);
            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;
            if (!this._previewData.isDrag &&
                Date.now() - this._previewData.timerStart < dragTimeMs &&
                delta < dragMoveDistance) {
                return;
            }
            if (this._previewData.timer) {
                window.clearTimeout(this._previewData.timer);
                this._previewData.timer = null;
            }
            this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));
            this._previewData.element = element;
            this._previewData.timerStart = Date.now() + dragTimeMs;
            this._previewData.isDrag = true;
            this._previewData.startPoint = currentPoints.canvas;
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = this.getOperationData(element);
            if (!this._previewData.preview && !this._previewData.isDrag) {
                this.applyActiveStrategy(enabledElement, operationData);
            }
            this.doneEditMemo();
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.resetElementCursor)(element);
            this.updateCursor(evt);
            this._editData = null;
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.OnInteractionEnd);
            if (!this._previewData.isDrag) {
                this.acceptPreview(element);
            }
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    disableCursor() {
        this._hoverData = undefined;
        this.rejectPreview();
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const { element } = eventData;
        const { currentPoints } = eventData;
        const centerCanvas = currentPoints.canvas;
        this._hoverData = this.createHoverData(element, centerCanvas);
        this._calculateCursor(element, centerCanvas);
        if (!this._hoverData) {
            return;
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__["default"])(this._hoverData.viewportIdsToRender);
    }
    _calculateCursor(element, centerCanvas) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvasToWorld } = viewport;
        const camera = viewport.getCamera();
        const { brushSize } = this.configuration;
        const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
        const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(viewRight, viewUp, viewPlaneNormal);
        const centerCursorInWorld = canvasToWorld([
            centerCanvas[0],
            centerCanvas[1],
        ]);
        const bottomCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        const topCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        const leftCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        const rightCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        for (let i = 0; i <= 2; i++) {
            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;
            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;
            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;
            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;
        }
        if (!this._hoverData) {
            return;
        }
        const { brushCursor } = this._hoverData;
        const { data } = brushCursor;
        if (data.handles === undefined) {
            data.handles = {};
        }
        data.handles.points = [
            bottomCursorInWorld,
            topCursorInWorld,
            leftCursorInWorld,
            rightCursorInWorld,
        ];
        const activeStrategy = this.configuration.activeStrategy;
        const strategy = this.configuration.strategies[activeStrategy];
        if (typeof strategy?.computeInnerCircleRadius === 'function') {
            strategy.computeInnerCircleRadius({
                configuration: this.configuration,
                viewport,
            });
        }
        data.invalidated = false;
    }
    getStatistics(element, segmentIndices) {
        if (!element) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.GetStatistics, segmentIndices);
        return stats;
    }
    rejectPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        this.doneEditMemo();
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview);
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    acceptPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        super.acceptPreview(element);
    }
    interpolate(element, config) {
        if (!element) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate, config.configuration);
        this._previewData.isDrag = true;
    }
    invalidateBrushCursor() {
        if (this._hoverData === undefined) {
            return;
        }
        const { data } = this._hoverData.brushCursor;
        const { viewport } = this._hoverData;
        data.invalidated = true;
        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};
        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this._hoverData) {
            return;
        }
        const { viewport } = enabledElement;
        const viewportIdsToRender = this._hoverData.viewportIdsToRender;
        if (!viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const brushCursor = this._hoverData.brushCursor;
        if (brushCursor.data.invalidated === true) {
            const { centerCanvas } = this._hoverData;
            const { element } = viewport;
            this._calculateCursor(element, centerCanvas);
        }
        const toolMetadata = brushCursor.metadata;
        if (!toolMetadata) {
            return;
        }
        const annotationUID = toolMetadata.brushCursorUID;
        const data = brushCursor.data;
        const { points } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const bottom = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const center = [
            Math.floor((bottom[0] + top[0]) / 2),
            Math.floor((bottom[1] + top[1]) / 2),
        ];
        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return;
        }
        const circleUID = '0';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
            color,
            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,
        });
        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {
            dynamicRadiusInCanvas: 0,
        };
        if (dynamicRadiusInCanvas) {
            const circleUID1 = '1';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {
                color,
            });
        }
    }
}
BrushTool.toolName = 'Brush';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LabelmapBaseTool)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js");
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _utilities_annotationHydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/annotationHydration */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js");
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js");
/* harmony import */ var _stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/segmentation/config/segmentationColor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities_segmentation_createLabelmapMemo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/segmentation/createLabelmapMemo */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/planar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js");
/* harmony import */ var _utilities_math_polyline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/math/polyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _strategies__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./strategies */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js");

















class LabelmapBaseTool extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseTool {
    static { this.previewData = {
        preview: null,
        element: null,
        timerStart: 0,
        timer: null,
        startPoint: [NaN, NaN],
        isDrag: false,
    }; }
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
        this.memoMap = new Map();
        this.acceptedMemoIds = new Map();
        this.centerSegmentIndexInfo = {
            segmentIndex: null,
            hasSegmentIndex: false,
            hasPreviewIndex: false,
            changedIndices: [],
        };
    }
    _historyRedoHandler(evt) {
        const { id, operationType } = evt.detail;
        if (operationType !== 'labelmap') {
            return;
        }
        if (this.acceptedMemoIds.has(id)) {
            this._hoverData = null;
            const memoData = this.acceptedMemoIds.get(id);
            const element = memoData?.element;
            const operationData = this.getOperationData(element);
            operationData.segmentIndex = memoData?.segmentIndex;
            if (element) {
                this.applyActiveStrategyCallback((0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element), operationData, _enums__WEBPACK_IMPORTED_MODULE_10__.StrategyCallbacks.AcceptPreview);
            }
        }
        this._previewData.isDrag = true;
    }
    get _previewData() {
        return LabelmapBaseTool.previewData;
    }
    createMemo(segmentationId, segmentationVoxelManager) {
        const voxelManagerId = segmentationVoxelManager.id;
        if (this.memo &&
            this.memo.segmentationVoxelManager === segmentationVoxelManager) {
            return this.memo;
        }
        let memo = this.memoMap.get(voxelManagerId);
        if (!memo) {
            memo = _utilities_segmentation_createLabelmapMemo__WEBPACK_IMPORTED_MODULE_11__.createLabelmapMemo(segmentationId, segmentationVoxelManager);
            this.memoMap.set(voxelManagerId, memo);
        }
        else {
            if (memo.redoVoxelManager) {
                memo = _utilities_segmentation_createLabelmapMemo__WEBPACK_IMPORTED_MODULE_11__.createLabelmapMemo(segmentationId, segmentationVoxelManager);
                this.memoMap.set(voxelManagerId, memo);
            }
        }
        this.memo = memo;
        return memo;
    }
    createEditData(element) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const activeSegmentation = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_3__.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            const event = new CustomEvent(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ERROR_EVENT, {
                detail: {
                    type: 'Segmentation',
                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',
                },
                cancelable: true,
            });
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.dispatchEvent(event);
            return null;
        }
        const { segmentationId } = activeSegmentation;
        const segmentsLocked = (0,_stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_4__.getLockedSegmentIndices)(segmentationId);
        const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_5__.getSegmentation)(segmentationId);
        const editData = this.getEditData({
            viewport,
            representationData,
            segmentsLocked,
            segmentationId,
        });
        return editData;
    }
    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const { volumeId } = representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__["default"].Labelmap];
            const actors = viewport.getActors();
            const isStackViewport = viewport instanceof _utilities_annotationHydration__WEBPACK_IMPORTED_MODULE_6__.getClosestImageIdForStackViewport;
            if (isStackViewport) {
                const event = new CustomEvent(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ERROR_EVENT, {
                    detail: {
                        type: 'Segmentation',
                        message: 'Cannot perform brush operation on the selected viewport',
                    },
                    cancelable: true,
                });
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.dispatchEvent(event);
                return null;
            }
            const volumes = actors.map((actorEntry) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(actorEntry.referencedId));
            const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            const referencedVolumeIdToThreshold = volumes.find((volume) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;
            return {
                volumeId,
                referencedVolumeId: this.configuration.threshold?.volumeId ??
                    referencedVolumeIdToThreshold,
                segmentsLocked,
            };
        }
        else {
            const segmentationImageId = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_7__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
            if (!segmentationImageId) {
                return;
            }
            return {
                imageId: segmentationImageId,
                segmentsLocked,
            };
        }
    }
    createHoverData(element, centerCanvas) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const viewportIdsToRender = [viewport.id];
        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};
        const brushCursor = {
            metadata: {
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                referencedImageId: '',
                toolName: this.getToolName(),
                segmentColor,
            },
            data: {},
        };
        return {
            brushCursor,
            centerCanvas,
            segmentIndex,
            viewport,
            segmentationId,
            segmentColor,
            viewportIdsToRender,
        };
    }
    getActiveSegmentationData(viewport) {
        const viewportId = viewport.id;
        const activeRepresentation = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_3__.getActiveSegmentation)(viewportId);
        if (!activeRepresentation) {
            return;
        }
        const { segmentationId } = activeRepresentation;
        const segmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_9__.getActiveSegmentIndex)(segmentationId);
        if (!segmentIndex) {
            return;
        }
        const segmentColor = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_8__.getSegmentIndexColor)(viewportId, segmentationId, segmentIndex);
        return {
            segmentIndex,
            segmentationId,
            segmentColor,
        };
    }
    getOperationData(element) {
        const editData = this._editData || this.createEditData(element);
        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);
        const { data, metadata = {} } = brushCursor || {};
        const { viewPlaneNormal, viewUp } = metadata;
        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const segmentColor = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_8__.getSegmentIndexColor)(viewport.id, segmentationId, segmentIndex);
        if (!configColor && !segmentColor) {
            return;
        }
        let previewColor = null, previewSegmentIndex = null;
        if (this.configuration.preview.enabled) {
            previewColor = configColor || lightenColor(...segmentColor);
            previewSegmentIndex = 255;
        }
        const operationData = {
            ...editData,
            points: data?.handles?.points,
            segmentIndex,
            viewPlaneNormal,
            previewOnHover: !this._previewData.isDrag,
            toolGroupId: this.toolGroupId,
            segmentationId,
            viewUp,
            centerSegmentIndexInfo: this.centerSegmentIndexInfo,
            activeStrategy: this.configuration.activeStrategy,
            configuration: this.configuration,
            previewColor,
            previewSegmentIndex,
            createMemo: this.createMemo.bind(this),
        };
        return operationData;
    }
    addPreview(element = this._previewData.element, options) {
        const { _previewData } = this;
        const acceptReject = options?.acceptReject;
        if (acceptReject === true) {
            this.acceptPreview(element);
        }
        else if (acceptReject === false) {
            this.rejectPreview(element);
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_10__.StrategyCallbacks.AddPreview);
        _previewData.isDrag = true;
        return results;
    }
    rejectPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        this.doneEditMemo();
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_10__.StrategyCallbacks.RejectPreview);
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    acceptPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        const operationData = this.getOperationData(element);
        if (this.memo && this.memo.id) {
            this.acceptedMemoIds.set(this.memo.id, {
                element,
                segmentIndex: operationData.segmentIndex,
            });
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_10__.StrategyCallbacks.AcceptPreview);
        this.doneEditMemo();
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    static viewportContoursToLabelmap(viewport, options) {
        const removeContours = options?.removeContours ?? true;
        const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_12__.getAllAnnotations)();
        const viewAnnotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_13__.filterAnnotationsForDisplay)(viewport, annotations);
        if (!viewAnnotations?.length) {
            return;
        }
        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);
        if (!contourAnnotations.length) {
            return;
        }
        const brushInstance = new LabelmapBaseTool({}, {
            configuration: {
                strategies: {
                    FILL_INSIDE_CIRCLE: _strategies__WEBPACK_IMPORTED_MODULE_16__.fillInsideCircle,
                },
                activeStrategy: 'FILL_INSIDE_CIRCLE',
            },
        });
        const preview = brushInstance.addPreview(viewport.element);
        const { memo, segmentationId } = preview;
        const previewVoxels = memo?.voxelManager;
        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;
        const { dimensions } = previewVoxels;
        const imageData = viewport
            .getDefaultActor()
            .actor.getMapper()
            .getInputData();
        for (const annotation of contourAnnotations) {
            const boundsIJK = [
                [Infinity, -Infinity],
                [Infinity, -Infinity],
                [Infinity, -Infinity],
            ];
            const { polyline } = annotation.data.contour;
            for (const point of polyline) {
                const indexPoint = imageData.worldToIndex(point);
                indexPoint.forEach((v, idx) => {
                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);
                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);
                });
            }
            boundsIJK.forEach((bound, idx) => {
                bound[0] = Math.round(Math.max(0, bound[0]));
                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));
            });
            const activeIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_9__.getActiveSegmentIndex)(segmentationId);
            const startPoint = annotation.data.handles?.[0] || polyline[0];
            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);
            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;
            let hasZeroIndex = false;
            let hasPositiveIndex = false;
            for (const polyPoint of polyline) {
                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);
                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);
                if (polyValue === startValue) {
                    hasZeroIndex = true;
                }
                else if (polyValue >= 0) {
                    hasPositiveIndex = true;
                }
            }
            const hasBoth = hasZeroIndex && hasPositiveIndex;
            const segmentIndex = hasBoth
                ? startValue
                : startValue === 0
                    ? activeIndex
                    : 0;
            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {
                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {
                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {
                        const worldPoint = imageData.indexToWorld([i, j, k]);
                        const isContained = (0,_utilities_math_polyline__WEBPACK_IMPORTED_MODULE_14__.isPointInsidePolyline3D)(worldPoint, polyline);
                        if (isContained) {
                            previewVoxels.setAtIJK(i, j, k, segmentIndex);
                        }
                    }
                }
            }
            if (removeContours) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_12__.removeAnnotation)(annotation.annotationUID);
            }
        }
        const slices = previewVoxels.getArrayOfModifiedSlices();
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_15__.triggerSegmentationDataModified)(segmentationId, slices);
    }
}
function lightenColor(r, g, b, a, factor = 0.4) {
    return [
        Math.round(r + (255 - r) * factor),
        Math.round(g + (255 - g) * factor),
        Math.round(b + (255 - b) * factor),
        a,
    ];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/throttle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js");
/* harmony import */ var _utilities_debounce__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/debounce */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js");
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/drawing */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js");
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/planar/getWorldWidthAndHeightFromCorners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../annotation/RectangleROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js");
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/viewport/isViewportPreScaled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js");
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../utilities/math/basic */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js");
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../utilities/planar */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js");
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utilities/getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");




















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class RectangleROIStartEndThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_15__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            storePointData: false,
            numSlicesToPropagate: 10,
            calculatePointsInsideVolume: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_17__.BasicStatsCalculator,
            showTextBox: false,
            throttleTimeout: 100,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                    spacingInNormal,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        projectionPointsImageIds: [referencedImageId],
                        statistics: [],
                    },
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_12__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_13__["default"])(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_12__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_13__["default"])(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__.triggerAnnotationCompleted)(annotation);
            }
            else {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__.triggerAnnotationModified)(annotation, element);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_18__.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data, metadata } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let startCoord = startCoordinate;
                let endCoord = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);
                    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal);
                    data.handles.points.forEach((point) => {
                        point[indexOfDirection] = startCoord;
                    });
                    data.startCoordinate = startCoord;
                }
                if (Array.isArray(endCoordinate)) {
                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);
                    data.endCoordinate = endCoord;
                    data.endCoordinate = endCoord;
                }
                const roundedStartCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(startCoord);
                const roundedEndCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(endCoord);
                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(coord);
                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||
                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {
                    continue;
                }
                if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, enabledElement);
                }
                let firstOrLastSlice = false;
                if (roundedCoord === roundedStartCoord ||
                    roundedCoord === roundedEndCoord) {
                    firstOrLastSlice = true;
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    firstOrLastSlice) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineDashToUse = lineDash;
                if (!firstOrLastSlice) {
                    lineDashToUse = 2;
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth,
                });
                renderStatus = true;
                if (this.configuration.showTextBox) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data, { metadata });
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    if (!data.handles.textBox.hasMoved) {
                        const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_9__.getTextBoxCoordsCanvas)(canvasCoordinates);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        if (this.configuration.calculatePointsInsideVolume) {
            this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_7__["default"])(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });
        }
        else {
            this._throttledCalculateCachedStats = (0,_utilities_debounce__WEBPACK_IMPORTED_MODULE_8__["default"])(this._calculateCachedStatsTool, this.configuration.throttleTimeout);
        }
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { imageData } = imageVolume;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const startIJK = transformWorldToIndex(imageData, points[0]);
        const endIJK = transformWorldToIndex(imageData, points[0]);
        const startWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create();
        imageData.indexToWorldVec3(startIJK, startWorld);
        const endWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create();
        imageData.indexToWorldVec3(endIJK, endWorld);
        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
            startWorld[2] = startCoordinate;
            endWorld[2] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
            startWorld[0] = startCoordinate;
            endWorld[0] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
            startWorld[1] = startCoordinate;
            endWorld[1] = endCoordinate;
        }
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.distance(startWorld, endWorld);
        const newProjectionPoints = [];
        for (let dist = 0; dist < distance; dist += spacingInNormal) {
            newProjectionPoints.push(points.map((point) => {
                const newPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[3];
        const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_10__["default"])(viewPlaneNormal, viewUp, worldPos1, worldPos2);
        const measureInfo = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__.getCalibratedLengthUnitsAndScale)(image, data.habdles);
        const area = Math.abs(worldWidth * worldHeight) /
            (measureInfo.scale * measureInfo.scale);
        const modalityUnitOptions = {
            isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_16__.isViewportPreScaled)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_19__.getPixelValueUnits)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const projectionPoint = projectionPoints[i][0];
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                this.isHandleOutsideImage = false;
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
        annotation.invalidated = false;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__.triggerAnnotationModified)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, viewPlaneNormal) {
        const startPos = worldPos;
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const endPos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function defaultGetTextLines(data, _context = {}) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
RectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROIStartEndThresholdTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationLocking */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js");
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../drawingSvg */ "../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js");
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/viewportFilters */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js");
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../cursors/elementCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js");
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js");
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../stateManagement/annotation/helpers/state */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js");
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../annotation/RectangleROITool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js");










class RectangleROIThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__["default"] {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const targetId = this.getTargetId(viewport);
            let referencedImageId, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                referencedImageId = targetId.split('imageId:')[1];
            }
            else {
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: null,
                            worldBoundingBox: null,
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    segmentationId: null,
                },
            };
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__["default"])(viewportIdsToRender);
            return annotation;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element);
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                });
                renderStatus = true;
            }
            return renderStatus;
        };
    }
}
RectangleROIThresholdTool.toolName = 'RectangleROIThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROIThresholdTool);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BrushStrategy)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compositions */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js");
/* harmony import */ var _utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/getStrategyData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");





class BrushStrategy {
    static { this.COMPOSITIONS = _compositions__WEBPACK_IMPORTED_MODULE_2__["default"]; }
    static { this.childFunctions = {
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.OnInteractionStart]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.OnInteractionStart, _enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.OnInteractionEnd]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.OnInteractionEnd, _enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Fill]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Fill),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.CreateIsInThreshold),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Interpolate]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Interpolate, _enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.AcceptPreview]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.AcceptPreview, _enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.RejectPreview]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.RejectPreview, _enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.INTERNAL_setValue),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Preview]: addSingletonMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Preview, false),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.ComputeInnerCircleRadius),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.EnsureImageVolumeFor3DManipulation),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.AddPreview]: addListMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.AddPreview),
        [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.GetStatistics]: addSingletonMethod(_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.GetStatistics),
        compositions: null,
    }; }
    constructor(name, ...initializers) {
        this._initialize = [];
        this._fill = [];
        this._onInteractionStart = [];
        this.fill = (enabledElement, operationData) => {
            const initializedData = this.initialize(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Fill);
            if (!initializedData) {
                return;
            }
            this._fill.forEach((func) => func(initializedData));
            const { segmentationVoxelManager, segmentIndex } = initializedData;
            (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);
            return initializedData;
        };
        this.onInteractionStart = (enabledElement, operationData) => {
            const initializedData = this.initialize(enabledElement, operationData);
            if (!initializedData) {
                return;
            }
            this._onInteractionStart.forEach((func) => func.call(this, initializedData));
        };
        this.addPreview = (enabledElement, operationData) => {
            const initializedData = this.initialize(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.AddPreview);
            if (!initializedData) {
                return;
            }
            return initializedData;
        };
        this.configurationName = name;
        this.compositions = initializers;
        initializers.forEach((initializer) => {
            const result = typeof initializer === 'function' ? initializer() : initializer;
            if (!result) {
                return;
            }
            for (const key in result) {
                if (!BrushStrategy.childFunctions[key]) {
                    throw new Error(`Didn't find ${key} as a brush strategy`);
                }
                BrushStrategy.childFunctions[key](this, result[key]);
            }
        });
        this.strategyFunction = (enabledElement, operationData) => {
            return this.fill(enabledElement, operationData);
        };
        for (const key of Object.keys(BrushStrategy.childFunctions)) {
            this.strategyFunction[key] = this[key];
        }
    }
    initialize(enabledElement, operationData, operationName) {
        const { viewport } = enabledElement;
        const data = (0,_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__.getStrategyData)({ operationData, viewport, strategy: this });
        if (!data) {
            return null;
        }
        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;
        const memo = operationData.createMemo(operationData.segmentationId, segmentationVoxelManager);
        const initializedData = {
            operationName,
            ...operationData,
            segmentIndex: operationData.segmentIndex,
            enabledElement,
            imageVoxelManager,
            segmentationVoxelManager,
            segmentationImageData,
            viewport,
            centerWorld: null,
            isInObject: null,
            isInObjectBoundsIJK: null,
            brushStrategy: this,
            memo,
        };
        this._initialize.forEach((func) => func(initializedData));
        return initializedData;
    }
}
function addListMethod(name, createInitialized) {
    const listName = `_${name}`;
    return (brushStrategy, func) => {
        brushStrategy[listName] ||= [];
        brushStrategy[listName].push(func);
        brushStrategy[name] ||= createInitialized
            ? (enabledElement, operationData, ...args) => {
                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);
                let returnValue;
                brushStrategy[listName].forEach((func) => {
                    const value = func.call(brushStrategy, initializedData, ...args);
                    returnValue ||= value;
                });
                return returnValue;
            }
            : (operationData, ...args) => {
                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData, ...args));
            };
    };
}
function addSingletonMethod(name, isInitialized = true) {
    return (brushStrategy, func) => {
        if (brushStrategy[name]) {
            throw new Error(`The singleton method ${name} already exists`);
        }
        brushStrategy[name] = isInitialized
            ? func
            : (enabledElement, operationData, ...args) => {
                operationData.enabledElement = enabledElement;
                return func.call(brushStrategy, operationData, ...args);
            };
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__["default"].OnInteractionStart]: (operationData) => {
        const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, viewPlaneNormal, segmentationImageData, configuration, } = operationData;
        if (!configuration?.useCenterSegmentIndex) {
            return;
        }
        let hasSegmentIndex = false;
        let hasPreviewIndex = false;
        const nestedBounds = [
            ...segmentationVoxelManager.getBoundsIJK(),
        ];
        if (Math.abs(viewPlaneNormal[0]) > 0.8) {
            nestedBounds[0] = [centerIJK[0], centerIJK[0]];
        }
        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {
            nestedBounds[1] = [centerIJK[1], centerIJK[1]];
        }
        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {
            nestedBounds[2] = [centerIJK[2], centerIJK[2]];
        }
        const callback = ({ value }) => {
            hasSegmentIndex ||= value === segmentIndex;
            hasPreviewIndex ||= value === previewSegmentIndex;
        };
        segmentationVoxelManager.forEach(callback, {
            imageData: segmentationImageData,
            isInObject: operationData.isInObject,
            boundsIJK: nestedBounds,
        });
        if (!hasSegmentIndex && !hasPreviewIndex) {
            operationData.centerSegmentIndexInfo.segmentIndex = null;
            return;
        }
        const existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);
        operationData.centerSegmentIndexInfo.segmentIndex = existingValue;
        operationData.centerSegmentIndexInfo.hasSegmentIndex = hasSegmentIndex;
        operationData.centerSegmentIndexInfo.hasPreviewIndex = hasPreviewIndex;
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js":
/*!**************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].Initialize]: (operationData) => {
        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;
        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {
            return;
        }
        if (operationName === _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].RejectPreview ||
            operationName === _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].OnInteractionEnd) {
            return;
        }
        const boundsIJK = segmentationVoxelManager.getBoundsIJK();
        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;
        const useDelta = oldThreshold ? 0 : dynamicRadius;
        const { viewPlaneNormal } = viewport.getCamera();
        const nestedBounds = boundsIJK.map((ijk, idx) => {
            const [min, max] = ijk;
            return [
                Math.max(min, centerIJK[idx] - useDelta),
                Math.min(max, centerIJK[idx] + useDelta),
            ];
        });
        if (Math.abs(viewPlaneNormal[0]) > 0.8) {
            nestedBounds[0] = [centerIJK[0], centerIJK[0]];
        }
        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {
            nestedBounds[1] = [centerIJK[1], centerIJK[1]];
        }
        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {
            nestedBounds[2] = [centerIJK[2], centerIJK[2]];
        }
        const threshold = oldThreshold || [Infinity, -Infinity];
        const useDeltaSqr = useDelta * useDelta;
        const callback = ({ value, pointIJK }) => {
            const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sqrDist(centerIJK, pointIJK);
            if (distance > useDeltaSqr) {
                return;
            }
            const gray = Array.isArray(value) ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.len(value) : value;
            threshold[0] = Math.min(gray, threshold[0]);
            threshold[1] = Math.max(gray, threshold[1]);
        };
        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });
        configuration.threshold.range = threshold;
    },
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].OnInteractionStart]: (operationData) => {
        const { configuration } = operationData;
        if (!configuration?.threshold?.isDynamic) {
            return;
        }
        configuration.threshold.range = null;
    },
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].ComputeInnerCircleRadius]: (operationData) => {
        const { configuration, viewport } = operationData;
        const { dynamicRadius = 0, isDynamic } = configuration.threshold;
        if (!isDynamic) {
            configuration.threshold.dynamicRadiusInCanvas = 0;
            return;
        }
        if (dynamicRadius === 0) {
            return;
        }
        const imageData = viewport.getImageData();
        if (!imageData) {
            return;
        }
        const { spacing } = imageData;
        const centerCanvas = [
            viewport.element.clientWidth / 2,
            viewport.element.clientHeight / 2,
        ];
        const radiusInWorld = dynamicRadius * spacing[0];
        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);
        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);
        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);
        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);
        if (!configuration.threshold.dynamicRadiusInCanvas) {
            configuration.threshold.dynamicRadiusInCanvas = 0;
        }
        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureImageVolume.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureImageVolume.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _utilities_segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utilities/segmentation/getOrCreateImageVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].EnsureImageVolumeFor3DManipulation]: (data) => {
        const { operationData, viewport } = data;
        let referencedImageIds;
        if (viewport) {
            referencedImageIds = viewport.getImageIds();
            const isValidVolumeForSphere = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
            if (!isValidVolumeForSphere) {
                throw new Error('Volume is not reconstructable for sphere manipulation');
            }
        }
        else {
            const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(operationData.segmentationId);
            const imageIds = segmentation.representationData
                .Labelmap.imageIds;
            referencedImageIds = imageIds.map((imageId) => {
                const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId);
                return image.referencedImageId;
            });
        }
        const imageVolume = (0,_utilities_segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_3__["default"])(referencedImageIds);
        if (!imageVolume) {
            throw new Error('Failed to create or get image volume');
        }
        operationData.imageVoxelManager = imageVolume.voxelManager;
        operationData.imageData = imageVolume.imageData;
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureSegmentationVolume.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureSegmentationVolume.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _utilities_segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utilities/segmentation/getOrCreateSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].EnsureSegmentationVolumeFor3DManipulation]: (data) => {
        const { operationData, viewport } = data;
        const { segmentationId, imageIds: segImageIds } = operationData;
        const referencedImageIds = viewport
            ? viewport.getImageIds()
            : segImageIds.map((imageId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId).referencedImageId);
        const isValidVolumeForSphere = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
        if (!isValidVolumeForSphere) {
            throw new Error('Volume is not reconstructable for sphere manipulation');
        }
        const segVolume = (0,_utilities_segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__["default"])(segmentationId);
        if (!segVolume) {
            return;
        }
        operationData.segmentationVoxelManager = segVolume.voxelManager;
        operationData.segmentationImageData = segVolume.imageData;
        return;
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__["default"].Initialize]: (operationData) => {
        operationData.segmentIndex = 0;
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _determineSegmentIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./determineSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js");
/* harmony import */ var _dynamicThreshold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dynamicThreshold */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js");
/* harmony import */ var _erase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./erase */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js");
/* harmony import */ var _islandRemovalComposition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./islandRemovalComposition */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js");
/* harmony import */ var _preview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./preview */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js");
/* harmony import */ var _regionFill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./regionFill */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js");
/* harmony import */ var _setValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./setValue */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js");
/* harmony import */ var _threshold__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js");
/* harmony import */ var _labelmapStatistics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./labelmapStatistics */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js");
/* harmony import */ var _ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ensureSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureSegmentationVolume.js");
/* harmony import */ var _ensureImageVolume__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ensureImageVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureImageVolume.js");











/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    determineSegmentIndex: _determineSegmentIndex__WEBPACK_IMPORTED_MODULE_0__["default"],
    dynamicThreshold: _dynamicThreshold__WEBPACK_IMPORTED_MODULE_1__["default"],
    erase: _erase__WEBPACK_IMPORTED_MODULE_2__["default"],
    islandRemoval: _islandRemovalComposition__WEBPACK_IMPORTED_MODULE_3__["default"],
    preview: _preview__WEBPACK_IMPORTED_MODULE_4__["default"],
    regionFill: _regionFill__WEBPACK_IMPORTED_MODULE_5__["default"],
    setValue: _setValue__WEBPACK_IMPORTED_MODULE_6__["default"],
    threshold: _threshold__WEBPACK_IMPORTED_MODULE_7__["default"],
    labelmapStatistics: _labelmapStatistics__WEBPACK_IMPORTED_MODULE_8__["default"],
    ensureSegmentationVolumeFor3DManipulation: _ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_9__["default"],
    ensureImageVolumeFor3DManipulation: _ensureImageVolume__WEBPACK_IMPORTED_MODULE_10__["default"],
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js":
/*!**********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _utilities_segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utilities/segmentation/islandRemoval */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].OnInteractionEnd]: (operationData) => {
        const { previewSegmentIndex, segmentIndex, viewport, segmentationVoxelManager, activeStrategy, memo, } = operationData;
        if (activeStrategy !== 'THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL' ||
            segmentIndex === null) {
            return;
        }
        const islandRemoval = new _utilities_segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_2__["default"]();
        const voxelManager = memo?.voxelManager || segmentationVoxelManager;
        if (!islandRemoval.initialize(viewport, voxelManager, {
            previewSegmentIndex,
            segmentIndex,
        })) {
            return;
        }
        islandRemoval.floodFillSegmentIsland();
        islandRemoval.removeExternalIslands();
        islandRemoval.removeInternalIslands();
        const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();
        if (!arrayOfSlices) {
            return;
        }
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationDataModified)(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js":
/*!****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _utilities_segmentation_getStatistics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utilities/segmentation/getStatistics */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getStatistics.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__["default"].GetStatistics]: function (enabledElement, operationData, options) {
        const { indices } = options;
        const { segmentationId, viewport } = operationData;
        (0,_utilities_segmentation_getStatistics__WEBPACK_IMPORTED_MODULE_1__["default"])({
            segmentationId,
            segmentIndices: indices,
        });
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/events/triggerSegmentationDataModified */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js");
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/config/segmentationColor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js");
/* harmony import */ var _stateManagement_segmentation_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/getViewportIdsWithSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_2__["default"].Preview]: function (operationData) {
        const { previewSegmentIndex, configuration, enabledElement } = operationData;
        if (!previewSegmentIndex || !configuration) {
            return;
        }
        this.onInteractionStart?.(enabledElement, operationData);
        const preview = this.fill(enabledElement, operationData);
        if (preview) {
            this.onInteractionEnd?.(enabledElement, operationData);
        }
        return preview;
    },
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_2__["default"].Initialize]: (operationData) => {
        const { segmentIndex, previewColor, previewSegmentIndex } = operationData;
        if (previewSegmentIndex == null || segmentIndex == null) {
            return;
        }
        const viewportIds = (0,_stateManagement_segmentation_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithSegmentation)(operationData.segmentationId);
        viewportIds?.forEach((viewportId) => {
            (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_3__.setSegmentIndexColor)(viewportId, operationData.segmentationId, previewSegmentIndex, previewColor);
        });
    },
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_2__["default"].AcceptPreview]: (operationData) => {
        const { previewSegmentIndex, segmentationVoxelManager, memo, segmentIndex, centerSegmentIndexInfo, } = operationData || {};
        const { changedIndices } = centerSegmentIndexInfo || {};
        const labelmapMemo = memo;
        const callback = ({ index }) => {
            const oldValue = segmentationVoxelManager.getAtIndex(index);
            if (changedIndices?.length > 0) {
                if (changedIndices.includes(index)) {
                    labelmapMemo.voxelManager.setAtIndex(index, 0);
                }
            }
            else {
                if (oldValue === previewSegmentIndex) {
                    labelmapMemo.voxelManager.setAtIndex(index, segmentIndex);
                }
            }
        };
        segmentationVoxelManager.forEach(callback);
        (0,_stateManagement_segmentation_events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(operationData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);
        operationData.centerSegmentIndexInfo.changedIndices = [];
    },
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_2__["default"].RejectPreview]: (operationData) => {
        if (!operationData) {
            return;
        }
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.HistoryMemo.DefaultHistoryMemo.undoIf((memo) => {
            const labelmapMemo = memo;
            if (!labelmapMemo?.voxelManager) {
                return false;
            }
            const { segmentationVoxelManager } = labelmapMemo;
            let hasPreviewSegmentIndex = false;
            const callback = ({ value }) => {
                if (value === operationData.previewSegmentIndex) {
                    hasPreviewSegmentIndex = true;
                }
            };
            segmentationVoxelManager.forEach(callback);
            return hasPreviewSegmentIndex;
        });
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__["default"].Fill]: (operationData) => {
        const { segmentsLocked, segmentationImageData, segmentationVoxelManager, brushStrategy, centerIJK, } = operationData;
        const isWithinThreshold = brushStrategy.createIsInThreshold?.(operationData);
        const { setValue } = brushStrategy;
        const callback = isWithinThreshold
            ? (data) => {
                const { value, index } = data;
                if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {
                    return;
                }
                setValue(operationData, data);
            }
            : (data) => setValue(operationData, data);
        segmentationVoxelManager.forEach(callback, {
            imageData: segmentationImageData,
            isInObject: operationData.isInObject,
            boundsIJK: operationData.isInObjectBoundsIJK,
        });
        segmentationVoxelManager.addPoint(centerIJK);
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _utils_handleUseSegmentCenterIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/handleUseSegmentCenterIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_0__["default"].INTERNAL_setValue]: (operationData, { value, index }) => {
        const { segmentsLocked, previewSegmentIndex, memo, segmentationVoxelManager, centerSegmentIndexInfo, segmentIndex, } = operationData;
        const existingValue = segmentationVoxelManager.getAtIndex(index);
        if (segmentsLocked.includes(value)) {
            return;
        }
        if (!centerSegmentIndexInfo && existingValue === segmentIndex) {
            return;
        }
        if (centerSegmentIndexInfo?.segmentIndex !== 0 &&
            existingValue === segmentIndex) {
            return;
        }
        if (centerSegmentIndexInfo?.segmentIndex === null) {
            memo.voxelManager.setAtIndex(index, previewSegmentIndex ?? segmentIndex);
            return;
        }
        if (!previewSegmentIndex) {
            let useSegmentIndex = segmentIndex;
            if (centerSegmentIndexInfo) {
                useSegmentIndex = centerSegmentIndexInfo.segmentIndex;
            }
            memo.voxelManager.setAtIndex(index, useSegmentIndex);
            return;
        }
        (0,_utils_handleUseSegmentCenterIndex__WEBPACK_IMPORTED_MODULE_1__.handleUseSegmentCenterIndex)({
            operationData,
            existingValue,
            index,
        });
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__["default"].CreateIsInThreshold]: (operationData) => {
        const { imageVoxelManager, segmentIndex, configuration } = operationData;
        if (!configuration || !segmentIndex) {
            return;
        }
        return (index) => {
            const voxelValue = imageVoxelManager.getAtIndex(index);
            const gray = Array.isArray(voxelValue)
                ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.length(voxelValue)
                : voxelValue;
            const { threshold } = configuration || {};
            if (!threshold?.range?.length) {
                return true;
            }
            return threshold.range[0] <= gray && gray <= threshold.range[1];
        };
    },
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eraseInsideCircle: () => (/* binding */ eraseInsideCircle)
/* harmony export */ });
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrushStrategy */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js");
/* harmony import */ var _fillCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fillCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js");
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compositions */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js");



const ERASE_CIRCLE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_0__["default"]('EraseCircle', _compositions__WEBPACK_IMPORTED_MODULE_2__["default"].erase, ..._fillCircle__WEBPACK_IMPORTED_MODULE_1__.CIRCLE_STRATEGY.compositions);
const eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eraseInsideSphere: () => (/* binding */ eraseInsideSphere)
/* harmony export */ });
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrushStrategy */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js");
/* harmony import */ var _fillSphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fillSphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js");
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compositions */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js");



const ERASE_SPHERE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_0__["default"]('EraseSphere', _compositions__WEBPACK_IMPORTED_MODULE_2__["default"].erase, ..._fillSphere__WEBPACK_IMPORTED_MODULE_1__.SPHERE_STRATEGY.compositions);
const eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CIRCLE_STRATEGY: () => (/* binding */ CIRCLE_STRATEGY),
/* harmony export */   CIRCLE_THRESHOLD_STRATEGY: () => (/* binding */ CIRCLE_THRESHOLD_STRATEGY),
/* harmony export */   createEllipseInPoint: () => (/* binding */ createPointInEllipse),
/* harmony export */   fillInsideCircle: () => (/* binding */ fillInsideCircle),
/* harmony export */   fillOutsideCircle: () => (/* binding */ fillOutsideCircle),
/* harmony export */   thresholdInsideCircle: () => (/* binding */ thresholdInsideCircle)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utilities/math/ellipse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js");
/* harmony import */ var _utilities_boundingBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utilities/boundingBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js");
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BrushStrategy */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./compositions */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js");
/* harmony import */ var _utilities_math_sphere__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utilities/math/sphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/index.js");








const { transformWorldToIndex, isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const initializeCircle = {
    [_enums__WEBPACK_IMPORTED_MODULE_5__.StrategyCallbacks.Initialize]: (operationData) => {
        const { points, viewport, segmentationImageData, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(center, center, point);
        });
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const [topLeftCanvas, bottomRightCanvas] = (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_2__.getCanvasEllipseCorners)(canvasCoordinates);
        const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
        const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
        const circleCornersIJK = points.map((world) => {
            return transformWorldToIndex(segmentationImageData, world);
        });
        const boundsIJK = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_3__.getBoundingBoxAroundShapeIJK)(circleCornersIJK, segmentationImageData.getDimensions());
        operationData.isInObject = createPointInEllipse({
            topLeftWorld,
            bottomRightWorld,
            center,
        });
        operationData.isInObjectBoundsIJK = boundsIJK;
    },
};
function createPointInEllipse(worldInfo) {
    const { topLeftWorld, bottomRightWorld, center } = worldInfo;
    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
    const radius = Math.max(xRadius, yRadius, zRadius);
    if (isEqual(xRadius, radius) &&
        isEqual(yRadius, radius) &&
        isEqual(zRadius, radius)) {
        const sphereObj = {
            center,
            radius,
            radius2: radius * radius,
        };
        return (pointLPS) => (0,_utilities_math_sphere__WEBPACK_IMPORTED_MODULE_7__.pointInSphere)(sphereObj, pointLPS);
    }
    const ellipseObj = {
        center: center,
        xRadius,
        yRadius,
        zRadius,
    };
    const { precalculated } = (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_2__.precalculatePointInEllipse)(ellipseObj, {});
    return precalculated;
}
const CIRCLE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_4__["default"]('Circle', _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].regionFill, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].setValue, initializeCircle, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].preview, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].labelmapStatistics);
const CIRCLE_THRESHOLD_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_4__["default"]('CircleThreshold', _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].regionFill, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].setValue, initializeCircle, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].threshold, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].preview, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].islandRemoval, _compositions__WEBPACK_IMPORTED_MODULE_6__["default"].labelmapStatistics);
const fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;
const thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;
function fillOutsideCircle() {
    throw new Error('Not yet implemented');
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RECTANGLE_STRATEGY: () => (/* binding */ RECTANGLE_STRATEGY),
/* harmony export */   RECTANGLE_THRESHOLD_STRATEGY: () => (/* binding */ RECTANGLE_THRESHOLD_STRATEGY),
/* harmony export */   fillInsideRectangle: () => (/* binding */ fillInsideRectangle),
/* harmony export */   thresholdInsideRectangle: () => (/* binding */ thresholdInsideRectangle)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utilities/boundingBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _utils_getStrategyData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/getStrategyData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js");
/* harmony import */ var _utilities_rectangleROITool_isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utilities/rectangleROITool/isAxisAlignedRectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js");
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BrushStrategy */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./compositions */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js");









const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const initializeRectangle = {
    [_enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.Initialize]: (operationData) => {
        const { points, imageVoxelManager, viewport, segmentationImageData, segmentationVoxelManager, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(center, center, point);
        });
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);
        operationData.isInObject = pointInShapeFn;
        operationData.isInObjectBoundsIJK = boundsIJK;
    },
};
function createPointInRectangle(viewport, points, segmentationImageData) {
    let rectangleCornersIJK = points.map((world) => {
        return transformWorldToIndex(segmentationImageData, world);
    });
    rectangleCornersIJK = rectangleCornersIJK.map((point) => {
        return point.map((coord) => {
            return Math.round(coord);
        });
    });
    const boundsIJK = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeIJK)(rectangleCornersIJK, segmentationImageData.getDimensions());
    const isStackViewport = viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.StackViewport;
    const isAligned = isStackViewport || (0,_utilities_rectangleROITool_isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_5__.isAxisAlignedRectangle)(rectangleCornersIJK);
    const direction = segmentationImageData.getDirection();
    const spacing = segmentationImageData.getSpacing();
    const { viewPlaneNormal } = viewport.getCamera();
    const EPS = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getSpacingInNormalDirection({
        direction,
        spacing,
    }, viewPlaneNormal);
    const pointsBoundsLPS = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeWorld)(points);
    let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;
    xMin -= EPS;
    xMax += EPS;
    yMin -= EPS;
    yMax += EPS;
    zMin -= EPS;
    zMax += EPS;
    const pointInShapeFn = isAligned
        ? () => true
        : (pointLPS) => {
            const [x, y, z] = pointLPS;
            const xInside = x >= xMin && x <= xMax;
            const yInside = y >= yMin && y <= yMax;
            const zInside = z >= zMin && z <= zMax;
            return xInside && yInside && zInside;
        };
    return { boundsIJK, pointInShapeFn };
}
const RECTANGLE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_6__["default"]('Rectangle', _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].regionFill, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].setValue, initializeRectangle, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].preview, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].labelmapStatistics);
const RECTANGLE_THRESHOLD_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_6__["default"]('RectangleThreshold', _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].regionFill, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].setValue, initializeRectangle, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].threshold, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].preview, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].islandRemoval, _compositions__WEBPACK_IMPORTED_MODULE_8__["default"].labelmapStatistics);
const fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;
const thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SPHERE_STRATEGY: () => (/* binding */ SPHERE_STRATEGY),
/* harmony export */   fillInsideSphere: () => (/* binding */ fillInsideSphere),
/* harmony export */   fillOutsideSphere: () => (/* binding */ fillOutsideSphere),
/* harmony export */   thresholdInsideSphere: () => (/* binding */ thresholdInsideSphere),
/* harmony export */   thresholdInsideSphereIsland: () => (/* binding */ thresholdInsideSphereIsland)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BrushStrategy */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js");
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compositions */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js");
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../enums/StrategyCallbacks */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js");
/* harmony import */ var _fillCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fillCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js");
/* harmony import */ var _utilities_getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utilities/getSphereBoundsInfo */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js");






const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;

const sphereComposition = {
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_4__["default"].Initialize]: (operationData) => {
        const { points, viewport, segmentationImageData } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(center, center, point);
        });
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const { boundsIJK: newBoundsIJK, topLeftWorld, bottomRightWorld, } = (0,_utilities_getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_6__.getSphereBoundsInfoFromViewport)(points.slice(0, 2), segmentationImageData, viewport);
        operationData.isInObjectBoundsIJK = newBoundsIJK;
        operationData.isInObject = (0,_fillCircle__WEBPACK_IMPORTED_MODULE_5__.createEllipseInPoint)({
            topLeftWorld,
            bottomRightWorld,
            center,
        });
    },
};
const SPHERE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_2__["default"]('Sphere', _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].regionFill, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].setValue, sphereComposition, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].preview, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].labelmapStatistics, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].ensureSegmentationVolumeFor3DManipulation);
const fillInsideSphere = SPHERE_STRATEGY.strategyFunction;
const SPHERE_THRESHOLD_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_2__["default"]('SphereThreshold', ...SPHERE_STRATEGY.compositions, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].threshold, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].ensureSegmentationVolumeFor3DManipulation, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].ensureImageVolumeFor3DManipulation);
const SPHERE_THRESHOLD_STRATEGY_ISLAND = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_2__["default"]('SphereThreshold', ...SPHERE_STRATEGY.compositions, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].threshold, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].islandRemoval, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].ensureSegmentationVolumeFor3DManipulation, _compositions__WEBPACK_IMPORTED_MODULE_3__["default"].ensureImageVolumeFor3DManipulation);
const thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;
const thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;
function fillOutsideSphere() {
    throw new Error('fill outside sphere not implemented');
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fillInsideCircle: () => (/* reexport safe */ _fillCircle__WEBPACK_IMPORTED_MODULE_1__.fillInsideCircle),
/* harmony export */   fillInsideRectangle: () => (/* reexport safe */ _fillRectangle__WEBPACK_IMPORTED_MODULE_0__.fillInsideRectangle),
/* harmony export */   fillOutsideCircle: () => (/* reexport safe */ _fillCircle__WEBPACK_IMPORTED_MODULE_1__.fillOutsideCircle),
/* harmony export */   thresholdInsideRectangle: () => (/* reexport safe */ _fillRectangle__WEBPACK_IMPORTED_MODULE_0__.thresholdInsideRectangle)
/* harmony export */ });
/* harmony import */ var _fillRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fillRectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js");
/* harmony import */ var _fillCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fillCircle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getStrategyData: () => (/* binding */ getStrategyData)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");
/* harmony import */ var _stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../stateManagement/segmentation/helpers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/index.js");
/* harmony import */ var _utilities_segmentation_getReferenceVolumeForSegmentationVolume__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utilities/segmentation/getReferenceVolumeForSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentationVolume.js");




function getStrategyDataForVolumeViewport({ operationData }) {
    const { volumeId } = operationData;
    if (!volumeId) {
        const event = new CustomEvent(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ERROR_EVENT, {
            detail: {
                type: 'Segmentation',
                message: 'No volume id found for the segmentation',
            },
            cancelable: true,
        });
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.dispatchEvent(event);
        return null;
    }
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    const imageVolume = (0,_utilities_segmentation_getReferenceVolumeForSegmentationVolume__WEBPACK_IMPORTED_MODULE_3__.getReferenceVolumeForSegmentationVolume)(volumeId);
    if (!segmentationVolume || !imageVolume) {
        return null;
    }
    const { imageData: segmentationImageData } = segmentationVolume;
    const { voxelManager: segmentationVoxelManager } = segmentationVolume;
    const { voxelManager: imageVoxelManager, imageData } = imageVolume;
    return {
        segmentationImageData,
        segmentationVoxelManager,
        segmentationScalarData: null,
        imageScalarData: null,
        imageVoxelManager,
        imageData,
    };
}
function getStrategyDataForStackViewport({ operationData, viewport, strategy, }) {
    const { segmentationId } = operationData;
    let segmentationImageData;
    let segmentationVoxelManager;
    let segmentationScalarData;
    let imageScalarData;
    let imageVoxelManager;
    let imageData;
    if (strategy.ensureSegmentationVolumeFor3DManipulation) {
        strategy.ensureSegmentationVolumeFor3DManipulation({
            operationData,
            viewport,
        });
        segmentationVoxelManager = operationData.segmentationVoxelManager;
        segmentationImageData = operationData.segmentationImageData;
        segmentationScalarData = null;
    }
    else {
        const labelmapImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
        if (!labelmapImageId) {
            return null;
        }
        const actorEntry = (0,_stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__.getLabelmapActorEntry)(viewport.id, segmentationId);
        if (!actorEntry) {
            return null;
        }
        const currentSegImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(labelmapImageId);
        segmentationImageData = actorEntry.actor.getMapper().getInputData();
        segmentationVoxelManager = currentSegImage.voxelManager;
        const currentSegmentationImageId = operationData.imageId;
        const segmentationImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(currentSegmentationImageId);
        if (!segmentationImage) {
            return null;
        }
        segmentationScalarData = segmentationImage.getPixelData?.();
    }
    if (strategy.ensureImageVolumeFor3DManipulation) {
        strategy.ensureImageVolumeFor3DManipulation({
            operationData,
            viewport,
        });
        imageVoxelManager = operationData.imageVoxelManager;
        imageScalarData = operationData.imageScalarData;
        imageData = operationData.imageData;
    }
    else {
        const currentImageId = viewport.getCurrentImageId();
        if (!currentImageId) {
            return null;
        }
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(currentImageId);
        imageData = image ? null : viewport.getImageData();
        imageScalarData = image?.getPixelData() || imageData.getScalarData();
        imageVoxelManager = image?.voxelManager;
    }
    return {
        segmentationImageData,
        segmentationScalarData,
        imageScalarData,
        segmentationVoxelManager,
        imageVoxelManager,
        imageData,
    };
}
function getStrategyData({ operationData, viewport, strategy, }) {
    if (!operationData) {
        return null;
    }
    if (('volumeId' in operationData && operationData.volumeId != null) ||
        ('referencedVolumeId' in operationData &&
            operationData.referencedVolumeId != null)) {
        return getStrategyDataForVolumeViewport({ operationData });
    }
    return getStrategyDataForStackViewport({ operationData, viewport, strategy });
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js":
/*!******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   handleUseSegmentCenterIndex: () => (/* binding */ handleUseSegmentCenterIndex)
/* harmony export */ });
function handleUseSegmentCenterIndex({ operationData, existingValue, index, }) {
    const { previewSegmentIndex, memo, centerSegmentIndexInfo, previewOnHover, segmentIndex, } = operationData;
    const { hasPreviewIndex, hasSegmentIndex, segmentIndex: centerSegmentIndex, } = centerSegmentIndexInfo;
    if (centerSegmentIndex === 0 && hasSegmentIndex && hasPreviewIndex) {
        if (existingValue === segmentIndex) {
            return;
        }
        if (previewOnHover) {
            return;
        }
        if (existingValue === previewSegmentIndex) {
            memo.voxelManager.setAtIndex(index, 0);
            return;
        }
        return;
    }
    if (centerSegmentIndex === 0 && hasSegmentIndex && !hasPreviewIndex) {
        if (existingValue === 0 || existingValue !== segmentIndex) {
            return;
        }
        memo.voxelManager.setAtIndex(index, previewSegmentIndex);
        centerSegmentIndexInfo.changedIndices.push(index);
        return;
    }
    if (centerSegmentIndex === 0 && !hasSegmentIndex && hasPreviewIndex) {
        if (existingValue === segmentIndex) {
            return;
        }
        if (previewOnHover) {
            return;
        }
        if (existingValue === previewSegmentIndex) {
            memo.voxelManager.setAtIndex(index, 0);
            return;
        }
        return;
    }
    if (centerSegmentIndex === 0 && !hasSegmentIndex && !hasPreviewIndex) {
        if (existingValue === segmentIndex) {
            return;
        }
        if (existingValue === previewSegmentIndex) {
            memo.voxelManager.setAtIndex(index, previewSegmentIndex);
            return;
        }
        return;
    }
    if (centerSegmentIndex === previewSegmentIndex &&
        hasSegmentIndex &&
        hasPreviewIndex) {
        if (existingValue === segmentIndex) {
            return;
        }
        memo.voxelManager.setAtIndex(index, previewSegmentIndex);
        return;
    }
    if (centerSegmentIndex === previewSegmentIndex &&
        !hasSegmentIndex &&
        hasPreviewIndex) {
        if (existingValue === segmentIndex) {
            return;
        }
        memo.voxelManager.setAtIndex(index, previewSegmentIndex);
        return;
    }
    if (centerSegmentIndex === segmentIndex &&
        hasSegmentIndex &&
        hasPreviewIndex) {
        if (existingValue === segmentIndex) {
            return;
        }
        memo.voxelManager.setAtIndex(index, previewSegmentIndex);
        return;
    }
    if (centerSegmentIndex === segmentIndex &&
        hasSegmentIndex &&
        !hasPreviewIndex) {
        if (existingValue === segmentIndex) {
            return;
        }
        memo.voxelManager.setAtIndex(index, previewSegmentIndex);
        return;
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContourWindingDirection: () => (/* binding */ ContourWindingDirection)
/* harmony export */ });
var ContourWindingDirection;
(function (ContourWindingDirection) {
    ContourWindingDirection[ContourWindingDirection["CounterClockwise"] = -1] = "CounterClockwise";
    ContourWindingDirection[ContourWindingDirection["Unknown"] = 0] = "Unknown";
    ContourWindingDirection[ContourWindingDirection["Clockwise"] = 1] = "Clockwise";
})(ContourWindingDirection || (ContourWindingDirection = {}));


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotationHydration: () => (/* binding */ annotationHydration),
/* harmony export */   getClosestImageIdForStackViewport: () => (/* binding */ getClosestImageIdForStackViewport)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");



function annotationHydration(viewport, toolName, worldPoints, options) {
    const viewReference = viewport.getViewReference();
    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;
    const annotation = {
        annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
        data: {
            handles: {
                points: worldPoints,
            },
        },
        highlighted: false,
        autoGenerated: false,
        invalidated: false,
        isLocked: false,
        isVisible: true,
        metadata: {
            toolName,
            viewPlaneNormal,
            FrameOfReferenceUID,
            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),
            ...options,
        },
    };
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, viewport.element);
    return annotation;
}
function getReferencedImageId(viewport, worldPos, viewPlaneNormal) {
    let referencedImageId;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);
    }
    else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const targetId = getTargetId(viewport);
        const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
    }
    else {
        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');
    }
    return referencedImageId;
}
function getTargetId(viewport) {
    const targetId = viewport.getViewReferenceId?.();
    if (targetId) {
        return targetId;
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        return `volumeId:${getTargetVolumeId(viewport)}`;
    }
    throw new Error('getTargetId: viewport must have a getTargetId method');
}
function getTargetVolumeId(viewport) {
    const actorEntries = viewport.getActors();
    if (!actorEntries) {
        return;
    }
    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;
}
function getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {
    const imageIds = viewport.getImageIds();
    if (!imageIds || !imageIds.length) {
        return;
    }
    const distanceImagePairs = imageIds.map((imageId) => {
        const { imagePositionPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('imagePlaneModule', imageId);
        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);
        return { imageId, distance };
    });
    distanceImagePairs.sort((a, b) => a.distance - b.distance);
    return distanceImagePairs[0].imageId;
}
function calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {
    const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.sub(dir, worldPos, ImagePositionPatient);
    const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.dot(dir, viewPlaneNormal);
    return Math.abs(dot);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {
    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);
    if (sliceNormalIndex === -1) {
        throw new Error('3D bounding boxes not supported in an oblique plane');
    }
    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;
    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;
    return boundsIJK;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extend2DBoundingBoxInViewAxis);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBoundingBoxAroundShapeIJK: () => (/* binding */ getBoundingBoxAroundShapeIJK),
/* harmony export */   getBoundingBoxAroundShapeWorld: () => (/* binding */ getBoundingBoxAroundShapeWorld)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS;
function calculateBoundingBox(points, dimensions, isWorld = false) {
    let xMin = Infinity;
    let xMax = isWorld ? -Infinity : 0;
    let yMin = Infinity;
    let yMax = isWorld ? -Infinity : 0;
    let zMin = Infinity;
    let zMax = isWorld ? -Infinity : 0;
    const is3D = points[0]?.length === 3;
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        xMin = Math.min(p[0], xMin);
        xMax = Math.max(p[0], xMax);
        yMin = Math.min(p[1], yMin);
        yMax = Math.max(p[1], yMax);
        if (is3D) {
            zMin = Math.min(p[2] ?? zMin, zMin);
            zMax = Math.max(p[2] ?? zMax, zMax);
        }
    }
    if (dimensions) {
        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);
        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);
        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);
        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);
        if (is3D && dimensions.length === 3) {
            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);
            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);
        }
    }
    else if (!isWorld) {
        xMin = Math.max(0, xMin);
        xMax = Math.min(Infinity, xMax);
        yMin = Math.max(0, yMin);
        yMax = Math.min(Infinity, yMax);
        if (is3D) {
            zMin = Math.max(0, zMin);
            zMax = Math.min(Infinity, zMax);
        }
    }
    return is3D
        ? [
            [xMin, xMax],
            [yMin, yMax],
            [zMin, zMax],
        ]
        : [[xMin, xMax], [yMin, yMax], null];
}
function getBoundingBoxAroundShapeIJK(points, dimensions) {
    return calculateBoundingBox(points, dimensions, false);
}
function getBoundingBoxAroundShapeWorld(points, clipBounds) {
    return calculateBoundingBox(points, clipBounds, true);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extend2DBoundingBoxInViewAxis: () => (/* reexport safe */ _extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   getBoundingBoxAroundShape: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.getBoundingBoxAroundShapeIJK),
/* harmony export */   getBoundingBoxAroundShapeIJK: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.getBoundingBoxAroundShapeIJK),
/* harmony export */   getBoundingBoxAroundShapeWorld: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.getBoundingBoxAroundShapeWorld)
/* harmony export */ });
/* harmony import */ var _extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extend2DBoundingBoxInViewAxis */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js");
/* harmony import */ var _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBoundingBoxAroundShape */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addContourSegmentationAnnotation: () => (/* binding */ addContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");

function addContourSegmentationAnnotation(annotation) {
    if (annotation.parentAnnotationUID) {
        return;
    }
    if (!annotation.data.segmentation) {
        throw new Error('addContourSegmentationAnnotation: annotation does not have a segmentation data');
    }
    const { segmentationId, segmentIndex } = annotation.data.segmentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    if (!segmentation.representationData.Contour) {
        segmentation.representationData.Contour = { annotationUIDsMap: new Map() };
    }
    let { annotationUIDsMap } = segmentation.representationData.Contour;
    if (!annotationUIDsMap) {
        annotationUIDsMap = new Map();
    }
    let annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);
    if (!annotationsUIDsSet) {
        annotationsUIDsSet = new Set();
        annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);
    }
    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet.add(annotation.annotationUID));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ areSameSegment)
/* harmony export */ });
function areSameSegment(firstAnnotation, secondAnnotation) {
    const { segmentation: firstSegmentation } = firstAnnotation.data;
    const { segmentation: secondSegmentation } = secondAnnotation.data;
    return (firstSegmentation.segmentationId === secondSegmentation.segmentationId &&
        firstSegmentation.segmentIndex === secondSegmentation.segmentIndex);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addContourSegmentationAnnotation: () => (/* reexport safe */ _addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_2__.addContourSegmentationAnnotation),
/* harmony export */   areSameSegment: () => (/* reexport safe */ _areSameSegment__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   isContourSegmentationAnnotation: () => (/* reexport safe */ _isContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   removeContourSegmentationAnnotation: () => (/* reexport safe */ _removeContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_3__.removeContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _areSameSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./areSameSegment */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js");
/* harmony import */ var _isContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isContourSegmentationAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js");
/* harmony import */ var _addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addContourSegmentationAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js");
/* harmony import */ var _removeContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./removeContourSegmentationAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js":
/*!****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isContourSegmentationAnnotation)
/* harmony export */ });
function isContourSegmentationAnnotation(annotation) {
    return !!annotation.data?.segmentation;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js":
/*!********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeContourSegmentationAnnotation: () => (/* binding */ removeContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");

function removeContourSegmentationAnnotation(annotation) {
    if (!annotation.data.segmentation) {
        throw new Error('removeContourSegmentationAnnotation: annotation does not have a segmentation data');
    }
    const { segmentationId, segmentIndex } = annotation.data.segmentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__.getSegmentation)(segmentationId);
    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};
    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);
    if (!annotationsUIDsSet) {
        return;
    }
    annotationsUIDsSet.delete(annotation.annotationUID);
    if (!annotationsUIDsSet.size) {
        annotationUIDsMap.delete(segmentIndex);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _RectangleROIStartEndThreshold__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RectangleROIStartEndThreshold */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js");

function validateAnnotation(annotation) {
    if (!annotation?.data) {
        throw new Error('Tool data is empty');
    }
    if (!annotation.metadata || annotation.metadata.referencedImageId) {
        throw new Error('Tool data is not associated with any imageId');
    }
}
class AnnotationToPointData {
    static { this.TOOL_NAMES = {}; }
    constructor() {
    }
    static convert(annotation, index, metadataProvider) {
        validateAnnotation(annotation);
        const { toolName } = annotation.metadata;
        const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];
        if (!toolClass) {
            throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);
        }
        const ContourSequence = toolClass.getContourSequence(annotation, metadataProvider);
        const color = [
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
        ];
        return {
            ReferencedROINumber: index + 1,
            ROIDisplayColor: color,
            ContourSequence,
        };
    }
    static register(toolClass) {
        AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;
    }
}
AnnotationToPointData.register(_RectangleROIStartEndThreshold__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationToPointData);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class RectangleROIStartEndThreshold {
    constructor() {
    }
    static getContourSequence(toolData, metadataProvider) {
        const { data } = toolData;
        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;
        return projectionPoints.map((point, index) => {
            const ContourData = getPointData(point);
            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);
            return {
                NumberOfContourPoints: ContourData.length / 3,
                ContourImageSequence,
                ContourGeometricType: 'CLOSED_PLANAR',
                ContourData,
            };
        });
    }
}
RectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';
function getPointData(points) {
    const orderedPoints = [
        ...points[0],
        ...points[1],
        ...points[3],
        ...points[2],
    ];
    const pointsArray = orderedPoints.flat();
    const pointsArrayWithPrecision = pointsArray.map((point) => {
        return point.toFixed(2);
    });
    return pointsArrayWithPrecision;
}
function getContourImageSequence(imageId, metadataProvider) {
    const sopCommon = metadataProvider.get('sopCommonModule', imageId);
    return {
        ReferencedSOPClassUID: sopCommon.sopClassUID,
        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROIStartEndThreshold);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ areCoplanarContours)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function areCoplanarContours(firstAnnotation, secondAnnotation) {
    const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;
    const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;
    const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);
    const parallelPlanes = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.glMatrix.equals(1, Math.abs(dot));
    if (!parallelPlanes) {
        return false;
    }
    const { polyline: firstPolyline } = firstAnnotation.data.contour;
    const { polyline: secondPolyline } = secondAnnotation.data.contour;
    const firstDistance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(firstViewPlaneNormal, firstPolyline[0]);
    const secondDistance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(firstViewPlaneNormal, secondPolyline[0]);
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.glMatrix.equals(firstDistance, secondDistance);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function calculatePerimeter(polyline, closed) {
    let perimeter = 0;
    for (let i = 0; i < polyline.length - 1; i++) {
        const point1 = polyline[i];
        const point2 = polyline[i + 1];
        perimeter += Math.sqrt(Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2));
    }
    if (closed) {
        const firstPoint = polyline[0];
        const lastPoint = polyline[polyline.length - 1];
        perimeter += Math.sqrt(Math.pow(lastPoint[0] - firstPoint[0], 2) +
            Math.pow(lastPoint[1] - firstPoint[1], 2));
    }
    return perimeter;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (calculatePerimeter);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   findContours: () => (/* binding */ findContours),
/* harmony export */   findContoursFromReducedSet: () => (/* binding */ findContoursFromReducedSet)
/* harmony export */ });
function findNextLink(line, lines, contourPoints) {
    let index = -1;
    lines.forEach((cell, i) => {
        if (index >= 0) {
            return;
        }
        if (cell.a == line.b) {
            index = i;
        }
    });
    if (index >= 0) {
        const nextLine = lines[index];
        lines.splice(index, 1);
        contourPoints.push(nextLine.b);
        if (contourPoints[0] == nextLine.b) {
            return {
                remainingLines: lines,
                contourPoints,
                type: 'CLOSED_PLANAR',
            };
        }
        return findNextLink(nextLine, lines, contourPoints);
    }
    return {
        remainingLines: lines,
        contourPoints,
        type: 'OPEN_PLANAR',
    };
}
function findContours(lines) {
    if (lines.length == 0) {
        return [];
    }
    const contourPoints = [];
    const firstCell = lines.shift();
    contourPoints.push(firstCell.a);
    contourPoints.push(firstCell.b);
    const result = findNextLink(firstCell, lines, contourPoints);
    if (result.remainingLines.length == 0) {
        return [
            {
                type: result.type,
                contourPoints: result.contourPoints,
            },
        ];
    }
    else {
        const extraContours = findContours(result.remainingLines);
        extraContours.push({
            type: result.type,
            contourPoints: result.contourPoints,
        });
        return extraContours;
    }
}
function findContoursFromReducedSet(lines) {
    return findContours(lines);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    findContours,
    findContoursFromReducedSet,
});


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   processContourHoles: () => (/* binding */ processContourHoles)
/* harmony export */ });
const getIsPointInsidePolygon = (point, vertices) => {
    const x = point[0];
    const y = point[1];
    let inside = false;
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i][0], yi = vertices[i][1];
        const xj = vertices[j][0], yj = vertices[j][1];
        const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
        if (intersect) {
            inside = !inside;
        }
    }
    return inside;
};
function checkEnclosed(outerContour, innerContour, points) {
    const vertices = [];
    outerContour.contourPoints.forEach((point) => {
        vertices.push([points[point][0], points[point][1]]);
    });
    let pointsNotEnclosed = 0;
    innerContour.contourPoints.forEach((point) => {
        const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);
        if (!result) {
            pointsNotEnclosed++;
        }
    });
    return pointsNotEnclosed === 0;
}
function processContourHoles(contours, points, useXOR = true) {
    const retContours = contours.filter((contour) => contour.type !== 'CLOSED_PLANAR');
    const closedContours = contours.filter((contour) => contour.type === 'CLOSED_PLANAR');
    const contourWithHoles = [];
    let contourWithoutHoles = [];
    closedContours.forEach((contour, index) => {
        const holes = [];
        closedContours.forEach((hContour, hIndex) => {
            if (index != hIndex) {
                if (checkEnclosed(contour, hContour, points)) {
                    holes.push(hIndex);
                }
            }
        });
        if (holes.length > 0) {
            contourWithHoles.push({
                contour,
                holes,
            });
        }
        else {
            contourWithoutHoles.push(index);
        }
    });
    if (useXOR) {
        contourWithHoles.forEach((contourHoleSet) => {
            contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';
            retContours.push(contourHoleSet.contour);
            contourHoleSet.holes.forEach((holeIndex) => {
                closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';
                retContours.push(closedContours[holeIndex]);
                contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {
                    return contourIndex !== holeIndex;
                });
            });
        });
        contourWithoutHoles.forEach((contourIndex) => {
            retContours.push(closedContours[contourIndex]);
        });
    }
    else {
    }
    return retContours;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ processContourHoles });


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findHandlePolylineIndex)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");


const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function findHandlePolylineIndex(annotation, handleIndex) {
    const { polyline } = annotation.data.contour;
    const { points } = annotation.data.handles;
    const { length } = points;
    if (handleIndex === length) {
        return polyline.length;
    }
    if (handleIndex < 0) {
        handleIndex = (handleIndex + length) % length;
    }
    if (handleIndex === 0) {
        return 0;
    }
    const handle = points[handleIndex];
    const index = polyline.findIndex((point) => isEqual(handle, point));
    if (index !== -1) {
        return index;
    }
    let closestDistance = Infinity;
    return polyline.reduce((closestIndex, point, testIndex) => {
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.squaredDistance(point, handle);
        if (distance < closestDistance) {
            closestDistance = distance;
            return testIndex;
        }
        return closestIndex;
    }, -1);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateContourSetsFromLabelmap: () => (/* binding */ generateContourSetsFromLabelmap)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/SegmentationRepresentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../registerComputeWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js");
/* harmony import */ var _segmentation_utilsForWorker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../segmentation/utilsForWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js");
/* harmony import */ var _segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../segmentation/getOrCreateSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js");






const { Labelmap } = _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__["default"];
async function generateContourSetsFromLabelmap({ segmentations }) {
    (0,_registerComputeWorker__WEBPACK_IMPORTED_MODULE_3__.registerComputeWorker)();
    (0,_segmentation_utilsForWorker__WEBPACK_IMPORTED_MODULE_4__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_2__.WorkerTypes.GENERATE_CONTOUR_SETS, 0);
    const { representationData, segments = [0, 1], segmentationId, } = segmentations;
    let { volumeId: segVolumeId } = representationData[Labelmap];
    if (!segVolumeId) {
        const segVolume = (0,_segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_5__["default"])(segmentationId);
        if (segVolume) {
            segVolumeId = segVolume.volumeId;
        }
    }
    const vol = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    const voxelManager = vol.voxelManager;
    const segScalarData = voxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segScalarData,
        dimensions: vol.dimensions,
        spacing: vol.imageData.getSpacing(),
        origin: vol.imageData.getOrigin(),
        direction: vol.imageData.getDirection(),
    };
    const indices = Array.isArray(segments)
        ? segments
            .filter((segment) => segment !== null)
            .map((segment) => segment.segmentIndex || segment)
        : Object.values(segments)
            .filter((segment) => segment !== null)
            .map((segment) => segment.segmentIndex || segment);
    const contourSets = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'generateContourSetsFromLabelmapVolume', {
        segmentation: segmentationInfo,
        indices,
        mode: 'individual',
    });
    const refImages = vol.imageIds.map((imageId) => {
        const refImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId)?.referencedImageId;
        return refImageId ? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(refImageId) : undefined;
    });
    const refImageDataMetadata = refImages.map((image) => {
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getImageDataMetadata(image);
    });
    const processedContourSets = contourSets
        .map((contourSet) => {
        const segment = segments[contourSet.segment.segmentIndex] || {};
        if (!contourSet.sliceContours.length) {
            return null;
        }
        const p1 = contourSet.sliceContours[0].polyData.points[0];
        let refImageId;
        if (p1) {
            const refImageIndex = refImageDataMetadata.findIndex((imageDataMetadata) => {
                const { scanAxisNormal, origin } = imageDataMetadata;
                const plane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeEquation(scanAxisNormal, origin);
                return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.isPointOnPlane(p1, plane);
            });
            if (refImageIndex !== -1) {
                refImageId = refImages[refImageIndex].imageId;
            }
        }
        return {
            label: segment.label,
            color: segment.color,
            metadata: {
                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,
                referencedImageId: refImageId,
            },
            sliceContours: contourSet.sliceContours.map((contourData) => ({
                contours: contourData.contours,
                polyData: contourData.polyData,
                FrameNumber: contourData.sliceIndex + 1,
                sliceIndex: contourData.sliceIndex,
                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,
                referencedImageId: refImageId,
            })),
        };
    })
        .filter((contourSet) => contourSet !== null);
    (0,_segmentation_utilsForWorker__WEBPACK_IMPORTED_MODULE_4__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_2__.WorkerTypes.GENERATE_CONTOUR_SETS, 100);
    return processedContourSets;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getContourHolesDataCanvas)
/* harmony export */ });
/* harmony import */ var _getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getContourHolesDataWorld */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js");

function getContourHolesDataCanvas(annotation, viewport) {
    const worldHoleContours = (0,_getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_0__["default"])(annotation);
    const canvasHoleContours = [];
    worldHoleContours.forEach((worldHoleContour) => {
        const numPoints = worldHoleContour.length;
        const canvasHoleContour = new Array(numPoints);
        for (let i = 0; i < numPoints; i++) {
            canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);
        }
        canvasHoleContours.push(canvasHoleContour);
    });
    return canvasHoleContours;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getContourHolesDataWorld)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");

function getContourHolesDataWorld(annotation) {
    const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];
    return childAnnotationUIDs.map((uid) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__.getAnnotation)(uid).data.contour.polyline);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getDeduplicatedVTKPolyDataPoints: () => (/* binding */ getDeduplicatedVTKPolyDataPoints)
/* harmony export */ });
function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {
    const points = polyData.getPoints();
    const lines = polyData.getLines();
    const pointsArray = new Array(points.getNumberOfPoints())
        .fill(0)
        .map((_, i) => points.getPoint(i).slice());
    const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {
        const cell = lines.getCell(i * 3).slice();
        return { a: cell[0], b: cell[1] };
    });
    if (bypass) {
        return { points: pointsArray, lines: linesArray };
    }
    const newPoints = [];
    for (const [i, pt] of pointsArray.entries()) {
        const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);
        if (index >= 0) {
            linesArray.map((line) => {
                if (line.a === i) {
                    line.a = index;
                }
                if (line.b === i) {
                    line.b = index;
                }
                return line;
            });
        }
        else {
            const newIndex = newPoints.length;
            newPoints.push(pt);
            linesArray.map((line) => {
                if (line.a === i) {
                    line.a = newIndex;
                }
                if (line.b === i) {
                    line.b = newIndex;
                }
                return line;
            });
        }
    }
    const newLines = linesArray.filter((line) => line.a !== line.b);
    return { points: newPoints, lines: newLines };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ getDeduplicatedVTKPolyDataPoints });


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js":
/*!***************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotationToPointData: () => (/* reexport safe */ _AnnotationToPointData__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   acceptAutogeneratedInterpolations: () => (/* reexport safe */ _interpolation_acceptAutogeneratedInterpolations__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   areCoplanarContours: () => (/* reexport safe */ _areCoplanarContours__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   calculatePerimeter: () => (/* reexport safe */ _calculatePerimeter__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   contourFinder: () => (/* reexport safe */ _contourFinder__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   detectContourHoles: () => (/* reexport safe */ _detectContourHoles__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   findHandlePolylineIndex: () => (/* reexport safe */ _findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   generateContourSetsFromLabelmap: () => (/* reexport safe */ _generateContourSetsFromLabelmap__WEBPACK_IMPORTED_MODULE_4__.generateContourSetsFromLabelmap),
/* harmony export */   getContourHolesDataCanvas: () => (/* reexport safe */ _getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   getContourHolesDataWorld: () => (/* reexport safe */ _getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   getDeduplicatedVTKPolyDataPoints: () => (/* reexport safe */ _getDeduplicatedVTKPolyDataPoints__WEBPACK_IMPORTED_MODULE_2__.getDeduplicatedVTKPolyDataPoints),
/* harmony export */   updateContourPolyline: () => (/* reexport safe */ _updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__["default"])
/* harmony export */ });
/* harmony import */ var _areCoplanarContours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./areCoplanarContours */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js");
/* harmony import */ var _contourFinder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contourFinder */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js");
/* harmony import */ var _getDeduplicatedVTKPolyDataPoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDeduplicatedVTKPolyDataPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js");
/* harmony import */ var _detectContourHoles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./detectContourHoles */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js");
/* harmony import */ var _generateContourSetsFromLabelmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generateContourSetsFromLabelmap */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js");
/* harmony import */ var _AnnotationToPointData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnnotationToPointData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js");
/* harmony import */ var _getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getContourHolesDataWorld */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js");
/* harmony import */ var _getContourHolesDataCanvas__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getContourHolesDataCanvas */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js");
/* harmony import */ var _updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./updateContourPolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js");
/* harmony import */ var _interpolation_acceptAutogeneratedInterpolations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interpolation/acceptAutogeneratedInterpolations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js");
/* harmony import */ var _findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./findHandlePolylineIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js");
/* harmony import */ var _calculatePerimeter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./calculatePerimeter */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js");















/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ acceptAutogeneratedInterpolations)
/* harmony export */ });
/* harmony import */ var _segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../segmentation/InterpolationManager/InterpolationManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js");

function acceptAutogeneratedInterpolations(annotationGroupSelector, selector) {
    _segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_0__["default"].acceptAutoGenerated(annotationGroupSelector, selector);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createPolylineToolData)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function createPolylineToolData(polyline, handlePoints, referencedToolData) {
    const annotation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge({
        data: {},
        metadata: {},
    }, referencedToolData);
    Object.assign(annotation, {
        highlighted: false,
        invalidated: true,
        autoGenerated: true,
        annotationUID: undefined,
        cachedStats: {},
        childAnnotationUIDs: [],
        parentAnnotationUID: undefined,
    });
    Object.assign(annotation.data, {
        handles: {
            points: handlePoints.points || handlePoints || [],
            interpolationSources: handlePoints.sources,
            activeHandleIndex: null,
            textBox: {
                hasMoved: false,
                worldPosition: [0, 0, 0],
                worldBoundingBox: {
                    topLeft: [0, 0, 0],
                    topRight: [0, 0, 0],
                    bottomLeft: [0, 0, 0],
                    bottomRight: [0, 0, 0],
                },
            },
        },
        contour: {
            ...referencedToolData.data.contour,
            polyline,
        },
    });
    return annotation;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js":
/*!******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getInterpolationData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getInterpolationData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js");

function findAnnotationsForInterpolation(toolData, viewportData) {
    const interpolationData = (0,_getInterpolationData__WEBPACK_IMPORTED_MODULE_0__["default"])(viewportData, [
        {
            key: 'interpolationUID',
            value: viewportData.interpolationUID,
        },
    ]);
    const rangeToInterpolate = getRangeToInterpolate(interpolationData);
    if (!rangeToInterpolate) {
        console.warn('No annotations found to interpolate', interpolationData);
        return;
    }
    const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);
    const interpolationList = [];
    for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {
        if (_sliceNeedsInterpolating(interpolationData, i)) {
            const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);
            if (contourPair?.[0] === sliceEdited ||
                contourPair?.[1] === sliceEdited) {
                _appendInterpolationList(contourPair, interpolationList, i);
            }
        }
    }
    return {
        interpolationData,
        interpolationList,
    };
}
function getRangeToInterpolate(interpolationData) {
    let first = Infinity;
    let last = -Infinity;
    let found = false;
    for (const [sliceIndex, annotations] of interpolationData.entries()) {
        if (annotations.length) {
            first = Math.min(sliceIndex, first);
            last = Math.max(sliceIndex, last);
            found = true;
        }
    }
    if (!found) {
        return;
    }
    return [first, last];
}
function _getSlicePositionOfToolData(interpolationData, annotationUID) {
    for (const [sliceIndex, annotations] of interpolationData) {
        for (let j = 0; j < annotations.length; j++) {
            if (annotations[j].annotationUID === annotationUID) {
                return sliceIndex;
            }
        }
    }
    return;
}
function _sliceNeedsInterpolating(interpolationData, sliceIndex) {
    const annotations = interpolationData.get(sliceIndex);
    return (!annotations?.length ||
        (annotations.length === 1 && annotations[0].autoGenerated));
}
function _appendInterpolationList(contourPair, interpolationList, itemIndex) {
    const [startIndex] = contourPair;
    interpolationList[startIndex] ||= {
        pair: contourPair,
        list: [],
    };
    interpolationList[startIndex].list.push(itemIndex);
}
function _getBoundingPair(sliceIndex, sliceRange, interpolationData) {
    const annotationPair = [];
    let canInterpolate = true;
    for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {
        const annotations = interpolationData.get(i);
        if (annotations?.length) {
            if (annotations[0].autoGenerated) {
                continue;
            }
            if (annotations.length > 1) {
                canInterpolate = false;
            }
            annotationPair.push(i);
            break;
        }
    }
    if (!canInterpolate || !annotationPair.length) {
        return;
    }
    for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {
        const annotations = interpolationData.get(i);
        if (annotations?.length) {
            if (annotations[0].autoGenerated) {
                continue;
            }
            if (annotations.length > 1) {
                canInterpolate = false;
            }
            annotationPair.push(i);
            break;
        }
    }
    if (!canInterpolate || annotationPair.length < 2) {
        return;
    }
    return annotationPair;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (findAnnotationsForInterpolation);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getInterpolationData)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");

const DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';
function getInterpolationData(viewportData, filterParams = []) {
    const { viewport, sliceData, annotation } = viewportData;
    const interpolationDatas = new Map();
    const { toolName, originalToolName } = annotation.metadata;
    const testToolName = originalToolName || toolName;
    const annotations = ((0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__.getAnnotations)(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||
        annotation.metadata.originalToolName === testToolName);
    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {
        const modifiedAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__.getAnnotations)(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);
        if (modifiedAnnotations?.length) {
            modifiedAnnotations.forEach((annotation) => {
                const { metadata } = annotation;
                if (metadata.originalToolName === testToolName &&
                    metadata.originalToolName !== metadata.toolName) {
                    annotations.push(annotation);
                }
            });
        }
    }
    if (!annotations?.length) {
        return interpolationDatas;
    }
    for (let i = 0; i < sliceData.numberOfSlices; i++) {
        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);
        if (!imageAnnotations?.length) {
            continue;
        }
        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {
            return filterParams.every((x) => {
                const parent = x.parentKey
                    ? x.parentKey(imageAnnotation)
                    : imageAnnotation;
                const value = parent?.[x.key];
                if (Array.isArray(value)) {
                    return value.every((item, index) => item === x.value[index]);
                }
                return value === x.value;
            });
        });
        if (filteredInterpolatedAnnotations.length) {
            interpolationDatas.set(i, filteredInterpolatedAnnotations);
        }
    }
    return interpolationDatas;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js":
/*!******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getInterpolationDataCollection)
/* harmony export */ });
/* harmony import */ var _getInterpolationData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getInterpolationData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js");

function getInterpolationDataCollection(viewportData, filterParams) {
    const imageAnnotations = (0,_getInterpolationData__WEBPACK_IMPORTED_MODULE_0__["default"])(viewportData, filterParams);
    const interpolatedDataCollection = [];
    if (!imageAnnotations?.size) {
        return interpolatedDataCollection;
    }
    for (const annotations of imageAnnotations.values()) {
        annotations.forEach((annotation) => {
            interpolatedDataCollection.push(annotation);
        });
    }
    return interpolatedDataCollection;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _createPolylineToolData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPolylineToolData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js");
/* harmony import */ var _findAnnotationForInterpolation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./findAnnotationForInterpolation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../stateManagement/annotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js");
/* harmony import */ var _selectHandles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./selectHandles */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js");
/* harmony import */ var _updateChildInterpolationUID__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./updateChildInterpolationUID */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js");
/* harmony import */ var _eventListeners_annotations_contourSegmentation_contourSegmentationCompleted__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../eventListeners/annotations/contourSegmentation/contourSegmentationCompleted */ "../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js");









const { PointsManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const dP = 0.2;
function interpolate(viewportData) {
    if (!viewportData.annotation) {
        return;
    }
    const { isInterpolationUpdate, annotation } = viewportData;
    queueMicrotask(() => {
        try {
            if (isInterpolationUpdate) {
                annotation.isInterpolationUpdate = true;
                annotation.autoGenerated = false;
            }
            startInterpolation(viewportData);
        }
        finally {
            if (isInterpolationUpdate) {
                annotation.autoGenerated = true;
            }
        }
    });
}
function startInterpolation(viewportData) {
    const { annotation: toolData } = viewportData;
    (0,_updateChildInterpolationUID__WEBPACK_IMPORTED_MODULE_7__["default"])(toolData);
    const { interpolationData, interpolationList } = (0,_findAnnotationForInterpolation__WEBPACK_IMPORTED_MODULE_3__["default"])(toolData, viewportData) || {};
    if (!interpolationData || !interpolationList) {
        return;
    }
    const eventData = {
        toolName: toolData.metadata.toolName,
        toolType: toolData.metadata.toolName,
        viewport: viewportData.viewport,
    };
    for (let i = 0; i < interpolationList.length; i++) {
        if (interpolationList[i]) {
            _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);
        }
    }
    const { id, renderingEngineId, element } = viewportData.viewport;
    const eventDetails = {
        annotation: toolData,
        element,
        viewportId: id,
        renderingEngineId,
    };
    if (interpolationList.length) {
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(viewportData.viewport.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__["default"].ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);
    }
}
function _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {
    const annotation0 = interpolationData.get(annotationPair[0])[0];
    const annotation1 = interpolationData.get(annotationPair[1])[0];
    const c1 = _generateClosedContour(annotation0.data.contour.polyline);
    const c2 = _generateClosedContour(annotation1.data.contour.polyline);
    const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);
    c1Interp.kIndex = annotationPair[0];
    c2Interp.kIndex = annotationPair[1];
    indices.forEach(function (index) {
        _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);
    });
}
function getPointCount(pointArray) {
    let sum = 0;
    for (let i = 0; i < pointArray.I.length; i++) {
        if (pointArray.I[i]) {
            sum++;
        }
    }
    return sum;
}
function _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {
    const [startIndex, endIndex] = annotationPair;
    const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);
    const annotation0 = interpolationData.get(startIndex)[0];
    const annotation1 = interpolationData.get(endIndex)[0];
    const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);
    const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;
    const handlePoints = (0,_selectHandles__WEBPACK_IMPORTED_MODULE_6__["default"])(interpolated3DPoints);
    if (interpolationData.has(sliceIndex)) {
        _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);
    }
    else {
        _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);
    }
}
function _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {
    const points = interpolated3DPoints.points;
    const { viewport } = eventData;
    const interpolatedAnnotation = (0,_createPolylineToolData__WEBPACK_IMPORTED_MODULE_2__["default"])(points, handlePoints, referencedToolData);
    const viewRef = viewport.getViewReference({ sliceIndex });
    if (!viewRef) {
        throw new Error(`Can't find slice ${sliceIndex}`);
    }
    Object.assign(interpolatedAnnotation.metadata, viewRef);
    _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_5__.state.addAnnotation(interpolatedAnnotation, viewport.element);
    referencedToolData.onInterpolationComplete?.(interpolatedAnnotation, referencedToolData);
    const { parentAnnotationUID } = referencedToolData;
    if (parentAnnotationUID) {
        const parentReferenced = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_5__.state.getAnnotation(parentAnnotationUID);
        const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);
        (0,_eventListeners_annotations_contourSegmentation_contourSegmentationCompleted__WEBPACK_IMPORTED_MODULE_8__.createPolylineHole)(viewport, parentAnnotation, interpolatedAnnotation);
    }
}
function _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {
    const { viewport } = eventData;
    const annotations = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_5__.state.getAnnotations(referencedToolData.metadata.toolName, viewport.element);
    for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        if (annotation.interpolationUID === referencedToolData.interpolationUID &&
            annotation.metadata.sliceIndex === sliceIndex) {
            return annotation;
        }
    }
}
function _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {
    const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);
    const points = interpolated3DPoints.points;
    const interpolatedAnnotation = (0,_createPolylineToolData__WEBPACK_IMPORTED_MODULE_2__["default"])(points, handlePoints, oldAnnotationData);
    Object.assign(oldAnnotationData, {
        metadata: interpolatedAnnotation.metadata,
        data: interpolatedAnnotation.data,
    });
}
function _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {
    const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;
    const c1 = PointsManager.fromXYZ(c1ir);
    const c2 = PointsManager.fromXYZ(c2ir);
    const { length } = c1;
    const cInterp = PointsManager.create3(length);
    const vecSubtract = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    const vecResult = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    const c1Source = PointsManager.create3(length);
    c1Source.kIndex = c1ir.kIndex;
    const c2Source = PointsManager.create3(length);
    c2Source.kIndex = c2ir.kIndex;
    for (let i = 0; i < c1ir.x.length; i++) {
        if (indices[i]) {
            const c1point = c1.getPoint(i);
            const c2point = c2.getPoint(i);
            c1Source.push(c1point);
            c2Source.push(c2point);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.sub(vecSubtract, c2point, c1point);
            cInterp.push(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));
        }
    }
    cInterp.sources = [c1Source, c2Source];
    return cInterp;
}
function _generateInterpolationContourPair(c1, c2) {
    const cumPerim1 = _getCumulativePerimeter(c1);
    const cumPerim2 = _getCumulativePerimeter(c2);
    const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));
    const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);
    const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);
    const numNodes1 = interpNodes + c2.x.length;
    const numNodes2 = interpNodes + c1.x.length;
    const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);
    const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);
    const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);
    const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);
    const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);
    const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);
    const c1i = _getSuperSampledContour(c1, nodesPerSegment1);
    const c2i = _getSuperSampledContour(c2, nodesPerSegment2);
    _shiftSuperSampledContourInPlace(c1i, c2i);
    return _reduceContoursToOriginNodes(c1i, c2i);
}
function _reduceContoursToOriginNodes(c1i, c2i) {
    const c1Interp = {
        x: [],
        y: [],
        z: [],
        I: [],
    };
    const c2Interp = {
        x: [],
        y: [],
        z: [],
        I: [],
    };
    for (let i = 0; i < c1i.x.length; i++) {
        if (c1i.I[i] || c2i.I[i]) {
            c1Interp.x.push(c1i.x[i]);
            c1Interp.y.push(c1i.y[i]);
            c1Interp.z.push(c1i.z[i]);
            c1Interp.I.push(c1i.I[i]);
            c2Interp.x.push(c2i.x[i]);
            c2Interp.y.push(c2i.y[i]);
            c2Interp.z.push(c2i.z[i]);
            c2Interp.I.push(c2i.I[i]);
        }
    }
    return {
        c1Interp,
        c2Interp,
    };
}
function _shiftSuperSampledContourInPlace(c1i, c2i) {
    const c1iLength = c1i.x.length;
    const optimal = {
        startingNode: 0,
        totalSquaredXYLengths: Infinity,
    };
    for (let startingNode = 0; startingNode < c1iLength; startingNode++) {
        let node = startingNode;
        let totalSquaredXYLengths = 0;
        for (let iteration = 0; iteration < c1iLength; iteration++) {
            totalSquaredXYLengths +=
                (c1i.x[node] - c2i.x[iteration]) ** 2 +
                    (c1i.y[node] - c2i.y[iteration]) ** 2 +
                    (c1i.z[node] - c2i.z[iteration]) ** 2;
            node++;
            if (node === c1iLength) {
                node = 0;
            }
        }
        if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {
            optimal.totalSquaredXYLengths = totalSquaredXYLengths;
            optimal.startingNode = startingNode;
        }
    }
    const node = optimal.startingNode;
    _shiftCircularArray(c1i.x, node);
    _shiftCircularArray(c1i.y, node);
    _shiftCircularArray(c1i.z, node);
    _shiftCircularArray(c1i.I, node);
}
function _shiftCircularArray(arr, count) {
    count -= arr.length * Math.floor(count / arr.length);
    const slicedArray = arr.splice(0, count);
    arr.push(...slicedArray);
    return arr;
}
function _getSuperSampledContour(c, nodesPerSegment) {
    const ci = {
        x: [],
        y: [],
        z: [],
        I: [],
    };
    for (let n = 0; n < c.x.length - 1; n++) {
        ci.x.push(c.x[n]);
        ci.y.push(c.y[n]);
        ci.z.push(c.z[n]);
        ci.I.push(true);
        const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);
        const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);
        const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);
        for (let i = 0; i < nodesPerSegment[n] - 1; i++) {
            ci.x.push(ci.x[ci.x.length - 1] + xSpacing);
            ci.y.push(ci.y[ci.y.length - 1] + ySpacing);
            ci.z.push(ci.z[ci.z.length - 1] + zSpacing);
            ci.I.push(false);
        }
    }
    return ci;
}
function _getNodesPerSegment(perimInterp, perimInd) {
    const idx = [];
    for (let i = 0; i < perimInterp.length; ++i) {
        idx[i] = i;
    }
    idx.sort(function (a, b) {
        return perimInterp[a] < perimInterp[b] ? -1 : 1;
    });
    const perimIndSorted = [];
    for (let i = 0; i < perimInd.length; i++) {
        perimIndSorted.push(perimInd[idx[i]]);
    }
    const indicesOfOriginNodes = perimIndSorted.reduce(function (arr, elementValue, i) {
        if (elementValue) {
            arr.push(i);
        }
        return arr;
    }, []);
    const nodesPerSegment = [];
    for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {
        nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);
    }
    return nodesPerSegment;
}
function _getIndicatorArray(numFalse, numTrue) {
    const perimInd = new Array(numFalse + numTrue);
    perimInd.fill(false, 0, numFalse);
    perimInd.fill(true, numFalse, numFalse + numTrue);
    return perimInd;
}
function _getInterpolatedPerim(numNodes, cumPerimNorm) {
    const diff = 1 / (numNodes - 1);
    const linspace = [diff];
    for (let i = 1; i < numNodes - 2; i++) {
        linspace.push(linspace[linspace.length - 1] + diff);
    }
    return linspace.concat(cumPerimNorm);
}
function _normalisedCumulativePerimeter(cumPerim) {
    const cumPerimNorm = [];
    for (let i = 0; i < cumPerim.length; i++) {
        cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);
    }
    return cumPerimNorm;
}
function _getCumulativePerimeter(contour) {
    const cumulativePerimeter = [0];
    for (let i = 1; i < contour.x.length; i++) {
        const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 +
            (contour.y[i] - contour.y[i - 1]) ** 2 +
            (contour.z[i] - contour.z[i - 1]) ** 2);
        cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);
    }
    return cumulativePerimeter;
}
function _generateClosedContour(points) {
    const c = {
        x: [],
        y: [],
        z: [],
    };
    for (let i = 0; i < points.length; i++) {
        c.x[i] = points[i][0];
        c.y[i] = points[i][1];
        c.z[i] = points[i][2];
    }
    c.x.push(c.x[0]);
    c.y.push(c.y[0]);
    c.z.push(c.z[0]);
    return c;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (interpolate);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addInterval: () => (/* binding */ addInterval),
/* harmony export */   createDotValues: () => (/* binding */ createDotValues),
/* harmony export */   "default": () => (/* binding */ selectHandles)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


const { PointsManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
function selectHandles(polyline, handleCount = 12) {
    const handles = PointsManager.create3(handleCount);
    handles.sources = [];
    const { sources: destPoints } = handles;
    const { length, sources: sourcePoints = [] } = polyline;
    const distance = 5;
    if (length < distance * 3) {
        return polyline.subselect(handleCount);
    }
    const interval = Math.floor(Math.max((2 * length) / handleCount, distance * 2));
    sourcePoints.forEach(() => destPoints.push(PointsManager.create3(handleCount)));
    const dotValues = createDotValues(polyline, distance);
    const minimumRegions = findMinimumRegions(dotValues, handleCount);
    const indices = [];
    if (minimumRegions?.length > 2) {
        let lastHandle = -1;
        const thirdInterval = interval / 3;
        minimumRegions.forEach((region) => {
            const [start, , end] = region;
            const midIndex = Math.ceil((start + end) / 2);
            if (end - lastHandle < thirdInterval) {
                return;
            }
            if (midIndex - start > 2 * thirdInterval) {
                addInterval(indices, lastHandle, start, interval, length);
                lastHandle = addInterval(indices, start, midIndex, interval, length);
            }
            else {
                lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);
            }
            if (end - lastHandle > thirdInterval) {
                lastHandle = addInterval(indices, lastHandle, end, interval, length);
            }
        });
        const firstHandle = indices[0];
        const lastDistance = indexValue(firstHandle + length - lastHandle, length);
        if (lastDistance > 2 * thirdInterval) {
            addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);
        }
    }
    else {
        const interval = Math.floor(length / handleCount);
        addInterval(indices, -1, length - interval, interval, length);
    }
    indices.forEach((index) => {
        const point = polyline.getPointArray(index);
        handles.push(point);
        sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));
    });
    return handles;
}
function createDotValues(polyline, distance = 6) {
    const { length } = polyline;
    const prevVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    const nextVec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    const dotValues = new Float32Array(length);
    for (let i = 0; i < length; i++) {
        const point = polyline.getPoint(i);
        const prevPoint = polyline.getPoint(i - distance);
        const nextPoint = polyline.getPoint((i + distance) % length);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(prevVec3, point, prevPoint);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(nextVec3, nextPoint, point);
        const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(prevVec3, nextVec3) / (gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.len(prevVec3) * gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.len(nextVec3));
        dotValues[i] = dot;
    }
    return dotValues;
}
function findMinimumRegions(dotValues, handleCount) {
    const { max, deviation } = getStats(dotValues);
    const { length } = dotValues;
    if (deviation < 0.01 || length < handleCount * 3) {
        return [];
    }
    const inflection = [];
    let pair = null;
    let minValue;
    let minIndex = 0;
    for (let i = 0; i < length; i++) {
        const dot = dotValues[i];
        if (dot < max - deviation) {
            if (pair) {
                pair[2] = i;
                if (dot < minValue) {
                    minValue = dot;
                    minIndex = i;
                }
                pair[1] = minIndex;
            }
            else {
                minValue = dot;
                minIndex = i;
                pair = [i, i, i];
            }
        }
        else {
            if (pair) {
                inflection.push(pair);
                pair = null;
            }
        }
    }
    if (pair) {
        if (inflection[0][0] === 0) {
            inflection[0][0] = pair[0];
        }
        else {
            pair[1] = minIndex;
            pair[2] = length - 1;
            inflection.push(pair);
        }
    }
    return inflection;
}
function addInterval(indices, start, finish, interval, length) {
    if (finish < start) {
        finish += length;
    }
    const distance = finish - start;
    const count = Math.ceil(distance / interval);
    if (count <= 0) {
        if (indices[indices.length - 1] !== finish) {
            indices.push(indexValue(finish, length));
        }
        return finish;
    }
    for (let i = 1; i <= count; i++) {
        const index = indexValue(start + (i * distance) / count, length);
        indices.push(index);
    }
    return indices[indices.length - 1];
}
function indexValue(v, length) {
    return (Math.round(v) + length) % length;
}
function getStats(dotValues) {
    const { length } = dotValues;
    let sum = 0;
    let min = Infinity;
    let max = -Infinity;
    let sumSq = 0;
    for (let i = 0; i < length; i++) {
        const dot = dotValues[i];
        sum += dot;
        min = Math.min(min, dot);
        max = Math.max(max, dot);
    }
    const mean = sum / length;
    for (let i = 0; i < length; i++) {
        const valueDiff = dotValues[i] - mean;
        sumSq += valueDiff * valueDiff;
    }
    return {
        mean,
        max,
        min,
        sumSq,
        deviation: Math.sqrt(sumSq / length),
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateChildInterpolationUID)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../stateManagement/annotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js");

function updateChildInterpolationUID(annotation) {
    const { parentAnnotationUID, annotationUID } = annotation;
    if (!parentAnnotationUID) {
        return annotation.interpolationUID;
    }
    const parentAnnotation = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_0__.state.getAnnotation(parentAnnotationUID);
    const { interpolationUID } = parentAnnotation;
    const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);
    annotation.interpolationUID = `${interpolationUID}-${index}`;
    return annotation.interpolationUID;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateContourPolyline)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/annotation/annotationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js");



function updateContourPolyline(annotation, polylineData, transforms, options) {
    const { canvasToWorld, worldToCanvas } = transforms;
    const { data } = annotation;
    const { targetWindingDirection } = polylineData;
    let { points: polyline } = polylineData;
    let windingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(polyline);
    if (options?.decimate?.enabled) {
        polyline = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.decimate(polylineData.points, options?.decimate?.epsilon);
    }
    let { closed } = polylineData;
    const numPoints = polyline.length;
    const polylineWorldPoints = new Array(numPoints);
    const currentPolylineWindingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(polyline);
    const parentAnnotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getParentAnnotation)(annotation);
    if (closed === undefined) {
        let currentClosedState = false;
        if (polyline.length > 3) {
            const lastToFirstDist = _math__WEBPACK_IMPORTED_MODULE_1__.point.distanceToPointSquared(polyline[0], polyline[numPoints - 1]);
            currentClosedState = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(0, lastToFirstDist);
        }
        closed = currentClosedState;
    }
    if (options?.updateWindingDirection !== false) {
        let updatedWindingDirection = parentAnnotation
            ? parentAnnotation.data.contour.windingDirection * -1
            : targetWindingDirection;
        if (updatedWindingDirection === undefined) {
            updatedWindingDirection = windingDirection;
        }
        if (updatedWindingDirection !== windingDirection) {
            polyline.reverse();
        }
        const handlePoints = (data.handles?.points ?? []).map(worldToCanvas);
        if (handlePoints.length > 2) {
            const currentHandlesWindingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(handlePoints);
            if (currentHandlesWindingDirection !== updatedWindingDirection) {
                data.handles.points.reverse();
            }
        }
        windingDirection = updatedWindingDirection;
    }
    for (let i = 0; i < numPoints; i++) {
        polylineWorldPoints[i] = canvasToWorld(polyline[i]);
    }
    data.contour.polyline = polylineWorldPoints;
    data.contour.closed = closed;
    data.contour.windingDirection = windingDirection;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.invalidateAnnotation)(annotation);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js");

function debounce(func, wait, options) {
    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;
    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;
    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    wait = Number(wait) || 0;
    if ((0,_isObject__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
        leading = Boolean(options.leading);
        maxing = 'maxWait' in options;
        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;
    }
    function invokeFunc(time) {
        const args = lastArgs;
        const thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function startTimer(pendingFunc, wait) {
        if (useRAF) {
            return window.requestAnimationFrame(pendingFunc);
        }
        return setTimeout(pendingFunc, wait);
    }
    function cancelTimer(id) {
        if (useRAF) {
            return window.cancelAnimationFrame(id);
        }
        clearTimeout(id);
    }
    function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = startTimer(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        const timeWaiting = wait - timeSinceLastCall;
        return maxing
            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
    }
    function shouldInvoke(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        return (lastCallTime === undefined ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && timeSinceLastInvoke >= maxWait));
    }
    function timerExpired() {
        const time = Date.now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        timerId = startTimer(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            cancelTimer(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(Date.now());
    }
    function pending() {
        return timerId !== undefined;
    }
    function debounced(...args) {
        const time = Date.now();
        const isInvoking = shouldInvoke(time);
        lastArgs = args;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                timerId = startTimer(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = startTimer(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    debounced.pending = pending;
    return debounced;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debounce);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTextBoxCoordsCanvas)
/* harmony export */ });
function getTextBoxCoordsCanvas(annotationCanvasPoints) {
    const corners = _determineCorners(annotationCanvasPoints);
    const centerY = (corners.top[1] + corners.bottom[1]) / 2;
    const textBoxCanvas = [corners.right[0], centerY];
    return textBoxCanvas;
}
function _determineCorners(canvasPoints) {
    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);
    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);
    const right = handlesLeftToRight[handlesLeftToRight.length - 1];
    const top = handlesTopToBottom[0];
    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];
    return {
        top,
        bottom,
        right,
    };
    function _compareX(a, b) {
        return a[0] < b[0] ? -1 : 1;
    }
    function _compareY(a, b) {
        return a[1] < b[1] ? -1 : 1;
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js":
/*!**************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTextBoxCoordsCanvas: () => (/* reexport safe */ _getTextBoxCoordsCanvas__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _getTextBoxCoordsCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getTextBoxCoordsCanvas */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCalibratedAspect: () => (/* binding */ getCalibratedAspect),
/* harmony export */   getCalibratedLengthUnitsAndScale: () => (/* binding */ getCalibratedLengthUnitsAndScale),
/* harmony export */   getCalibratedProbeUnitsAndValue: () => (/* binding */ getCalibratedProbeUnitsAndValue)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const { CalibrationTypes } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums;
const PIXEL_UNITS = 'px';
const VOXEL_UNITS = 'voxels';
const SUPPORTED_REGION_DATA_TYPES = [
    1,
    2,
    3,
    4,
];
const SUPPORTED_LENGTH_VARIANT = [
    '3,3',
    '4,7',
];
const SUPPORTED_PROBE_VARIANT = [
    '4,3',
    '4,7',
];
const UNIT_MAPPING = {
    0: 'px',
    1: 'percent',
    2: 'dB',
    3: 'cm',
    4: 'seconds',
    5: 'hertz',
    6: 'dB/seconds',
    7: 'cm/sec',
    8: 'cm\xb2',
    9: 'cm\xb2/s',
    0xc: 'degrees',
};
const EPS = 1e-3;
const SQUARE = '\xb2';
const getCalibratedLengthUnitsAndScale = (image, handles) => {
    const { calibration, hasPixelSpacing } = image;
    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;
    const volumeUnit = hasPixelSpacing ? 'mm\xb3' : VOXEL_UNITS;
    let areaUnit = unit + SQUARE;
    let scale = 1;
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { unit, areaUnit, scale, volumeUnit };
    }
    if (calibration.type === CalibrationTypes.UNCALIBRATED) {
        return {
            unit: PIXEL_UNITS,
            areaUnit: PIXEL_UNITS + SQUARE,
            scale,
            volumeUnit: VOXEL_UNITS,
        };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        let imageIndex1, imageIndex2;
        if (Array.isArray(handles) && handles.length === 2) {
            [imageIndex1, imageIndex2] = handles;
        }
        else if (typeof handles === 'function') {
            const points = handles();
            imageIndex1 = points[0];
            imageIndex2 = points[1];
        }
        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&
            imageIndex1[0] <= region.regionLocationMaxX1 &&
            imageIndex1[1] >= region.regionLocationMinY0 &&
            imageIndex1[1] <= region.regionLocationMaxY1 &&
            imageIndex2[0] >= region.regionLocationMinX0 &&
            imageIndex2[0] <= region.regionLocationMaxX1 &&
            imageIndex2[1] >= region.regionLocationMinY0 &&
            imageIndex2[1] <= region.regionLocationMaxY1);
        if (!regions?.length) {
            return { unit, areaUnit, scale, volumeUnit };
        }
        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));
        if (!regions.length) {
            return {
                unit: PIXEL_UNITS,
                areaUnit: PIXEL_UNITS + SQUARE,
                scale,
                volumeUnit: VOXEL_UNITS,
            };
        }
        const region = regions[0];
        const physicalDeltaX = Math.abs(region.physicalDeltaX);
        const physicalDeltaY = Math.abs(region.physicalDeltaY);
        const isSamePhysicalDelta = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);
        if (isSamePhysicalDelta) {
            scale = 1 / physicalDeltaX;
            calibrationType = 'US Region';
            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';
            areaUnit = unit + SQUARE;
        }
        else {
            return {
                unit: PIXEL_UNITS,
                areaUnit: PIXEL_UNITS + SQUARE,
                scale,
                volumeUnit: VOXEL_UNITS,
            };
        }
    }
    else if (calibration.scale) {
        scale = calibration.scale;
    }
    const types = [
        CalibrationTypes.ERMF,
        CalibrationTypes.USER,
        CalibrationTypes.ERROR,
        CalibrationTypes.PROJECTION,
        CalibrationTypes.CALIBRATED,
        CalibrationTypes.UNKNOWN,
    ];
    if (types.includes(calibration?.type)) {
        calibrationType = calibration.type;
    }
    return {
        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),
        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),
        scale,
        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),
    };
};
const getCalibratedProbeUnitsAndValue = (image, handles) => {
    const [imageIndex] = handles;
    const { calibration } = image;
    let units = ['raw'];
    let values = [null];
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { units, values };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));
        if (!supportedRegionsMetadata?.length) {
            return { units, values };
        }
        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&
            imageIndex[0] <= region.regionLocationMaxX1 &&
            imageIndex[1] >= region.regionLocationMinY0 &&
            imageIndex[1] <= region.regionLocationMaxY1);
        if (!region) {
            return { units, values };
        }
        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;
        const { physicalDeltaX, physicalDeltaY } = region;
        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *
            physicalDeltaY;
        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *
            physicalDeltaX;
        calibrationType = 'US Region';
        values = [xValue, yValue];
        units = [
            UNIT_MAPPING[region.physicalUnitsXDirection],
            UNIT_MAPPING[region.physicalUnitsYDirection],
        ];
    }
    return {
        units,
        values,
        calibrationType,
    };
};
const getCalibratedAspect = (image) => image.calibration?.aspect || 1;



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPixelValueUnits: () => (/* binding */ getPixelValueUnits),
/* harmony export */   getPixelValueUnitsImageId: () => (/* binding */ getPixelValueUnitsImageId)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function getPixelValueUnitsImageId(imageId, options) {
    const generalSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('generalSeriesModule', imageId);
    return getPixelValueUnits(generalSeriesModule.modality, imageId, options);
}
function getPixelValueUnits(modality, imageId, options) {
    if (modality === 'CT') {
        return 'HU';
    }
    else if (modality === 'PT') {
        return _handlePTModality(imageId, options);
    }
    else {
        return '';
    }
}
function _handlePTModality(imageId, options) {
    if (!options.isPreScaled) {
        return 'raw';
    }
    if (options.isSuvScaled) {
        return 'SUV';
    }
    const generalSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('generalSeriesModule', imageId);
    if (generalSeriesModule?.modality === 'PT') {
        const petSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('petSeriesModule', imageId);
        return petSeriesModule?.units || 'unitless';
    }
    return 'unknown';
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSphereBoundsInfo: () => (/* binding */ getSphereBoundsInfo),
/* harmony export */   getSphereBoundsInfoFromViewport: () => (/* binding */ getSphereBoundsInfoFromViewport)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _boundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boundingBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js");



const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {
    const [bottom, top] = circlePoints;
    const centerWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
    const radiusWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.distance(bottom, top) / 2;
    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);
    return {
        boundsIJK,
        centerWorld: centerWorld,
        radiusWorld,
        topLeftWorld: topLeftWorld,
        bottomRightWorld: bottomRightWorld,
    };
}
function getSphereBoundsInfo(circlePoints, imageData) {
    const direction = imageData.getDirection();
    const rowCosine = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(direction[0], direction[1], direction[2]);
    const columnCosine = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(direction[3], direction[4], direction[5]);
    const scanAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(direction[6], direction[7], direction[8]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), scanAxis);
    const directionVectors = {
        row: rowCosine,
        column: columnCosine,
        normal: viewPlaneNormal,
    };
    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {
    if (!viewport) {
        throw new Error('viewport is required in order to calculate the sphere bounds');
    }
    const camera = viewport.getCamera();
    const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(viewRight, viewUp, viewPlaneNormal);
    const directionVectors = {
        row: viewRight,
        normal: viewPlaneNormal,
        column: gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), viewUp),
    };
    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {
    const dimensions = imageData.getDimensions();
    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;
    const topLeftWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    const bottomRightWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);
    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);
    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);
    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));
    const boundsIJK = (0,_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeIJK)([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);
    return { boundsIJK, topLeftWorld, bottomRightWorld };
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getToolsWithModesForElement)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");


function getToolsWithModesForElement(element, modesFilter) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngineId, viewportId } = enabledElement;
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__.getToolGroupForViewport)(viewportId, renderingEngineId);
    if (!toolGroup) {
        return [];
    }
    const enabledTools = [];
    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
    for (let j = 0; j < toolGroupToolNames.length; j++) {
        const toolName = toolGroupToolNames[j];
        const toolOptions = toolGroup.toolOptions[toolName];
        if (!toolOptions) {
            continue;
        }
        if (modesFilter.includes(toolOptions.mode)) {
            const toolInstance = toolGroup.getToolInstance(toolName);
            enabledTools.push(toolInstance);
        }
    }
    return enabledTools;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportForAnnotation)
/* harmony export */ });
/* harmony import */ var _getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getViewportsForAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js");

function getViewportForAnnotation(annotation) {
    const viewports = (0,_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_0__["default"])(annotation);
    return viewports.length ? viewports[0] : undefined;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportsForAnnotation)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function getViewportsForAnnotation(annotation) {
    const { metadata } = annotation;
    return (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElements)()
        .filter((enabledElement) => {
        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {
            const viewport = enabledElement.viewport;
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&
                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));
        }
        return;
    })
        .map((enabledElement) => enabledElement.viewport);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function isObject(value) {
    const type = typeof value;
    return value !== null && (type === 'object' || type === 'function');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPoint.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPoint.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPoint)
/* harmony export */ });
/* harmony import */ var _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceToPointSquared */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPointSquared.js");

function distanceToPoint(aabb, point) {
    return Math.sqrt((0,_distanceToPointSquared__WEBPACK_IMPORTED_MODULE_0__["default"])(aabb, point));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPointSquared.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPointSquared.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPointSquared)
/* harmony export */ });
function distanceToPointSquared(aabb, point) {
    const aabbWidth = aabb.maxX - aabb.minX;
    const aabbHeight = aabb.maxY - aabb.minY;
    const aabbSize = [aabbWidth, aabbHeight];
    const aabbCenter = [
        aabb.minX + aabbWidth / 2,
        aabb.minY + aabbHeight / 2,
    ];
    const translatedPoint = [
        Math.abs(point[0] - aabbCenter[0]),
        Math.abs(point[1] - aabbCenter[1]),
    ];
    const dx = translatedPoint[0] - aabbSize[0] * 0.5;
    const dy = translatedPoint[1] - aabbSize[1] * 0.5;
    if (dx > 0 && dy > 0) {
        return dx * dx + dy * dy;
    }
    const dist = Math.max(dx, 0) + Math.max(dy, 0);
    return dist * dist;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/index.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distanceToPoint: () => (/* reexport safe */ _distanceToPoint__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   distanceToPointSquared: () => (/* reexport safe */ _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   intersectAABB: () => (/* reexport safe */ _intersectAABB__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _intersectAABB__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./intersectAABB */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/intersectAABB.js");
/* harmony import */ var _distanceToPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distanceToPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPoint.js");
/* harmony import */ var _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./distanceToPointSquared */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPointSquared.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/intersectAABB.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/intersectAABB.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ intersectAABB)
/* harmony export */ });
function intersectAABB(aabb1, aabb2) {
    return (aabb1.minX <= aabb2.maxX &&
        aabb1.maxX >= aabb2.minX &&
        aabb1.minY <= aabb2.maxY &&
        aabb1.maxY >= aabb2.minY);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ angleBetweenLines)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function angleBetween3DLines(line1, line2) {
    const [p1, p2] = line1;
    const [p3, p4] = line2;
    const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), p2, p1);
    const v2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), p3, p4);
    const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(v1, v2);
    const v1Length = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.length(v1);
    const v2Length = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.length(v2);
    const cos = dot / (v1Length * v2Length);
    const radian = Math.acos(cos);
    return (radian * 180) / Math.PI;
}
function angleBetween2DLines(line1, line2) {
    const [p1, p2] = line1;
    const [p3, p4] = line2;
    const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), p2, p1);
    const v2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(), p3, p4);
    const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.dot(v1, v2);
    const v1Length = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.length(v1);
    const v2Length = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.length(v2);
    const cos = dot / (v1Length * v2Length);
    return Math.acos(cos) * (180 / Math.PI);
}
function angleBetweenLines(line1, line2) {
    const is3D = line1[0].length === 3;
    return is3D
        ? angleBetween3DLines(line1, line2)
        : angleBetween2DLines(line1, line2);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   angleBetweenLines: () => (/* reexport safe */ _angleBetweenLines__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _angleBetweenLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./angleBetweenLines */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicStatsCalculator: () => (/* binding */ BasicStatsCalculator),
/* harmony export */   InstanceBasicStatsCalculator: () => (/* binding */ InstanceBasicStatsCalculator)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _Calculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Calculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/Calculator.js");


const { PointsManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function createBasicStatsState(storePointData) {
    return {
        max: [-Infinity],
        min: [Infinity],
        sum: [0],
        count: 0,
        maxIJK: null,
        maxLPS: null,
        minIJK: null,
        minLPS: null,
        runMean: [0],
        m2: [0],
        m3: [0],
        m4: [0],
        allValues: [[]],
        pointsInShape: storePointData ? PointsManager.create3(1024) : null,
        sumLPS: [0, 0, 0],
    };
}
function basicStatsCallback(state, newValue, pointLPS = null, pointIJK = null) {
    if (Array.isArray(newValue) &&
        newValue.length > 1 &&
        state.max.length === 1) {
        state.max.push(state.max[0], state.max[0]);
        state.min.push(state.min[0], state.min[0]);
        state.sum.push(state.sum[0], state.sum[0]);
        state.runMean.push(0, 0);
        state.m2.push(state.m2[0], state.m2[0]);
        state.m3.push(state.m3[0], state.m3[0]);
        state.m4.push(state.m4[0], state.m4[0]);
        state.allValues.push([], []);
    }
    if (state?.pointsInShape && pointLPS) {
        state.pointsInShape.push(pointLPS);
    }
    const newArray = Array.isArray(newValue) ? newValue : [newValue];
    state.count += 1;
    if (pointLPS) {
        state.sumLPS[0] += pointLPS[0];
        state.sumLPS[1] += pointLPS[1];
        state.sumLPS[2] += pointLPS[2];
    }
    state.max.forEach((it, idx) => {
        const value = newArray[idx];
        state.allValues[idx].push(value);
        const n = state.count;
        const delta = value - state.runMean[idx];
        const delta_n = delta / n;
        const term1 = delta * delta_n * (n - 1);
        state.sum[idx] += value;
        state.runMean[idx] += delta_n;
        state.m4[idx] +=
            term1 * delta_n * delta_n * (n * n - 3 * n + 3) +
                6 * delta_n * delta_n * state.m2[idx] -
                4 * delta_n * state.m3[idx];
        state.m3[idx] += term1 * delta_n * (n - 2) - 3 * delta_n * state.m2[idx];
        state.m2[idx] += term1;
        if (value < state.min[idx]) {
            state.min[idx] = value;
            if (idx === 0) {
                state.minIJK = pointIJK ? [...pointIJK] : null;
                state.minLPS = pointLPS ? [...pointLPS] : null;
            }
        }
        if (value > state.max[idx]) {
            state.max[idx] = value;
            if (idx === 0) {
                state.maxIJK = pointIJK ? [...pointIJK] : null;
                state.maxLPS = pointLPS ? [...pointLPS] : null;
            }
        }
    });
}
function calculateMedian(values) {
    if (values.length === 0) {
        return 0;
    }
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
    }
    else {
        return sorted[mid];
    }
}
function basicGetStatistics(state, unit) {
    const mean = state.sum.map((sum) => sum / state.count);
    const stdDev = state.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / state.count));
    const center = state.sumLPS.map((sum) => sum / state.count);
    const skewness = state.m3.map((m3, idx) => {
        const variance = state.m2[idx] / state.count;
        if (variance === 0) {
            return 0;
        }
        return m3 / (state.count * Math.pow(variance, 1.5));
    });
    const kurtosis = state.m4.map((m4, idx) => {
        const variance = state.m2[idx] / state.count;
        if (variance === 0) {
            return 0;
        }
        return m4 / (state.count * variance * variance) - 3;
    });
    const median = state.allValues.map((values) => calculateMedian(values));
    const named = {
        max: {
            name: 'max',
            label: 'Max Pixel',
            value: state.max.length === 1 ? state.max[0] : state.max,
            unit,
            pointIJK: state.maxIJK ? [...state.maxIJK] : null,
            pointLPS: state.maxLPS ? [...state.maxLPS] : null,
        },
        min: {
            name: 'min',
            label: 'Min Pixel',
            value: state.min.length === 1 ? state.min[0] : state.min,
            unit,
            pointIJK: state.minIJK ? [...state.minIJK] : null,
            pointLPS: state.minLPS ? [...state.minLPS] : null,
        },
        mean: {
            name: 'mean',
            label: 'Mean Pixel',
            value: mean.length === 1 ? mean[0] : mean,
            unit,
        },
        stdDev: {
            name: 'stdDev',
            label: 'Standard Deviation',
            value: stdDev.length === 1 ? stdDev[0] : stdDev,
            unit,
        },
        count: {
            name: 'count',
            label: 'Voxel Count',
            value: state.count,
            unit: null,
        },
        median: {
            name: 'median',
            label: 'Median',
            value: median.length === 1 ? median[0] : median,
            unit,
        },
        skewness: {
            name: 'skewness',
            label: 'Skewness',
            value: skewness.length === 1 ? skewness[0] : skewness,
            unit: null,
        },
        kurtosis: {
            name: 'kurtosis',
            label: 'Kurtosis',
            value: kurtosis.length === 1 ? kurtosis[0] : kurtosis,
            unit: null,
        },
        maxLPS: {
            name: 'maxLPS',
            label: 'Max LPS',
            value: state.maxLPS ? Array.from(state.maxLPS) : null,
            unit: null,
        },
        minLPS: {
            name: 'minLPS',
            label: 'Min LPS',
            value: state.minLPS ? Array.from(state.minLPS) : null,
            unit: null,
        },
        pointsInShape: state.pointsInShape,
        center: {
            name: 'center',
            label: 'Center',
            value: center ? [...center] : null,
            unit: null,
        },
        array: [],
    };
    named.array.push(named.min, named.max, named.mean, named.stdDev, named.median, named.skewness, named.kurtosis, named.count, named.maxLPS, named.minLPS);
    if (named.center.value) {
        named.array.push(named.center);
    }
    const store = state.pointsInShape !== null;
    const freshState = createBasicStatsState(store);
    state.max = freshState.max;
    state.min = freshState.min;
    state.sum = freshState.sum;
    state.count = freshState.count;
    state.maxIJK = freshState.maxIJK;
    state.maxLPS = freshState.maxLPS;
    state.minIJK = freshState.minIJK;
    state.minLPS = freshState.minLPS;
    state.runMean = freshState.runMean;
    state.m2 = freshState.m2;
    state.m3 = freshState.m3;
    state.m4 = freshState.m4;
    state.allValues = freshState.allValues;
    state.pointsInShape = freshState.pointsInShape;
    state.sumLPS = freshState.sumLPS;
    return named;
}
class BasicStatsCalculator extends _Calculator__WEBPACK_IMPORTED_MODULE_1__.Calculator {
    static { this.state = createBasicStatsState(true); }
    static statsInit(options) {
        if (!options.storePointData) {
            this.state.pointsInShape = null;
        }
        this.state = createBasicStatsState(options.storePointData);
    }
    static { this.statsCallback = ({ value: newValue, pointLPS = null, pointIJK = null, }) => {
        basicStatsCallback(this.state, newValue, pointLPS, pointIJK);
    }; }
    static { this.getStatistics = (options) => {
        return basicGetStatistics(this.state, options?.unit);
    }; }
}
class InstanceBasicStatsCalculator extends _Calculator__WEBPACK_IMPORTED_MODULE_1__.InstanceCalculator {
    constructor(options) {
        super(options);
        this.state = createBasicStatsState(options.storePointData);
    }
    statsInit(options) {
        this.state = createBasicStatsState(options.storePointData);
    }
    statsCallback(data) {
        basicStatsCallback(this.state, data.value, data.pointLPS, data.pointIJK);
    }
    getStatistics(options) {
        return basicGetStatistics(this.state, options?.unit);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/Calculator.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/Calculator.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Calculator: () => (/* binding */ Calculator),
/* harmony export */   InstanceCalculator: () => (/* binding */ InstanceCalculator)
/* harmony export */ });
class Calculator {
}
class InstanceCalculator {
    constructor(options) {
        this.storePointData = options.storePointData;
    }
    getStatistics() {
        console.debug('InstanceCalculator getStatistics called');
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicStatsCalculator: () => (/* reexport safe */ _BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__.BasicStatsCalculator),
/* harmony export */   Calculator: () => (/* reexport safe */ _Calculator__WEBPACK_IMPORTED_MODULE_1__.Calculator),
/* harmony export */   InstanceBasicStatsCalculator: () => (/* reexport safe */ _BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__.InstanceBasicStatsCalculator),
/* harmony export */   InstanceCalculator: () => (/* reexport safe */ _Calculator__WEBPACK_IMPORTED_MODULE_1__.InstanceCalculator)
/* harmony export */ });
/* harmony import */ var _BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BasicStatsCalculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js");
/* harmony import */ var _Calculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Calculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/Calculator.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleCorners.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleCorners.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCanvasCircleCorners)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");

function getCanvasCircleCorners(circleCanvasPoints) {
    const [center, end] = circleCanvasPoints;
    const radius = (0,_point__WEBPACK_IMPORTED_MODULE_0__.distanceToPoint)(center, end);
    const topLeft = [center[0] - radius, center[1] - radius];
    const bottomRight = [center[0] + radius, center[1] + radius];
    return [topLeft, bottomRight];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleRadius.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleRadius.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCanvasCircleRadius)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");

function getCanvasCircleRadius(circleCanvasPoints) {
    const [center, end] = circleCanvasPoints;
    return (0,_point__WEBPACK_IMPORTED_MODULE_0__.distanceToPoint)(center, end);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCanvasCircleCorners: () => (/* reexport safe */ _getCanvasCircleCorners__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   getCanvasCircleRadius: () => (/* reexport safe */ _getCanvasCircleRadius__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _getCanvasCircleRadius__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCanvasCircleRadius */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleRadius.js");
/* harmony import */ var _getCanvasCircleCorners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCanvasCircleCorners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleCorners.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCanvasEllipseCorners)
/* harmony export */ });
function getCanvasEllipseCorners(ellipseCanvasPoints) {
    const [bottom, top, left, right] = ellipseCanvasPoints;
    const topLeft = [left[0], top[1]];
    const bottomRight = [right[0], bottom[1]];
    return [topLeft, bottomRight];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCanvasEllipseCorners: () => (/* reexport safe */ _getCanvasEllipseCorners__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   pointInEllipse: () => (/* reexport safe */ _pointInEllipse__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   precalculatePointInEllipse: () => (/* reexport safe */ _pointInEllipse__WEBPACK_IMPORTED_MODULE_0__.precalculatePointInEllipse)
/* harmony export */ });
/* harmony import */ var _pointInEllipse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointInEllipse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/pointInEllipse.js");
/* harmony import */ var _getCanvasEllipseCorners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCanvasEllipseCorners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/pointInEllipse.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/pointInEllipse.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pointInEllipse),
/* harmony export */   precalculatePointInEllipse: () => (/* binding */ precalculatePointInEllipse)
/* harmony export */ });
function pointInEllipse(ellipse, pointLPS, inverts = {}) {
    if (!inverts.precalculated) {
        precalculatePointInEllipse(ellipse, inverts);
    }
    return inverts.precalculated(pointLPS);
}
const precalculatePointInEllipse = (ellipse, inverts = {}) => {
    const { xRadius, yRadius, zRadius } = ellipse;
    if (inverts.invXRadiusSq === undefined ||
        inverts.invYRadiusSq === undefined ||
        inverts.invZRadiusSq === undefined) {
        inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;
        inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;
        inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;
    }
    const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;
    const { center } = ellipse;
    const [centerL, centerP, centerS] = center;
    inverts.precalculated = (pointLPS) => {
        const dx = pointLPS[0] - centerL;
        let inside = dx * dx * invXRadiusSq;
        if (inside > 1) {
            return false;
        }
        const dy = pointLPS[1] - centerP;
        inside += dy * dy * invYRadiusSq;
        if (inside > 1) {
            return false;
        }
        const dz = pointLPS[2] - centerS;
        inside += dz * dz * invZRadiusSq;
        return inside <= 1;
    };
    return inverts;
};



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicStatsCalculator: () => (/* reexport module object */ _basic__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   aabb: () => (/* reexport module object */ _aabb__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   angle: () => (/* reexport module object */ _angle__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   circle: () => (/* reexport module object */ _circle__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   ellipse: () => (/* reexport module object */ _ellipse__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   lineSegment: () => (/* reexport module object */ _line__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   point: () => (/* reexport module object */ _point__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   polyline: () => (/* reexport module object */ _polyline__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   rectangle: () => (/* reexport module object */ _rectangle__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   vec2: () => (/* reexport module object */ _vec2__WEBPACK_IMPORTED_MODULE_8__)
/* harmony export */ });
/* harmony import */ var _aabb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aabb */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/index.js");
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js");
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ellipse */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./polyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rectangle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js");
/* harmony import */ var _vec2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec2 */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/index.js");
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./angle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/index.js");













/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPoint)
/* harmony export */ });
/* harmony import */ var _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceToPointSquared */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js");

function distanceToPoint(lineStart, lineEnd, point) {
    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {
        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');
    }
    return Math.sqrt((0,_distanceToPointSquared__WEBPACK_IMPORTED_MODULE_0__["default"])(lineStart, lineEnd, point));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPointSquared)
/* harmony export */ });
/* harmony import */ var _distanceToPointSquaredInfo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceToPointSquaredInfo */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquaredInfo.js");

function distanceToPointSquared(lineStart, lineEnd, point) {
    return (0,_distanceToPointSquaredInfo__WEBPACK_IMPORTED_MODULE_0__["default"])(lineStart, lineEnd, point).distanceSquared;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquaredInfo.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquaredInfo.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPointSquaredInfo)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");

function distanceToPointSquaredInfo(lineStart, lineEnd, point) {
    let closestPoint;
    const distanceSquared = (0,_point__WEBPACK_IMPORTED_MODULE_0__.distanceToPointSquared)(lineStart, lineEnd);
    if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {
        closestPoint = lineStart;
    }
    if (!closestPoint) {
        const dotProduct = ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +
            (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /
            distanceSquared;
        if (dotProduct < 0) {
            closestPoint = lineStart;
        }
        else if (dotProduct > 1) {
            closestPoint = lineEnd;
        }
        else {
            closestPoint = [
                lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),
                lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),
            ];
        }
    }
    return {
        point: [...closestPoint],
        distanceSquared: (0,_point__WEBPACK_IMPORTED_MODULE_0__.distanceToPointSquared)(point, closestPoint),
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distanceToPoint: () => (/* reexport safe */ _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   distanceToPointSquared: () => (/* reexport safe */ _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   distanceToPointSquaredInfo: () => (/* reexport safe */ _distanceToPointSquaredInfo__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   intersectLine: () => (/* reexport safe */ _intersectLine__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   isPointOnLineSegment: () => (/* reexport safe */ _isPointOnLineSegment__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceToPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js");
/* harmony import */ var _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distanceToPointSquared */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js");
/* harmony import */ var _distanceToPointSquaredInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./distanceToPointSquaredInfo */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquaredInfo.js");
/* harmony import */ var _intersectLine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./intersectLine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js");
/* harmony import */ var _isPointOnLineSegment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isPointOnLineSegment */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/isPointOnLineSegment.js");








/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ intersectLine)
/* harmony export */ });
function sign(x) {
    return typeof x === 'number'
        ? x
            ? x < 0
                ? -1
                : 1
            : x === x
                ? 0
                : NaN
        : NaN;
}
function intersectLine(line1Start, line1End, line2Start, line2End) {
    const [x1, y1] = line1Start;
    const [x2, y2] = line1End;
    const [x3, y3] = line2Start;
    const [x4, y4] = line2End;
    const a1 = y2 - y1;
    const b1 = x1 - x2;
    const c1 = x2 * y1 - x1 * y2;
    const r3 = a1 * x3 + b1 * y3 + c1;
    const r4 = a1 * x4 + b1 * y4 + c1;
    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {
        return;
    }
    const a2 = y4 - y3;
    const b2 = x3 - x4;
    const c2 = x4 * y3 - x3 * y4;
    const r1 = a2 * x1 + b2 * y1 + c2;
    const r2 = a2 * x2 + b2 * y2 + c2;
    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {
        return;
    }
    const denom = a1 * b2 - a2 * b1;
    let num;
    num = b1 * c2 - b2 * c1;
    const x = num / denom;
    num = a2 * c1 - a1 * c2;
    const y = num / denom;
    const intersectionPoint = [x, y];
    return intersectionPoint;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/isPointOnLineSegment.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/isPointOnLineSegment.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isPointOnLineSegment)
/* harmony export */ });
const ORIENTATION_TOLERANCE = 1e-2;
function isPointOnLineSegment(lineStart, lineEnd, point) {
    const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];
    const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];
    const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];
    const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];
    const aabbContainsPoint = point[0] >= minX - ORIENTATION_TOLERANCE &&
        point[0] <= maxX + ORIENTATION_TOLERANCE &&
        point[1] >= minY - ORIENTATION_TOLERANCE &&
        point[1] <= maxY + ORIENTATION_TOLERANCE;
    if (!aabbContainsPoint) {
        return false;
    }
    const orientation = (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -
        (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);
    const absOrientation = orientation >= 0 ? orientation : -orientation;
    return absOrientation <= ORIENTATION_TOLERANCE;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPoint)
/* harmony export */ });
/* harmony import */ var _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceToPointSquared */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPointSquared.js");

function distanceToPoint(p1, p2) {
    return Math.sqrt((0,_distanceToPointSquared__WEBPACK_IMPORTED_MODULE_0__["default"])(p1, p2));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPointSquared.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPointSquared.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPointSquared)
/* harmony export */ });
function distanceToPointSquared(p1, p2) {
    if (p1.length !== p2.length) {
        throw Error('Both points should have the same dimensionality');
    }
    const [x1, y1, z1 = 0] = p1;
    const [x2, y2, z2 = 0] = p2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dz = z2 - z1;
    return dx * dx + dy * dy + dz * dz;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js":
/*!*****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distanceToPoint: () => (/* reexport safe */ _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   distanceToPointSquared: () => (/* reexport safe */ _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   mirror: () => (/* reexport safe */ _mirror__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceToPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js");
/* harmony import */ var _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distanceToPointSquared */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPointSquared.js");
/* harmony import */ var _mirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mirror */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/mirror.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/mirror.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/mirror.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mirror)
/* harmony export */ });
function mirror(mirrorPoint, staticPoint) {
    const [x1, y1] = mirrorPoint;
    const [x2, y2] = staticPoint;
    const newX = 2 * x2 - x1;
    const newY = 2 * y2 - y1;
    return [newX, newY];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");


const addCanvasPointsToArray = (element, canvasPoints, newCanvasPoint, commonData) => {
    const { xDir, yDir, spacing } = commonData;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewport } = enabledElement;
    if (!canvasPoints.length) {
        canvasPoints.push(newCanvasPoint);
        console.log('>>>>> !canvasPoints. :: RETURN');
        return 1;
    }
    const lastWorldPos = viewport.canvasToWorld(canvasPoints[canvasPoints.length - 1]);
    const newWorldPos = viewport.canvasToWorld(newCanvasPoint);
    const worldPosDiff = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);
    const xDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(worldPosDiff, xDir));
    const yDist = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(worldPosDiff, yDir));
    const numPointsToAdd = Math.max(Math.floor(xDist / spacing[0]), Math.floor(yDist / spacing[0]));
    if (numPointsToAdd > 1) {
        const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];
        const canvasDist = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec2.dist(lastCanvasPoint, newCanvasPoint);
        const canvasDir = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec2.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);
        const distPerPoint = canvasDist / numPointsToAdd;
        for (let i = 1; i <= numPointsToAdd; i++) {
            canvasPoints.push([
                lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,
                lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,
            ]);
        }
    }
    else {
        canvasPoints.push(newCanvasPoint);
    }
    return numPointsToAdd;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addCanvasPointsToArray);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ areLineSegmentsIntersecting)
/* harmony export */ });
function areLineSegmentsIntersecting(p1, q1, p2, q2) {
    let result = false;
    const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];
    const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];
    const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];
    const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];
    const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];
    const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];
    const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];
    const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];
    if (line1MinX > line2MaxX ||
        line1MaxX < line2MinX ||
        line1MinY > line2MaxY ||
        line1MaxY < line2MinY) {
        return false;
    }
    const orient = [
        orientation(p1, q1, p2),
        orientation(p1, q1, q2),
        orientation(p2, q2, p1),
        orientation(p2, q2, q1),
    ];
    if (orient[0] !== orient[1] && orient[2] !== orient[3]) {
        return true;
    }
    if (orient[0] === 0 && onSegment(p1, p2, q1)) {
        result = true;
    }
    else if (orient[1] === 0 && onSegment(p1, q2, q1)) {
        result = true;
    }
    else if (orient[2] === 0 && onSegment(p2, p1, q2)) {
        result = true;
    }
    else if (orient[3] === 0 && onSegment(p2, q1, q2)) {
        result = true;
    }
    return result;
}
function orientation(p, q, r) {
    const orientationValue = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    if (orientationValue === 0) {
        return 0;
    }
    return orientationValue > 0 ? 1 : 2;
}
function onSegment(p, q, r) {
    if (q[0] <= Math.max(p[0], r[0]) &&
        q[0] >= Math.min(p[0], r[0]) &&
        q[1] <= Math.max(p[1], r[1]) &&
        q[1] >= Math.min(p[1], r[1])) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/combinePolyline.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/combinePolyline.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergePolylines: () => (/* binding */ mergePolylines),
/* harmony export */   subtractPolylines: () => (/* binding */ subtractPolylines)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");
/* harmony import */ var _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getLineSegmentIntersectionsIndexes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js");
/* harmony import */ var _containsPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./containsPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js");
/* harmony import */ var _getNormal2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getNormal2 */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal2.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _getLinesIntersection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getLinesIntersection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLinesIntersection.js");






var PolylinePointType;
(function (PolylinePointType) {
    PolylinePointType[PolylinePointType["Vertex"] = 0] = "Vertex";
    PolylinePointType[PolylinePointType["Intersection"] = 1] = "Intersection";
})(PolylinePointType || (PolylinePointType = {}));
var PolylinePointPosition;
(function (PolylinePointPosition) {
    PolylinePointPosition[PolylinePointPosition["Outside"] = -1] = "Outside";
    PolylinePointPosition[PolylinePointPosition["Edge"] = 0] = "Edge";
    PolylinePointPosition[PolylinePointPosition["Inside"] = 1] = "Inside";
})(PolylinePointPosition || (PolylinePointPosition = {}));
var PolylinePointDirection;
(function (PolylinePointDirection) {
    PolylinePointDirection[PolylinePointDirection["Exiting"] = -1] = "Exiting";
    PolylinePointDirection[PolylinePointDirection["Unknown"] = 0] = "Unknown";
    PolylinePointDirection[PolylinePointDirection["Entering"] = 1] = "Entering";
})(PolylinePointDirection || (PolylinePointDirection = {}));
function ensuresNextPointers(polylinePoints) {
    for (let i = 0, len = polylinePoints.length; i < len; i++) {
        const currentPoint = polylinePoints[i];
        if (!currentPoint.next) {
            currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];
        }
    }
}
function getSourceAndTargetPointsList(targetPolyline, sourcePolyline) {
    const targetPolylinePoints = [];
    const sourcePolylinePoints = [];
    const sourceIntersectionsCache = new Map();
    const isFirstPointInside = (0,_containsPoint__WEBPACK_IMPORTED_MODULE_2__["default"])(sourcePolyline, targetPolyline[0]);
    let intersectionPointDirection = isFirstPointInside
        ? PolylinePointDirection.Exiting
        : PolylinePointDirection.Entering;
    for (let i = 0, len = targetPolyline.length; i < len; i++) {
        const p1 = targetPolyline[i];
        const pointInside = (0,_containsPoint__WEBPACK_IMPORTED_MODULE_2__["default"])(sourcePolyline, p1);
        const vertexPoint = {
            type: PolylinePointType.Vertex,
            coordinates: p1,
            position: pointInside
                ? PolylinePointPosition.Inside
                : PolylinePointPosition.Outside,
            visited: false,
            next: null,
        };
        targetPolylinePoints.push(vertexPoint);
        const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];
        const intersectionsInfo = (0,_getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_1__["default"])(sourcePolyline, p1, q1).map((intersectedLineSegment) => {
            const sourceLineSegmentId = intersectedLineSegment[0];
            const p2 = sourcePolyline[intersectedLineSegment[0]];
            const q2 = sourcePolyline[intersectedLineSegment[1]];
            const intersectionCoordinate = (0,_getLinesIntersection__WEBPACK_IMPORTED_MODULE_5__["default"])(p1, q1, p2, q2);
            const targetStartPointDistSquared = _point__WEBPACK_IMPORTED_MODULE_0__.distanceToPointSquared(p1, intersectionCoordinate);
            return {
                sourceLineSegmentId,
                coordinate: intersectionCoordinate,
                targetStartPointDistSquared,
            };
        });
        intersectionsInfo.sort((left, right) => left.targetStartPointDistSquared - right.targetStartPointDistSquared);
        intersectionsInfo.forEach((intersectionInfo) => {
            const { sourceLineSegmentId, coordinate: intersectionCoordinate } = intersectionInfo;
            const targetEdgePoint = {
                type: PolylinePointType.Intersection,
                coordinates: intersectionCoordinate,
                position: PolylinePointPosition.Edge,
                direction: intersectionPointDirection,
                visited: false,
                next: null,
            };
            const sourceEdgePoint = {
                ...targetEdgePoint,
                direction: PolylinePointDirection.Unknown,
                cloned: true,
            };
            if (intersectionPointDirection === PolylinePointDirection.Entering) {
                targetEdgePoint.next = sourceEdgePoint;
            }
            else {
                sourceEdgePoint.next = targetEdgePoint;
            }
            let sourceIntersectionPoints = sourceIntersectionsCache.get(sourceLineSegmentId);
            if (!sourceIntersectionPoints) {
                sourceIntersectionPoints = [];
                sourceIntersectionsCache.set(sourceLineSegmentId, sourceIntersectionPoints);
            }
            targetPolylinePoints.push(targetEdgePoint);
            sourceIntersectionPoints.push(sourceEdgePoint);
            intersectionPointDirection *= -1;
        });
    }
    for (let i = 0, len = sourcePolyline.length; i < len; i++) {
        const lineSegmentId = i;
        const p1 = sourcePolyline[i];
        const vertexPoint = {
            type: PolylinePointType.Vertex,
            coordinates: p1,
            visited: false,
            next: null,
        };
        sourcePolylinePoints.push(vertexPoint);
        const sourceIntersectionPoints = sourceIntersectionsCache.get(lineSegmentId);
        if (!sourceIntersectionPoints?.length) {
            continue;
        }
        sourceIntersectionPoints
            .map((intersectionPoint) => ({
            intersectionPoint,
            lineSegStartDistSquared: _point__WEBPACK_IMPORTED_MODULE_0__.distanceToPointSquared(p1, intersectionPoint.coordinates),
        }))
            .sort((left, right) => left.lineSegStartDistSquared - right.lineSegStartDistSquared)
            .map(({ intersectionPoint }) => intersectionPoint)
            .forEach((intersectionPoint) => sourcePolylinePoints.push(intersectionPoint));
    }
    ensuresNextPointers(targetPolylinePoints);
    ensuresNextPointers(sourcePolylinePoints);
    return { targetPolylinePoints, sourcePolylinePoints };
}
function getUnvisitedOutsidePoint(polylinePoints) {
    for (let i = 0, len = polylinePoints.length; i < len; i++) {
        const point = polylinePoints[i];
        if (!point.visited && point.position === PolylinePointPosition.Outside) {
            return point;
        }
    }
}
function mergePolylines(targetPolyline, sourcePolyline) {
    const targetNormal = (0,_getNormal2__WEBPACK_IMPORTED_MODULE_3__["default"])(targetPolyline);
    const sourceNormal = (0,_getNormal2__WEBPACK_IMPORTED_MODULE_3__["default"])(sourcePolyline);
    const dotNormals = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.dot(sourceNormal, targetNormal);
    if (!gl_matrix__WEBPACK_IMPORTED_MODULE_4__.glMatrix.equals(1, dotNormals)) {
        sourcePolyline = sourcePolyline.slice().reverse();
    }
    const { targetPolylinePoints } = getSourceAndTargetPointsList(targetPolyline, sourcePolyline);
    const startPoint = getUnvisitedOutsidePoint(targetPolylinePoints);
    if (!startPoint) {
        return targetPolyline.slice();
    }
    const mergedPolyline = [startPoint.coordinates];
    let currentPoint = startPoint.next;
    while (currentPoint !== startPoint) {
        if (currentPoint.type === PolylinePointType.Intersection &&
            currentPoint.cloned) {
            currentPoint = currentPoint.next;
            continue;
        }
        mergedPolyline.push(currentPoint.coordinates);
        currentPoint = currentPoint.next;
    }
    return mergedPolyline;
}
function subtractPolylines(targetPolyline, sourcePolyline) {
    const targetNormal = (0,_getNormal2__WEBPACK_IMPORTED_MODULE_3__["default"])(targetPolyline);
    const sourceNormal = (0,_getNormal2__WEBPACK_IMPORTED_MODULE_3__["default"])(sourcePolyline);
    const dotNormals = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.dot(sourceNormal, targetNormal);
    if (!gl_matrix__WEBPACK_IMPORTED_MODULE_4__.glMatrix.equals(-1, dotNormals)) {
        sourcePolyline = sourcePolyline.slice().reverse();
    }
    const { targetPolylinePoints } = getSourceAndTargetPointsList(targetPolyline, sourcePolyline);
    let startPoint = null;
    const subtractedPolylines = [];
    while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {
        const subtractedPolyline = [startPoint.coordinates];
        let currentPoint = startPoint.next;
        startPoint.visited = true;
        while (currentPoint !== startPoint) {
            currentPoint.visited = true;
            if (currentPoint.type === PolylinePointType.Intersection &&
                currentPoint.cloned) {
                currentPoint = currentPoint.next;
                continue;
            }
            subtractedPolyline.push(currentPoint.coordinates);
            currentPoint = currentPoint.next;
        }
        subtractedPolylines.push(subtractedPolyline);
    }
    return subtractedPolylines;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ containsPoint)
/* harmony export */ });
/* harmony import */ var _isClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isClosed */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js");

function containsPoint(polyline, point, options = {
    closed: undefined,
}) {
    if (polyline.length < 3) {
        return false;
    }
    const numPolylinePoints = polyline.length;
    let numIntersections = 0;
    const { closed, holes } = options;
    if (holes?.length) {
        for (const hole of holes) {
            if (containsPoint(hole, point)) {
                return false;
            }
        }
    }
    const shouldClose = !(closed === undefined ? (0,_isClosed__WEBPACK_IMPORTED_MODULE_0__["default"])(polyline) : closed);
    const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);
    for (let i = 0; i <= maxSegmentIndex; i++) {
        const p1 = polyline[i];
        const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;
        const p2 = polyline[p2Index];
        const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];
        const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];
        const minY = p1[1] <= p2[1] ? p1[1] : p2[1];
        const mayIntersectLineSegment = point[0] <= maxX && point[1] >= minY && point[1] < maxY;
        if (mayIntersectLineSegment) {
            const isVerticalLine = p1[0] === p2[0];
            let intersects = isVerticalLine;
            if (!intersects) {
                const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];
                intersects = point[0] <= xIntersection;
            }
            numIntersections += intersects ? 1 : 0;
        }
    }
    return !!(numIntersections % 2);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoints.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoints.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ containsPoints)
/* harmony export */ });
/* harmony import */ var _containsPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./containsPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js");

function containsPoints(polyline, points) {
    for (let i = 0, numPoint = points.length; i < numPoint; i++) {
        if (!(0,_containsPoint__WEBPACK_IMPORTED_MODULE_0__["default"])(polyline, points[i])) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/decimate.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/decimate.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ decimate)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");

const DEFAULT_EPSILON = 0.1;
function decimate(polyline, epsilon = DEFAULT_EPSILON) {
    const numPoints = polyline.length;
    if (numPoints < 3) {
        return polyline;
    }
    const epsilonSquared = epsilon * epsilon;
    const partitionQueue = [[0, numPoints - 1]];
    const polylinePointFlags = new Array(numPoints).fill(false);
    let numDecimatedPoints = 2;
    polylinePointFlags[0] = true;
    polylinePointFlags[numPoints - 1] = true;
    while (partitionQueue.length) {
        const [startIndex, endIndex] = partitionQueue.pop();
        if (endIndex - startIndex === 1) {
            continue;
        }
        const startPoint = polyline[startIndex];
        const endPoint = polyline[endIndex];
        let maxDistSquared = -Infinity;
        let maxDistIndex = -1;
        for (let i = startIndex + 1; i < endIndex; i++) {
            const currentPoint = polyline[i];
            const distSquared = _line__WEBPACK_IMPORTED_MODULE_0__.distanceToPointSquared(startPoint, endPoint, currentPoint);
            if (distSquared > maxDistSquared) {
                maxDistSquared = distSquared;
                maxDistIndex = i;
            }
        }
        if (maxDistSquared < epsilonSquared) {
            continue;
        }
        polylinePointFlags[maxDistIndex] = true;
        numDecimatedPoints++;
        partitionQueue.push([maxDistIndex, endIndex]);
        partitionQueue.push([startIndex, maxDistIndex]);
    }
    const decimatedPolyline = new Array(numDecimatedPoints);
    for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {
        if (polylinePointFlags[srcIndex]) {
            decimatedPolyline[dstIndex++] = polyline[srcIndex];
        }
    }
    return decimatedPolyline;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getAABB.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getAABB.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAABB)
/* harmony export */ });
function getAABB(polyline, options) {
    let polylineToUse = polyline;
    const numDimensions = options?.numDimensions || 2;
    const is3D = numDimensions === 3;
    if (!Array.isArray(polyline[0])) {
        const currentPolyline = polyline;
        const totalPoints = currentPolyline.length / numDimensions;
        polylineToUse = new Array(currentPolyline.length / numDimensions);
        for (let i = 0, len = totalPoints; i < len; i++) {
            polylineToUse[i] = [
                currentPolyline[i * numDimensions],
                currentPolyline[i * numDimensions + 1],
            ];
            if (is3D) {
                polylineToUse[i].push(currentPolyline[i * numDimensions + 2]);
            }
        }
    }
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let minZ = Infinity;
    let maxZ = -Infinity;
    polylineToUse = polylineToUse;
    for (let i = 0, len = polylineToUse.length; i < len; i++) {
        const [x, y, z] = polylineToUse[i];
        minX = minX < x ? minX : x;
        minY = minY < y ? minY : y;
        maxX = maxX > x ? maxX : x;
        maxY = maxY > y ? maxY : y;
        if (is3D) {
            minZ = minZ < z ? minZ : z;
            maxZ = maxZ > z ? maxZ : z;
        }
    }
    return is3D
        ? { minX, maxX, minY, maxY, minZ, maxZ }
        : { minX, maxX, minY, maxY };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getArea.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getArea.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getArea)
/* harmony export */ });
function getArea(points) {
    const n = points.length;
    let area = 0.0;
    let j = n - 1;
    for (let i = 0; i < n; i++) {
        area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);
        j = i;
    }
    return Math.abs(area / 2.0);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getClosestLineSegmentIntersection.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getClosestLineSegmentIntersection.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClosestLineSegmentIntersection)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _areLineSegmentsIntersecting__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./areLineSegmentsIntersecting */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js");


function getClosestLineSegmentIntersection(points, p1, q1, closed = true) {
    let initialQ2Index;
    let p2Index;
    if (closed) {
        p2Index = points.length - 1;
        initialQ2Index = 0;
    }
    else {
        p2Index = 0;
        initialQ2Index = 1;
    }
    const intersections = [];
    for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {
        const p2 = points[p2Index];
        const q2 = points[q2Index];
        if ((0,_areLineSegmentsIntersecting__WEBPACK_IMPORTED_MODULE_1__["default"])(p1, q1, p2, q2)) {
            intersections.push([p2Index, q2Index]);
        }
        p2Index = q2Index;
    }
    if (intersections.length === 0) {
        return;
    }
    const distances = [];
    intersections.forEach((intersection) => {
        const intersectionPoints = [
            points[intersection[0]],
            points[intersection[1]],
        ];
        const midpoint = [
            (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,
            (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,
        ];
        distances.push(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(midpoint, p1));
    });
    const minDistance = Math.min(...distances);
    const indexOfMinDistance = distances.indexOf(minDistance);
    return {
        segment: intersections[indexOfMinDistance],
        distance: minDistance,
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFirstLineSegmentIntersectionIndexes)
/* harmony export */ });
/* harmony import */ var _areLineSegmentsIntersecting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./areLineSegmentsIntersecting */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js");

function getFirstLineSegmentIntersectionIndexes(points, p1, q1, closed = true) {
    let initialI;
    let j;
    if (closed) {
        j = points.length - 1;
        initialI = 0;
    }
    else {
        j = 0;
        initialI = 1;
    }
    for (let i = initialI; i < points.length; i++) {
        const p2 = points[j];
        const q2 = points[i];
        if ((0,_areLineSegmentsIntersecting__WEBPACK_IMPORTED_MODULE_0__["default"])(p1, q1, p2, q2)) {
            return [j, i];
        }
        j = i;
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLineSegmentIntersectionsCoordinates)
/* harmony export */ });
/* harmony import */ var _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getLineSegmentIntersectionsIndexes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js");
/* harmony import */ var _getLinesIntersection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getLinesIntersection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLinesIntersection.js");


function getLineSegmentIntersectionsCoordinates(points, p1, q1, closed = true) {
    const result = [];
    const polylineIndexes = (0,_getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_0__["default"])(points, p1, q1, closed);
    for (let i = 0; i < polylineIndexes.length; i++) {
        const p2 = points[polylineIndexes[i][0]];
        const q2 = points[polylineIndexes[i][1]];
        const intersection = (0,_getLinesIntersection__WEBPACK_IMPORTED_MODULE_1__["default"])(p1, q1, p2, q2);
        result.push(intersection);
    }
    return result;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLineSegmentIntersectionsIndexes)
/* harmony export */ });
/* harmony import */ var _areLineSegmentsIntersecting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./areLineSegmentsIntersecting */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js");

function getLineSegmentIntersectionsIndexes(polyline, p1, q1, closed = true) {
    const intersections = [];
    const numPoints = polyline.length;
    const maxI = numPoints - (closed ? 1 : 2);
    for (let i = 0; i <= maxI; i++) {
        const p2 = polyline[i];
        const j = i === numPoints - 1 ? 0 : i + 1;
        const q2 = polyline[j];
        if ((0,_areLineSegmentsIntersecting__WEBPACK_IMPORTED_MODULE_0__["default"])(p1, q1, p2, q2)) {
            intersections.push([i, j]);
        }
    }
    return intersections;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLinesIntersection.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLinesIntersection.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLinesIntersection)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");

const PARALLEL_LINES_TOLERANCE = 1e-2;
function getLinesIntersection(p1, q1, p2, q2) {
    const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];
    const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];
    const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];
    const absDenominator = denominator >= 0 ? denominator : -denominator;
    if (absDenominator < PARALLEL_LINES_TOLERANCE) {
        const line1AABB = [
            p1[0] < q1[0] ? p1[0] : q1[0],
            p1[0] > q1[0] ? p1[0] : q1[0],
            p1[1] < q1[1] ? p1[1] : q1[1],
            p1[1] > q1[1] ? p1[1] : q1[1],
        ];
        const line2AABB = [
            p2[0] < q2[0] ? p2[0] : q2[0],
            p2[0] > q2[0] ? p2[0] : q2[0],
            p2[1] < q2[1] ? p2[1] : q2[1],
            p2[1] > q2[1] ? p2[1] : q2[1],
        ];
        const aabbIntersects = line1AABB[0] <= line2AABB[1] &&
            line1AABB[1] >= line2AABB[0] &&
            line1AABB[2] <= line2AABB[3] &&
            line1AABB[3] >= line2AABB[2];
        if (!aabbIntersects) {
            return;
        }
        const overlap = _line__WEBPACK_IMPORTED_MODULE_0__.isPointOnLineSegment(p1, q1, p2) ||
            _line__WEBPACK_IMPORTED_MODULE_0__.isPointOnLineSegment(p1, q1, q2) ||
            _line__WEBPACK_IMPORTED_MODULE_0__.isPointOnLineSegment(p2, q2, p1);
        if (!overlap) {
            return;
        }
        const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];
        const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];
        const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];
        const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];
        const midX = (minX + maxX) * 0.5;
        const midY = (minY + maxY) * 0.5;
        return [midX, midY];
    }
    let a = p1[1] - p2[1];
    let b = p1[0] - p2[0];
    const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;
    const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;
    a = numerator1 / denominator;
    b = numerator2 / denominator;
    const resultX = p1[0] + a * diffQ1P1[0];
    const resultY = p1[1] + a * diffQ1P1[1];
    return [resultX, resultY];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal2.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal2.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNormal2)
/* harmony export */ });
/* harmony import */ var _getSignedArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSignedArea */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js");

function getNormal2(polyline) {
    const area = (0,_getSignedArea__WEBPACK_IMPORTED_MODULE_0__["default"])(polyline);
    return [0, 0, area / Math.abs(area)];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal3.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal3.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNormal3)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function _getAreaVector(polyline) {
    const vecArea = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    const refPoint = polyline[0];
    for (let i = 0, len = polyline.length; i < len; i++) {
        const p1 = polyline[i];
        const p2Index = i === len - 1 ? 0 : i + 1;
        const p2 = polyline[p2Index];
        const aX = p1[0] - refPoint[0];
        const aY = p1[1] - refPoint[1];
        const aZ = p1[2] - refPoint[2];
        const bX = p2[0] - refPoint[0];
        const bY = p2[1] - refPoint[1];
        const bZ = p2[2] - refPoint[2];
        vecArea[0] += aY * bZ - aZ * bY;
        vecArea[1] += aZ * bX - aX * bZ;
        vecArea[2] += aX * bY - aY * bX;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scale(vecArea, vecArea, 0.5);
    return vecArea;
}
function getNormal3(polyline) {
    const vecArea = _getAreaVector(polyline);
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(vecArea, vecArea);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getSignedArea)
/* harmony export */ });
function getSignedArea(polyline) {
    if (polyline.length < 3) {
        return 0;
    }
    const refPoint = polyline[0];
    let area = 0;
    for (let i = 0, len = polyline.length; i < len; i++) {
        const p1 = polyline[i];
        const p2Index = i === len - 1 ? 0 : i + 1;
        const p2 = polyline[p2Index];
        const aX = p1[0] - refPoint[0];
        const aY = p1[1] - refPoint[1];
        const bX = p2[0] - refPoint[0];
        const bY = p2[1] - refPoint[1];
        area += aX * bY - aY * bX;
    }
    area *= 0.5;
    return area;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");


const EPSILON = 1e-3;
const getSubPixelSpacingAndXYDirections = (viewport, subPixelResolution) => {
    let spacing;
    let xDir;
    let yDir;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        const imageData = viewport.getImageData();
        if (!imageData) {
            return;
        }
        xDir = imageData.direction.slice(0, 3);
        yDir = imageData.direction.slice(3, 6);
        spacing = imageData.spacing;
    }
    else {
        const imageData = viewport.getImageData();
        const { direction, spacing: volumeSpacing } = imageData;
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        const iVector = direction.slice(0, 3);
        const jVector = direction.slice(3, 6);
        const kVector = direction.slice(6, 9);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(viewRight, viewUp, viewPlaneNormal);
        const absViewRightDotI = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewRight, iVector));
        const absViewRightDotJ = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewRight, jVector));
        const absViewRightDotK = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewRight, kVector));
        let xSpacing;
        if (Math.abs(1 - absViewRightDotI) < EPSILON) {
            xSpacing = volumeSpacing[0];
            xDir = iVector;
        }
        else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {
            xSpacing = volumeSpacing[1];
            xDir = jVector;
        }
        else if (Math.abs(1 - absViewRightDotK) < EPSILON) {
            xSpacing = volumeSpacing[2];
            xDir = kVector;
        }
        else {
            throw new Error('No support yet for oblique plane planar contours');
        }
        const absViewUpDotI = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewUp, iVector));
        const absViewUpDotJ = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewUp, jVector));
        const absViewUpDotK = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(viewUp, kVector));
        let ySpacing;
        if (Math.abs(1 - absViewUpDotI) < EPSILON) {
            ySpacing = volumeSpacing[0];
            yDir = iVector;
        }
        else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {
            ySpacing = volumeSpacing[1];
            yDir = jVector;
        }
        else if (Math.abs(1 - absViewUpDotK) < EPSILON) {
            ySpacing = volumeSpacing[2];
            yDir = kVector;
        }
        else {
            throw new Error('No support yet for oblique plane planar contours');
        }
        spacing = [xSpacing, ySpacing];
    }
    const subPixelSpacing = [
        spacing[0] / subPixelResolution,
        spacing[1] / subPixelResolution,
    ];
    return { spacing: subPixelSpacing, xDir, yDir };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSubPixelSpacingAndXYDirections);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getWindingDirection.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getWindingDirection.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindingDirection)
/* harmony export */ });
/* harmony import */ var _getSignedArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSignedArea */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js");

function getWindingDirection(polyline) {
    const signedArea = (0,_getSignedArea__WEBPACK_IMPORTED_MODULE_0__["default"])(polyline);
    return signedArea >= 0 ? 1 : -1;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js":
/*!********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addCanvasPointsToArray: () => (/* reexport safe */ _addCanvasPointsToArray__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   containsPoint: () => (/* reexport safe */ _containsPoint__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   containsPoints: () => (/* reexport safe */ _containsPoints__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   decimate: () => (/* reexport safe */ _decimate__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   getAABB: () => (/* reexport safe */ _getAABB__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   getArea: () => (/* reexport safe */ _getArea__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   getClosestLineSegmentIntersection: () => (/* reexport safe */ _getClosestLineSegmentIntersection__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   getFirstLineSegmentIntersectionIndexes: () => (/* reexport safe */ _getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   getLineSegmentIntersectionsCoordinates: () => (/* reexport safe */ _getLineSegmentIntersectionsCoordinates__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   getLineSegmentIntersectionsIndexes: () => (/* reexport safe */ _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   getNormal2: () => (/* reexport safe */ _getNormal2__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   getNormal3: () => (/* reexport safe */ _getNormal3__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   getSignedArea: () => (/* reexport safe */ _getSignedArea__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   getSubPixelSpacingAndXYDirections: () => (/* reexport safe */ _getSubPixelSpacingAndXYDirections__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   getWindingDirection: () => (/* reexport safe */ _getWindingDirection__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   intersectPolyline: () => (/* reexport safe */ _intersectPolyline__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   isClosed: () => (/* reexport safe */ _isClosed__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   isPointInsidePolyline3D: () => (/* reexport safe */ _isPointInsidePolyline3D__WEBPACK_IMPORTED_MODULE_20__.isPointInsidePolyline3D),
/* harmony export */   mergePolylines: () => (/* reexport safe */ _combinePolyline__WEBPACK_IMPORTED_MODULE_9__.mergePolylines),
/* harmony export */   pointCanProjectOnLine: () => (/* reexport safe */ _pointCanProjectOnLine__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   pointsAreWithinCloseContourProximity: () => (/* reexport safe */ _pointsAreWithinCloseContourProximity__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   projectTo2D: () => (/* reexport safe */ _projectTo2D__WEBPACK_IMPORTED_MODULE_21__.projectTo2D),
/* harmony export */   subtractPolylines: () => (/* reexport safe */ _combinePolyline__WEBPACK_IMPORTED_MODULE_9__.subtractPolylines)
/* harmony export */ });
/* harmony import */ var _isClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isClosed */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js");
/* harmony import */ var _containsPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./containsPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js");
/* harmony import */ var _containsPoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./containsPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoints.js");
/* harmony import */ var _getAABB__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getAABB */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getAABB.js");
/* harmony import */ var _getArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getArea */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getArea.js");
/* harmony import */ var _getSignedArea__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getSignedArea */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js");
/* harmony import */ var _getWindingDirection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getWindingDirection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getWindingDirection.js");
/* harmony import */ var _getNormal3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getNormal3 */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal3.js");
/* harmony import */ var _getNormal2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getNormal2 */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal2.js");
/* harmony import */ var _combinePolyline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./combinePolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/combinePolyline.js");
/* harmony import */ var _intersectPolyline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./intersectPolyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolyline.js");
/* harmony import */ var _decimate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./decimate */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/decimate.js");
/* harmony import */ var _getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getFirstLineSegmentIntersectionIndexes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.js");
/* harmony import */ var _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./getLineSegmentIntersectionsIndexes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js");
/* harmony import */ var _getLineSegmentIntersectionsCoordinates__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./getLineSegmentIntersectionsCoordinates */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.js");
/* harmony import */ var _getClosestLineSegmentIntersection__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./getClosestLineSegmentIntersection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getClosestLineSegmentIntersection.js");
/* harmony import */ var _getSubPixelSpacingAndXYDirections__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./getSubPixelSpacingAndXYDirections */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js");
/* harmony import */ var _pointsAreWithinCloseContourProximity__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./pointsAreWithinCloseContourProximity */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js");
/* harmony import */ var _addCanvasPointsToArray__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./addCanvasPointsToArray */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js");
/* harmony import */ var _pointCanProjectOnLine__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./pointCanProjectOnLine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js");
/* harmony import */ var _isPointInsidePolyline3D__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./isPointInsidePolyline3D */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isPointInsidePolyline3D.js");
/* harmony import */ var _projectTo2D__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./projectTo2D */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/projectTo2D.js");

























/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolyline.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolyline.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ intersectPolyline)
/* harmony export */ });
/* harmony import */ var _getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFirstLineSegmentIntersectionIndexes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.js");

function intersectPolyline(sourcePolyline, targetPolyline) {
    for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {
        const sourceP1 = sourcePolyline[i];
        const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;
        const sourceP2 = sourcePolyline[sourceP2Index];
        const intersectionPointIndexes = (0,_getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_0__["default"])(targetPolyline, sourceP1, sourceP2);
        if (intersectionPointIndexes?.length === 2) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isClosed)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js");


function isClosed(polyline) {
    if (polyline.length < 3) {
        return false;
    }
    const numPolylinePoints = polyline.length;
    const firstPoint = polyline[0];
    const lastPoint = polyline[numPolylinePoints - 1];
    const distFirstToLastPoints = (0,_point__WEBPACK_IMPORTED_MODULE_1__.distanceToPointSquared)(firstPoint, lastPoint);
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.glMatrix.equals(0, distFirstToLastPoints);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isPointInsidePolyline3D.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isPointInsidePolyline3D.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPointInsidePolyline3D: () => (/* binding */ isPointInsidePolyline3D)
/* harmony export */ });
/* harmony import */ var _containsPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./containsPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js");
/* harmony import */ var _projectTo2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projectTo2D */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/projectTo2D.js");


function isPointInsidePolyline3D(point, polyline, options = {}) {
    const { sharedDimensionIndex, projectedPolyline } = (0,_projectTo2D__WEBPACK_IMPORTED_MODULE_1__.projectTo2D)(polyline);
    const { holes } = options;
    const projectedHoles = [];
    if (holes) {
        for (let i = 0; i < holes.length; i++) {
            const hole = holes[i];
            const hole2D = [];
            for (let j = 0; j < hole.length; j++) {
                hole2D.push([
                    hole[j][(sharedDimensionIndex + 1) % 3],
                    hole[j][(sharedDimensionIndex + 2) % 3],
                ]);
            }
            projectedHoles.push(hole2D);
        }
    }
    const point2D = [
        point[(sharedDimensionIndex + 1) % 3],
        point[(sharedDimensionIndex + 2) % 3],
    ];
    return (0,_containsPoint__WEBPACK_IMPORTED_MODULE_0__["default"])(projectedPolyline, point2D, { holes: projectedHoles });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

const pointCanProjectOnLine = (p, p1, p2, proximity) => {
    const p1p = [p[0] - p1[0], p[1] - p1[1]];
    const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];
    const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];
    if (dot < 0) {
        return false;
    }
    const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);
    if (p1p2Mag === 0) {
        return false;
    }
    const projectionVectorMag = dot / p1p2Mag;
    const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];
    const projectionVector = [
        p1p2UnitVector[0] * projectionVectorMag,
        p1p2UnitVector[1] * projectionVectorMag,
    ];
    const projectionPoint = [
        p1[0] + projectionVector[0],
        p1[1] + projectionVector[1],
    ];
    const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(p, projectionPoint);
    if (distance > proximity) {
        return false;
    }
    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(p1, projectionPoint) > gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.distance(p1, p2)) {
        return false;
    }
    return true;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pointCanProjectOnLine);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

const pointsAreWithinCloseContourProximity = (p1, p2, closeContourProximity) => {
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.dist(p1, p2) < closeContourProximity;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pointsAreWithinCloseContourProximity);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/projectTo2D.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/projectTo2D.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   projectTo2D: () => (/* binding */ projectTo2D)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const epsilon = 1e-6;
function projectTo2D(polyline) {
    let sharedDimensionIndex;
    const testPoints = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getRandomSampleFromArray(polyline, 50);
    for (let i = 0; i < 3; i++) {
        if (testPoints.every((point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon)) {
            sharedDimensionIndex = i;
            break;
        }
    }
    if (sharedDimensionIndex === undefined) {
        throw new Error('Cannot find a shared dimension index for polyline, probably oblique plane');
    }
    const points2D = [];
    const firstDim = (sharedDimensionIndex + 1) % 3;
    const secondDim = (sharedDimensionIndex + 2) % 3;
    for (let i = 0; i < polyline.length; i++) {
        points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);
    }
    return {
        sharedDimensionIndex,
        projectedPolyline: points2D,
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ distanceToPoint)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js");

function rectToLineSegments(left, top, width, height) {
    const topLineStart = [left, top];
    const topLineEnd = [left + width, top];
    const rightLineStart = [left + width, top];
    const rightLineEnd = [left + width, top + height];
    const bottomLineStart = [left + width, top + height];
    const bottomLineEnd = [left, top + height];
    const leftLineStart = [left, top + height];
    const leftLineEnd = [left, top];
    const lineSegments = {
        top: [topLineStart, topLineEnd],
        right: [rightLineStart, rightLineEnd],
        bottom: [bottomLineStart, bottomLineEnd],
        left: [leftLineStart, leftLineEnd],
    };
    return lineSegments;
}
function distanceToPoint(rect, point) {
    if (rect.length !== 4 || point.length !== 2) {
        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');
    }
    const [left, top, width, height] = rect;
    let minDistance = 655535;
    const lineSegments = rectToLineSegments(left, top, width, height);
    Object.keys(lineSegments).forEach((segment) => {
        const [lineStart, lineEnd] = lineSegments[segment];
        const distance = _line__WEBPACK_IMPORTED_MODULE_0__.distanceToPoint(lineStart, lineEnd, point);
        if (distance < minDistance) {
            minDistance = distance;
        }
    });
    return minDistance;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js":
/*!*********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distanceToPoint: () => (/* reexport safe */ _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distanceToPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/index.js":
/*!******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pointInSphere: () => (/* reexport safe */ _pointInSphere__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _pointInSphere__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointInSphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js");




/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pointInSphere)
/* harmony export */ });
function pointInSphere(sphere, pointLPS) {
    const { center, radius } = sphere;
    const radius2 = sphere.radius2 || radius * radius;
    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +
        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +
        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=
        radius2);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findClosestPoint)
/* harmony export */ });
function findClosestPoint(sourcePoints, targetPoint) {
    let minPoint = [0, 0];
    let minDistance = Number.MAX_SAFE_INTEGER;
    sourcePoints.forEach(function (sourcePoint) {
        const distance = _distanceBetween(targetPoint, sourcePoint);
        if (distance < minDistance) {
            minDistance = distance;
            minPoint = [...sourcePoint];
        }
    });
    return minPoint;
}
function _distanceBetween(p1, p2) {
    const [x1, y1] = p1;
    const [x2, y2] = p2;
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/index.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findClosestPoint: () => (/* reexport safe */ _findClosestPoint__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   liangBarksyClip: () => (/* reexport safe */ _liangBarksyClip__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _findClosestPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findClosestPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js");
/* harmony import */ var _liangBarksyClip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./liangBarksyClip */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js");





/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clip)
/* harmony export */ });
const EPSILON = 1e-6;
const INSIDE = 1;
const OUTSIDE = 0;
function clipT(num, denom, c) {
    const [tE, tL] = c;
    if (Math.abs(denom) < EPSILON) {
        return num < 0;
    }
    const t = num / denom;
    if (denom > 0) {
        if (t > tL) {
            return 0;
        }
        if (t > tE) {
            c[0] = t;
        }
    }
    else {
        if (t < tE) {
            return 0;
        }
        if (t < tL) {
            c[1] = t;
        }
    }
    return 1;
}
function clip(a, b, box, da, db) {
    const [x1, y1] = a;
    const [x2, y2] = b;
    const dx = x2 - x1;
    const dy = y2 - y1;
    if (da === undefined || db === undefined) {
        da = a;
        db = b;
    }
    else {
        da[0] = a[0];
        da[1] = a[1];
        db[0] = b[0];
        db[1] = b[1];
    }
    if (Math.abs(dx) < EPSILON &&
        Math.abs(dy) < EPSILON &&
        x1 >= box[0] &&
        x1 <= box[2] &&
        y1 >= box[1] &&
        y1 <= box[3]) {
        return INSIDE;
    }
    const c = [0, 1];
    if (clipT(box[0] - x1, dx, c) &&
        clipT(x1 - box[2], -dx, c) &&
        clipT(box[1] - y1, dy, c) &&
        clipT(y1 - box[3], -dy, c)) {
        const [tE, tL] = c;
        if (tL < 1) {
            db[0] = x1 + tL * dx;
            db[1] = y1 + tL * dy;
        }
        if (tE > 0) {
            da[0] += tE * dx;
            da[1] += tE * dy;
        }
        return INSIDE;
    }
    return OUTSIDE;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeViewportPlane)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const acquisitionMapping = {
    toIJK: (ijkPrime) => ijkPrime,
    fromIJK: (ijk) => ijk,
    type: 'acquistion',
};
const jkMapping = {
    toIJK: ([j, k, i]) => [i, j, k],
    fromIJK: ([i, j, k]) => [j, k, i],
    type: 'jk',
};
const ikMapping = {
    toIJK: ([i, k, j]) => [i, j, k],
    fromIJK: ([i, j, k]) => [i, k, j],
    type: 'ik',
};
function normalizeViewportPlane(viewport, boundsIJK) {
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport)) {
        return { ...acquisitionMapping, boundsIJKPrime: boundsIJK };
    }
    const { viewPlaneNormal } = viewport.getCamera();
    const mapping = (isEqual(Math.abs(viewPlaneNormal[0]), 1) && jkMapping) ||
        (isEqual(Math.abs(viewPlaneNormal[1]), 1) && ikMapping) ||
        (isEqual(Math.abs(viewPlaneNormal[2]), 1) && acquisitionMapping);
    if (!mapping) {
        return {
            toIJK: null,
            boundsIJKPrime: null,
            fromIJK: null,
            error: `Only mappings orthogonal to acquisition plane are permitted, but requested ${viewPlaneNormal}`,
        };
    }
    return { ...mapping, boundsIJKPrime: mapping.fromIJK(boundsIJK) };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolatePoints: () => (/* binding */ interpolatePoints)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "../../../node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../../node_modules/d3-array/src/index.js");


function isPoints3D(points) {
    return points[0]?.length === 3;
}
function interpolatePoints(originalPoints, knotsIndexes) {
    if (!knotsIndexes ||
        knotsIndexes.length === 0 ||
        knotsIndexes.length === originalPoints.length) {
        return originalPoints;
    }
    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;
    const xInterpolator = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.interpolateBasis)(knotsIndexes.map((k) => originalPoints[k][0]));
    const yInterpolator = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.interpolateBasis)(knotsIndexes.map((k) => originalPoints[k][1]));
    if (isPoints3D(originalPoints)) {
        const zInterpolator = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.interpolateBasis)(knotsIndexes.map((k) => originalPoints[k][2]));
        return ((0,d3_array__WEBPACK_IMPORTED_MODULE_1__.zip)((0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.quantize)(xInterpolator, n), (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.quantize)(yInterpolator, n), (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.quantize)(zInterpolator, n)));
    }
    else {
        return ((0,d3_array__WEBPACK_IMPORTED_MODULE_1__.zip)((0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.quantize)(xInterpolator, n), (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.quantize)(yInterpolator, n)));
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ interpolateSegmentPoints)
/* harmony export */ });
/* harmony import */ var _algorithms_bspline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/bspline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js");

function getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {
    const result = [];
    const [intervalIni, intervalEnd] = closedInterval;
    const intervalSize = intervalEnd - intervalIni + 1;
    const intensity = Math.floor(intervalSize / minDistributionDistance);
    let x = 0;
    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;
    while (continuosDistributionValue <= intervalEnd) {
        result.push(continuosDistributionValue);
        x++;
        continuosDistributionValue =
            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;
    }
    return result;
}
function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {
    const segmentSize = endIndex - iniIndex + 1;
    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;
    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;
    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {
        return points;
    }
    if (segmentSize / minKnotDistance < 2) {
        return points;
    }
    const interpolationIniIndex = Math.max(0, iniIndex);
    const interpolationEndIndex = Math.min(points.length - 1, endIndex);
    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);
    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);
    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [
        interpolationIniIndex,
        interpolationEndIndex,
    ]);
    const interpolatedPoints = (0,_algorithms_bspline__WEBPACK_IMPORTED_MODULE_0__.interpolatePoints)(points, knotsIndexes);
    return [
        ...segmentPointsUnchangedBeg,
        ...interpolatedPoints,
        ...segmentPointsUnchangedEnd,
    ];
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getInterpolatedPoints: () => (/* binding */ getInterpolatedPoints),
/* harmony export */   shouldSmooth: () => (/* binding */ shouldSmooth)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js");
/* harmony import */ var _interpolation_interpolateSegmentPoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interpolation/interpolateSegmentPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js");


function shouldSmooth(configuration, annotation) {
    if (annotation?.autoGenerated) {
        return false;
    }
    const shouldSmooth = configuration?.smoothing?.smoothOnAdd === true ||
        configuration?.smoothing?.smoothOnEdit === true;
    return shouldSmooth;
}
function isEqualByProximity(pointA, pointB) {
    return _math__WEBPACK_IMPORTED_MODULE_0__.point.distanceToPoint(pointA, pointB) < 0.001;
}
function isEqual(pointA, pointB) {
    return _math__WEBPACK_IMPORTED_MODULE_0__.point.distanceToPoint(pointA, pointB) === 0;
}
function findMatchIndexes(points, otherPoints) {
    for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < otherPoints.length; j++) {
            if (isEqual(points[i], otherPoints[j])) {
                return [i, j];
            }
        }
    }
}
function followingIndex(index, size, direction) {
    return (index + size + direction) % size;
}
function circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {
    const [, indexDelimiter, points] = listParams;
    const [, otherIndexDelimiter, otherPoints] = otherListParams;
    const pointsLength = points.length;
    const otherPointsLength = otherPoints.length;
    let startIndex = listParams[0];
    let otherStartIndex = otherListParams[0];
    if (!points[startIndex] ||
        !otherPoints[otherStartIndex] ||
        !points[indexDelimiter] ||
        !otherPoints[otherIndexDelimiter]) {
        return [undefined, undefined];
    }
    while (startIndex !== indexDelimiter &&
        otherStartIndex !== otherIndexDelimiter) {
        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {
            return [startIndex, otherStartIndex];
        }
        startIndex = followingIndex(startIndex, pointsLength, direction);
        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);
    }
    return [undefined, undefined];
}
function findChangedSegment(points, previousPoints) {
    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];
    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;
    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([
        followingIndex(firstMatchIndex, points.length, 1),
        firstMatchIndex,
        points,
    ], [
        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),
        previousFirstMatchIndex,
        previousPoints,
    ], toBeNotEqualCriteria, 1);
    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [
        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),
        lowOtherDiffIndex,
        previousPoints,
    ], toBeNotEqualCriteria, -1);
    return [lowDiffIndex, highIndex];
}
function getInterpolatedPoints(configuration, points, pointsOfReference) {
    const { interpolation, smoothing } = configuration;
    const result = points;
    if (interpolation) {
        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false, } = smoothing;
        const knotsRatioPercentage = pointsOfReference
            ? knotsRatioPercentageOnEdit
            : knotsRatioPercentageOnAdd;
        const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;
        if (isEnabled) {
            const [changedIniIndex, changedEndIndex] = pointsOfReference
                ? findChangedSegment(points, pointsOfReference)
                : [0, points.length - 1];
            if (!points[changedIniIndex] || !points[changedEndIndex]) {
                return points;
            }
            return ((0,_interpolation_interpolateSegmentPoints__WEBPACK_IMPORTED_MODULE_1__["default"])(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));
        }
    }
    return result;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filterAnnotationsForDisplay)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _filterAnnotationsWithinSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filterAnnotationsWithinSlice */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js");


function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
        const camera = viewport.getCamera();
        const { spacingInNormalDirection } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
        return (0,_filterAnnotationsWithinSlice__WEBPACK_IMPORTED_MODULE_1__["default"])(annotations, camera, spacingInNormalDirection);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        const imageId = viewport.getCurrentImageId();
        if (!imageId) {
            return [];
        }
        const colonIndex = imageId.indexOf(':');
        filterOptions.imageURI = imageId.substring(colonIndex + 1);
    }
    return annotations.filter((annotation) => {
        if (!annotation.isVisible) {
            return false;
        }
        if (annotation.data.isCanvasAnnotation) {
            return true;
        }
        return viewport.isReferenceViewable(annotation.metadata, filterOptions);
    });
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filterAnnotationsWithinSamePlane: () => (/* binding */ filterAnnotationsWithinSamePlane)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON;
function filterAnnotationsWithinSamePlane(annotations, camera) {
    const { viewPlaneNormal } = camera;
    const annotationsWithParallelNormals = annotations.filter((td) => {
        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
        if (!annotationViewPlaneNormal) {
            const { referencedImageId } = td.metadata;
            const { imageOrientationPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', referencedImageId);
            const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
            const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
            annotationViewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);
            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;
        }
        const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >
            PARALLEL_THRESHOLD;
        return annotationViewPlaneNormal && isParallel;
    });
    if (!annotationsWithParallelNormals.length) {
        return [];
    }
    return annotationsWithParallelNormals;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filterAnnotationsWithinSlice)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON;
function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
    const { viewPlaneNormal } = camera;
    const annotationsWithParallelNormals = annotations.filter((td) => {
        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
        if (!td.metadata.referencedImageId &&
            !annotationViewPlaneNormal &&
            td.metadata.FrameOfReferenceUID) {
            for (const point of td.data.handles.points) {
                const vector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), point, camera.focalPoint);
                const dotProduct = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(vector, camera.viewPlaneNormal);
                if (!isEqual(dotProduct, 0)) {
                    return false;
                }
            }
            td.metadata.viewPlaneNormal = camera.viewPlaneNormal;
            td.metadata.cameraFocalPoint = camera.focalPoint;
            return true;
        }
        if (!annotationViewPlaneNormal) {
            const { referencedImageId } = td.metadata;
            const { imageOrientationPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', referencedImageId);
            const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
            const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
            annotationViewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);
            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;
        }
        const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >
            PARALLEL_THRESHOLD;
        return annotationViewPlaneNormal && isParallel;
    });
    if (!annotationsWithParallelNormals.length) {
        return [];
    }
    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
    const { focalPoint } = camera;
    const annotationsWithinSlice = [];
    for (const annotation of annotationsWithParallelNormals) {
        const data = annotation.data;
        const point = data.handles.points[0] || data.contour?.polyline[0];
        if (!annotation.isVisible) {
            continue;
        }
        const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
        if (!point) {
            annotationsWithinSlice.push(annotation);
            continue;
        }
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(dir, focalPoint, point);
        const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(dir, viewPlaneNormal);
        if (Math.abs(dot) < halfSpacingInNormalDirection) {
            annotationsWithinSlice.push(annotation);
        }
    }
    return annotationsWithinSlice;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPointInLineOfSightWithCriteria: () => (/* binding */ getPointInLineOfSightWithCriteria),
/* harmony export */   getPointsInLineOfSight: () => (/* binding */ getPointsInLineOfSight)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {
    const points = getPointsInLineOfSight(viewport, worldPos, {
        targetVolumeId,
        stepSize,
    });
    let pickedPoint;
    for (const point of points) {
        const intensity = viewport.getIntensityFromWorld(point);
        const pointToPick = criteriaFunction(intensity, point);
        if (pointToPick) {
            pickedPoint = pointToPick;
        }
    }
    return pickedPoint;
}
function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {
    const camera = viewport.getCamera();
    const { viewPlaneNormal: normalDirection } = camera;
    const { spacingInNormalDirection } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);
    const step = spacingInNormalDirection * stepSize || 1;
    const bounds = viewport.getBounds();
    const points = [];
    let currentPos = [...worldPos];
    while (_inBounds(currentPos, bounds)) {
        points.push([...currentPos]);
        currentPos[0] += normalDirection[0] * step;
        currentPos[1] += normalDirection[1] * step;
        currentPos[2] += normalDirection[2] * step;
    }
    currentPos = [...worldPos];
    while (_inBounds(currentPos, bounds)) {
        points.push([...currentPos]);
        currentPos[0] -= normalDirection[0] * step;
        currentPos[1] -= normalDirection[1] * step;
        currentPos[2] -= normalDirection[2] * step;
    }
    return points;
}
const _inBounds = function (point, bounds) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    const padding = 10;
    return (point[0] > xMin + padding &&
        point[0] < xMax - padding &&
        point[1] > yMin + padding &&
        point[1] < yMax - padding &&
        point[2] > zMin + padding &&
        point[2] < zMax - padding);
};


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWorldWidthAndHeightFromCorners)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {
    const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(viewRight, viewUp, viewPlaneNormal);
    const pos1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(...topLeftWorld);
    const pos2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(...bottomRightWorld);
    const diagonal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(diagonal, pos1, pos2);
    const diagonalLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.length(diagonal);
    if (diagonalLength < 0.0001) {
        return { worldWidth: 0, worldHeight: 0 };
    }
    const cosTheta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(diagonal, viewRight) / (diagonalLength * gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.length(viewRight));
    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
    const worldWidth = sinTheta * diagonalLength;
    const worldHeight = cosTheta * diagonalLength;
    return { worldWidth, worldHeight };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWorldWidthAndHeightFromTwoPoints)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {
    const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(viewRight, viewUp, viewPlaneNormal);
    const pos1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(...worldPos1);
    const pos2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(...worldPos2);
    const diagonal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(diagonal, pos1, pos2);
    const diagonalLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.length(diagonal);
    if (diagonalLength < 0.0001) {
        return { worldWidth: 0, worldHeight: 0 };
    }
    const cosTheta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(diagonal, viewRight) / (diagonalLength * gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.length(viewRight));
    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
    const worldWidth = sinTheta * diagonalLength;
    const worldHeight = cosTheta * diagonalLength;
    return { worldWidth, worldHeight };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   filterAnnotationsForDisplay: () => (/* reexport safe */ _filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   filterAnnotationsWithinSamePlane: () => (/* reexport safe */ _filterAnnotationsWithinPlane__WEBPACK_IMPORTED_MODULE_6__.filterAnnotationsWithinSamePlane),
/* harmony export */   filterAnnotationsWithinSlice: () => (/* reexport safe */ _filterAnnotationsWithinSlice__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   getPointInLineOfSightWithCriteria: () => (/* reexport safe */ _getPointInLineOfSightWithCriteria__WEBPACK_IMPORTED_MODULE_4__.getPointInLineOfSightWithCriteria),
/* harmony export */   getPointsInLineOfSight: () => (/* reexport safe */ _getPointInLineOfSightWithCriteria__WEBPACK_IMPORTED_MODULE_4__.getPointsInLineOfSight),
/* harmony export */   getWorldWidthAndHeightFromCorners: () => (/* reexport safe */ _getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   getWorldWidthAndHeightFromTwoPoints: () => (/* reexport safe */ _getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   isPlaneIntersectingAABB: () => (/* reexport safe */ _isPlaneIntersectingAABB__WEBPACK_IMPORTED_MODULE_5__.isPlaneIntersectingAABB)
/* harmony export */ });
/* harmony import */ var _filterAnnotationsWithinSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filterAnnotationsWithinSlice */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js");
/* harmony import */ var _getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWorldWidthAndHeightFromCorners */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js");
/* harmony import */ var _filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filterAnnotationsForDisplay */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js");
/* harmony import */ var _getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWorldWidthAndHeightFromTwoPoints */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js");
/* harmony import */ var _getPointInLineOfSightWithCriteria__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getPointInLineOfSightWithCriteria */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js");
/* harmony import */ var _isPlaneIntersectingAABB__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isPlaneIntersectingAABB */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js");
/* harmony import */ var _filterAnnotationsWithinPlane__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filterAnnotationsWithinPlane */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    filterAnnotationsWithinSlice: _filterAnnotationsWithinSlice__WEBPACK_IMPORTED_MODULE_0__["default"],
    getWorldWidthAndHeightFromCorners: _getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_1__["default"],
    getWorldWidthAndHeightFromTwoPoints: _getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_3__["default"],
    filterAnnotationsForDisplay: _filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_2__["default"],
    getPointInLineOfSightWithCriteria: _getPointInLineOfSightWithCriteria__WEBPACK_IMPORTED_MODULE_4__.getPointInLineOfSightWithCriteria,
    isPlaneIntersectingAABB: _isPlaneIntersectingAABB__WEBPACK_IMPORTED_MODULE_5__.isPlaneIntersectingAABB,
    filterAnnotationsWithinSamePlane: _filterAnnotationsWithinPlane__WEBPACK_IMPORTED_MODULE_6__.filterAnnotationsWithinSamePlane,
    getPointsInLineOfSight: _getPointInLineOfSightWithCriteria__WEBPACK_IMPORTED_MODULE_4__.getPointsInLineOfSight,
});



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPlaneIntersectingAABB: () => (/* binding */ isPlaneIntersectingAABB)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

const isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {
    const vertices = [
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(minX, minY, minZ),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(maxX, minY, minZ),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(minX, maxY, minZ),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(maxX, maxY, minZ),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(minX, minY, maxZ),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(maxX, minY, maxZ),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(minX, maxY, maxZ),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(maxX, maxY, maxZ),
    ];
    const normalVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(normal[0], normal[1], normal[2]);
    const originVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(origin[0], origin[1], origin[2]);
    const planeDistance = -gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(normalVec, originVec);
    let initialSign = null;
    for (const vertex of vertices) {
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(normalVec, vertex) + planeDistance;
        if (initialSign === null) {
            initialSign = Math.sign(distance);
        }
        else if (Math.sign(distance) !== initialSign) {
            return true;
        }
    }
    return false;
};


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js":
/*!******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../boundingBox/getBoundingBoxAroundShape */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js");
/* harmony import */ var _boundingBox_extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../boundingBox/extend2DBoundingBoxInViewAxis */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js");



function getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {
    const AllBoundsIJK = [];
    annotations.forEach((annotation) => {
        const { data } = annotation;
        const { points } = data.handles;
        const { imageData, dimensions } = referenceVolume;
        let pointsToUse = points;
        if (data.cachedStats?.projectionPoints) {
            const { projectionPoints } = data.cachedStats;
            pointsToUse = [].concat(...projectionPoints);
        }
        const rectangleCornersIJK = pointsToUse.map((world) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, world));
        let boundsIJK = (0,_boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.getBoundingBoxAroundShapeIJK)(rectangleCornersIJK, dimensions);
        if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {
            boundsIJK = (0,_boundingBox_extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_2__["default"])(boundsIJK, options.numSlicesToProject);
        }
        AllBoundsIJK.push(boundsIJK);
    });
    if (AllBoundsIJK.length === 1) {
        return AllBoundsIJK[0];
    }
    const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {
        return {
            iMin: Math.min(accumulator.iMin, currentValue.iMin),
            jMin: Math.min(accumulator.jMin, currentValue.jMin),
            kMin: Math.min(accumulator.kMin, currentValue.kMin),
            iMax: Math.max(accumulator.iMax, currentValue.iMax),
            jMax: Math.max(accumulator.jMax, currentValue.jMax),
            kMax: Math.max(accumulator.kMax, currentValue.kMax),
        };
    }, {
        iMin: Infinity,
        jMin: Infinity,
        kMin: Infinity,
        iMax: -Infinity,
        jMax: -Infinity,
        kMax: -Infinity,
    });
    return boundsIJK;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getBoundsIJKFromRectangleAnnotations);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAxisAlignedRectangle: () => (/* binding */ isAxisAlignedRectangle)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");


const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const iAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(1, 0, 0);
const jAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(0, 1, 0);
const kAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(0, 0, 1);
const axisList = [iAxis, jAxis, kAxis];
function isAxisAlignedRectangle(rectangleCornersIJK) {
    const rectangleVec1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);
    const rectangleVec2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);
    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);
    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);
    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||
        isEqual(angle, 90) ||
        isEqual(angle, 180) ||
        isEqual(angle, 270));
    return isAligned;
}
function calculateAnglesWithAxes(vec, axes) {
    return axes.map((axis) => (gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.angle(vec, axis) * 180) / Math.PI);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerComputeWorker: () => (/* binding */ registerComputeWorker)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "../../../node_modules/@cornerstonejs/tools/dist/esm/config.js");


let registered = false;
function registerComputeWorker() {
    if (registered) {
        return;
    }
    registered = true;
    const workerFn = () => {
        return new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("compute"), __webpack_require__.b), {
            name: 'compute',
            type: undefined,
        });
    };
    const workerManager = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)();
    const config = (0,_config__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
    const computeWorkerConfig = config.computeWorker;
    const options = {
        maxWorkerInstances: 1,
        autoTerminateOnIdle: computeWorkerConfig?.autoTerminateOnIdle ?? {
            enabled: true,
            idleTimeThreshold: 2000,
        },
    };
    workerManager.registerWorker('compute', workerFn, options);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InterpolationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../stateManagement/annotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js");
/* harmony import */ var _contours_interpolation_getInterpolationDataCollection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../contours/interpolation/getInterpolationDataCollection */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js");
/* harmony import */ var _contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../contours/interpolation/interpolate */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js");
/* harmony import */ var _deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deleteRelatedAnnotations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js");
/* harmony import */ var _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../enums/ChangeTypes */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js");
/* harmony import */ var _getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../getViewportForAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js");
/* harmony import */ var _contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../contourSegmentation/addContourSegmentationAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js");








const { uuidv4 } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const ChangeTypesForInterpolation = [
    _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__["default"].HandlesUpdated,
    _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__["default"].InterpolationUpdated,
];
class InterpolationManager {
    static { this.toolNames = []; }
    static addTool(toolName) {
        if (!this.toolNames.includes(toolName)) {
            this.toolNames.push(toolName);
        }
    }
    static acceptAutoGenerated(annotationGroupSelector, selector = {}) {
        const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;
        for (const toolName of toolNames || InterpolationManager.toolNames) {
            const annotations = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.getAnnotations(toolName, annotationGroupSelector);
            if (!annotations?.length) {
                continue;
            }
            for (const annotation of annotations) {
                const { interpolationUID, data, autoGenerated, metadata } = annotation;
                if (interpolationUID) {
                    annotation.interpolationCompleted = true;
                }
                if (!autoGenerated) {
                    continue;
                }
                if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {
                    continue;
                }
                if (sliceIndex !== undefined &&
                    metadata &&
                    sliceIndex !== metadata.sliceIndex) {
                    continue;
                }
                if (segmentationId &&
                    segmentationId !== data.segmentation.segmentationId) {
                    continue;
                }
                (0,_contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__.addContourSegmentationAnnotation)(annotation);
                annotation.autoGenerated = false;
            }
        }
    }
    static { this.handleAnnotationCompleted = (evt) => {
        const annotation = evt.detail.annotation;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName, originalToolName } = annotation.metadata;
        if (!this.toolNames.includes(toolName) &&
            !this.toolNames.includes(originalToolName)) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__["default"])(annotation);
        if (!viewport) {
            console.warn('Unable to find viewport for', annotation);
            return;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
        };
        const hasInterpolationUID = !!annotation.interpolationUID;
        annotation.autoGenerated = false;
        if (hasInterpolationUID) {
            (0,_deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__["default"])(viewportData);
            (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportData);
            return;
        }
        const filterData = [
            {
                key: 'segmentIndex',
                value: annotation.data.segmentation.segmentIndex,
                parentKey: (annotation) => annotation.data.segmentation,
            },
            {
                key: 'viewPlaneNormal',
                value: annotation.metadata.viewPlaneNormal,
                parentKey: (annotation) => annotation.metadata,
            },
            {
                key: 'viewUp',
                value: annotation.metadata.viewUp,
                parentKey: (annotation) => annotation.metadata,
            },
        ];
        let interpolationAnnotations = (0,_contours_interpolation_getInterpolationDataCollection__WEBPACK_IMPORTED_MODULE_2__["default"])(viewportData, filterData);
        const { sliceIndex } = annotation.metadata;
        const skipUIDs = new Set();
        interpolationAnnotations.forEach((interpolationAnnotation) => {
            if (interpolationAnnotation.interpolationCompleted ||
                interpolationAnnotation.metadata.sliceIndex === sliceIndex) {
                const { interpolationUID } = interpolationAnnotation;
                skipUIDs.add(interpolationUID);
            }
        });
        interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));
        annotation.interpolationUID =
            interpolationAnnotations[0]?.interpolationUID || uuidv4();
        viewportData.interpolationUID = annotation.interpolationUID;
        (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportData);
    }; }
    static { this.handleAnnotationUpdate = (evt) => {
        const annotation = evt.detail.annotation;
        const { changeType = _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__["default"].HandlesUpdated } = evt.detail;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName, originalToolName } = annotation.metadata;
        if ((!this.toolNames.includes(toolName) &&
            !this.toolNames.includes(originalToolName)) ||
            !ChangeTypesForInterpolation.includes(changeType)) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__["default"])(annotation);
        if (!viewport) {
            console.warn('Unable to find matching viewport for annotation interpolation', annotation);
            return;
        }
        if (annotation.autoGenerated) {
            (0,_contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__.addContourSegmentationAnnotation)(annotation);
            annotation.autoGenerated = false;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
            isInterpolationUpdate: changeType === _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__["default"].InterpolationUpdated,
        };
        (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportData);
    }; }
    static { this.handleAnnotationDelete = (evt) => {
        const annotation = evt.detail.annotation;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName } = annotation.metadata;
        if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__["default"])(annotation);
        if (!viewport) {
            console.warn("No viewport, can't delete interpolated results", annotation);
            return;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
        };
        annotation.autoGenerated = false;
        (0,_deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__["default"])(viewportData);
    }; }
}
function getSliceData(viewport) {
    const sliceData = {
        numberOfSlices: viewport.getNumberOfSlices(),
        imageIndex: viewport.getCurrentImageIdIndex(),
    };
    return sliceData;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ deleteRelatedAnnotations)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../stateManagement/annotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js");
/* harmony import */ var _contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../contours/interpolation/interpolate */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js");
/* harmony import */ var _contours_interpolation_getInterpolationData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../contours/interpolation/getInterpolationData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");





function deleteRelatedAnnotations(viewportData) {
    const { annotation } = viewportData;
    const interpolationAnnotations = (0,_contours_interpolation_getInterpolationData__WEBPACK_IMPORTED_MODULE_3__["default"])(viewportData, [
        { key: 'interpolationUID', value: viewportData.interpolationUID },
    ]);
    const referencedSliceIndex = annotation.metadata.sliceIndex;
    let minInterpolation = -1;
    let maxInterpolation = viewportData.sliceData.numberOfSlices;
    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {
        if (sliceIndex === referencedSliceIndex) {
            continue;
        }
        const nonInterpolated = annotations.find((annotation) => !annotation.autoGenerated);
        if (!nonInterpolated) {
            continue;
        }
        if (sliceIndex < referencedSliceIndex) {
            minInterpolation = Math.max(sliceIndex, minInterpolation);
        }
        else {
            maxInterpolation = Math.min(sliceIndex, maxInterpolation);
        }
    }
    const removedAnnotations = [];
    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {
        if (sliceIndex <= minInterpolation ||
            sliceIndex >= maxInterpolation ||
            sliceIndex === referencedSliceIndex) {
            continue;
        }
        annotations.forEach((annotationToDelete) => {
            if (annotationToDelete.autoGenerated) {
                _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.removeAnnotation(annotationToDelete.annotationUID);
                removedAnnotations.push(annotationToDelete);
            }
        });
    }
    if (removedAnnotations.length) {
        const eventDetails = {
            annotations: removedAnnotations,
            element: viewportData.viewport.element,
            viewportId: viewportData.viewport.id,
            renderingEngineId: viewportData.viewport.getRenderingEngine().id,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(viewportData.viewport.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__["default"].INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);
    }
    if (minInterpolation >= 0 &&
        maxInterpolation < viewportData.sliceData.numberOfSlices) {
        const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];
        const viewportNewData = {
            viewport: viewportData.viewport,
            sliceData: {
                numberOfSlices: viewportData.sliceData.numberOfSlices,
                imageIndex: nextAnnotation.metadata.sliceIndex,
            },
            annotation: nextAnnotation,
            interpolationUID: nextAnnotation.interpolationUID,
        };
        (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])(viewportNewData);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SegmentStatsCalculator)
/* harmony export */ });
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VolumetricCalculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js");

class SegmentStatsCalculator {
    static { this.calculators = new Map(); }
    static { this.indices = []; }
    static { this.mode = 'collective'; }
    static statsInit(options) {
        const { storePointData, indices, mode } = options;
        this.mode = mode;
        this.indices = indices;
        this.calculators.clear();
        if (this.mode === 'individual') {
            indices.forEach((index) => {
                this.calculators.set(index, new _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__.InstanceVolumetricCalculator({ storePointData }));
            });
        }
        else {
            this.calculators.set(indices, new _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__.InstanceVolumetricCalculator({ storePointData }));
        }
    }
    static statsCallback(data) {
        const { segmentIndex, ...statsData } = data;
        if (!segmentIndex) {
            throw new Error('Segment index is required for stats calculation');
        }
        const calculator = this.mode === 'individual'
            ? this.calculators.get(segmentIndex)
            : this.calculators.get(this.indices);
        if (!calculator) {
            throw new Error(`No calculator found for segment ${segmentIndex}`);
        }
        calculator.statsCallback(statsData);
    }
    static getStatistics(options) {
        if (this.mode === 'individual') {
            const result = {};
            this.calculators.forEach((calculator, segmentIndex) => {
                result[segmentIndex] = calculator.getStatistics(options);
            });
            return result;
        }
        const calculator = this.calculators.get(this.indices);
        return calculator.getStatistics(options);
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InstanceVolumetricCalculator: () => (/* binding */ InstanceVolumetricCalculator),
/* harmony export */   VolumetricCalculator: () => (/* binding */ VolumetricCalculator),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/basic/BasicStatsCalculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js");
/* harmony import */ var _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getCalibratedUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js");


const TEST_MAX_LOCATIONS = 10;
function createVolumetricState() {
    return {
        maxIJKs: [],
    };
}
function volumetricStatsCallback(state, data) {
    const { value } = data;
    const { maxIJKs } = state;
    const length = maxIJKs.length;
    if (typeof value !== 'number' ||
        (length >= TEST_MAX_LOCATIONS && value < maxIJKs[0].value)) {
        return;
    }
    const dataCopy = {
        value: data.value,
        pointLPS: data.pointLPS
            ? [data.pointLPS[0], data.pointLPS[1], data.pointLPS[2]]
            : undefined,
        pointIJK: data.pointIJK
            ? [data.pointIJK[0], data.pointIJK[1], data.pointIJK[2]]
            : undefined,
    };
    if (!length || value >= maxIJKs[length - 1].value) {
        maxIJKs.push(dataCopy);
    }
    else {
        for (let i = 0; i < length; i++) {
            if (value <= maxIJKs[i].value) {
                maxIJKs.splice(i, 0, dataCopy);
                break;
            }
        }
    }
    if (length >= TEST_MAX_LOCATIONS) {
        maxIJKs.splice(0, 1);
    }
}
function volumetricGetStatistics(state, stats, options) {
    const { spacing, calibration } = options;
    const { volumeUnit } = (0,_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__.getCalibratedLengthUnitsAndScale)({
        calibration,
        hasPixelSpacing: true,
    }, []);
    const volumeScale = spacing ? spacing[0] * spacing[1] * spacing[2] : 1;
    stats.volume = {
        value: Array.isArray(stats.count.value)
            ? stats.count.value.map((v) => v * volumeScale)
            : stats.count.value * volumeScale,
        unit: volumeUnit,
        name: 'volume',
        label: 'Volume',
    };
    stats.maxIJKs = state.maxIJKs.filter((entry) => entry.pointIJK !== undefined);
    stats.array.push(stats.volume);
    state.maxIJKs = [];
    return stats;
}
class VolumetricCalculator extends _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__.BasicStatsCalculator {
    static { this.volumetricState = createVolumetricState(); }
    static statsInit(options) {
        super.statsInit(options);
        this.volumetricState = createVolumetricState();
    }
    static statsCallback(data) {
        super.statsCallback(data);
        volumetricStatsCallback(this.volumetricState, data);
    }
    static getStatistics(options) {
        const optionsWithUnit = {
            ...options,
            unit: options?.unit || 'none',
            calibration: options?.calibration,
            hasPixelSpacing: options?.hasPixelSpacing,
        };
        const stats = super.getStatistics(optionsWithUnit);
        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);
    }
}
class InstanceVolumetricCalculator extends _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__.InstanceBasicStatsCalculator {
    constructor(options) {
        super(options);
        this.volumetricState = createVolumetricState();
    }
    statsInit(options) {
        super.statsInit(options);
        this.volumetricState = createVolumetricState();
    }
    statsCallback(data) {
        super.statsCallback(data);
        volumetricStatsCallback(this.volumetricState, data);
    }
    getStatistics(options) {
        const optionsWithUnit = {
            ...options,
            unit: options?.unit || 'none',
            calibration: options?.calibration,
            hasPixelSpacing: options?.hasPixelSpacing,
        };
        const stats = super.getStatistics(optionsWithUnit);
        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VolumetricCalculator);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBrushSizeForToolGroup: () => (/* binding */ getBrushSizeForToolGroup),
/* harmony export */   setBrushSizeForToolGroup: () => (/* binding */ setBrushSizeForToolGroup)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBrushToolInstances */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js");




function setBrushSizeForToolGroup(toolGroupId, brushSize, toolName) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_3__.getBrushToolInstances)(toolGroupId, toolName);
    brushBasedToolInstances.forEach((tool) => {
        tool.configuration.brushSize = brushSize;
        tool.invalidateBrushCursor();
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
    if (!viewportsInfoArray.length) {
        return;
    }
    const { renderingEngineId } = viewportsInfoArray[0];
    const viewportIds = toolGroup.getViewportIds();
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getRenderingEngine)(renderingEngineId);
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__["default"])(viewportIds);
}
function getBrushSizeForToolGroup(toolGroupId, toolName) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_3__.getBrushToolInstances)(toolGroupId, toolName);
    const brushToolInstance = brushBasedToolInstances[0];
    if (!brushToolInstance) {
        return;
    }
    return brushToolInstance.configuration.brushSize;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBrushThresholdForToolGroup: () => (/* binding */ getBrushThresholdForToolGroup),
/* harmony export */   setBrushThresholdForToolGroup: () => (/* binding */ setBrushThresholdForToolGroup)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getBrushToolInstances */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js");



function setBrushThresholdForToolGroup(toolGroupId, threshold) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__.getBrushToolInstances)(toolGroupId);
    brushBasedToolInstances.forEach((tool) => {
        const activeStrategy = tool.configuration.activeStrategy;
        if (!activeStrategy.toLowerCase().includes('threshold')) {
            return;
        }
        tool.configuration = {
            ...tool.configuration,
            threshold: {
                ...tool.configuration.threshold,
                ...threshold,
            },
        };
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    if (!viewportsInfo.length) {
        return;
    }
    const viewportIds = toolGroup.getViewportIds();
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__["default"])(viewportIds);
}
function getBrushThresholdForToolGroup(toolGroupId) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__.getBrushToolInstances)(toolGroupId);
    const brushToolInstance = brushBasedToolInstances[0];
    if (!brushToolInstance) {
        return;
    }
    return brushToolInstance.configuration.threshold.range;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeAndAddRepresentation: () => (/* binding */ computeAndAddRepresentation)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_internalAddRepresentationData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/internalAddRepresentationData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../debounce */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js");





const computedRepresentations = new Map();
async function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {
    const data = await computeFunction();
    (0,_stateManagement_segmentation_internalAddRepresentationData__WEBPACK_IMPORTED_MODULE_2__["default"])({
        segmentationId,
        type,
        data,
    });
    onComputationComplete?.();
    if (!computedRepresentations.has(segmentationId)) {
        computedRepresentations.set(segmentationId, []);
    }
    const representations = computedRepresentations.get(segmentationId);
    if (!representations.includes(type)) {
        representations.push(type);
    }
    subscribeToSegmentationChanges(updateFunction);
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
    return data;
}
function subscribeToSegmentationChanges(updateFunction) {
    const debouncedUpdateFunction = (event) => {
        _debouncedSegmentationModified(event, updateFunction);
    };
    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);
}
const _debouncedSegmentationModified = (0,_debounce__WEBPACK_IMPORTED_MODULE_4__["default"])((event, updateFunction) => {
    const segmentationId = event.detail.segmentationId;
    const representations = computedRepresentations.get(segmentationId);
    if (!representations || !representations.length) {
        return;
    }
    updateFunction(segmentationId);
    if (representations.length) {
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
    }
}, 300);



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeMetabolicStats: () => (/* binding */ computeMetabolicStats)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilsForWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilsForWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../registerComputeWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js");
/* harmony import */ var _createMergedLabelmapForIndex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createMergedLabelmapForIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getOrCreateSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js");
/* harmony import */ var _getReferenceVolumeForSegmentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getReferenceVolumeForSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js");








async function computeMetabolicStats({ segmentationIds, segmentIndex, }) {
    (0,_registerComputeWorker__WEBPACK_IMPORTED_MODULE_3__.registerComputeWorker)();
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_2__.WorkerTypes.COMPUTE_STATISTICS, 0);
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_5__.getSegmentation)(segmentationIds[0]);
    const { imageIds: segImageIds } = segmentation.representationData
        .Labelmap;
    const isValidVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(segImageIds);
    if (!isValidVolume) {
        throw new Error('Invalid volume - TMTV cannot be calculated');
    }
    const stats = await calculateForVolume({
        segmentationIds,
        segmentIndex,
    });
    return stats;
}
async function calculateForVolume({ segmentationIds, segmentIndex }) {
    const labelmapVolumes = segmentationIds.map((id) => {
        return (0,_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_6__["default"])(id);
    });
    const mergedLabelmap = (0,_createMergedLabelmapForIndex__WEBPACK_IMPORTED_MODULE_4__["default"])(labelmapVolumes, segmentIndex);
    if (!mergedLabelmap) {
        throw new Error('Invalid volume - TMTV cannot be calculated');
    }
    const { imageData, dimensions, direction, origin, voxelManager } = mergedLabelmap;
    const spacing = imageData.getSpacing();
    const segmentationScalarData = voxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions,
        spacing,
        origin,
        direction,
    };
    const referenceVolume = (0,_getReferenceVolumeForSegmentation__WEBPACK_IMPORTED_MODULE_7__.getReferenceVolumeForSegmentation)(segmentationIds[0]);
    const imageInfo = {
        dimensions: referenceVolume.dimensions,
        spacing: referenceVolume.spacing,
        origin: referenceVolume.origin,
        direction: referenceVolume.direction,
        scalarData: referenceVolume.voxelManager.getCompleteScalarDataArray(),
    };
    if (imageInfo.scalarData.length === 0 ||
        segmentationInfo.scalarData.length === 0) {
        return {
            [segmentIndex]: {
                name: 'TMTV',
                value: 0,
            },
        };
    }
    const stats = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'computeMetabolicStats', {
        segmentationInfo,
        imageInfo,
    });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_2__.WorkerTypes.COMPUTE_STATISTICS, 100);
    return stats;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contourAndFindLargestBidirectional)
/* harmony export */ });
/* harmony import */ var _contours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../contours */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js");
/* harmony import */ var _findLargestBidirectional__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./findLargestBidirectional */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js");
/* harmony import */ var _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getOrCreateSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js");



async function contourAndFindLargestBidirectional(segmentation) {
    const contours = await (0,_contours__WEBPACK_IMPORTED_MODULE_0__.generateContourSetsFromLabelmap)({
        segmentations: segmentation,
    });
    if (!contours?.length || !contours[0].sliceContours.length) {
        return;
    }
    const { segments = [
        null,
        { label: 'Unspecified', color: null, containedSegmentIndices: null },
    ], } = segmentation;
    const vol = (0,_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__["default"])(segmentation.segmentationId);
    if (!vol) {
        return;
    }
    const segmentIndex = segments.findIndex((it) => !!it);
    if (segmentIndex === -1) {
        return;
    }
    segments[segmentIndex].segmentIndex = segmentIndex;
    return (0,_findLargestBidirectional__WEBPACK_IMPORTED_MODULE_1__["default"])(contours[0], vol.volumeId, segments[segmentIndex]);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createBidirectionalToolData)
/* harmony export */ });
function createBidirectionalToolData(bidirectionalData, viewport) {
    const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;
    const [major0, major1] = majorAxis;
    const [minor0, minor1] = minorAxis;
    const points = [major0, major1, minor0, minor1];
    const bidirectionalToolData = {
        highlighted: true,
        invalidated: true,
        metadata: {
            toolName: 'Bidirectional',
            ...viewport.getViewReference({ sliceIndex }),
        },
        data: {
            handles: {
                points,
                textBox: {
                    hasMoved: false,
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
                activeHandleIndex: null,
            },
            label,
            cachedStats: {},
        },
        isLocked: false,
        isVisible: true,
    };
    return bidirectionalToolData;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLabelmapMemo: () => (/* binding */ createLabelmapMemo),
/* harmony export */   createRleMemo: () => (/* binding */ createRleMemo),
/* harmony export */   restoreMemo: () => (/* binding */ restoreMemo)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/Events */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js");



const { VoxelManager, RLEVoxelMap } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function createLabelmapMemo(segmentationId, segmentationVoxelManager) {
    return createRleMemo(segmentationId, segmentationVoxelManager);
}
function restoreMemo(isUndo) {
    const { segmentationVoxelManager, undoVoxelManager, redoVoxelManager } = this;
    const useVoxelManager = isUndo === false ? redoVoxelManager : undoVoxelManager;
    useVoxelManager.forEach(({ value, pointIJK }) => {
        segmentationVoxelManager.setAtIJKPoint(pointIJK, value);
    });
    const slices = useVoxelManager.getArrayOfModifiedSlices();
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(this.segmentationId, slices);
}
function createRleMemo(segmentationId, segmentationVoxelManager) {
    const voxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
    const state = {
        segmentationId,
        restoreMemo,
        commitMemo,
        segmentationVoxelManager,
        voxelManager,
        id: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
        operationType: 'labelmap',
    };
    return state;
}
function commitMemo() {
    if (this.redoVoxelManager) {
        return true;
    }
    if (!this.voxelManager.modifiedSlices.size) {
        return false;
    }
    const { segmentationVoxelManager } = this;
    const undoVoxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
    RLEVoxelMap.copyMap(undoVoxelManager.map, this.voxelManager.map);
    for (const key of this.voxelManager.modifiedSlices.keys()) {
        undoVoxelManager.modifiedSlices.add(key);
    }
    this.undoVoxelManager = undoVoxelManager;
    const redoVoxelManager = VoxelManager.createRLEVolumeVoxelManager({
        dimensions: this.segmentationVoxelManager.dimensions,
    });
    this.redoVoxelManager = redoVoxelManager;
    undoVoxelManager.forEach(({ index, pointIJK, value }) => {
        const currentValue = segmentationVoxelManager.getAtIJKPoint(pointIJK);
        if (currentValue === value) {
            return;
        }
        redoVoxelManager.setAtIndex(index, currentValue);
    });
    return true;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createLabelmapVolumeForViewport)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

async function createLabelmapVolumeForViewport(input) {
    const { viewportId, renderingEngineId, options } = input;
    let { segmentationId } = input;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
    if (!enabledElement) {
        throw new Error('element disabled');
    }
    const { viewport } = enabledElement;
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport)) {
        throw new Error('Segmentation only supports VolumeViewport');
    }
    const { uid } = viewport.getDefaultActor();
    if (segmentationId === undefined) {
        segmentationId = `${uid}-based-segmentation-${options?.volumeId ?? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4().slice(0, 8)}`;
    }
    if (options) {
        const properties = structuredClone(options);
        await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createLocalVolume(segmentationId, properties);
    }
    else {
        const volumeId = viewport.getVolumeId();
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(volumeId, {
            volumeId: segmentationId,
        });
    }
    return segmentationId;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = 'mergedLabelmap') {
    labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {
        if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(dimensions, labelmaps[0].dimensions) ||
            !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(direction, labelmaps[0].direction) ||
            !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(spacing, labelmaps[0].spacing) ||
            !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(origin, labelmaps[0].origin)) {
            throw new Error('labelmaps must have the same size and shape');
        }
    });
    const labelmap = labelmaps[0];
    const arrayType = labelmap.voxelManager.getConstructor();
    const outputData = new arrayType(labelmap.voxelManager.getScalarDataLength());
    labelmaps.forEach((labelmap) => {
        const voxelManager = labelmap.voxelManager;
        const scalarDataLength = voxelManager.getScalarDataLength();
        for (let i = 0; i < scalarDataLength; i++) {
            if (voxelManager.getAtIndex(i) === segmentIndex) {
                outputData[i] = segmentIndex;
            }
        }
    });
    const options = {
        scalarData: outputData,
        metadata: labelmap.metadata,
        spacing: labelmap.spacing,
        origin: labelmap.origin,
        direction: labelmap.direction,
        dimensions: labelmap.dimensions,
    };
    const cachedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    let mergedVolume;
    if (cachedVolume) {
        mergedVolume = cachedVolume;
        mergedVolume.voxelManager.setCompleteScalarDataArray(outputData);
    }
    else {
        mergedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createLocalVolume(volumeId, options);
    }
    return mergedVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createMergedLabelmapForIndex);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createBidirectionalForSlice: () => (/* binding */ createBidirectionalForSlice),
/* harmony export */   "default": () => (/* binding */ findLargestBidirectional)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _isLineInSegment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isLineInSegment */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js");


const EPSILON = 1e-2;
function findLargestBidirectional(contours, segVolumeId, segment) {
    const { sliceContours } = contours;
    const { segmentIndex, containedSegmentIndices } = segment;
    let maxBidirectional;
    const isInSegment = (0,_isLineInSegment__WEBPACK_IMPORTED_MODULE_1__.createIsInSegment)(segVolumeId, segmentIndex, containedSegmentIndices);
    for (const sliceContour of sliceContours) {
        const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);
        if (!bidirectional) {
            continue;
        }
        maxBidirectional = bidirectional;
    }
    if (maxBidirectional) {
        Object.assign(maxBidirectional, segment);
    }
    return maxBidirectional;
}
function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {
    const { points } = sliceContour.polyData;
    const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;
    let maxMajor = currentMaxMajor * currentMaxMajor;
    let maxMinor = currentMaxMinor * currentMaxMinor;
    let maxMajorPoints;
    for (let index1 = 0; index1 < points.length; index1++) {
        for (let index2 = index1 + 1; index2 < points.length; index2++) {
            const point1 = points[index1];
            const point2 = points[index2];
            const distance2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sqrDist(point1, point2);
            if (distance2 < maxMajor) {
                continue;
            }
            if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {
                continue;
            }
            if (!isInSegment.testCenter(point1, point2)) {
                continue;
            }
            if (!(0,_isLineInSegment__WEBPACK_IMPORTED_MODULE_1__.isLineInSegment)(point1, point2, isInSegment)) {
                continue;
            }
            maxMajor = distance2 - EPSILON;
            maxMajorPoints = [index1, index2];
            maxMinor = 0;
        }
    }
    if (!maxMajorPoints) {
        return;
    }
    maxMajor = Math.sqrt(maxMajor + EPSILON);
    const handle0 = points[maxMajorPoints[0]];
    const handle1 = points[maxMajorPoints[1]];
    const unitMajor = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), handle0, handle1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scale(unitMajor, unitMajor, 1 / maxMajor);
    let maxMinorPoints;
    for (let index1 = 0; index1 < points.length; index1++) {
        for (let index2 = index1 + 1; index2 < points.length; index2++) {
            const point1 = points[index1];
            const point2 = points[index2];
            const distance2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sqrDist(point1, point2);
            if (distance2 <= maxMinor) {
                continue;
            }
            const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), point1, point2);
            const dot = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);
            if (dot > EPSILON) {
                continue;
            }
            if (!isInSegment.testCenter(point1, point2)) {
                continue;
            }
            if (!(0,_isLineInSegment__WEBPACK_IMPORTED_MODULE_1__.isLineInSegment)(point1, point2, isInSegment)) {
                continue;
            }
            maxMinor = distance2;
            maxMinorPoints = [index1, index2];
        }
    }
    if (!maxMinorPoints) {
        return;
    }
    maxMinor = Math.sqrt(maxMinor);
    const handle2 = points[maxMinorPoints[0]];
    const handle3 = points[maxMinorPoints[1]];
    const bidirectional = {
        majorAxis: [handle0, handle1],
        minorAxis: [handle2, handle3],
        maxMajor,
        maxMinor,
        ...sliceContour,
    };
    return bidirectional;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function floodFill(getter, seed, options = {}) {
    const onFlood = options.onFlood;
    const onBoundary = options.onBoundary;
    const equals = options.equals;
    const filter = options.filter;
    const diagonals = options.diagonals || false;
    const startNode = get(seed);
    const permutations = prunedPermutations();
    const stack = [];
    const flooded = [];
    const visits = new Set();
    const bounds = options.bounds;
    stack.push({ currentArgs: seed });
    while (stack.length > 0) {
        flood(stack.pop());
    }
    return {
        flooded,
    };
    function flood(job) {
        const getArgs = job.currentArgs;
        const prevArgs = job.previousArgs;
        if (visited(getArgs)) {
            return;
        }
        markAsVisited(getArgs);
        if (member(getArgs)) {
            markAsFlooded(getArgs);
            pushAdjacent(getArgs);
        }
        else {
            markAsBoundary(prevArgs);
        }
    }
    function visited(key) {
        const [x, y, z = 0] = key;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        return visits.has(iKey);
    }
    function markAsVisited(key) {
        const [x, y, z = 0] = key;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        visits.add(iKey);
    }
    function member(getArgs) {
        const node = get(getArgs);
        return equals ? equals(node, startNode) : node === startNode;
    }
    function markAsFlooded(getArgs) {
        flooded.push(getArgs);
        if (onFlood) {
            onFlood(...getArgs);
        }
    }
    function markAsBoundary(prevArgs) {
        const [x, y, z = 0] = prevArgs;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        bounds?.set(iKey, prevArgs);
        if (onBoundary) {
            onBoundary(...prevArgs);
        }
    }
    function pushAdjacent(getArgs) {
        for (let i = 0; i < permutations.length; i += 1) {
            const perm = permutations[i];
            const nextArgs = getArgs.slice(0);
            for (let j = 0; j < getArgs.length; j += 1) {
                nextArgs[j] += perm[j];
            }
            if (filter?.(nextArgs) === false) {
                continue;
            }
            if (visited(nextArgs)) {
                continue;
            }
            stack.push({
                currentArgs: nextArgs,
                previousArgs: getArgs,
            });
        }
    }
    function get(getArgs) {
        return getter(...getArgs);
    }
    function prunedPermutations() {
        const permutations = permute(seed.length);
        return permutations.filter(function (perm) {
            const count = countNonZeroes(perm);
            return count !== 0 && (count === 1 || diagonals);
        });
    }
    function permute(length) {
        const perms = [];
        const permutation = function (string) {
            return string.split('').map(function (c) {
                return parseInt(c, 10) - 1;
            });
        };
        for (let i = 0; i < Math.pow(3, length); i += 1) {
            const string = lpad(i.toString(3), '0', length);
            perms.push(permutation(string));
        }
        return perms;
    }
}
function countNonZeroes(array) {
    let count = 0;
    for (let i = 0; i < array.length; i += 1) {
        if (array[i] !== 0) {
            count += 1;
        }
    }
    return count;
}
function lpad(string, character, length) {
    const array = new Array(length + 1);
    const pad = array.join(character);
    return (pad + string).slice(-length);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (floodFill);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBrushToolInstances: () => (/* binding */ getBrushToolInstances)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _tools_segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/segmentation/BrushTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js");


function getBrushToolInstances(toolGroupId, toolName) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    if (toolName && toolInstances[toolName]) {
        return [toolInstances[toolName]];
    }
    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof _tools_segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_1__["default"]);
    return brushBasedToolInstances;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHoveredContourSegmentationAnnotation: () => (/* binding */ getHoveredContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");


function getHoveredContourSegmentationAnnotation(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    const { annotationUIDsMap } = segmentation.representationData.Contour;
    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {
        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => (0,_stateManagement__WEBPACK_IMPORTED_MODULE_0__.getAnnotation)(annotationUID).highlighted);
        if (highlightedAnnotationUID) {
            return segmentIndex;
        }
    }
    return undefined;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function getOrCreateImageVolume(referencedImageIds) {
    if (!referencedImageIds || referencedImageIds.length <= 1) {
        return;
    }
    const isValidVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
    if (!isValidVolume) {
        return;
    }
    const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(referencedImageIds);
    let imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    if (imageVolume) {
        return imageVolume;
    }
    imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds);
    return imageVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getOrCreateImageVolume);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");


function getOrCreateSegmentationVolume(segmentationId) {
    const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    let { volumeId } = representationData.Labelmap;
    let segVolume;
    if (volumeId) {
        segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (segVolume) {
            return segVolume;
        }
    }
    const { imageIds: labelmapImageIds } = representationData.Labelmap;
    volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(labelmapImageIds);
    if (!labelmapImageIds || labelmapImageIds.length === 1) {
        return;
    }
    const isValidVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(labelmapImageIds);
    if (!isValidVolume) {
        return;
    }
    segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);
    return segVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getOrCreateSegmentationVolume);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getReferenceVolumeForSegmentation: () => (/* binding */ getReferenceVolumeForSegmentation)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getOrCreateImageVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js");



function getReferenceVolumeForSegmentation(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    if (!segmentation) {
        return null;
    }
    let referenceImageIds;
    const labelmap = segmentation.representationData.Labelmap;
    if ('imageIds' in labelmap) {
        const { imageIds } = labelmap;
        const firstImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageIds[0]);
        const volumeInfo = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolumeContainingImageId(firstImage.referencedImageId);
        if (volumeInfo?.volume) {
            return volumeInfo.volume;
        }
        referenceImageIds = imageIds.map((imageId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId).referencedImageId);
    }
    else if ('volumeId' in labelmap) {
        const { volumeId, referencedVolumeId } = labelmap;
        if (referencedVolumeId) {
            const refVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
            if (refVolume) {
                return refVolume;
            }
        }
        const segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (segVolume) {
            referenceImageIds = segVolume.imageIds.map((imageId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId).referencedImageId);
        }
    }
    return (0,_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_2__["default"])(referenceImageIds);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentationVolume.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentationVolume.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getReferenceVolumeForSegmentationVolume: () => (/* binding */ getReferenceVolumeForSegmentationVolume)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function getReferenceVolumeForSegmentationVolume(segmentationVolumeId) {
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationVolumeId);
    if (!segmentationVolume) {
        return null;
    }
    const referencedVolumeId = segmentationVolume.referencedVolumeId;
    let imageVolume;
    if (referencedVolumeId) {
        imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
    }
    else {
        const imageIds = segmentationVolume.imageIds;
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageIds[0]);
        const referencedImageId = image.referencedImageId;
        const volumeInfo = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolumeContainingImageId(referencedImageId);
        imageVolume = volumeInfo?.volume;
    }
    return imageVolume;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSVGStyleForSegment: () => (/* binding */ getSVGStyleForSegment)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/config/segmentationColor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentationRepresentationVisibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentationRepresentationVisibility */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js");
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js");
/* harmony import */ var _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/segmentation/SegmentationStyle */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js");







function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {
    const segmentColor = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_1__.getSegmentIndexColor)(viewportId, segmentationId, segmentIndex);
    const segmentationVisible = (0,_stateManagement_segmentation_getSegmentationRepresentationVisibility__WEBPACK_IMPORTED_MODULE_4__.getSegmentationRepresentationVisibility)(viewportId, {
        segmentationId,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
    });
    const activeSegmentation = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_2__.getActiveSegmentation)(viewportId);
    const isActive = activeSegmentation?.segmentationId === segmentationId;
    const style = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_6__.segmentationStyle.getStyle({
        viewportId,
        segmentationId,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
        segmentIndex,
    });
    const mergedConfig = style;
    let lineWidth = 1;
    let lineDash = undefined;
    let lineOpacity = 1;
    let fillOpacity = 0;
    if (autoGenerated) {
        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;
        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;
        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;
        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;
    }
    else if (isActive) {
        lineWidth = mergedConfig.outlineWidth ?? lineWidth;
        lineDash = mergedConfig.outlineDash ?? lineDash;
        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;
        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;
    }
    else {
        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;
        lineDash = mergedConfig.outlineDashInactive ?? lineDash;
        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;
        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;
    }
    if ((0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_3__.getActiveSegmentIndex)(segmentationId) === segmentIndex) {
        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;
    }
    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;
    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;
    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;
    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;
    const hiddenSegments = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_5__.internalGetHiddenSegmentIndices)(viewportId, {
        segmentationId,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
    });
    const isVisible = !hiddenSegments.has(segmentIndex);
    return {
        color,
        fillColor,
        lineWidth,
        fillOpacity,
        lineDash,
        textbox: {
            color,
        },
        visibility: segmentationVisible && isVisible,
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSegmentIndexAtLabelmapBorder: () => (/* binding */ getSegmentIndexAtLabelmapBorder)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");
/* harmony import */ var _stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/helpers */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/index.js");



function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    const labelmapData = segmentation.representationData.Labelmap;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const { volumeId } = labelmapData;
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const voxelManager = segmentationVolume.voxelManager;
        const imageData = segmentationVolume.imageData;
        const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);
        const canvasPoint = viewport.worldToCanvas(worldPoint);
        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);
        return onEdge ? segmentIndex : undefined;
    }
    const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
    const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationActorEntry = (0,_stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__.getLabelmapActorEntry)(viewport.id, segmentationId);
    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();
    const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData: imageData.getPointData().getScalars().getData(),
        }));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);
    return onEdge ? segmentIndex : undefined;
}
function isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {
    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);
    for (const deltaI of neighborRange) {
        for (const deltaJ of neighborRange) {
            for (const deltaK of neighborRange) {
                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {
                    continue;
                }
                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);
                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {
                    return true;
                }
            }
        }
    }
    return false;
}
function isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {
        const neighborIJK = [
            indexIJK[0] + deltaI,
            indexIJK[1] + deltaJ,
            indexIJK[2] + deltaK,
        ];
        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}
function isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ) => {
        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];
        const worldPoint = viewport.canvasToWorld(neighborCanvas);
        const voxelManager = imageData.get('voxelManager').voxelManager;
        const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSegmentIndexAtWorldForContour: () => (/* binding */ getSegmentIndexAtWorldForContour),
/* harmony export */   getSegmentIndexAtWorldForLabelmap: () => (/* binding */ getSegmentIndexAtWorldForLabelmap),
/* harmony export */   getSegmentIndexAtWorldPoint: () => (/* binding */ getSegmentIndexAtWorldPoint)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/segmentationState */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js");
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js");
/* harmony import */ var _math_polyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/polyline */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js");
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/segmentation/helpers/getSegmentationActor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js");






function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
    const representationData = segmentation.representationData;
    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];
    if (!desiredRepresentation) {
        throw new Error(`Segmentation ${segmentationId} does not have any representations`);
    }
    switch (desiredRepresentation) {
        case _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap:
            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);
        case _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour:
            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);
        default:
            return;
    }
}
function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {
    const labelmapData = segmentation.representationData.Labelmap;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const { volumeId } = labelmapData;
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);
        return segmentIndex;
    }
    const segmentationImageIds = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__.getCurrentLabelmapImageIdsForViewport)(viewport.id, segmentation.segmentationId);
    if (segmentationImageIds.length > 1) {
        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');
        return;
    }
    const segmentationImageId = segmentationImageIds[0];
    const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationActorEntry = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__.getLabelmapActorEntry)(viewport.id, segmentation.segmentationId);
    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();
    const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData: imageData.getPointData().getScalars().getData(),
        }));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    return segmentIndex;
}
function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {
    const contourData = segmentation.representationData.Contour;
    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());
    const { viewPlaneNormal } = viewport.getCamera();
    for (const segmentIndex of segmentIndices) {
        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);
        if (!annotationsSet) {
            continue;
        }
        for (const annotationUID of annotationsSet) {
            const annotation = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__.getAnnotation)(annotationUID);
            if (!annotation) {
                continue;
            }
            const { polyline } = annotation.data.contour;
            if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {
                continue;
            }
            if ((0,_math_polyline__WEBPACK_IMPORTED_MODULE_4__.isPointInsidePolyline3D)(worldPoint, polyline)) {
                return Number(segmentIndex);
            }
        }
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentLargestBidirectional.js":
/*!********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentLargestBidirectional.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSegmentLargestBidirectional: () => (/* binding */ getSegmentLargestBidirectional)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registerComputeWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js");
/* harmony import */ var _utilsForWorker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utilsForWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js");




async function getSegmentLargestBidirectional({ segmentationId, segmentIndices, mode = 'individual', }) {
    (0,_registerComputeWorker__WEBPACK_IMPORTED_MODULE_2__.registerComputeWorker)();
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_1__.WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 0);
    const segData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__.getSegmentationDataForWorker)(segmentationId, segmentIndices);
    if (!segData) {
        return;
    }
    const { operationData, segImageIds, reconstructableVolume, indices } = segData;
    const bidirectionalData = reconstructableVolume
        ? await calculateVolumeBidirectional({
            operationData,
            indices,
            mode,
        })
        : await calculateStackBidirectional({
            segImageIds,
            indices,
            mode,
        });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_1__.WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 100);
    return bidirectionalData;
}
async function calculateVolumeBidirectional({ operationData, indices, mode }) {
    const strategyData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__.prepareVolumeStrategyDataForWorker)(operationData);
    const { segmentationVoxelManager, segmentationImageData } = strategyData;
    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions: segmentationImageData.getDimensions(),
        spacing: segmentationImageData.getSpacing(),
        origin: segmentationImageData.getOrigin(),
        direction: segmentationImageData.getDirection(),
    };
    const bidirectionalData = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {
        segmentationInfo,
        indices,
        mode,
    });
    return bidirectionalData;
}
async function calculateStackBidirectional({ segImageIds, indices, mode }) {
    const { segmentationInfo } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__.prepareStackDataForWorker)(segImageIds);
    const bidirectionalData = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {
        segmentationInfo,
        indices,
        mode,
        isStack: true,
    });
    return bidirectionalData;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getStatistics.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getStatistics.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _utilsForWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilsForWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js");
/* harmony import */ var _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getPixelValueUnits */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js");
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VolumetricCalculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../registerComputeWorker */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js");






const radiusForVol1 = Math.pow((3 * 1000) / (4 * Math.PI), 1 / 3);
async function getStatistics({ segmentationId, segmentIndices, mode = 'collective', }) {
    (0,_registerComputeWorker__WEBPACK_IMPORTED_MODULE_5__.registerComputeWorker)();
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 0);
    const segData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.getSegmentationDataForWorker)(segmentationId, segmentIndices);
    if (!segData) {
        return;
    }
    const { operationData, segVolumeId, segImageIds, reconstructableVolume, indices, } = segData;
    const { refImageId, modalityUnitOptions } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.getImageReferenceInfo)(segVolumeId, segImageIds);
    const unit = (0,_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_2__.getPixelValueUnitsImageId)(refImageId, modalityUnitOptions);
    const stats = reconstructableVolume
        ? await calculateVolumeStatistics({
            operationData,
            indices,
            unit,
            mode,
        })
        : await calculateStackStatistics({
            segImageIds,
            indices,
            unit,
            mode,
        });
    return stats;
}
async function calculateVolumeStatistics({ operationData, indices, unit, mode, }) {
    const strategyData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.prepareVolumeStrategyDataForWorker)(operationData);
    const { segmentationVoxelManager, imageVoxelManager, segmentationImageData, imageData, } = strategyData;
    if (!segmentationVoxelManager || !segmentationImageData) {
        return;
    }
    const spacing = segmentationImageData.getSpacing();
    const { boundsIJK: boundsOrig } = segmentationVoxelManager;
    if (!boundsOrig) {
        return _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__["default"].getStatistics({ spacing });
    }
    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions: segmentationImageData.getDimensions(),
        spacing: segmentationImageData.getSpacing(),
        origin: segmentationImageData.getOrigin(),
        direction: segmentationImageData.getDirection(),
    };
    const imageInfo = {
        scalarData: imageVoxelManager.getCompleteScalarDataArray(),
        dimensions: imageData.getDimensions(),
        spacing: imageData.getSpacing(),
        origin: imageData.getOrigin(),
        direction: imageData.getDirection(),
    };
    if (!imageInfo.scalarData?.length) {
        return;
    }
    const stats = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'calculateSegmentsStatisticsVolume', {
        segmentationInfo,
        imageInfo,
        indices,
        unit,
        mode,
    });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 100);
    if (mode === 'collective') {
        return processSegmentationStatistics({
            stats,
            unit,
            spacing,
            segmentationImageData,
            imageVoxelManager,
        });
    }
    else {
        const finalStats = {};
        Object.entries(stats).forEach(([segmentIndex, stat]) => {
            finalStats[segmentIndex] = processSegmentationStatistics({
                stats: stat,
                unit,
                spacing,
                segmentationImageData,
                imageVoxelManager,
            });
        });
        return finalStats;
    }
}
const updateStatsArray = (stats, newStat) => {
    if (!stats.array) {
        return;
    }
    const existingIndex = stats.array.findIndex((stat) => stat.name === newStat.name);
    if (existingIndex !== -1) {
        stats.array[existingIndex] = newStat;
    }
    else {
        stats.array.push(newStat);
    }
};
const processSegmentationStatistics = ({ stats, unit, spacing, segmentationImageData, imageVoxelManager, }) => {
    stats.mean.unit = unit;
    stats.max.unit = unit;
    stats.min.unit = unit;
    if (unit !== 'SUV') {
        return stats;
    }
    const radiusIJK = spacing.map((s) => Math.max(1, Math.round((1.1 * radiusForVol1) / s)));
    for (const testMax of stats.maxIJKs) {
        const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);
        if (!testStats) {
            continue;
        }
        const { mean } = testStats;
        if (!stats.peakValue || stats.peakValue.value <= mean.value) {
            stats.peakValue = {
                name: 'peakValue',
                label: 'Peak Value',
                value: mean.value,
                unit,
            };
            stats.peakPoint = {
                name: 'peakLPS',
                label: 'Peak SUV Point',
                value: testMax.pointLPS ? [...testMax.pointLPS] : null,
                unit: null,
            };
            updateStatsArray(stats, stats.peakValue);
            updateStatsArray(stats, stats.peakPoint);
        }
    }
    if (stats.volume && stats.mean) {
        const mtv = stats.volume.value;
        const suvMean = stats.mean.value;
        stats.lesionGlycolysis = {
            name: 'lesionGlycolysis',
            label: 'Lesion Glycolysis',
            value: mtv * suvMean,
            unit: `${stats.volume.unit}${unit}`,
        };
        updateStatsArray(stats, stats.lesionGlycolysis);
    }
    return stats;
};
async function calculateStackStatistics({ segImageIds, indices, unit, mode }) {
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 0);
    const { segmentationInfo, imageInfo } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.prepareStackDataForWorker)(segImageIds);
    const stats = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'calculateSegmentsStatisticsStack', {
        segmentationInfo,
        imageInfo,
        indices,
        mode,
    });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__.triggerWorkerProgress)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 100);
    const spacing = segmentationInfo[0].spacing;
    const segmentationImageData = segmentationInfo[0];
    const imageVoxelManager = imageInfo[0].voxelManager;
    if (mode === 'collective') {
        return processSegmentationStatistics({
            stats,
            unit,
            spacing,
            segmentationImageData,
            imageVoxelManager,
        });
    }
    else {
        const finalStats = {};
        Object.entries(stats).forEach(([segmentIndex, stat]) => {
            finalStats[segmentIndex] = processSegmentationStatistics({
                stats: stat,
                unit,
                spacing,
                segmentationImageData,
                imageVoxelManager,
            });
        });
        return finalStats;
    }
}
function getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {
    const { pointIJK: centerIJK, pointLPS: centerLPS } = testMax;
    if (!centerIJK) {
        return;
    }
    const boundsIJK = centerIJK.map((ijk, idx) => [
        ijk - radiusIJK[idx],
        ijk + radiusIJK[idx],
    ]);
    const testFunction = (_pointLPS, pointIJK) => {
        const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];
        const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];
        const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];
        const radius = i * i + j * j + k * k;
        return radius <= 1;
    };
    const statsFunction = ({ pointIJK, pointLPS }) => {
        const value = imageVoxels.getAtIJKPoint(pointIJK);
        if (value === undefined) {
            return;
        }
        _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__["default"].statsCallback({ value, pointLPS, pointIJK });
    };
    _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__["default"].statsInit({ storePointData: false });
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.pointInShapeCallback(segData, {
        pointInShapeFn: testFunction,
        callback: statsFunction,
        boundsIJK,
    });
    return _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__["default"].getStatistics({ spacing });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getStatistics);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getUniqueSegmentIndices: () => (/* binding */ getUniqueSegmentIndices)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");




function getUniqueSegmentIndices(segmentationId) {
    const cachedResult = (0,_utilities__WEBPACK_IMPORTED_MODULE_2__.getCachedSegmentIndices)(segmentationId);
    if (cachedResult) {
        return cachedResult;
    }
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__.getSegmentation)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);
    }
    let indices;
    if (segmentation.representationData.Labelmap) {
        indices = handleLabelmapSegmentation(segmentation, segmentationId);
    }
    else if (segmentation.representationData.Contour) {
        indices = handleContourSegmentation(segmentation);
    }
    else if (segmentation.representationData.Surface) {
        indices = handleSurfaceSegmentation(segmentation);
    }
    else {
        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);
    }
    (0,_utilities__WEBPACK_IMPORTED_MODULE_2__.setCachedSegmentIndices)(segmentationId, indices);
    return indices;
}
function handleLabelmapSegmentation(segmentation, segmentationId) {
    const labelmapData = segmentation.representationData[_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap];
    const keySet = new Set();
    if (labelmapData.imageIds) {
        addImageSegmentIndices(keySet, labelmapData.imageIds);
    }
    else {
        addVolumeSegmentIndices(keySet, segmentationId);
    }
    return Array.from(keySet)
        .map(Number)
        .sort((a, b) => a - b);
}
function addVolumeSegmentIndices(keySet, segmentationId) {
    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationId);
    volume.voxelManager.forEach(({ value }) => {
        if (value !== 0) {
            keySet.add(value);
        }
    });
}
function addImageSegmentIndices(keySet, imageIds) {
    imageIds.forEach((segmentationImageId) => {
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
        const scalarData = image.voxelManager.getScalarData();
        scalarData.forEach((segmentIndex) => {
            if (segmentIndex !== 0) {
                keySet.add(segmentIndex);
            }
        });
    });
}
function handleContourSegmentation(segmentation) {
    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};
    if (!geometryIds) {
        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);
    }
    const indices = new Set([...annotationUIDsMap.keys()]);
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        indices.add(geometry.data.segmentIndex);
    });
    return Array.from(indices).sort((a, b) => a - b);
}
function handleSurfaceSegmentation(segmentation) {
    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];
    return Array.from(geometryIds.keys())
        .map(Number)
        .sort((a, b) => a - b);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/constants.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/constants.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_NEGATIVE_SEEDS_COUNT: () => (/* binding */ DEFAULT_NEGATIVE_SEEDS_COUNT),
/* harmony export */   DEFAULT_NEGATIVE_SEED_MARGIN: () => (/* binding */ DEFAULT_NEGATIVE_SEED_MARGIN),
/* harmony export */   DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER: () => (/* binding */ DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER),
/* harmony export */   DEFAULT_NEIGHBORHOOD_RADIUS: () => (/* binding */ DEFAULT_NEIGHBORHOOD_RADIUS),
/* harmony export */   DEFAULT_POSITIVE_STD_DEV_MULTIPLIER: () => (/* binding */ DEFAULT_POSITIVE_STD_DEV_MULTIPLIER),
/* harmony export */   MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER: () => (/* binding */ MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER),
/* harmony export */   NEGATIVE_SEED_LABEL: () => (/* binding */ NEGATIVE_SEED_LABEL),
/* harmony export */   POSITIVE_SEED_LABEL: () => (/* binding */ POSITIVE_SEED_LABEL)
/* harmony export */ });
const POSITIVE_SEED_LABEL = 254;
const NEGATIVE_SEED_LABEL = 255;
const DEFAULT_NEIGHBORHOOD_RADIUS = 1;
const DEFAULT_POSITIVE_STD_DEV_MULTIPLIER = 1.8;
const DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER = 3.2;
const DEFAULT_NEGATIVE_SEED_MARGIN = 30;
const DEFAULT_NEGATIVE_SEEDS_COUNT = 70;
const MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER = 50;


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const shader = `
const MAX_STRENGTH = 65535f;

// Workgroup size - X*Y*Z must be multiple of 32 for better performance
override workGroupSizeX = 1u;
override workGroupSizeY = 1u;
override workGroupSizeZ = 1u;

// Compare the current voxel to neighbors using a 9x9x9 window
override windowSize = 9i;

struct Params {
  size: vec3u,
  iteration: u32,
}

// New structure to track bounds of modified voxels
struct Bounds {
  minX: atomic<i32>,
  minY: atomic<i32>,
  minZ: atomic<i32>,
  maxX: atomic<i32>,
  maxY: atomic<i32>,
  maxZ: atomic<i32>,
}

@group(0) @binding(0) var<uniform> params: Params;
@group(0) @binding(1) var<storage> volumePixelData: array<f32>;
@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;
@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;
@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;
@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;
@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;
@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;

fn getPixelIndex(ijkPos: vec3u) -> u32 {
  let numPixelsPerSlice = params.size.x * params.size.y;
  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;
}

fn updateBounds(position: vec3i) {
  // Atomically update min bounds (use min operation)
  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);
  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);
  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);

  // Atomically update max bounds (use max operation)
  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);
  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);
  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);
}

@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
fn main(
  @builtin(global_invocation_id) globalId: vec3u,
) {
  // Make sure it will not get out of bounds for volume with sizes that
  // are not multiple of workGroupSize
  if (
    globalId.x >= params.size.x ||
    globalId.y >= params.size.y ||
    globalId.z >= params.size.z
  ) {
    return;
  }

  // Initialize bounds for the first iteration
  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {
    // Initialize to opposite extremes to ensure any update will improve the bounds
    atomicStore(&modifiedBounds.minX, i32(params.size.x));
    atomicStore(&modifiedBounds.minY, i32(params.size.y));
    atomicStore(&modifiedBounds.minZ, i32(params.size.z));
    atomicStore(&modifiedBounds.maxX, -1);
    atomicStore(&modifiedBounds.maxY, -1);
    atomicStore(&modifiedBounds.maxZ, -1);
  }

  let currentCoord = vec3i(globalId);
  let currentPixelIndex = getPixelIndex(globalId);

  let numPixels = arrayLength(&volumePixelData);
  let currentPixelValue = volumePixelData[currentPixelIndex];

  if (params.iteration == 0) {
    // All non-zero initial labels are given maximum strength
    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);

    // Update bounds for non-zero initial labels
    if (labelmap[currentPixelIndex] != 0) {
      updateBounds(currentCoord);
    }
    return;
  }

  // It should at least copy the values from previous state
  var newLabel = prevLabelmap[currentPixelIndex];
  var newStrength = prevStrengthData[currentPixelIndex];

  let window = i32(ceil(f32(windowSize - 1) * .5));
  let minWindow = -1i * window;
  let maxWindow = 1i * window;

  for (var k = minWindow; k <= maxWindow; k++) {
    for (var j = minWindow; j <= maxWindow; j++) {
      for (var i = minWindow; i <= maxWindow; i++) {
        // Skip current voxel
        if (i == 0 && j == 0 && k == 0) {
          continue;
        }

        let neighborCoord = currentCoord + vec3i(i, j, k);

        //  Boundary conditions. Do not grow outside of the volume
        if (
          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||
          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||
          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)
        ) {
          continue;
        }

        let neighborIndex = getPixelIndex(vec3u(neighborCoord));
        let neighborPixelValue = volumePixelData[neighborIndex];
        let prevNeighborStrength = prevStrengthData[neighborIndex];
        let strengthCost = abs(neighborPixelValue - currentPixelValue);
        let takeoverStrength = prevNeighborStrength - strengthCost;

        if (takeoverStrength > newStrength) {
          newLabel = prevLabelmap[neighborIndex];
          newStrength = takeoverStrength;
        }
      }
    }
  }

  if (labelmap[currentPixelIndex] != newLabel) {
    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);

    // Update bounds for modified voxels
    updateBounds(currentCoord);
  }

  labelmap[currentPixelIndex] = newLabel;
  strengthData[currentPixelIndex] = newStrength;
}
`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shader);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/index.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   run: () => (/* reexport safe */ _runGrowCut__WEBPACK_IMPORTED_MODULE_0__.run),
/* harmony export */   runGrowCutForBoundingBox: () => (/* reexport safe */ _runGrowCutForBoundingBox__WEBPACK_IMPORTED_MODULE_2__.runGrowCutForBoundingBox),
/* harmony export */   runGrowCutForSphere: () => (/* reexport safe */ _runGrowCutForSphere__WEBPACK_IMPORTED_MODULE_1__.runGrowCutForSphere),
/* harmony export */   runOneClickGrowCut: () => (/* reexport safe */ _runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__.runOneClickGrowCut)
/* harmony export */ });
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runGrowCut */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js");
/* harmony import */ var _runGrowCutForSphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runGrowCutForSphere */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js");
/* harmony import */ var _runGrowCutForBoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runGrowCutForBoundingBox */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js");
/* harmony import */ var _runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./runOneClickGrowCut */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js");






/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ runGrowCut),
/* harmony export */   run: () => (/* binding */ runGrowCut)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _growCutShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./growCutShader */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js");


const GB = 1024 * 1024 * 1024;
const WEBGPU_MEMORY_LIMIT = 1.99 * GB;
const DEFAULT_GROWCUT_OPTIONS = {
    windowSize: 3,
    maxProcessingTime: 30000,
    inspection: {
        numCyclesInterval: 5,
        numCyclesBelowThreshold: 3,
        threshold: 1e-4,
    },
};
async function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {
    const workGroupSize = [8, 8, 4];
    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);
    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);
    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referenceVolumeId);
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(labelmapVolumeId);
    const [columns, rows, numSlices] = volume.dimensions;
    if (labelmap.dimensions[0] !== columns ||
        labelmap.dimensions[1] !== rows ||
        labelmap.dimensions[2] !== numSlices) {
        throw new Error('Volume and labelmap must have the same size');
    }
    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);
    numIterations = Math.min(numIterations, 500);
    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();
    if (!(volumePixelData instanceof Float32Array)) {
        volumePixelData = new Float32Array(volumePixelData);
    }
    const requiredLimits = {
        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,
        maxBufferSize: WEBGPU_MEMORY_LIMIT,
    };
    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter.requestDevice({ requiredLimits });
    const BUFFER_SIZE = volumePixelData.byteLength;
    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;
    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;
    const shaderModule = device.createShaderModule({
        code: _growCutShader__WEBPACK_IMPORTED_MODULE_1__["default"],
    });
    const numIterationIndex = 3;
    const paramsArrayValues = new Uint32Array([
        columns,
        rows,
        numSlices,
        0,
    ]);
    const gpuParamsBuffer = device.createBuffer({
        size: paramsArrayValues.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    const gpuVolumePixelDataBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);
    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    }));
    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));
    const gpuStrengthBuffers = [0, 1].map(() => {
        const strengthBuffer = device.createBuffer({
            size: BUFFER_SIZE,
            usage: GPUBufferUsage.STORAGE |
                GPUBufferUsage.COPY_SRC |
                GPUBufferUsage.COPY_DST,
        });
        return strengthBuffer;
    });
    const gpuCounterBuffer = device.createBuffer({
        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    });
    const gpuBoundsBuffer = device.createBuffer({
        size: BOUNDS_BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    });
    const initialBounds = new Int32Array([
        columns,
        rows,
        numSlices,
        -1,
        -1,
        -1,
    ]);
    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 4,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 5,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 6,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 7,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });
    const bindGroups = [0, 1].map((i) => {
        const outputLabelmapBuffer = gpuLabelmapBuffers[i];
        const outputStrengthBuffer = gpuStrengthBuffers[i];
        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];
        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];
        return device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: gpuParamsBuffer,
                    },
                },
                {
                    binding: 1,
                    resource: {
                        buffer: gpuVolumePixelDataBuffer,
                    },
                },
                {
                    binding: 2,
                    resource: {
                        buffer: outputLabelmapBuffer,
                    },
                },
                {
                    binding: 3,
                    resource: {
                        buffer: outputStrengthBuffer,
                    },
                },
                {
                    binding: 4,
                    resource: {
                        buffer: previouLabelmapBuffer,
                    },
                },
                {
                    binding: 5,
                    resource: {
                        buffer: previousStrengthBuffer,
                    },
                },
                {
                    binding: 6,
                    resource: {
                        buffer: gpuCounterBuffer,
                    },
                },
                {
                    binding: 7,
                    resource: {
                        buffer: gpuBoundsBuffer,
                    },
                },
            ],
        });
    });
    const pipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [bindGroupLayout],
        }),
        compute: {
            module: shaderModule,
            entryPoint: 'main',
            constants: {
                workGroupSizeX: workGroupSize[0],
                workGroupSizeY: workGroupSize[1],
                workGroupSizeZ: workGroupSize[2],
                windowSize,
            },
        },
    });
    const numWorkGroups = [
        Math.ceil(columns / workGroupSize[0]),
        Math.ceil(rows / workGroupSize[1]),
        Math.ceil(numSlices / workGroupSize[2]),
    ];
    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({
        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    const limitProcessingTime = maxProcessingTime
        ? performance.now() + maxProcessingTime
        : 0;
    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
    let belowThresholdCounter = 0;
    for (let i = 0; i < numIterations; i++) {
        paramsArrayValues[numIterationIndex] = i;
        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);
        const commandEncoder = device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroups[i % 2]);
        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);
        passEncoder.end();
        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);
        device.queue.submit([commandEncoder.finish()]);
        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);
        if (inspect) {
            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));
            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;
            gpuUpdatedVoxelsCounterStagingBuffer.unmap();
            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {
                currentInspectionNumCyclesInterval = 1;
                belowThresholdCounter++;
                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {
                    break;
                }
            }
            else {
                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
            }
        }
        if (limitProcessingTime && performance.now() > limitProcessingTime) {
            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);
            break;
        }
    }
    const commandEncoder = device.createCommandEncoder();
    const outputLabelmapBufferIndex = (numIterations + 1) % 2;
    const labelmapStagingBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    const boundsStagingBuffer = device.createBuffer({
        size: BOUNDS_BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);
    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);
    device.queue.submit([commandEncoder.finish()]);
    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);
    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);
    const labelmapResult = new Uint32Array(labelmapResultBuffer);
    labelmapData.set(labelmapResult);
    labelmapStagingBuffer.unmap();
    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);
    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);
    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));
    boundsStagingBuffer.unmap();
    const minX = boundsResult[0];
    const minY = boundsResult[1];
    const minZ = boundsResult[2];
    const maxX = boundsResult[3];
    const maxY = boundsResult[4];
    const maxZ = boundsResult[5];
    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);
    labelmap.voxelManager.clearBounds();
    labelmap.voxelManager.setBounds([
        [minX, maxX],
        [minY, maxY],
        [minZ, maxZ],
    ]);
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ runGrowCutForBoundingBox),
/* harmony export */   runGrowCutForBoundingBox: () => (/* binding */ runGrowCutForBoundingBox)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runGrowCut */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js");


const POSITIVE_SEED_VALUE = 254;
const NEGATIVE_SEED_VALUE = 255;
const NEGATIVE_PIXEL_RANGE = [-Infinity, -995];
const POSITIVE_PIXEL_RANGE = [0, 1900];
function _setNegativeSeedValues(subVolume, labelmap, options) {
    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const [width, height, numSlices] = labelmap.dimensions;
    const middleSliceIndex = Math.floor(numSlices / 2);
    const visited = new Array(width * height).fill(false);
    const sliceOffset = middleSliceIndex * width * height;
    const bfs = (startX, startY) => {
        const queue = [[startX, startY]];
        while (queue.length) {
            const [x, y] = queue.shift();
            const slicePixelIndex = y * width + x;
            if (x < 0 ||
                x >= width ||
                y < 0 ||
                y >= height ||
                visited[slicePixelIndex]) {
                continue;
            }
            visited[slicePixelIndex] = true;
            const volumeVoxelIndex = sliceOffset + slicePixelIndex;
            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
            if (volumeVoxelValue < negativePixelRange[0] ||
                volumeVoxelValue > negativePixelRange[1]) {
                continue;
            }
            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);
            queue.push([x - 1, y]);
            queue.push([x + 1, y]);
            queue.push([x, y - 1]);
            queue.push([x, y + 1]);
        }
    };
    const scanLine = (startX, limitX, incX, y) => {
        for (let x = startX; x !== limitX; x += incX) {
            const slicePixelIndex = y * width + x;
            const volumeVoxelIndex = sliceOffset + slicePixelIndex;
            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
            if (volumeVoxelValue < negativePixelRange[0] ||
                volumeVoxelValue > negativePixelRange[1]) {
                break;
            }
            if (!visited[slicePixelIndex]) {
                bfs(x, y);
            }
        }
    };
    for (let y = 0; y < height; y++) {
        scanLine(0, width - 1, 1, y);
        scanLine(width - 1, 0, -1, y);
    }
}
function _setPositiveSeedValues(subVolume, labelmap, options) {
    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
    const [width, height, numSlices] = labelmap.dimensions;
    const middleSliceIndex = Math.floor(numSlices / 2);
    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);
    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);
    const pixelsPerSlice = width * height;
    for (let z = startSliceIndex; z < stopSliceIndex; z++) {
        const zOffset = z * pixelsPerSlice;
        for (let y = 0; y < height; y++) {
            const yOffset = y * width;
            for (let x = 0; x < width; x++) {
                const index = zOffset + yOffset + x;
                const pixelValue = subVolPixelData[index];
                const isPositiveValue = pixelValue >= positivePixelRange[0] &&
                    pixelValue <= positivePixelRange[1];
                if (isPositiveValue) {
                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);
                }
            }
        }
    }
}
async function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
    _setPositiveSeedValues(subVolume, labelmap, options);
    _setNegativeSeedValues(subVolume, labelmap, options);
    return labelmap;
}
async function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {
    const { boundingBox } = boundingBoxInfo;
    const { ijkTopLeft, ijkBottomRight } = boundingBox;
    const subVolumeBoundsIJK = {
        minX: ijkTopLeft[0],
        maxX: ijkBottomRight[0],
        minY: ijkTopLeft[1],
        maxY: ijkBottomRight[1],
        minZ: ijkTopLeft[2],
        maxZ: ijkBottomRight[2],
    };
    const subVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {
        targetBuffer: {
            type: 'Float32Array',
        },
    });
    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_1__.run)(subVolume.volumeId, labelmap.volumeId);
    return labelmap;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ runGrowCutForSphere),
/* harmony export */   runGrowCutForSphere: () => (/* binding */ runGrowCutForSphere)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runGrowCut */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js");
/* harmony import */ var _getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../getSphereBoundsInfo */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js");




const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const POSITIVE_SEED_VALUE = 254;
const NEGATIVE_SEED_VALUE = 255;
const POSITIVE_SEED_VARIANCE = 0.1;
const NEGATIVE_SEED_VARIANCE = 0.8;
function _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {
    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;
    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);
    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);
    return {
        ...sphereBoundsInfo,
        topLeftIJK,
        bottomRightIJK,
    };
}
function _getSphereBoundsInfo(referencedVolume, sphereInfo) {
    const direction = referencedVolume.imageData.getDirection();
    const vecColumn = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.fromValues(direction[3], direction[4], direction[5]);
    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;
    const refVolImageData = referencedVolume.imageData;
    const topCirclePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), sphereCenterPoint, vecColumn, -sphereRadius);
    const bottomCirclePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), sphereCenterPoint, vecColumn, sphereRadius);
    const sphereBoundsInfo = (0,_getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_3__.getSphereBoundsInfo)([bottomCirclePoint, topCirclePoint], refVolImageData);
    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);
}
function _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {
    const refVolImageData = referencedVolume.imageData;
    const camera = viewport.getCamera();
    const { ijkVecRowDir, ijkVecColDir } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeDirectionVectors(refVolImageData, camera);
    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[0]), 1) &&
        !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[1]), 1) &&
        !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[2]), 1));
    if (obliqueView) {
        console.warn('Oblique view is not supported!');
        return;
    }
    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);
    const subVolumeBoundsIJK = {
        minX: sphereBoundsIJK[0][0],
        maxX: sphereBoundsIJK[0][1] + 1,
        minY: sphereBoundsIJK[1][0],
        maxY: sphereBoundsIJK[1][1] + 1,
        minZ: sphereBoundsIJK[2][0],
        maxZ: sphereBoundsIJK[2][1] + 1,
    };
    return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {
        targetBuffer: {
            type: 'Float32Array',
        },
    });
}
function _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {
    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();
    const worldStartPos = sphereInfo.center;
    const [width, height, numSlices] = referencedVolume.dimensions;
    const numPixelsPerSlice = width * height;
    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);
    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0]];
    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;
    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;
    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);
    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;
    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;
    const neighborsCoordDelta = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1],
    ];
    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0];
    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);
    const queue = [ijkStartPosition];
    while (queue.length) {
        const ijkVoxel = queue.shift();
        const [x, y, z] = ijkVoxel;
        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {
            const neighborCoordDelta = neighborsCoordDelta[i];
            const nx = x + neighborCoordDelta[0];
            const ny = y + neighborCoordDelta[1];
            const nz = z + neighborCoordDelta[2];
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                nz < 0 ||
                nz >= numSlices) {
                continue;
            }
            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;
            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];
            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);
            if (neighborLabelmapValue === positiveSeedValue ||
                neighborPixelValue < minPositivePixelValue ||
                neighborPixelValue > maxPositivePixelValue) {
                continue;
            }
            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);
            queue.push([nx, ny, nz]);
        }
    }
}
function _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const [columns, rows, numSlices] = labelmap.dimensions;
    const numPixelsPerSlice = columns * rows;
    const { worldVecRowDir, worldVecSliceDir } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());
    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);
    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +
        ijkSphereCenter[1] * columns +
        ijkSphereCenter[0]];
    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;
    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;
    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);
    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;
    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;
    const numCirclePoints = 360;
    const rotationAngle = (2 * Math.PI) / numCirclePoints;
    const worldQuat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.quat.setAxisAngle(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.quat.create(), worldVecSliceDir, rotationAngle);
    const vecRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.clone(worldVecRowDir);
    for (let i = 0; i < numCirclePoints; i++) {
        const worldCircleBorderPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(), sphereInfo.center, vecRotation, sphereInfo.radius);
        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);
        const [x, y, z] = ijkCircleBorderPoint;
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformQuat(vecRotation, vecRotation, worldQuat);
        if (x < 0 ||
            x >= columns ||
            y < 0 ||
            y >= rows ||
            z < 0 ||
            z >= numSlices) {
            continue;
        }
        const offset = x + y * columns + z * numPixelsPerSlice;
        const pixelValue = subVolPixelData[offset];
        if (pixelValue < minNegativePixelValue ||
            pixelValue > maxNegativePixelValue) {
            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);
        }
    }
}
async function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {
    const labelmap = await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);
    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);
    return labelmap;
}
async function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {
    const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(referencedVolumeId);
    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);
    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_2__.run)(subVolume.volumeId, labelmap.volumeId);
    return labelmap;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateGrowCutSeeds: () => (/* binding */ calculateGrowCutSeeds),
/* harmony export */   "default": () => (/* binding */ runOneClickGrowCut),
/* harmony export */   runOneClickGrowCut: () => (/* binding */ runOneClickGrowCut)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runGrowCut */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/constants.js");



const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const MAX_POSITIVE_SEEDS = 100000;
function calculateGrowCutSeeds(referencedVolume, worldPosition, options) {
    const { dimensions, imageData: refImageData } = referencedVolume;
    const [width, height, numSlices] = dimensions;
    const referenceVolumeVoxelManager = referencedVolume.voxelManager;
    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();
    const numPixelsPerSlice = width * height;
    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? _constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_NEIGHBORHOOD_RADIUS;
    const positiveK = options?.positiveStdDevMultiplier ?? _constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_POSITIVE_STD_DEV_MULTIPLIER;
    const negativeK = options?.negativeStdDevMultiplier ?? _constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER;
    const negativeSeedMargin = options?.negativeSeedMargin ?? _constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_NEGATIVE_SEED_MARGIN;
    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? _constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_NEGATIVE_SEEDS_COUNT;
    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);
    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);
    if (ijkStart[0] < 0 ||
        ijkStart[0] >= width ||
        ijkStart[1] < 0 ||
        ijkStart[1] >= height ||
        ijkStart[2] < 0 ||
        ijkStart[2] >= numSlices) {
        console.warn('Click position is outside volume bounds.');
        return null;
    }
    const initialStats = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);
    if (initialStats.count === 0) {
        initialStats.mean = scalarData[startIndex];
        initialStats.stdDev = 0;
    }
    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;
    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;
    const neighborsCoordDelta = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1],
    ];
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
    const positiveSeedIndices = new Set();
    const queue = [];
    const startValue = scalarData[startIndex];
    if (startValue >= positiveIntensityMin &&
        startValue <= positiveIntensityMax) {
        positiveSeedIndices.add(startIndex);
        queue.push(ijkStart);
        minX = maxX = ijkStart[0];
        minY = maxY = ijkStart[1];
        minZ = maxZ = ijkStart[2];
    }
    else {
        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');
        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };
    }
    let currentQueueIndex = 0;
    while (currentQueueIndex < queue.length &&
        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {
        const [x, y, z] = queue[currentQueueIndex++];
        minX = Math.min(x, minX);
        minY = Math.min(y, minY);
        minZ = Math.min(z, minZ);
        maxX = Math.max(x, maxX);
        maxY = Math.max(y, maxY);
        maxZ = Math.max(z, maxZ);
        for (let i = 0; i < neighborsCoordDelta.length; i++) {
            const [dx, dy, dz] = neighborsCoordDelta[i];
            const nx = x + dx;
            const ny = y + dy;
            const nz = z + dz;
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                nz < 0 ||
                nz >= numSlices) {
                continue;
            }
            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;
            if (positiveSeedIndices.has(neighborIndex)) {
                continue;
            }
            const neighborValue = scalarData[neighborIndex];
            if (neighborValue >= positiveIntensityMin &&
                neighborValue <= positiveIntensityMax) {
                positiveSeedIndices.add(neighborIndex);
                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {
                    queue.push([nx, ny, nz]);
                }
            }
        }
    }
    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {
        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);
    }
    if (positiveSeedIndices.size === 0) {
        console.warn('No positive seeds found after BFS.');
        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };
    }
    let positiveSum = 0;
    let positiveSumSq = 0;
    positiveSeedIndices.forEach((index) => {
        const value = scalarData[index];
        positiveSum += value;
        positiveSumSq += value * value;
    });
    const positiveCount = positiveSeedIndices.size;
    const positiveMean = positiveSum / positiveCount;
    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;
    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));
    const negativeDiffThreshold = negativeK * positiveStdDev;
    const minXm = Math.max(0, minX - negativeSeedMargin);
    const minYm = Math.max(0, minY - negativeSeedMargin);
    const minZm = Math.max(0, minZ - negativeSeedMargin);
    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);
    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);
    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);
    const negativeSeedIndices = new Set();
    let attempts = 0;
    let patchesAdded = 0;
    const maxAttempts = negativeSeedsTargetPatches * _constants__WEBPACK_IMPORTED_MODULE_2__.MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER;
    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {
        attempts++;
        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);
        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);
        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);
        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;
        if (positiveSeedIndices.has(centerIndex) ||
            negativeSeedIndices.has(centerIndex)) {
            continue;
        }
        const centerValue = scalarData[centerIndex];
        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {
            let patchContributed = false;
            for (let dy = -1; dy <= 1; dy++) {
                const ny = ry + dy;
                if (ny < 0 || ny >= height) {
                    continue;
                }
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = rx + dx;
                    if (nx < 0 || nx >= width) {
                        continue;
                    }
                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;
                    if (positiveSeedIndices.has(neighborIndex) ||
                        negativeSeedIndices.has(neighborIndex)) {
                        continue;
                    }
                    negativeSeedIndices.add(neighborIndex);
                    patchContributed = true;
                }
            }
            if (patchContributed) {
                patchesAdded++;
            }
        }
    }
    if (negativeSeedIndices.size === 0) {
        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');
    }
    console.debug('positiveSeedIndices', positiveSeedIndices.size);
    console.debug('negativeSeedIndices', negativeSeedIndices.size);
    return { positiveSeedIndices, negativeSeedIndices };
}
async function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {
    const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);
    labelmap.voxelManager.forEach(({ index, value }) => {
        if (value !== 0) {
            labelmap.voxelManager.setAtIndex(index, 0);
        }
    });
    const seeds = options.seeds ??
        calculateGrowCutSeeds(referencedVolume, worldPosition, options);
    const positiveSeedLabel = options?.positiveSeedValue ?? _constants__WEBPACK_IMPORTED_MODULE_2__.POSITIVE_SEED_LABEL;
    const negativeSeedLabel = options?.negativeSeedValue ?? _constants__WEBPACK_IMPORTED_MODULE_2__.NEGATIVE_SEED_LABEL;
    if (!seeds) {
        return null;
    }
    const { positiveSeedIndices, negativeSeedIndices } = seeds;
    if (positiveSeedIndices.size < 10 ||
        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||
        negativeSeedIndices.size < 10) {
        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');
        return labelmap;
    }
    positiveSeedIndices.forEach((index) => {
        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);
    });
    negativeSeedIndices.forEach((index) => {
        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);
    });
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_1__.run)(referencedVolumeId, labelmap.volumeId, options);
    return labelmap;
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IslandRemoval: () => (/* reexport safe */ _islandRemoval__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   LabelmapMemo: () => (/* reexport module object */ _createLabelmapMemo__WEBPACK_IMPORTED_MODULE_21__),
/* harmony export */   SegmentStatsCalculator: () => (/* reexport safe */ _SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   VolumetricCalculator: () => (/* reexport safe */ _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   computeMetabolicStats: () => (/* reexport safe */ _computeMetabolicStats__WEBPACK_IMPORTED_MODULE_31__.computeMetabolicStats),
/* harmony export */   computeStackLabelmapFromVolume: () => (/* reexport safe */ _stateManagement_segmentation_helpers_computeStackLabelmapFromVolume__WEBPACK_IMPORTED_MODULE_27__.computeStackLabelmapFromVolume),
/* harmony export */   computeVolumeLabelmapFromStack: () => (/* reexport safe */ _stateManagement_segmentation_helpers_computeVolumeLabelmapFromStack__WEBPACK_IMPORTED_MODULE_28__.computeVolumeLabelmapFromStack),
/* harmony export */   contourAndFindLargestBidirectional: () => (/* reexport safe */ _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   createBidirectionalToolData: () => (/* reexport safe */ _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   createLabelmapVolumeForViewport: () => (/* reexport safe */ _createLabelmapVolumeForViewport__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   createMergedLabelmapForIndex: () => (/* reexport safe */ _createMergedLabelmapForIndex__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   floodFill: () => (/* reexport safe */ _floodFill__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   getBrushSizeForToolGroup: () => (/* reexport safe */ _brushSizeForToolGroup__WEBPACK_IMPORTED_MODULE_6__.getBrushSizeForToolGroup),
/* harmony export */   getBrushThresholdForToolGroup: () => (/* reexport safe */ _brushThresholdForToolGroup__WEBPACK_IMPORTED_MODULE_7__.getBrushThresholdForToolGroup),
/* harmony export */   getBrushToolInstances: () => (/* reexport safe */ _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_19__.getBrushToolInstances),
/* harmony export */   getHoveredContourSegmentationAnnotation: () => (/* reexport safe */ _getHoveredContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_18__.getHoveredContourSegmentationAnnotation),
/* harmony export */   getOrCreateImageVolume: () => (/* reexport safe */ _getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   getOrCreateSegmentationVolume: () => (/* reexport safe */ _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   getReferenceVolumeForSegmentationVolume: () => (/* reexport safe */ _getReferenceVolumeForSegmentationVolume__WEBPACK_IMPORTED_MODULE_29__.getReferenceVolumeForSegmentationVolume),
/* harmony export */   getSegmentIndexAtLabelmapBorder: () => (/* reexport safe */ _getSegmentIndexAtLabelmapBorder__WEBPACK_IMPORTED_MODULE_17__.getSegmentIndexAtLabelmapBorder),
/* harmony export */   getSegmentIndexAtWorldPoint: () => (/* reexport safe */ _getSegmentIndexAtWorldPoint__WEBPACK_IMPORTED_MODULE_16__.getSegmentIndexAtWorldPoint),
/* harmony export */   getSegmentLargestBidirectional: () => (/* reexport safe */ _getSegmentLargestBidirectional__WEBPACK_IMPORTED_MODULE_30__.getSegmentLargestBidirectional),
/* harmony export */   getStatistics: () => (/* reexport safe */ _getStatistics__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   getUniqueSegmentIndices: () => (/* reexport safe */ _getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_15__.getUniqueSegmentIndices),
/* harmony export */   growCut: () => (/* reexport module object */ _growCut__WEBPACK_IMPORTED_MODULE_20__),
/* harmony export */   invalidateBrushCursor: () => (/* reexport safe */ _invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_14__.invalidateBrushCursor),
/* harmony export */   rectangleROIThresholdVolumeByRange: () => (/* reexport safe */ _rectangleROIThresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   segmentContourAction: () => (/* reexport safe */ _segmentContourAction__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   setBrushSizeForToolGroup: () => (/* reexport safe */ _brushSizeForToolGroup__WEBPACK_IMPORTED_MODULE_6__.setBrushSizeForToolGroup),
/* harmony export */   setBrushThresholdForToolGroup: () => (/* reexport safe */ _brushThresholdForToolGroup__WEBPACK_IMPORTED_MODULE_7__.setBrushThresholdForToolGroup),
/* harmony export */   thresholdSegmentationByRange: () => (/* reexport safe */ _thresholdSegmentationByRange__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   thresholdVolumeByRange: () => (/* reexport safe */ _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   triggerSegmentationRender: () => (/* reexport safe */ _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRender),
/* harmony export */   triggerSegmentationRenderBySegmentationId: () => (/* reexport safe */ _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRenderBySegmentationId),
/* harmony export */   validateLabelmap: () => (/* reexport module object */ _validateLabelmap__WEBPACK_IMPORTED_MODULE_26__)
/* harmony export */ });
/* harmony import */ var _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thresholdVolumeByRange */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js");
/* harmony import */ var _rectangleROIThresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rectangleROIThresholdVolumeByRange */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js");
/* harmony import */ var _createMergedLabelmapForIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createMergedLabelmapForIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js");
/* harmony import */ var _createLabelmapVolumeForViewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createLabelmapVolumeForViewport */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js");
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stateManagement/segmentation/SegmentationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js");
/* harmony import */ var _floodFill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./floodFill */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js");
/* harmony import */ var _brushSizeForToolGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./brushSizeForToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js");
/* harmony import */ var _brushThresholdForToolGroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./brushThresholdForToolGroup */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js");
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VolumetricCalculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js");
/* harmony import */ var _SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SegmentStatsCalculator */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js");
/* harmony import */ var _thresholdSegmentationByRange__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./thresholdSegmentationByRange */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js");
/* harmony import */ var _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contourAndFindLargestBidirectional */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js");
/* harmony import */ var _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./createBidirectionalToolData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js");
/* harmony import */ var _segmentContourAction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./segmentContourAction */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/segmentContourAction.js");
/* harmony import */ var _invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./invalidateBrushCursor */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js");
/* harmony import */ var _getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./getUniqueSegmentIndices */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js");
/* harmony import */ var _getSegmentIndexAtWorldPoint__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./getSegmentIndexAtWorldPoint */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js");
/* harmony import */ var _getSegmentIndexAtLabelmapBorder__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./getSegmentIndexAtLabelmapBorder */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js");
/* harmony import */ var _getHoveredContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./getHoveredContourSegmentationAnnotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js");
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./getBrushToolInstances */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js");
/* harmony import */ var _growCut__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./growCut */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/index.js");
/* harmony import */ var _createLabelmapMemo__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./createLabelmapMemo */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js");
/* harmony import */ var _islandRemoval__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./islandRemoval */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js");
/* harmony import */ var _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./getOrCreateSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js");
/* harmony import */ var _getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./getOrCreateImageVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js");
/* harmony import */ var _getStatistics__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./getStatistics */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getStatistics.js");
/* harmony import */ var _validateLabelmap__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./validateLabelmap */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/validateLabelmap.js");
/* harmony import */ var _stateManagement_segmentation_helpers_computeStackLabelmapFromVolume__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../stateManagement/segmentation/helpers/computeStackLabelmapFromVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js");
/* harmony import */ var _stateManagement_segmentation_helpers_computeVolumeLabelmapFromStack__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js");
/* harmony import */ var _getReferenceVolumeForSegmentationVolume__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./getReferenceVolumeForSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentationVolume.js");
/* harmony import */ var _getSegmentLargestBidirectional__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./getSegmentLargestBidirectional */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentLargestBidirectional.js");
/* harmony import */ var _computeMetabolicStats__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./computeMetabolicStats */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js");



































/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   invalidateBrushCursor: () => (/* binding */ invalidateBrushCursor)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../triggerAnnotationRenderForViewportIds */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js");
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getBrushToolInstances */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js");



function invalidateBrushCursor(toolGroupId) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__.getBrushToolInstances)(toolGroupId);
    brushBasedToolInstances.forEach((tool) => {
        tool.invalidateBrushCursor();
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
    if (!viewportsInfoArray.length) {
        return;
    }
    const viewportIds = toolGroup.getViewportIds();
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__["default"])(viewportIds);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createIsInSegment: () => (/* binding */ createIsInSegment),
/* harmony export */   createIsInSegmentMetadata: () => (/* binding */ createIsInSegmentMetadata),
/* harmony export */   "default": () => (/* binding */ isLineInSegment),
/* harmony export */   isLineInSegment: () => (/* binding */ isLineInSegment)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");


function isLineInSegment(point1, point2, isInSegment) {
    const ijk1 = isInSegment.toIJK(point1);
    const ijk2 = isInSegment.toIJK(point2);
    const testPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
    const { testIJK } = isInSegment;
    const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), ijk1, ijk2);
    const testSize = Math.round(Math.max(...delta.map(Math.abs)));
    if (testSize < 2) {
        return true;
    }
    const unitDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), delta, 1 / testSize);
    for (let i = 1; i < testSize; i++) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);
        if (!testIJK(testPoint)) {
            return false;
        }
    }
    return true;
}
function createIsInSegmentMetadata({ dimensions, imageData, voxelManager, segmentIndex, containedSegmentIndices, }) {
    const width = dimensions[0];
    const pixelsPerSlice = width * dimensions[1];
    return {
        testCenter: (point1, point2) => {
            const point = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(), point1, point2).map((it) => it / 2);
            const ijk = imageData.worldToIndex(point).map(Math.round);
            const [i, j, k] = ijk;
            const index = i + j * width + k * pixelsPerSlice;
            const value = voxelManager.getAtIndex(index);
            return value === segmentIndex || containedSegmentIndices?.has(value);
        },
        toIJK: (point) => imageData.worldToIndex(point),
        testIJK: (ijk) => {
            const [i, j, k] = ijk;
            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;
            const value = voxelManager.getAtIndex(index);
            return value === segmentIndex || containedSegmentIndices?.has(value);
        },
    };
}
function createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {
    const vol = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    return createIsInSegmentMetadata({
        dimensions: vol.dimensions,
        imageData: vol.imageData,
        voxelManager: vol.voxelManager,
        segmentIndex,
        containedSegmentIndices,
    });
}



/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegmentationEnum: () => (/* binding */ SegmentationEnum),
/* harmony export */   "default": () => (/* binding */ IslandRemoval)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../normalizeViewportPlane */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js");


const { RLEVoxelMap, VoxelManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const MAX_IMAGE_SIZE = 65535;
var SegmentationEnum;
(function (SegmentationEnum) {
    SegmentationEnum[SegmentationEnum["SEGMENT"] = -1] = "SEGMENT";
    SegmentationEnum[SegmentationEnum["ISLAND"] = -2] = "ISLAND";
    SegmentationEnum[SegmentationEnum["INTERIOR"] = -3] = "INTERIOR";
    SegmentationEnum[SegmentationEnum["EXTERIOR"] = -4] = "EXTERIOR";
    SegmentationEnum[SegmentationEnum["INTERIOR_SMALL"] = -5] = "INTERIOR_SMALL";
    SegmentationEnum[SegmentationEnum["INTERIOR_TEST"] = -6] = "INTERIOR_TEST";
})(SegmentationEnum || (SegmentationEnum = {}));
class IslandRemoval {
    constructor(options) {
        this.fillInternalEdge = false;
        this.maxInternalRemove = 128;
        this.maxInternalRemove =
            options?.maxInternalRemove ?? this.maxInternalRemove;
        this.fillInternalEdge = options?.fillInternalEdge ?? this.fillInternalEdge;
    }
    initialize(viewport, segmentationVoxels, options) {
        const hasSource = !!segmentationVoxels.sourceVoxelManager;
        const segmentationVoxelManager = hasSource
            ? segmentationVoxels.sourceVoxelManager
            : segmentationVoxels;
        const previewVoxelManager = hasSource
            ? segmentationVoxels
            : VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
        const { segmentIndex = 1, previewSegmentIndex = 1 } = options;
        const clickedPoints = options.points || segmentationVoxelManager.getPoints();
        if (!clickedPoints?.length) {
            return;
        }
        const boundsIJK = segmentationVoxelManager
            .getBoundsIJK()
            .map((bound, i) => [
            Math.min(bound[0], ...clickedPoints.map((point) => point[i])),
            Math.max(bound[1], ...clickedPoints.map((point) => point[i])),
        ]);
        if (boundsIJK.find((it) => it[0] < 0 || it[1] > MAX_IMAGE_SIZE)) {
            return;
        }
        const { toIJK, fromIJK, boundsIJKPrime, error } = (0,_normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_1__["default"])(viewport, boundsIJK);
        if (error) {
            console.warn('Not performing island removal for planes not orthogonal to acquisition plane', error);
            return;
        }
        const [width, height, depth] = fromIJK(segmentationVoxelManager.dimensions);
        const segmentSet = new RLEVoxelMap(width, height, depth);
        const getter = (i, j, k) => {
            const index = segmentationVoxelManager.toIndex(toIJK([i, j, k]));
            const oldVal = segmentationVoxelManager.getAtIndex(index);
            if (oldVal === previewSegmentIndex || oldVal === segmentIndex) {
                return SegmentationEnum.SEGMENT;
            }
        };
        segmentSet.fillFrom(getter, boundsIJKPrime);
        segmentSet.normalizer = { toIJK, fromIJK, boundsIJKPrime };
        this.segmentSet = segmentSet;
        this.previewVoxelManager = previewVoxelManager;
        this.segmentIndex = segmentIndex;
        this.previewSegmentIndex = previewSegmentIndex ?? segmentIndex;
        this.selectedPoints = clickedPoints;
        return true;
    }
    floodFillSegmentIsland() {
        const { selectedPoints: clickedPoints, segmentSet } = this;
        let floodedCount = 0;
        const { fromIJK } = segmentSet.normalizer;
        clickedPoints.forEach((clickedPoint) => {
            const ijkPrime = fromIJK(clickedPoint);
            const index = segmentSet.toIndex(ijkPrime);
            const [iPrime, jPrime, kPrime] = ijkPrime;
            if (segmentSet.get(index) === SegmentationEnum.SEGMENT) {
                floodedCount += segmentSet.floodFill(iPrime, jPrime, kPrime, SegmentationEnum.ISLAND);
            }
        });
        return floodedCount;
    }
    removeExternalIslands() {
        const { previewVoxelManager, segmentSet } = this;
        const { toIJK } = segmentSet.normalizer;
        const callback = (index, rle) => {
            const [, jPrime, kPrime] = segmentSet.toIJK(index);
            if (rle.value !== SegmentationEnum.ISLAND) {
                for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
                    const clearPoint = toIJK([iPrime, jPrime, kPrime]);
                    const v = previewVoxelManager.getAtIJKPoint(clearPoint);
                    previewVoxelManager.setAtIJKPoint(clearPoint, v === undefined ? 0 : null);
                }
            }
        };
        segmentSet.forEach(callback, { rowModified: true });
    }
    removeInternalIslands() {
        const { segmentSet, previewVoxelManager, previewSegmentIndex } = this;
        const { height, normalizer, width } = segmentSet;
        const { toIJK } = normalizer;
        segmentSet.forEachRow((baseIndex, row) => {
            let lastRle;
            for (const rle of [...row]) {
                if (rle.value !== SegmentationEnum.ISLAND) {
                    continue;
                }
                if (!lastRle) {
                    if (this.fillInternalEdge && rle.start > 0) {
                        for (let iPrime = 0; iPrime < rle.start; iPrime++) {
                            segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                        }
                    }
                    lastRle = rle;
                    continue;
                }
                for (let iPrime = lastRle.end; iPrime < rle.start; iPrime++) {
                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                }
                lastRle = rle;
            }
            if (this.fillInternalEdge && lastRle?.end < width) {
                for (let iPrime = lastRle.end; iPrime < width; iPrime++) {
                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                }
            }
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR) {
                return;
            }
            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
            const rowPrev = jPrime > 0 ? segmentSet.getRun(jPrime - 1, kPrime) : null;
            const rowNext = jPrime + 1 < height ? segmentSet.getRun(jPrime + 1, kPrime) : null;
            const isLast = jPrime === height - 1;
            const isFirst = jPrime === 0;
            const prevCovers = IslandRemoval.covers(rle, rowPrev) ||
                (isFirst && this.fillInternalEdge);
            const nextCovers = IslandRemoval.covers(rle, rowNext) || (isLast && this.fillInternalEdge);
            if (rle.end - rle.start > 2 && (!prevCovers || !nextCovers)) {
                segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.EXTERIOR, { singlePlane: true });
            }
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR) {
                return;
            }
            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
            const size = segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.INTERIOR_TEST);
            const isBig = size > this.maxInternalRemove;
            const newType = isBig
                ? SegmentationEnum.EXTERIOR
                : SegmentationEnum.INTERIOR_SMALL;
            segmentSet.floodFill(rle.start, jPrime, kPrime, newType);
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR_SMALL) {
                return;
            }
            for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
                const clearPoint = toIJK(segmentSet.toIJK(baseIndex + iPrime));
                previewVoxelManager.setAtIJKPoint(clearPoint, previewSegmentIndex);
            }
        });
        return previewVoxelManager.getArrayOfModifiedSlices();
    }
    static covers(rle, row) {
        if (!row) {
            return false;
        }
        let { start } = rle;
        const { end } = rle;
        for (const rowRle of row) {
            if (start >= rowRle.start && start < rowRle.end) {
                start = rowRle.end;
                if (start >= end) {
                    return true;
                }
            }
        }
        return false;
    }
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js":
/*!************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/annotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js");
/* harmony import */ var _tools_segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/segmentation/RectangleROIStartEndThresholdTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js");
/* harmony import */ var _tools_segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/segmentation/RectangleROIThresholdTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js");
/* harmony import */ var _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./thresholdVolumeByRange */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js");
/* harmony import */ var _rectangleROITool_getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rectangleROITool/getBoundsIJKFromRectangleAnnotations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js");





function rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {
    const annotations = annotationUIDs.map((annotationUID) => {
        return _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_0__.state.getAnnotation(annotationUID);
    });
    _validateAnnotations(annotations);
    let boundsIJK;
    for (let i = 0; i < thresholdVolumeInformation.length; i++) {
        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
        if (volumeSize === segmentationVolume.voxelManager.getScalarDataLength() ||
            i === 0) {
            boundsIJK = (0,_rectangleROITool_getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_4__["default"])(annotations, thresholdVolumeInformation[i].volume, options);
        }
    }
    const outputSegmentationVolume = (0,_thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_3__["default"])(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK, segmentationId: options.segmentationId });
    outputSegmentationVolume.modified();
    return outputSegmentationVolume;
}
function _validateAnnotations(annotations) {
    const validToolNames = [
        _tools_segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_2__["default"].toolName,
        _tools_segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_1__["default"].toolName,
    ];
    for (const annotation of annotations) {
        const name = annotation.metadata.toolName;
        if (!validToolNames.includes(name)) {
            throw new Error('rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations');
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rectangleROIThresholdVolumeByRange);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/segmentContourAction.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/segmentContourAction.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ segmentContourAction),
/* harmony export */   defaultGetSegment: () => (/* binding */ defaultGetSegment)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/annotation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js");
/* harmony import */ var _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contourAndFindLargestBidirectional */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js");
/* harmony import */ var _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createBidirectionalToolData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js");
/* harmony import */ var _tools_annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/annotation/BidirectionalTool */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentations */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");







async function segmentContourAction(element, configuration) {
    console.warn('Deprecation Alert: There is a new getSegmentLargestBidirectional function that handles volume, stack and individual segment cases properly. This function is deprecated and will be removed in a future version.');
    const { data: configurationData } = configuration;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);
    if (!segment) {
        return;
    }
    const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();
    const segmentationsList = (0,_stateManagement_segmentation_getSegmentations__WEBPACK_IMPORTED_MODULE_5__.getSegmentations)();
    const { segmentIndex, segmentationId } = segment;
    const bidirectionals = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.getAnnotations(this.toolName || _tools_annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_4__["default"].toolName, FrameOfReferenceUID);
    let hasExistingActiveSegment = false;
    const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {
        const segment = existingBidirectionalItem.data.segment;
        if (!segment) {
            return false;
        }
        if (segment.segmentationId === segmentationId &&
            segment.segmentIndex === segmentIndex) {
            hasExistingActiveSegment = true;
            existingBidirectionalItem.data.segment = segment;
        }
        return true;
    });
    if (!hasExistingActiveSegment) {
        existingLargestBidirectionals.push({
            data: { segment },
        });
    }
    let newBidirectional;
    existingLargestBidirectionals.forEach(async (existingLargestBidirectional) => {
        const segments = [];
        const updateSegment = existingLargestBidirectional.data
            .segment;
        const { segmentIndex, segmentationId } = updateSegment;
        segments[segmentIndex] = updateSegment;
        _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.removeAnnotation(existingLargestBidirectional.annotationUID);
        const bidirectionalData = await (0,_contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_2__["default"])({
            ...segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId),
            segments,
        });
        if (!bidirectionalData) {
            return;
        }
        const bidirectionalToolData = (0,_createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_3__["default"])(bidirectionalData, enabledElement.viewport);
        bidirectionalToolData.annotationUID =
            existingLargestBidirectional.annotationUID;
        bidirectionalToolData.data.segment = updateSegment;
        const annotationUID = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);
        if (updateSegment.segmentIndex === segment.segmentIndex &&
            updateSegment.segmentationId === segment.segmentationId) {
            newBidirectional = bidirectionalData;
            const { style } = segment;
            if (style) {
                _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.config.style.setAnnotationStyles(annotationUID, style);
            }
        }
    });
    if (newBidirectional) {
        const { sliceIndex } = newBidirectional;
        const imageIds = enabledElement.viewport.getImageIds();
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.jumpToSlice(element, {
            imageIndex: imageIds.length - 1 - sliceIndex,
        });
        enabledElement.viewport.render();
    }
    else {
        console.warn('No bidirectional found');
    }
    return newBidirectional;
}
function defaultGetSegment(enabledElement, configuration) {
    const segmentationsList = (0,_stateManagement_segmentation_getSegmentations__WEBPACK_IMPORTED_MODULE_5__.getSegmentations)();
    if (!segmentationsList.length) {
        return;
    }
    const segmentationId = configuration.segmentationId || segmentationsList[0].segmentationId;
    const segmentIndex = configuration.segmentIndex ?? (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_6__.getActiveSegmentIndex)(segmentationId);
    if (!segmentIndex) {
        return;
    }
    const segmentData = configuration.segmentData?.get(segmentIndex);
    return {
        label: `Segment ${segmentIndex}`,
        segmentIndex,
        segmentationId,
        ...segmentData,
    };
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js":
/*!******************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js");


function thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType, segmentationId) {
    if (!segmentationId) {
        throw new Error('Segmentation ID is required to be passed inside thresholdSegmentationByRange');
    }
    const { baseVolumeIdx, volumeInfoList } = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__.processVolumes)(segmentationVolume, thresholdVolumeInformation);
    const { voxelManager } = volumeInfoList[baseVolumeIdx];
    const refVoxelManager = voxelManager;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    const segVoxelManager = segmentationVolume.voxelManager;
    volumeInfoList.forEach((volumeInfo) => {
        const { volumeSize } = volumeInfo;
        if (volumeSize === scalarDataLength) {
            _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo);
        }
        else {
            _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);
        }
    });
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationDataModified)(segmentationId);
    return segmentationVolume;
}
function _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {
    const { imageData, lower, upper, dimensions } = volumeInfo;
    let total, overlaps, range;
    const segScalarDataLength = segVoxelManager.getScalarDataLength();
    for (let i = 0; i < segScalarDataLength; i++) {
        if (segScalarDataLength.getAtIndex(i) === segmentationIndex) {
            const overlapBounds = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__.getVoxelOverlap)(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));
            const callbackOverlap = ({ value }) => {
                total = total + 1;
                if (value >= range.lower && value <= range.upper) {
                    overlaps = overlaps + 1;
                }
            };
            total = 0;
            overlaps = 0;
            range = { lower, upper };
            let overlapTest = false;
            segVoxelManager.forEach(callbackOverlap, {
                imageData,
                boundsIJK: overlapBounds,
            });
            overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;
            segVoxelManager.setAtIndex(i, overlapTest ? segmentationIndex : 0);
        }
    }
    return { total, range, overlaps };
}
function _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo) {
    const { lower, upper } = volumeInfo;
    const scalarDataLength = segVoxelManager.getScalarDataLength();
    for (let i = 0; i < scalarDataLength; i++) {
        if (segVoxelManager.getAtIndex[i] === segmentationIndex) {
            const value = refVoxelManager.getAtIndex(i);
            segVoxelManager.setAtIndex(i, value >= lower && value <= upper ? segmentationIndex : 0);
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (thresholdSegmentationByRange);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stateManagement/segmentation/triggerSegmentationEvents */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js");


function thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {
    const { imageData: segmentationImageData } = segmentationVolume;
    const { overwrite, boundsIJK, segmentationId } = options;
    if (!segmentationId) {
        throw new Error('Segmentation ID is required to be passed inside thresholdVolumeByRange as options');
    }
    const overlapType = options?.overlapType || 0;
    const segVoxelManager = segmentationVolume.voxelManager;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    if (overwrite) {
        for (let i = 0; i < scalarDataLength; i++) {
            segVoxelManager.setAtIndex(i, 0);
        }
    }
    const { baseVolumeIdx, volumeInfoList } = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__.processVolumes)(segmentationVolume, thresholdVolumeInformation);
    let overlaps, total, range;
    const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {
        const callbackOverlap = ({ value }) => {
            total = total + 1;
            if (value >= range.lower && value <= range.upper) {
                overlaps = overlaps + 1;
            }
        };
        const { imageData, dimensions, lower, upper } = volumeInfo;
        const overlapBounds = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__.getVoxelOverlap)(imageData, dimensions, voxelSpacing, voxelCenter);
        total = 0;
        overlaps = 0;
        range = { lower, upper };
        let overlapTest = false;
        const { voxelManager } = imageData.get('voxelManager');
        voxelManager.forEach(callbackOverlap, {
            imageData,
            boundsIJK: overlapBounds,
        });
        if (overlapType === 0) {
            overlapTest = overlaps > 0;
        }
        else if (overlapType == 1) {
            overlapTest = overlaps === total;
        }
        return overlapTest;
    };
    const testRange = (volumeInfo, pointIJK) => {
        const { imageData, lower, upper } = volumeInfo;
        const voxelManager = imageData.get('voxelManager').voxelManager;
        const offset = voxelManager.toIndex(pointIJK);
        const value = voxelManager.getAtIndex(offset);
        if (value <= lower || value >= upper) {
            return false;
        }
        else {
            return true;
        }
    };
    const callback = ({ index, pointIJK, pointLPS }) => {
        let insert = volumeInfoList.length > 0;
        for (let i = 0; i < volumeInfoList.length; i++) {
            if (volumeInfoList[i].volumeSize === scalarDataLength) {
                insert = testRange(volumeInfoList[i], pointIJK);
            }
            else {
                insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);
            }
            if (!insert) {
                break;
            }
        }
        if (insert) {
            segVoxelManager.setAtIndex(index, options.segmentIndex || 1);
        }
    };
    const voxelManager = segmentationVolume.voxelManager;
    voxelManager.forEach(callback, {
        imageData: segmentationImageData,
        boundsIJK,
    });
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationDataModified)(options.segmentationId);
    return segmentationVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (thresholdVolumeByRange);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCachedSegmentIndices: () => (/* binding */ getCachedSegmentIndices),
/* harmony export */   getVoxelOverlap: () => (/* binding */ getVoxelOverlap),
/* harmony export */   processVolumes: () => (/* binding */ processVolumes),
/* harmony export */   setCachedSegmentIndices: () => (/* binding */ setCachedSegmentIndices),
/* harmony export */   setSegmentationClean: () => (/* binding */ setSegmentationClean),
/* harmony export */   setSegmentationDirty: () => (/* binding */ setSegmentationDirty)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../boundingBox/getBoundingBoxAroundShape */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js");


const equalsCheck = (a, b) => {
    return JSON.stringify(a) === JSON.stringify(b);
};
function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {
    const halfSpacingX = voxelSpacing[0] / 2;
    const halfSpacingY = voxelSpacing[1] / 2;
    const halfSpacingZ = voxelSpacing[2] / 2;
    const voxelCornersIJK = new Array(8);
    voxelCornersIJK[0] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, [
        voxelCenter[0] - halfSpacingX,
        voxelCenter[1] - halfSpacingY,
        voxelCenter[2] - halfSpacingZ,
    ]);
    const offsets = [
        [1, -1, -1],
        [-1, 1, -1],
        [1, 1, -1],
        [-1, -1, 1],
        [1, -1, 1],
        [-1, 1, 1],
        [1, 1, 1],
    ];
    for (let i = 0; i < 7; i++) {
        const [xOff, yOff, zOff] = offsets[i];
        voxelCornersIJK[i + 1] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, [
            voxelCenter[0] + xOff * halfSpacingX,
            voxelCenter[1] + yOff * halfSpacingY,
            voxelCenter[2] + zOff * halfSpacingZ,
        ]);
    }
    return (0,_boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.getBoundingBoxAroundShapeIJK)(voxelCornersIJK, dimensions);
}
function processVolumes(segmentationVolume, thresholdVolumeInformation) {
    const { spacing: segmentationSpacing } = segmentationVolume;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    const volumeInfoList = [];
    let baseVolumeIdx = 0;
    for (let i = 0; i < thresholdVolumeInformation.length; i++) {
        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;
        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
        if (volumeSize === scalarDataLength &&
            equalsCheck(spacing, segmentationSpacing)) {
            baseVolumeIdx = i;
        }
        const lower = thresholdVolumeInformation[i].lower;
        const upper = thresholdVolumeInformation[i].upper;
        volumeInfoList.push({
            imageData,
            lower,
            upper,
            spacing,
            dimensions,
            volumeSize,
            voxelManager,
        });
    }
    return {
        volumeInfoList,
        baseVolumeIdx,
    };
}
const segmentIndicesCache = new Map();
const setSegmentationDirty = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = true;
    }
};
const setSegmentationClean = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = false;
    }
};
const getCachedSegmentIndices = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached && !cached.isDirty) {
        return cached.indices;
    }
    return null;
};
const setCachedSegmentIndices = (segmentationId, indices) => {
    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });
};


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getImageReferenceInfo: () => (/* binding */ getImageReferenceInfo),
/* harmony export */   getSegmentationDataForWorker: () => (/* binding */ getSegmentationDataForWorker),
/* harmony export */   prepareImageInfo: () => (/* binding */ prepareImageInfo),
/* harmony export */   prepareStackDataForWorker: () => (/* binding */ prepareStackDataForWorker),
/* harmony export */   prepareVolumeStrategyDataForWorker: () => (/* binding */ prepareVolumeStrategyDataForWorker),
/* harmony export */   triggerWorkerProgress: () => (/* binding */ triggerWorkerProgress)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stateManagement/segmentation/getActiveSegmentIndex */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js");
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stateManagement/segmentation/getSegmentation */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js");
/* harmony import */ var _tools_segmentation_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/segmentation/strategies/utils/getStrategyData */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js");
/* harmony import */ var _tools_segmentation_strategies_compositions_ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/segmentation/strategies/compositions/ensureSegmentationVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureSegmentationVolume.js");
/* harmony import */ var _tools_segmentation_strategies_compositions_ensureImageVolume__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/segmentation/strategies/compositions/ensureImageVolume */ "../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureImageVolume.js");






const triggerWorkerProgress = (workerType, progress) => {
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.WEB_WORKER_PROGRESS, {
        progress,
        type: workerType,
    });
};
const getSegmentationDataForWorker = (segmentationId, segmentIndices) => {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
    const { representationData } = segmentation;
    const { Labelmap } = representationData;
    if (!Labelmap) {
        console.debug('No labelmap found for segmentation', segmentationId);
        return null;
    }
    const segVolumeId = Labelmap.volumeId;
    const segImageIds = Labelmap.imageIds;
    const operationData = {
        segmentationId,
        volumeId: segVolumeId,
        imageIds: segImageIds,
    };
    let reconstructableVolume = false;
    if (segImageIds) {
        const refImageIds = segImageIds.map((imageId) => {
            const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId);
            return image.referencedImageId;
        });
        reconstructableVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(refImageIds);
    }
    let indices = segmentIndices;
    if (!indices) {
        indices = [(0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_1__.getActiveSegmentIndex)(segmentationId)];
    }
    else if (!Array.isArray(indices)) {
        indices = [indices, 255];
    }
    return {
        operationData,
        segVolumeId,
        segImageIds,
        reconstructableVolume,
        indices,
    };
};
const prepareVolumeStrategyDataForWorker = (operationData) => {
    return (0,_tools_segmentation_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__.getStrategyData)({
        operationData,
        strategy: {
            ensureSegmentationVolumeFor3DManipulation: _tools_segmentation_strategies_compositions_ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_4__["default"].ensureSegmentationVolumeFor3DManipulation,
            ensureImageVolumeFor3DManipulation: _tools_segmentation_strategies_compositions_ensureImageVolume__WEBPACK_IMPORTED_MODULE_5__["default"].ensureImageVolumeFor3DManipulation,
        },
    });
};
const prepareImageInfo = (imageVoxelManager, imageData) => {
    const imageScalarData = imageVoxelManager.getCompleteScalarDataArray();
    return {
        scalarData: imageScalarData,
        dimensions: imageData.getDimensions(),
        spacing: imageData.getSpacing(),
        origin: imageData.getOrigin(),
        direction: imageData.getDirection(),
    };
};
const prepareStackDataForWorker = (segImageIds) => {
    const segmentationInfo = [];
    const imageInfo = [];
    for (const segImageId of segImageIds) {
        const segImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segImageId);
        const segPixelData = segImage.getPixelData();
        const { origin, direction, spacing, dimensions } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getImageDataMetadata(segImage);
        segmentationInfo.push({
            scalarData: segPixelData,
            dimensions,
            spacing,
            origin,
            direction,
        });
        const refImageId = segImage.referencedImageId;
        if (refImageId) {
            const refImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(refImageId);
            if (!refImage) {
                continue;
            }
            const refPixelData = refImage.getPixelData();
            const refVoxelManager = refImage.voxelManager;
            const refSpacing = [
                refImage.rowPixelSpacing,
                refImage.columnPixelSpacing,
            ];
            imageInfo.push({
                scalarData: refPixelData,
                dimensions: refVoxelManager
                    ? refVoxelManager.dimensions
                    : [refImage.columns, refImage.rows, 1],
                spacing: refSpacing,
            });
        }
    }
    return { segmentationInfo, imageInfo };
};
const getImageReferenceInfo = (segVolumeId, segImageIds) => {
    let refImageId;
    if (segVolumeId) {
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segVolumeId);
        const imageIds = segmentationVolume.imageIds;
        const cachedImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageIds[0]);
        if (cachedImage) {
            refImageId = cachedImage.referencedImageId;
        }
    }
    else if (segImageIds?.length) {
        const segImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segImageIds[0]);
        refImageId = segImage.referencedImageId;
    }
    const refImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(refImageId);
    const scalingModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('scalingModule', refImageId);
    const modalityUnitOptions = {
        isPreScaled: Boolean(refImage?.preScale?.scaled),
        isSuvScaled: typeof scalingModule?.suvbw === 'number',
    };
    return { refImageId, modalityUnitOptions };
};


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/validateLabelmap.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/validateLabelmap.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validate: () => (/* binding */ validate),
/* harmony export */   validatePublic: () => (/* binding */ validatePublic)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function validateRepresentationData(segmentationRepresentationData) {
    if ('volumeId' in segmentationRepresentationData) {
        segmentationRepresentationData =
            segmentationRepresentationData;
        const cachedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationRepresentationData.volumeId);
        if (!cachedVolume) {
            throw new Error(`volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);
        }
    }
    else if ('imageIds' in segmentationRepresentationData) {
        segmentationRepresentationData =
            segmentationRepresentationData;
        if (!segmentationRepresentationData.imageIds) {
            throw new Error('The segmentationInput.representationData.imageIds is undefined, please provide a valid representationData.imageIds for stack data');
        }
    }
    else {
        throw new Error('The segmentationInput.representationData is undefined, please provide a valid representationData');
    }
}
function validatePublic(segmentationInput) {
    if (!segmentationInput.representation.data) {
        throw new Error('The segmentationInput.representationData.data is undefined, please provide a valid representationData.data');
    }
    const representationData = segmentationInput.representation
        .data;
    validateRepresentationData(representationData);
}
function validate(segmentationRepresentationData) {
    validateRepresentationData(segmentationRepresentationData);
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debounce */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js");
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js");


function throttle(func, wait, options) {
    let leading = true;
    let trailing = true;
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    if ((0,_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(options)) {
        leading = 'leading' in options ? Boolean(options.leading) : leading;
        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;
    }
    return (0,_debounce__WEBPACK_IMPORTED_MODULE_0__["default"])(func, wait, {
        leading,
        trailing,
        maxWait: wait,
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stateManagement/annotation/AnnotationRenderingEngine */ "../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js");

function triggerAnnotationRender(element) {
    _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__.annotationRenderingEngine.renderViewport(element);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRender);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   triggerAnnotationRenderForToolGroupIds: () => (/* binding */ triggerAnnotationRenderForToolGroupIds)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerAnnotationRender */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");



function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {
    toolGroupIds.forEach((toolGroupId) => {
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroup)(toolGroupId);
        if (!toolGroup) {
            console.warn(`ToolGroup not available for ${toolGroupId}`);
            return;
        }
        const viewportsInfo = toolGroup.getViewportsInfo();
        viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId);
            if (!renderingEngine) {
                console.warn(`RenderingEngine not available for ${renderingEngineId}`);
                return;
            }
            const viewport = renderingEngine.getViewport(viewportId);
            (0,_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__["default"])(viewport.element);
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRenderForToolGroupIds);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   triggerAnnotationRenderForViewportIds: () => (/* binding */ triggerAnnotationRenderForViewportIds)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triggerAnnotationRender */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js");


function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {
    if (!viewportIdsToRender.length) {
        return;
    }
    viewportIdsToRender.forEach((viewportId) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const { viewport } = enabledElement;
        if (!viewport) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const element = viewport.element;
        (0,_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRenderForViewportIds);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filterViewportsWithFrameOfReferenceUID)
/* harmony export */ });
function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {
    const numViewports = viewports.length;
    const viewportsWithFrameOfReferenceUID = [];
    for (let vp = 0; vp < numViewports; vp++) {
        const viewport = viewports[vp];
        if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {
            viewportsWithFrameOfReferenceUID.push(viewport);
        }
    }
    return viewportsWithFrameOfReferenceUID;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   filterViewportsWithParallelNormals: () => (/* binding */ filterViewportsWithParallelNormals)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "../../../node_modules/gl-matrix/esm/index.js");

function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {
    return viewports.filter((viewport) => {
        const vpCamera = viewport.getCamera();
        const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >
            EPS;
        return isParallel;
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (filterViewportsWithParallelNormals);


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filterViewportsWithToolEnabled)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums */ "../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js");
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/ToolGroupManager */ "../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js");


const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes;
function filterViewportsWithToolEnabled(viewports, toolName) {
    const numViewports = viewports.length;
    const viewportsWithToolEnabled = [];
    for (let vp = 0; vp < numViewports; vp++) {
        const viewport = viewports[vp];
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__.getToolGroupForViewport)(viewport.id, viewport.renderingEngineId);
        if (!toolGroup) {
            continue;
        }
        const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);
        if (hasTool) {
            viewportsWithToolEnabled.push(viewport);
        }
    }
    return viewportsWithToolEnabled;
}
function _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {
    const { toolOptions } = toolGroup;
    const tool = toolOptions[toolName];
    if (!tool) {
        return false;
    }
    const toolMode = tool.mode;
    return toolMode === Active || toolMode === Passive || toolMode === Enabled;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportIdsWithToolToRender)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");
/* harmony import */ var _filterViewportsWithFrameOfReferenceUID__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filterViewportsWithFrameOfReferenceUID */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js");
/* harmony import */ var _filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filterViewportsWithToolEnabled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js");
/* harmony import */ var _filterViewportsWithParallelNormals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filterViewportsWithParallelNormals */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js");




function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngine, FrameOfReferenceUID } = enabledElement;
    let viewports = renderingEngine.getViewports();
    viewports = (0,_filterViewportsWithFrameOfReferenceUID__WEBPACK_IMPORTED_MODULE_1__["default"])(viewports, FrameOfReferenceUID);
    viewports = (0,_filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_2__["default"])(viewports, toolName);
    const viewport = renderingEngine.getViewport(enabledElement.viewportId);
    if (requireParallelNormals) {
        viewports = (0,_filterViewportsWithParallelNormals__WEBPACK_IMPORTED_MODULE_3__["default"])(viewports, viewport.getCamera());
    }
    const viewportIds = viewports.map((vp) => vp.id);
    return viewportIds;
}


/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filterViewportsWithFrameOfReferenceUID: () => (/* reexport safe */ _filterViewportsWithFrameOfReferenceUID__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   filterViewportsWithParallelNormals: () => (/* reexport safe */ _filterViewportsWithParallelNormals__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   filterViewportsWithToolEnabled: () => (/* reexport safe */ _filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   getViewportIdsWithToolToRender: () => (/* reexport safe */ _getViewportIdsWithToolToRender__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _filterViewportsWithFrameOfReferenceUID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filterViewportsWithFrameOfReferenceUID */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js");
/* harmony import */ var _filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filterViewportsWithToolEnabled */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js");
/* harmony import */ var _getViewportIdsWithToolToRender__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getViewportIdsWithToolToRender */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js");
/* harmony import */ var _filterViewportsWithParallelNormals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filterViewportsWithParallelNormals */ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js");







/***/ }),

/***/ "../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isViewportPreScaled: () => (/* binding */ isViewportPreScaled)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cornerstonejs/core */ "../../../node_modules/@cornerstonejs/core/dist/esm/index.js");

function isViewportPreScaled(viewport, targetId) {
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
        const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;
    }
    else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        const { preScale } = viewport.getImageData() || {};
        return !!preScale?.scaled;
    }
    else {
        return false;
    }
}



/***/ }),

/***/ "../../../node_modules/lodash.get/index.js":
/*!*************************************************!*\
  !*** ../../../node_modules/lodash.get/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_cornerstonejs_tools_dist_esm_utilities_segmentation_index_js.js.map